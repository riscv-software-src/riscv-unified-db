# Copyright (c) Qualcomm Technologies, Inc. and/or its subsidiaries.
# SPDX-License-Identifier: BSD-3-Clause-Clear

# yaml-language-server: $schema=../../../schemas/ext_schema.json

$schema: "ext_schema.json#"
kind: extension
name: V
type: unprivileged
long_name: Variable-length vector
versions:
  - version: "1.0.0"
    state: ratified
    ratification_date: null
description: |
  TODO
params:
  ELEN:
    description: |
      The maximum size in bits of a vector element that any operation can produce or consume, _ELEN_ {ge} 8, which
      must be a power of 2.
    schema:
      type: integer
      enum: [8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536]
  VLEN:
    description: |
      The number of bits in a single vector register, _VLEN_ {ge} ELEN, which must be a power of 2, and must be no greater than 2^16^.
    schema:
      type: integer
      enum: [8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536]
      extra_validation: |
        assert VLEN >= ELEN
  SEW_MIN:
    description: |
      Implementations must provide fractional LMUL settings that allow the
      narrowest supported type to occupy a fraction of a vector register
      corresponding to the ratio of the narrowest supported type's width to
      that of the largest supported type's width.  In general, the
      requirement is to support LMUL {ge} SEW~MIN~/ELEN, where SEW~MIN~ is
      the narrowest supported SEW value and ELEN is the widest supported SEW
      value.
    schema:
      type: integer
      enum: [8, 16, 32, 64]
      default: 8
      extra_validation: |
        assert SEW_MIN <= ELEN
  SUPPORT_FRACTIONAL_LMUL_BEYOND_REQUIRED:
    description:
      For a given supported fractional LMUL setting, implementations must support
      SEW settings between SEW~MIN~ and LMUL * ELEN, inclusive.
    schema:
      type: string
      enum: ["no_unrequired_supported", "custom"]
  VILL_SET_ON_RESERVED_VTYPE:
    description:
      The use of `vtype` encodings with LMUL < SEW~MIN~/ELEN is
      __reserved__, but implementations can set `vill` if they do not
      support these configurations.
    schema:
      type: boolean
  RESERVED_VSET_X0X0_VILL_SET:
    description: |
      When _rs1_=`x0` and _rd_=`x0`, the instructions operate as if the current vector length in `vl` is used as the AVL...
      Use of the [vset] instructions is also reserved if `vill` was 1 beforehand. Implementations may set `vill` in either case.
    schema:
      type: string
      enum: ["never", "always", "custom"]
  RESERVED_VSET_X0X0_VLMAX_CHANGE:
    description: |
      When _rs1_=`x0` and _rd_=`x0`, the instructions operate as if the current vector length in `vl` is used as the AVL...
      Use of the [vset] instructions with a new SEW/LMUL ratio that would result in a change of VLMAX is reserved...
      Implementations may set `vill` in either case.
    schema:
      type: string
      enum: ["never", "always", "custom"]
  VECTOR_LS_INDEX_MAX_EEW:
    description:
      A profile may place an upper limit on the maximum supported index
      EEW (e.g., only up to XLEN) smaller than ELEN.
    schema:
      type: string
      enum: ["8", "16", "32", "64", "XLEN"]
      extra_validation: |
        assert 8 <= ELEN    if VECTOR_LS_INDEX_MAX_EEW == "8"
        assert 16 <= ELEN   if VECTOR_LS_INDEX_MAX_EEW == "16"
        assert 32 <= ELEN   if VECTOR_LS_INDEX_MAX_EEW == "32"
        assert 64 <= ELEN   if VECTOR_LS_INDEX_MAX_EEW == "64"
        assert XLEN <= ELEN if VECTOR_LS_INDEX_MAX_EEW == "XLEN"
  VECTOR_FF_UPDATE_PAST_TRIM:
    description:
      Similarly, fault-only-first load instructions may update active destination elements past the element that causes trimming
      of the vector length (but not past the original vector length).  The values of these spurious updates do not have to correspond
      to the values in memory at the addressed memory locations.  Non-idempotent memory locations can only be accessed when it is known
      the corresponding element load operation will not be restarted due to a trap or vector-length trimming.
    schema:
      type: string
      enum: ["update_none", "custom"]
  VECTOR_FF_SEG_EXCEPTION_PARTIAL_LOAD:
    description: |
      For fault-only-first segment loads, if an exception is detected partway
      through accessing the zeroth segment, the trap is taken.
      If an exception is detected partway through accessing a subsequent segment,
      `vl` is reduced to the index of that segment.
      In both cases, it is implementation-defined whether a subset of the segment is
      loaded.
    schema:
      type: string
      enum: ["no_subsegment_loaded", "custom"]
  VECTOR_LS_MISSALIGNED_EXCEPTION:
    description: |
      If an element accessed by a vector memory instruction is not naturally aligned to the size of the element,
      either the element is transferred successfully or an address misaligned exception is raised on that element.

      Support for misaligned vector memory accesses is independent of an implementationâ€™s support for misaligned scalar memory accesses.
    schema:
      type: boolean
  VECTOR_LOAD_PAST_TRAP:
    description: |
      Load instructions may overwrite active destination vector register
      group elements past the element index at which the trap is reported.
    schema:
      type: boolean
  VECTOR_LOAD_SEG_FF_OVERWRITE_ELEMENTS_AFTER_FAULT:
    description: |
      These instructions may overwrite destination vector register group
      elements past the point at which a trap is reported or past the point
      at which vector length is trimmed.
    schema:
      type: string
      enum: ["no_overwrite", "custom"]
  VECTOR_LS_SEG_PARTIAL_ACCESS:
    description: |
      If a trap occurs during
      access to a segment, it is implementation-defined whether a subset
      of the faulting segment's accesses are performed before the trap is taken.
    schema:
      type: boolean
  LEGAL_VSTART:
    description: |
      Implementations are permitted to raise illegal-instruction exceptions when
      attempting to execute a vector instruction with a value of `vstart` that the
      implementation can never produce when executing that same instruction with
      the same `vtype` setting.
    schema:
      type: string
      enum: ["1_stride", "2_stride", "4_stride", "custom"]
  VECTOR_LS_WHOLEREG_MISSALIGNED_EXCEPTION:
    description: |
      Implementations are allowed to raise a misaligned address exception on
      whole register loads and stores if the base address is not naturally
      aligned to the larger of the size of the encoded EEW in bytes (EEW/8)
      or the implementation's smallest supported SEW size in bytes
      (SEW~MIN~/8).
    schema:
      type: boolean
  VSSTATUS_VS_EXISTS:
    description: |
      For implementations with a writable `misa.V` field,
      the `vsstatus.VS` field may exist even if `misa.V` is clear.
    schema:
      type: boolean
  VECTOR_FF_NO_EXCEPTION_TRIM:
    description: |
      Even when an exception is not raised, implementations are permitted to process
      fewer than `vl` elements and reduce `vl` accordingly, but if `vstart`=0 and
      `vl`>0, then at least one element must be processed.
    schema:
      type: boolean
  VFREDUSUM_NAN:
    description: |
      The reduction tree structure must be deterministic for a given value in vtype and vl.
      As a consequence of this definition, implementations need not propagate
      NaN payloads through the reduction tree when no elements are active. In
      particular, if no elements are active and the scalar input is NaN,
      implementations are permitted to canonicalize the NaN and, if the NaN is
      signaling, set the invalid exception flag.  Implementations are alternatively
      permitted to pass through the original NaN and set no exception flags, as with
      `vfredosum`.
    schema:
      type: string
      enum: ["no_change", "custom"]
  VFREDUSUM_NODE_ROUNDING_BEHAVIOR:
    description: |
      Each operator first computes an exact sum as a RISC-V scalar floating-point
      addition with infinite exponent range and precision, then converts this exact
      sum to a floating-point format with range and precision each at least as great as
      the element floating-point format indicated by SEW, rounding using the currently
      active floating-point dynamic rounding mode and raising exception flags as necessary.
      A different floating-point range and precision may be chosen for the result of each operator.
    schema:
      type: string
      enum: ["SEW_precision", "custom"]
  VFREDUSUM_INACTIVE_NODE_ELEMENT_BEHAVIOR:
    description: |
      A node where one input is derived only from elements masked-off or beyond the active
      vector length may either treat that input as the additive identity of the appropriate
      EEW or simply copy the other input to its output.
    schema:
      type: string
      enum: ["additive_identity", "copy"]
  VFREDUSUM_FINAL_NODE_ELEMENT_BEHAVIOR:
    description: |
      An implementation is allowed to add an additional additive identity to the final result.
    schema:
      type: string
      enum: ["additive_identity", "copy"]
  IMPRECISE_VECTOR_TRAP_SETTABLE:
    description: |
      Some profiles may choose to provide a privileged mode bit to select between precise and imprecise vector traps.
    schema:
      type: boolean
  MUTABLE_MISA_V:
    description: |
      Indicates whether or not the `V` extension can be disabled with the `misa.V` bit.
    schema:
      type: boolean
  HW_MSTATUS_VS_DIRTY_UPDATE:
    description: |
      Indicates whether or not hardware will write to `mstatus.VS`

      Values are:
      [separator="!"]
      !===
      h! never  ! Hardware never writes `mstatus.VS`
      h! precise  ! Hardware writes `mstatus.VS` to the Dirty (3) state precisely when V registers are modified
      h! imprecise ! Hardware writes `mstatus.VS` imprecisely. This will result in a call to unpredictable() on any attempt to read `mstatus` or write vector state.
      !===
    schema:
      type: string
      enum: ["never", "precise", "imprecise"]
  MSTATUS_VS_LEGAL_VALUES:
    description: |
      The set of values that mstatus.VS will accept from a software write.
    schema:
      type: array
      items:
        type: integer
        enum: [0, 1, 2, 3]
      maxItems: 4
      uniqueItems: true
    also_defined_in: S
    extra_validation: |
      assert MSTATUS_VS_LEGAL_VALUES.include?(0) && MSTATUS_VS_LEGAL_VALUES.include?(3) if ext?(:V)

      # if HW is writing VS, then Dirty (3) better be a supported value
      assert MSTATUS_VS_LEGAL_VALUES.include?(3) if ext?(:V) && (HW_MSTATUS_VS_DIRTY_UPDATE != "never")
