# Copyright (c) Qualcomm Technologies, Inc. and/or its subsidiaries.
# SPDX-License-Identifier: BSD-3-Clause-Clear

# yaml-language-server: $schema=../../../schemas/ext_schema.json

$schema: "ext_schema.json#"
kind: extension
name: V
type: unprivileged
long_name: Variable-length vector
versions:
  - version: "1.0.0"
    state: ratified
    ratification_date: null
description: |
  TODO
params:
  ELEN:
    description: |
      The maximum size in bits of a vector element that any operation can produce or consume, _ELEN_ {ge} 8, which
      must be a power of 2.
    schema:
      type: integer
      enum: [8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536]
  VLEN:
    description: |
      The number of bits in a single vector register, _VLEN_ {ge} ELEN, which must be a power of 2, and must be no greater than 2^16^.
    schema:
      type: integer
      enum: [8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536]
  SEW_MIN:
    description: |
      Implementations must provide fractional LMUL settings that allow the
      narrowest supported type to occupy a fraction of a vector register
      corresponding to the ratio of the narrowest supported type's width to
      that of the largest supported type's width.  In general, the
      requirement is to support LMUL {ge} SEW~MIN~/ELEN, where SEW~MIN~ is
      the narrowest supported SEW value and ELEN is the widest supported SEW
      value.
    schema:
      type: integer
      enum: [8, 16, 32, 64]
  VECTOR_AGNOSTIC_BEHAVIOR:
    description:
      When a set is marked agnostic, the corresponding set of destination
      elements in any vector destination operand can either retain the value
      they previously held, or are overwritten with 1s.
    schema:
      type: string
      enum: ["never_overwritten", "custom"]
  SUPPORT_FRACTIONAL_LMUL_BEYOND_REQUIRED:
    description:
      For a given supported fractional LMUL setting, implementations must support
      SEW settings between SEW~MIN~ and LMUL * ELEN, inclusive.
    schema:
      type: string
      enum: ["no_unrequired_supported", "custom"]
  VILL_SET_ON_RESERVED_VTYPE:
    description:
      The use of `vtype` encodings with LMUL < SEW~MIN~/ELEN is
      __reserved__, but implementations can set `vill` if they do not
      support these configurations.
    schema:
      type: boolean
  VILL_IMPLICIT_ENCODING:
    description: |
      A small implementation supporting ELEN=32 requires only seven bits of state in `vtype`: two bits for `ma` and `ta`, two bits for `vsew[1:0]` and three bits for `vlmul[2:0]`.  The illegal value represented by `vill` can be internally encoded using the illegal 64-bit combination in `vsew[1:0]` without requiring an additional storage.
      bit to hold `vill`.:
    schema:
      type: boolean
  HW_MSTATUS_VS_DIRTY_UPDATE:
    description: |
      Implementations may also change `mstatus.VS` or `vsstatus.VS` from Initial or
      Clean to Dirty at any time, even when there is no change in vector state.
    schema:
      type: string
      enum: ["never", "precise", "imprecise", "custom"]
  MSTATUS_VS_EXISTS:
    description: |
      Analogous to the way in which the floating-point unit is handled, the `mstatus.VS` field may exist even if `misa.V` is clear.
    schema:
      type: boolean
  RESERVED_VILL_SET:
    description: |
      When _rs1_=`x0` and _rd_=`x0`, the instructions operate as if the current vector length in `vl` is used as the AVL...
      Use of the instructions with a new SEW/LMUL ratio that would result in a change of VLMAX is reserved. 
      Use of the instructions is also reserved if `vill` was 1 beforehand. Implementations may set `vill` in either case.
    schema:
      type: string
      enum: ["never", "on_vlmax_change", "on_vill_set", "always", "custom"]
  VECTOR_LS_INDEX_MAX_EEW:
    description:
      A profile may place an upper limit on the maximum supported index
      EEW (e.g., only up to XLEN) smaller than ELEN.
    schema:
      type: integer
      enum: [8, 16, 32, 64]
  VECTOR_FF_UPDATE_PAST_TRIM:
    description: 
      Similarly, fault-only-first load instructions may update active destination elements past the element that causes trimming 
      of the vector length (but not past the original vector length).  The values of these spurious updates do not have to correspond 
      to the values in memory at the addressed memory locations.  Non-idempotent memory locations can only be accessed when it is known 
      the corresponding element load operation will not be restarted due to a trap or vector-length trimming.
    schema:
      type: string
      enum: ["update_none", "custom"]
  VECTOR_FF_SEG_EXCEPTION_PARTIAL_LOAD:
    description: |
      For fault-only-first segment loads, if an exception is detected partway
      through accessing the zeroth segment, the trap is taken.
      If an exception is detected partway through accessing a subsequent segment,
      `vl` is reduced to the index of that segment.
      In both cases, it is implementation-defined whether a subset of the segment is
      loaded.
    schema:
      type: string
      enum: ["no_subsegment_loaded", "custom"]
  VECTOR_LS_MISSALIGNED_EXCEPTION:
    description: |
      If an element accessed by a vector memory instruction is not naturally
      aligned to the size of the element, either the element is transferred
      successfully or an address-misaligned exception is raised on that
      element.
    schema:
      type: string
      enum: ["element_loaded_no_exception", "address-misaligned_exception"]
  VECTOR_LOAD_PAST_TRAP:
    description: |
      Load instructions may overwrite active destination vector register
      group elements past the element index at which the trap is reported.
    schema:
      type: string
      enum: ["preserve_inactive", "custom"]
  VECTOR_LS_SEG_FF_OVERLOAD:
    description: |
      These instructions may overwrite destination vector register group
      elements past the point at which a trap is reported or past the point
      at which vector length is trimmed.
    schema:
      type: string
      enum: ["no_overwrite", "custom"]
  VECTOR_LS_SEG_PARTIAL_ACCESS:
    description: |
      If a trap occurs during
      access to a segment, it is implementation-defined whether a subset
      of the faulting segment's accesses are performed before the trap is taken.
    schema:
      type: string
      enum: ["no_partial", "custom"]
  LEGAL_VSTART:
    description: |
      Implementations are permitted to raise illegal-instruction exceptions when
      attempting to execute a vector instruction with a value of `vstart` that the
      implementation can never produce when executing that same instruction with
      the same `vtype` setting.
    schema:
      type: string
      enum: ["1_stride", "2_stride", "4_stride", "custom"]
  VECTOR_LS_WHOLEREG_MISSALIGNED_EXCEPTION:
    description: |
      Implementations are allowed to raise a misaligned address exception on
      whole register loads and stores if the base address is not naturally
      aligned to the larger of the size of the encoded EEW in bytes (EEW/8)
      or the implementation's smallest supported SEW size in bytes
      (SEW~MIN~/8).
    schema:
      type: string
      enum: ["misaligned_exception", "permitted"]
  VSSTATUS_VS_EXISTS:
    description: |
      For implementations with a writable `misa.V` field,
      the `vsstatus.VS` field may exist even if `misa.V` is clear.
    schema:
      type: boolean
  VECTOR_FF_NO_EXCEPTION_TRIM:
    description: |
      Even when an exception is not raised, implementations are permitted to process
      fewer than `vl` elements and reduce `vl` accordingly, but if `vstart`=0 and
      `vl`>0, then at least one element must be processed.
    schema:
      type: string
      enum: ["no_trim", "custom"]
  vfredosum_nan
  VFREDUSUM_NAN:
    description: |
      As a consequence of this definition, implementations need not propagate
      NaN payloads through the reduction tree when no elements are active. In
      particular, if no elements are active and the scalar input is NaN,
      implementations are permitted to canonicalize the NaN and, if the NaN is
      signaling, set the invalid exception flag.  Implementations are alternatively
      permitted to pass through the original NaN and set no exception flags, as with
      `vfredosum`.
    schema:
      type: string
      enum: ["no_change", "custom"]
  VSLIDE_OPTIMIZED_VALUES:
    description: |
      Implementations
      may optimize certain OFFSET values for `vslideup` and `vslidedown`.
      In particular, power-of-2 offsets may operate substantially faster
      than other offsets.
    schema:
      type: string
      enum: ["custom"]
  MUTABLE_MISA_V:
    description: |
      Indicates whether or not the `V` extension can be disabled with the `misa.V` bit.
    schema:
      type: boolean
  HW_MSTATUS_VS_DIRTY_UPDATE:
    description: |
      Indicates whether or not hardware will write to `mstatus.VS`

      Values are:
      [separator="!"]
      !===
      h! never  ! Hardware never writes `mstatus.VS`
      h! precise  ! Hardware writes `mstatus.VS` to the Dirty (3) state precisely when V registers are modified
      h! imprecise ! Hardware writes `mstatus.VS` imprecisely. This will result in a call to unpredictable() on any attempt to read `mstatus` or write vector state.
      !===
    schema:
      type: string
      enum: ["never", "precise", "imprecise"]
  MSTATUS_VS_LEGAL_VALUES:
    description: |
      The set of values that mstatus.VS will accept from a software write.
    schema:
      type: array
      items:
        type: integer
        enum: [0, 1, 2, 3]
      maxItems: 4
      uniqueItems: true
    also_defined_in: S
    extra_validation: |
      assert MSTATUS_VS_LEGAL_VALUES.include?(0) && MSTATUS_VS_LEGAL_VALUES.include?(3) if ext?(:V)

      # if HW is writing VS, then Dirty (3) better be a supported value
      assert MSTATUS_VS_LEGAL_VALUES.include?(3) if ext?(:V) && (HW_MSTATUS_VS_DIRTY_UPDATE != "never")
