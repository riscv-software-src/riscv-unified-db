# Copyright (c) Qualcomm Technologies, Inc. and/or its subsidiaries.
# SPDX-License-Identifier: BSD-3-Clause-Clear

# yaml-language-server: $schema=../../../schemas/ext_schema.json

$schema: "ext_schema.json#"
kind: extension
name: Smepmp
type: privileged
long_name: Personal Physical Memory Protection (PMP) Enhancements for memory access and execution prevention on Machine mode
versions:
  - version: "1.0.0"
    state: ratified
    ratification_date: 2021-12
    contributors:
      - name: Nick Kossifidis
      - name: Joe Xie
      - name: Bill Huffman
      - name: Allen Baum
      - name: Greg Favor
      - name: Tariq Kurd
      - name: Fumio Arakawa
      - name: RISC-V TEE Task Group

description: |
  Being able to access the memory of a process running at a high privileged execution mode, such as the
  Supervisor or Machine mode, from a lower privileged mode such as the User mode, introduces an obvious attack
  vector since it allows for an attacker to perform privilege escalation, and tamper with the code and/or data of
  that process. A less obvious attack vector exists when the reverse happens, in which case an attacker instead of
  tampering with code and/or data that belong to a high-privileged process, can tamper with the memory of an
  unprivileged / less-privileged process and trick the high-privileged process to use or execute it.

  To prevent this attack vector, two mechanisms known as Supervisor Memory Access Prevention (SMAP) and
  Supervisor Memory Execution Prevention (SMEP) were introduced in recent systems. The first one prevents the
  OS from accessing the memory of an unprivileged process unless a specific code path is followed, and the second
  one prevents the OS from executing the memory of an unprivileged process at all times. RISC-V already includes
  support for SMAP, through the sstatus.SUM bit, and for SMEP by always denying execution of virtual memory
  pages marked with the U bit, with Supervisor mode (OS) privileges, as mandated on the Privilege Spec.

  [NOTE]
  --

  Terms:

  - *PMP Entry*: A pair of `pmpcfg[i]` / `pmpaddr[i]` registers.

  - *PMP Rule*: The contents of a pmpcfg register and its associated pmpaddr register(s),
    that encode a valid protected physical memory region, where `pmpcfg[i].A != OFF`, and
    if `pmpcfg[i].A == TOR`, `pmpaddr[i-1] < pmpaddr[i]`.
  - *Ignored*: Any permissions set by a matching PMP rule are ignored, and all accesses to
    the requested address range are allowed.
  - *Enforced*: Only access types configured in the PMP rule matching the requested address
    range are allowed; failures will cause an access-fault exception.
  - *Denied*: Any permissions set by a matching PMP rule are ignored, and no accesses to the
    requested address range are allowed.; failures will cause an access-fault exception.
  - *Locked*: A PMP rule/entry where the `pmpcfg.L` bit is set.
  - *PMP reset*: A reset process where all PMP settings of the hart, including locked
    rules/settings, are re-initialized to a set of safe defaults, before releasing the hart (back)
    to the firmware / OS / application.
  --
params:
  NUM_PMP_ENTRIES1:
    description: |
      Number of implemented PMP entries. Can be any value between 0-64, inclusive.

      The architecture mandates that the number of implemented PMP registers
      must appear to be 0, 16, or 64.

      Therefore, pmp registers will behave as follows according to NUN_PMP_ENTRIES:

      [separator="!"]
      !===
      ! NUM_PMP_ENTRIES ! pmpaddr<0-15> / pmpcfg<0-3> ! pmpaddr<16-63> / pmpcfg<4-15>
      ! 0               ! N                           ! N
      ! 1-16            ! Y                           ! N
      ! 17-64           ! Y                           ! Y
      !===

      ** N = Not implemented; access will cause `IllegalInstruction`
         if TRAP_ON_UNIMPLEMENTED_CSR is true
      ** Y = Implemented; access will not cause an exception (from M-mode), but register
         may be read-only-zero if NUM_PMP_ENTRIES is less than the corresponding register

      [NOTE]
      `pmpcfgN` for an odd N never exists when XLEN == 64

      When NUM_PMP_ENTRIES is not exactly 0, 16, or 64, some extant pmp registers,
      and associated pmpNcfg, will be read-only zero (but will never cause an exception).
    schema:
      type: integer
      minimum: 0
      maximum: 64
