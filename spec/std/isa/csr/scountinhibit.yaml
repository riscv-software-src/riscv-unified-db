# Copyright (c) Qualcomm Technologies, Inc. and/or its subsidiaries.
# SPDX-License-Identifier: BSD-3-Clause-Clear

# yaml-language-server: $schema=../../../schemas/csr_schema.json

$schema: "csr_schema.json#"
kind: csr
name: scountinhibit
long_name: Supervisor Counter-Inhibit Register
address: 0x120
writable: true
priv_mode: S
description: |
  For counters delegated to S-mode, the associated `mcountinhibit` bits can be accessed
  via `scountinhibit`. For counters not delegated to S-mode, the associated bits in
  `scountinhibit` are read-only zero.
length: SXLEN
definedBy:
  anyOf:
    - Smcdeleg
    - Ssccfg
fields:
  CY:
    location: 0
    description: |
      Cycle inhibit. When 1, the cycle counter does not increment. Only meaningful if
      mcycle is delegated to S-mode; otherwise reads as 0.
    type(): |
      return COUNTINHIBIT_EN[0] ? CsrFieldType::RW : CsrFieldType::RO;
    reset_value(): |
      return COUNTINHIBIT_EN[0] ? UNDEFINED_LEGAL : 0;
    sw_write(csr_value): |
      if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b0) {
        if (mode() == PrivilegeMode::M) {
        raise(ExceptionCode::IllegalInstruction, mode(), $encoding);
        }
      } else if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b1) {
        if ((mode() == PrivilegeMode::VS) || (mode() == PrivilegeMode::VU)) {
        raise(ExceptionCode::VirtualInstruction, mode(), $encoding);
        }
      } else {
        CSR[mcountinhibit].CY = csr_value.CY;
        return csr_value.CY;
      }
  IR:
    location: 2
    description: |
      Instructions-retired inhibit. When 1, the instret counter does not increment. Only
      meaningful if minstret is delegated to S-mode; else reads 0.
    type(): |
      return COUNTINHIBIT_EN[2] ? CsrFieldType::RW : CsrFieldType::RO;
    reset_value(): |
      return COUNTINHIBIT_EN[2] ? UNDEFINED_LEGAL : 0;
    sw_write(csr_value): |
      if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b0) {
        if (mode() == PrivilegeMode::M) {
        raise(ExceptionCode::IllegalInstruction, mode(), $encoding);
        }
      } else if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b1) {
        if ((mode() == PrivilegeMode::VS) || (mode() == PrivilegeMode::VU)) {
        raise(ExceptionCode::VirtualInstruction, mode(), $encoding);
        }
      } else {
        CSR[mcountinhibit].IR = csr_value.IR;
        return csr_value.IR;
      }
  HPM3:
    location: 3
    description:
      - id: csr-field-hpmcounter3.COUNT-effect
        normative: true
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 3
            value: true
        text: |
          When bit is set `hpmcounter3.COUNT` does not increment; when 0, `hpmcounter3.COUNT` increments normally.
      - id: hpmcounter3-not-implemented
        normative: false
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 3
            value: flase
        text: |
          Since hpmcounter3 is not implemented, this field is read-only zero.
    type(): |
      return COUNTINHIBIT_EN[3] ? CsrFieldType::RW : CsrFieldType::RO;
    reset_value(): |
      return COUNTINHIBIT_EN[3] ? UNDEFINED_LEGAL : 0;
    sw_write(csr_value): |
      if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b0) {
        if (mode() == PrivilegeMode::M) {
        raise(ExceptionCode::IllegalInstruction, mode(), $encoding);
        }
      } else if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b1) {
        if ((mode() == PrivilegeMode::VS) || (mode() == PrivilegeMode::VU)) {
        raise(ExceptionCode::VirtualInstruction, mode(), $encoding);
        }
      } else {
        CSR[mcountinhibit].HPM3 = csr_value.HPM3;
        return csr_value.HPM3;
      }
  HPM4:
    location: 4
    description:
      - id: csr-field-hpmcounter4.COUNT-effect
        normative: true
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 4
            value: true
        text: |
          When bit is set `hpmcounter4.COUNT` does not increment; when 0, `hpmcounter4.COUNT` increments normally.
      - id: hpmcounter4-not-implemented
        normative: false
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 4
            value: flase
        text: |
          Since hpmcounter4 is not implemented, this field is read-only zero.
    type(): |
      return COUNTINHIBIT_EN[4] ? CsrFieldType::RW : CsrFieldType::RO;
    reset_value(): |
      return COUNTINHIBIT_EN[4] ? UNDEFINED_LEGAL : 0;
    sw_write(csr_value): |
      if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b0) {
        if (mode() == PrivilegeMode::M) {
        raise(ExceptionCode::IllegalInstruction, mode(), $encoding);
        }
      } else if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b1) {
        if ((mode() == PrivilegeMode::VS) || (mode() == PrivilegeMode::VU)) {
        raise(ExceptionCode::VirtualInstruction, mode(), $encoding);
        }
      } else {
        CSR[mcountinhibit].HPM4 = csr_value.HPM4;
        return csr_value.HPM4;
      }
  HPM5:
    location: 5
    description:
      - id: csr-field-hpmcounter5.COUNT-effect
        normative: true
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 5
            value: true
        text: |
          When bit is set `hpmcounter5.COUNT` does not increment; when 0, `hpmcounter5.COUNT` increments normally.
      - id: hpmcounter5-not-implemented
        normative: false
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 5
            value: flase
        text: |
          Since hpmcounter5 is not implemented, this field is read-only zero.
    type(): |
      return COUNTINHIBIT_EN[5] ? CsrFieldType::RW : CsrFieldType::RO;
    reset_value(): |
      return COUNTINHIBIT_EN[5] ? UNDEFINED_LEGAL : 0;
    sw_write(csr_value): |
      if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b0) {
        if (mode() == PrivilegeMode::M) {
        raise(ExceptionCode::IllegalInstruction, mode(), $encoding);
        }
      } else if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b1) {
        if ((mode() == PrivilegeMode::VS) || (mode() == PrivilegeMode::VU)) {
        raise(ExceptionCode::VirtualInstruction, mode(), $encoding);
        }
      } else {
        CSR[mcountinhibit].HPM5 = csr_value.HPM5;
        return csr_value.HPM5;
      }
  HPM6:
    location: 6
    description:
      - id: csr-field-hpmcounter6.COUNT-effect
        normative: true
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 6
            value: true
        text: |
          When bit is set `hpmcounter6.COUNT` does not increment; when 0, `hpmcounter6.COUNT` increments normally.
      - id: hpmcounter6-not-implemented
        normative: false
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 6
            value: flase
        text: |
          Since hpmcounter6 is not implemented, this field is read-only zero.
    type(): |
      return COUNTINHIBIT_EN[6] ? CsrFieldType::RW : CsrFieldType::RO;
    reset_value(): |
      return COUNTINHIBIT_EN[6] ? UNDEFINED_LEGAL : 0;
    sw_write(csr_value): |
      if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b0) {
        if (mode() == PrivilegeMode::M) {
        raise(ExceptionCode::IllegalInstruction, mode(), $encoding);
        }
      } else if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b1) {
        if ((mode() == PrivilegeMode::VS) || (mode() == PrivilegeMode::VU)) {
        raise(ExceptionCode::VirtualInstruction, mode(), $encoding);
        }
      } else {
        CSR[mcountinhibit].HPM6 = csr_value.HPM6;
        return csr_value.HPM6;
      }
  HPM7:
    location: 7
    description:
      - id: csr-field-hpmcounter7.COUNT-effect
        normative: true
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 7
            value: true
        text: |
          When bit is set `hpmcounter7.COUNT` does not increment; when 0, `hpmcounter7.COUNT` increments normally.
      - id: hpmcounter7-not-implemented
        normative: false
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 7
            value: flase
        text: |
          Since hpmcounter7 is not implemented, this field is read-only zero.
    type(): |
      return COUNTINHIBIT_EN[7] ? CsrFieldType::RW : CsrFieldType::RO;
    reset_value(): |
      return COUNTINHIBIT_EN[7] ? UNDEFINED_LEGAL : 0;
    sw_write(csr_value): |
      if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b0) {
        if (mode() == PrivilegeMode::M) {
        raise(ExceptionCode::IllegalInstruction, mode(), $encoding);
        }
      } else if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b1) {
        if ((mode() == PrivilegeMode::VS) || (mode() == PrivilegeMode::VU)) {
        raise(ExceptionCode::VirtualInstruction, mode(), $encoding);
        }
      } else {
        CSR[mcountinhibit].HPM7 = csr_value.HPM7;
        return csr_value.HPM7;
      }
  HPM8:
    location: 8
    description:
      - id: csr-field-hpmcounter8.COUNT-effect
        normative: true
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 8
            value: true
        text: |
          When bit is set `hpmcounter8.COUNT` does not increment; when 0, `hpmcounter8.COUNT` increments normally.
      - id: hpmcounter8-not-implemented
        normative: false
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 8
            value: flase
        text: |
          Since hpmcounter8 is not implemented, this field is read-only zero.
    type(): |
      return COUNTINHIBIT_EN[8] ? CsrFieldType::RW : CsrFieldType::RO;
    reset_value(): |
      return COUNTINHIBIT_EN[8] ? UNDEFINED_LEGAL : 0;
    sw_write(csr_value): |
      if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b0) {
        if (mode() == PrivilegeMode::M) {
        raise(ExceptionCode::IllegalInstruction, mode(), $encoding);
        }
      } else if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b1) {
        if ((mode() == PrivilegeMode::VS) || (mode() == PrivilegeMode::VU)) {
        raise(ExceptionCode::VirtualInstruction, mode(), $encoding);
        }
      } else {
        CSR[mcountinhibit].HPM8 = csr_value.HPM8;
        return csr_value.HPM8;
      }
  HPM9:
    location: 9
    description:
      - id: csr-field-hpmcounter9.COUNT-effect
        normative: true
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 9
            value: true
        text: |
          When bit is set `hpmcounter9.COUNT` does not increment; when 0, `hpmcounter9.COUNT` increments normally.
      - id: hpmcounter9-not-implemented
        normative: false
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 9
            value: flase
        text: |
          Since hpmcounter9 is not implemented, this field is read-only zero.
    type(): |
      return COUNTINHIBIT_EN[9] ? CsrFieldType::RW : CsrFieldType::RO;
    reset_value(): |
      return COUNTINHIBIT_EN[9] ? UNDEFINED_LEGAL : 0;
    sw_write(csr_value): |
      if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b0) {
        if (mode() == PrivilegeMode::M) {
        raise(ExceptionCode::IllegalInstruction, mode(), $encoding);
        }
      } else if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b1) {
        if ((mode() == PrivilegeMode::VS) || (mode() == PrivilegeMode::VU)) {
        raise(ExceptionCode::VirtualInstruction, mode(), $encoding);
        }
      } else {
        CSR[mcountinhibit].HPM9 = csr_value.HPM9;
        return csr_value.HPM9;
      }
  HPM10:
    location: 10
    description:
      - id: csr-field-hpmcounter10.COUNT-effect
        normative: true
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 10
            value: true
        text: |
          When bit is set `hpmcounter10.COUNT` does not increment; when 0, `hpmcounter10.COUNT` increments normally.
      - id: hpmcounter10-not-implemented
        normative: false
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 10
            value: flase
        text: |
          Since hpmcounter10 is not implemented, this field is read-only zero.
    type(): |
      return COUNTINHIBIT_EN[10] ? CsrFieldType::RW : CsrFieldType::RO;
    reset_value(): |
      return COUNTINHIBIT_EN[10] ? UNDEFINED_LEGAL : 0;
    sw_write(csr_value): |
      if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b0) {
        if (mode() == PrivilegeMode::M) {
        raise(ExceptionCode::IllegalInstruction, mode(), $encoding);
        }
      } else if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b1) {
        if ((mode() == PrivilegeMode::VS) || (mode() == PrivilegeMode::VU)) {
        raise(ExceptionCode::VirtualInstruction, mode(), $encoding);
        }
      } else {
        CSR[mcountinhibit].HPM10 = csr_value.HPM10;
        return csr_value.HPM10;
      }
  HPM11:
    location: 11
    description:
      - id: csr-field-hpmcounter11.COUNT-effect
        normative: true
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 11
            value: true
        text: |
          When bit is set `hpmcounter11.COUNT` does not increment; when 0, `hpmcounter11.COUNT` increments normally.
      - id: hpmcounter11-not-implemented
        normative: false
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 11
            value: flase
        text: |
          Since hpmcounter11 is not implemented, this field is read-only zero.
    type(): |
      return COUNTINHIBIT_EN[11] ? CsrFieldType::RW : CsrFieldType::RO;
    reset_value(): |
      return COUNTINHIBIT_EN[11] ? UNDEFINED_LEGAL : 0;
    sw_write(csr_value): |
      if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b0) {
        if (mode() == PrivilegeMode::M) {
        raise(ExceptionCode::IllegalInstruction, mode(), $encoding);
        }
      } else if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b1) {
        if ((mode() == PrivilegeMode::VS) || (mode() == PrivilegeMode::VU)) {
        raise(ExceptionCode::VirtualInstruction, mode(), $encoding);
        }
      } else {
        CSR[mcountinhibit].HPM11 = csr_value.HPM11;
        return csr_value.HPM11;
      }
  HPM12:
    location: 12
    description:
      - id: csr-field-hpmcounter12.COUNT-effect
        normative: true
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 12
            value: true
        text: |
          When bit is set `hpmcounter12.COUNT` does not increment; when 0, `hpmcounter12.COUNT` increments normally.
      - id: hpmcounter12-not-implemented
        normative: false
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 12
            value: flase
        text: |
          Since hpmcounter12 is not implemented, this field is read-only zero.
    type(): |
      return COUNTINHIBIT_EN[12] ? CsrFieldType::RW : CsrFieldType::RO;
    reset_value(): |
      return COUNTINHIBIT_EN[12] ? UNDEFINED_LEGAL : 0;
    sw_write(csr_value): |
      if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b0) {
        if (mode() == PrivilegeMode::M) {
        raise(ExceptionCode::IllegalInstruction, mode(), $encoding);
        }
      } else if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b1) {
        if ((mode() == PrivilegeMode::VS) || (mode() == PrivilegeMode::VU)) {
        raise(ExceptionCode::VirtualInstruction, mode(), $encoding);
        }
      } else {
        CSR[mcountinhibit].HPM12 = csr_value.HPM12;
        return csr_value.HPM12;
      }
  HPM13:
    location: 13
    description:
      - id: csr-field-hpmcounter13.COUNT-effect
        normative: true
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 13
            value: true
        text: |
          When bit is set `hpmcounter13.COUNT` does not increment; when 0, `hpmcounter13.COUNT` increments normally.
      - id: hpmcounter13-not-implemented
        normative: false
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 13
            value: flase
        text: |
          Since hpmcounter13 is not implemented, this field is read-only zero.
    type(): |
      return COUNTINHIBIT_EN[13] ? CsrFieldType::RW : CsrFieldType::RO;
    reset_value(): |
      return COUNTINHIBIT_EN[13] ? UNDEFINED_LEGAL : 0;
    sw_write(csr_value): |
      if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b0) {
        if (mode() == PrivilegeMode::M) {
        raise(ExceptionCode::IllegalInstruction, mode(), $encoding);
        }
      } else if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b1) {
        if ((mode() == PrivilegeMode::VS) || (mode() == PrivilegeMode::VU)) {
        raise(ExceptionCode::VirtualInstruction, mode(), $encoding);
        }
      } else {
        CSR[mcountinhibit].HPM13 = csr_value.HPM13;
        return csr_value.HPM13;
      }
  HPM14:
    location: 14
    description:
      - id: csr-field-hpmcounter14.COUNT-effect
        normative: true
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 14
            value: true
        text: |
          When bit is set `hpmcounter14.COUNT` does not increment; when 0, `hpmcounter14.COUNT` increments normally.
      - id: hpmcounter14-not-implemented
        normative: false
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 14
            value: flase
        text: |
          Since hpmcounter14 is not implemented, this field is read-only zero.
    type(): |
      return COUNTINHIBIT_EN[14] ? CsrFieldType::RW : CsrFieldType::RO;
    reset_value(): |
      return COUNTINHIBIT_EN[14] ? UNDEFINED_LEGAL : 0;
    sw_write(csr_value): |
      if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b0) {
        if (mode() == PrivilegeMode::M) {
        raise(ExceptionCode::IllegalInstruction, mode(), $encoding);
        }
      } else if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b1) {
        if ((mode() == PrivilegeMode::VS) || (mode() == PrivilegeMode::VU)) {
        raise(ExceptionCode::VirtualInstruction, mode(), $encoding);
        }
      } else {
        CSR[mcountinhibit].HPM14 = csr_value.HPM14;
        return csr_value.HPM14;
      }
  HPM15:
    location: 15
    description:
      - id: csr-field-hpmcounter15.COUNT-effect
        normative: true
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 15
            value: true
        text: |
          When bit is set `hpmcounter15.COUNT` does not increment; when 0, `hpmcounter15.COUNT` increments normally.
      - id: hpmcounter15-not-implemented
        normative: false
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 15
            value: flase
        text: |
          Since hpmcounter15 is not implemented, this field is read-only zero.
    type(): |
      return COUNTINHIBIT_EN[15] ? CsrFieldType::RW : CsrFieldType::RO;
    reset_value(): |
      return COUNTINHIBIT_EN[15] ? UNDEFINED_LEGAL : 0;
    sw_write(csr_value): |
      if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b0) {
        if (mode() == PrivilegeMode::M) {
        raise(ExceptionCode::IllegalInstruction, mode(), $encoding);
        }
      } else if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b1) {
        if ((mode() == PrivilegeMode::VS) || (mode() == PrivilegeMode::VU)) {
        raise(ExceptionCode::VirtualInstruction, mode(), $encoding);
        }
      } else {
        CSR[mcountinhibit].HPM15 = csr_value.HPM15;
        return csr_value.HPM15;
      }
  HPM16:
    location: 16
    description:
      - id: csr-field-hpmcounter16.COUNT-effect
        normative: true
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 16
            value: true
        text: |
          When bit is set `hpmcounter16.COUNT` does not increment; when 0, `hpmcounter16.COUNT` increments normally.
      - id: hpmcounter16-not-implemented
        normative: false
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 16
            value: flase
        text: |
          Since hpmcounter16 is not implemented, this field is read-only zero.
    type(): |
      return COUNTINHIBIT_EN[16] ? CsrFieldType::RW : CsrFieldType::RO;
    reset_value(): |
      return COUNTINHIBIT_EN[16] ? UNDEFINED_LEGAL : 0;
    sw_write(csr_value): |
      if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b0) {
        if (mode() == PrivilegeMode::M) {
        raise(ExceptionCode::IllegalInstruction, mode(), $encoding);
        }
      } else if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b1) {
        if ((mode() == PrivilegeMode::VS) || (mode() == PrivilegeMode::VU)) {
        raise(ExceptionCode::VirtualInstruction, mode(), $encoding);
        }
      } else {
        CSR[mcountinhibit].HPM16 = csr_value.HPM16;
        return csr_value.HPM16;
      }
  HPM17:
    location: 17
    description:
      - id: csr-field-hpmcounter17.COUNT-effect
        normative: true
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 17
            value: true
        text: |
          When bit is set `hpmcounter17.COUNT` does not increment; when 0, `hpmcounter17.COUNT` increments normally.
      - id: hpmcounter17-not-implemented
        normative: false
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 17
            value: flase
        text: |
          Since hpmcounter17 is not implemented, this field is read-only zero.
    type(): |
      return COUNTINHIBIT_EN[17] ? CsrFieldType::RW : CsrFieldType::RO;
    reset_value(): |
      return COUNTINHIBIT_EN[17] ? UNDEFINED_LEGAL : 0;
    sw_write(csr_value): |
      if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b0) {
        if (mode() == PrivilegeMode::M) {
        raise(ExceptionCode::IllegalInstruction, mode(), $encoding);
        }
      } else if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b1) {
        if ((mode() == PrivilegeMode::VS) || (mode() == PrivilegeMode::VU)) {
        raise(ExceptionCode::VirtualInstruction, mode(), $encoding);
        }
      } else {
        CSR[mcountinhibit].HPM17 = csr_value.HPM17;
        return csr_value.HPM17;
      }
  HPM18:
    location: 18
    description:
      - id: csr-field-hpmcounter18.COUNT-effect
        normative: true
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 18
            value: true
        text: |
          When bit is set `hpmcounter18.COUNT` does not increment; when 0, `hpmcounter18.COUNT` increments normally.
      - id: hpmcounter18-not-implemented
        normative: false
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 18
            value: flase
        text: |
          Since hpmcounter18 is not implemented, this field is read-only zero.
    type(): |
      return COUNTINHIBIT_EN[18] ? CsrFieldType::RW : CsrFieldType::RO;
    reset_value(): |
      return COUNTINHIBIT_EN[18] ? UNDEFINED_LEGAL : 0;
    sw_write(csr_value): |
      if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b0) {
        if (mode() == PrivilegeMode::M) {
        raise(ExceptionCode::IllegalInstruction, mode(), $encoding);
        }
      } else if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b1) {
        if ((mode() == PrivilegeMode::VS) || (mode() == PrivilegeMode::VU)) {
        raise(ExceptionCode::VirtualInstruction, mode(), $encoding);
        }
      } else {
        CSR[mcountinhibit].HPM18 = csr_value.HPM18;
        return csr_value.HPM18;
      }
  HPM19:
    location: 19
    description:
      - id: csr-field-hpmcounter19.COUNT-effect
        normative: true
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 19
            value: true
        text: |
          When bit is set `hpmcounter19.COUNT` does not increment; when 0, `hpmcounter19.COUNT` increments normally.
      - id: hpmcounter19-not-implemented
        normative: false
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 19
            value: flase
        text: |
          Since hpmcounter19 is not implemented, this field is read-only zero.
    type(): |
      return COUNTINHIBIT_EN[19] ? CsrFieldType::RW : CsrFieldType::RO;
    reset_value(): |
      return COUNTINHIBIT_EN[19] ? UNDEFINED_LEGAL : 0;
    sw_write(csr_value): |
      if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b0) {
        if (mode() == PrivilegeMode::M) {
        raise(ExceptionCode::IllegalInstruction, mode(), $encoding);
        }
      } else if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b1) {
        if ((mode() == PrivilegeMode::VS) || (mode() == PrivilegeMode::VU)) {
        raise(ExceptionCode::VirtualInstruction, mode(), $encoding);
        }
      } else {
        CSR[mcountinhibit].HPM19 = csr_value.HPM19;
        return csr_value.HPM19;
      }
  HPM20:
    location: 20
    description:
      - id: csr-field-hpmcounter20.COUNT-effect
        normative: true
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 20
            value: true
        text: |
          When bit is set `hpmcounter20.COUNT` does not increment; when 0, `hpmcounter20.COUNT` increments normally.
      - id: hpmcounter20-not-implemented
        normative: false
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 20
            value: flase
        text: |
          Since hpmcounter20 is not implemented, this field is read-only zero.
    type(): |
      return COUNTINHIBIT_EN[20] ? CsrFieldType::RW : CsrFieldType::RO;
    reset_value(): |
      return COUNTINHIBIT_EN[20] ? UNDEFINED_LEGAL : 0;
    sw_write(csr_value): |
      if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b0) {
        if (mode() == PrivilegeMode::M) {
        raise(ExceptionCode::IllegalInstruction, mode(), $encoding);
        }
      } else if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b1) {
        if ((mode() == PrivilegeMode::VS) || (mode() == PrivilegeMode::VU)) {
        raise(ExceptionCode::VirtualInstruction, mode(), $encoding);
        }
      } else {
        CSR[mcountinhibit].HPM20 = csr_value.HPM20;
        return csr_value.HPM20;
      }
  HPM21:
    location: 21
    description:
      - id: csr-field-hpmcounter21.COUNT-effect
        normative: true
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 21
            value: true
        text: |
          When bit is set `hpmcounter21.COUNT` does not increment; when 0, `hpmcounter21.COUNT` increments normally.
      - id: hpmcounter21-not-implemented
        normative: false
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 21
            value: flase
        text: |
          Since hpmcounter21 is not implemented, this field is read-only zero.
    type(): |
      return COUNTINHIBIT_EN[21] ? CsrFieldType::RW : CsrFieldType::RO;
    reset_value(): |
      return COUNTINHIBIT_EN[21] ? UNDEFINED_LEGAL : 0;
    sw_write(csr_value): |
      if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b0) {
        if (mode() == PrivilegeMode::M) {
        raise(ExceptionCode::IllegalInstruction, mode(), $encoding);
        }
      } else if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b1) {
        if ((mode() == PrivilegeMode::VS) || (mode() == PrivilegeMode::VU)) {
        raise(ExceptionCode::VirtualInstruction, mode(), $encoding);
        }
      } else {
        CSR[mcountinhibit].HPM21 = csr_value.HPM21;
        return csr_value.HPM21;
      }
  HPM22:
    location: 22
    description:
      - id: csr-field-hpmcounter22.COUNT-effect
        normative: true
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 22
            value: true
        text: |
          When bit is set `hpmcounter22.COUNT` does not increment; when 0, `hpmcounter22.COUNT` increments normally.
      - id: hpmcounter22-not-implemented
        normative: false
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 22
            value: flase
        text: |
          Since hpmcounter22 is not implemented, this field is read-only zero.
    type(): |
      return COUNTINHIBIT_EN[22] ? CsrFieldType::RW : CsrFieldType::RO;
    reset_value(): |
      return COUNTINHIBIT_EN[22] ? UNDEFINED_LEGAL : 0;
    sw_write(csr_value): |
      if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b0) {
        if (mode() == PrivilegeMode::M) {
        raise(ExceptionCode::IllegalInstruction, mode(), $encoding);
        }
      } else if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b1) {
        if ((mode() == PrivilegeMode::VS) || (mode() == PrivilegeMode::VU)) {
        raise(ExceptionCode::VirtualInstruction, mode(), $encoding);
        }
      } else {
        CSR[mcountinhibit].HPM22 = csr_value.HPM22;
        return csr_value.HPM22;
      }
  HPM23:
    location: 23
    description:
      - id: csr-field-hpmcounter23.COUNT-effect
        normative: true
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 23
            value: true
        text: |
          When bit is set `hpmcounter23.COUNT` does not increment; when 0, `hpmcounter23.COUNT` increments normally.
      - id: hpmcounter23-not-implemented
        normative: false
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 23
            value: flase
        text: |
          Since hpmcounter23 is not implemented, this field is read-only zero.
    type(): |
      return COUNTINHIBIT_EN[23] ? CsrFieldType::RW : CsrFieldType::RO;
    reset_value(): |
      return COUNTINHIBIT_EN[23] ? UNDEFINED_LEGAL : 0;
    sw_write(csr_value): |
      if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b0) {
        if (mode() == PrivilegeMode::M) {
        raise(ExceptionCode::IllegalInstruction, mode(), $encoding);
        }
      } else if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b1) {
        if ((mode() == PrivilegeMode::VS) || (mode() == PrivilegeMode::VU)) {
        raise(ExceptionCode::VirtualInstruction, mode(), $encoding);
        }
      } else {
        CSR[mcountinhibit].HPM23 = csr_value.HPM23;
        return csr_value.HPM23;
      }
  HPM24:
    location: 24
    description:
      - id: csr-field-hpmcounter24.COUNT-effect
        normative: true
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 24
            value: true
        text: |
          When bit is set `hpmcounter24.COUNT` does not increment; when 0, `hpmcounter24.COUNT` increments normally.
      - id: hpmcounter24-not-implemented
        normative: false
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 24
            value: flase
        text: |
          Since hpmcounter24 is not implemented, this field is read-only zero.
    type(): |
      return COUNTINHIBIT_EN[24] ? CsrFieldType::RW : CsrFieldType::RO;
    reset_value(): |
      return COUNTINHIBIT_EN[24] ? UNDEFINED_LEGAL : 0;
    sw_write(csr_value): |
      if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b0) {
        if (mode() == PrivilegeMode::M) {
        raise(ExceptionCode::IllegalInstruction, mode(), $encoding);
        }
      } else if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b1) {
        if ((mode() == PrivilegeMode::VS) || (mode() == PrivilegeMode::VU)) {
        raise(ExceptionCode::VirtualInstruction, mode(), $encoding);
        }
      } else {
        CSR[mcountinhibit].HPM24 = csr_value.HPM24;
        return csr_value.HPM24;
      }
  HPM25:
    location: 25
    description:
      - id: csr-field-hpmcounter25.COUNT-effect
        normative: true
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 25
            value: true
        text: |
          When bit is set `hpmcounter25.COUNT` does not increment; when 0, `hpmcounter25.COUNT` increments normally.
      - id: hpmcounter25-not-implemented
        normative: false
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 25
            value: flase
        text: |
          Since hpmcounter25 is not implemented, this field is read-only zero.
    type(): |
      return COUNTINHIBIT_EN[25] ? CsrFieldType::RW : CsrFieldType::RO;
    reset_value(): |
      return COUNTINHIBIT_EN[25] ? UNDEFINED_LEGAL : 0;
    sw_write(csr_value): |
      if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b0) {
        if (mode() == PrivilegeMode::M) {
        raise(ExceptionCode::IllegalInstruction, mode(), $encoding);
        }
      } else if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b1) {
        if ((mode() == PrivilegeMode::VS) || (mode() == PrivilegeMode::VU)) {
        raise(ExceptionCode::VirtualInstruction, mode(), $encoding);
        }
      } else {
        CSR[mcountinhibit].HPM25 = csr_value.HPM25;
        return csr_value.HPM25;
      }
  HPM26:
    location: 26
    description:
      - id: csr-field-hpmcounter26.COUNT-effect
        normative: true
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 26
            value: true
        text: |
          When bit is set `hpmcounter26.COUNT` does not increment; when 0, `hpmcounter26.COUNT` increments normally.
      - id: hpmcounter26-not-implemented
        normative: false
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 26
            value: flase
        text: |
          Since hpmcounter26 is not implemented, this field is read-only zero.
    type(): |
      return COUNTINHIBIT_EN[26] ? CsrFieldType::RW : CsrFieldType::RO;
    reset_value(): |
      return COUNTINHIBIT_EN[26] ? UNDEFINED_LEGAL : 0;
    sw_write(csr_value): |
      if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b0) {
        if (mode() == PrivilegeMode::M) {
        raise(ExceptionCode::IllegalInstruction, mode(), $encoding);
        }
      } else if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b1) {
        if ((mode() == PrivilegeMode::VS) || (mode() == PrivilegeMode::VU)) {
        raise(ExceptionCode::VirtualInstruction, mode(), $encoding);
        }
      } else {
        CSR[mcountinhibit].HPM26 = csr_value.HPM26;
        return csr_value.HPM26;
      }
  HPM27:
    location: 27
    description:
      - id: csr-field-hpmcounter27.COUNT-effect
        normative: true
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 27
            value: true
        text: |
          When bit is set `hpmcounter27.COUNT` does not increment; when 0, `hpmcounter27.COUNT` increments normally.
      - id: hpmcounter27-not-implemented
        normative: false
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 27
            value: flase
        text: |
          Since hpmcounter27 is not implemented, this field is read-only zero.
    type(): |
      return COUNTINHIBIT_EN[27] ? CsrFieldType::RW : CsrFieldType::RO;
    reset_value(): |
      return COUNTINHIBIT_EN[27] ? UNDEFINED_LEGAL : 0;
    sw_write(csr_value): |
      if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b0) {
        if (mode() == PrivilegeMode::M) {
        raise(ExceptionCode::IllegalInstruction, mode(), $encoding);
        }
      } else if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b1) {
        if ((mode() == PrivilegeMode::VS) || (mode() == PrivilegeMode::VU)) {
        raise(ExceptionCode::VirtualInstruction, mode(), $encoding);
        }
      } else {
        CSR[mcountinhibit].HPM27 = csr_value.HPM27;
        return csr_value.HPM27;
      }
  HPM28:
    location: 28
    description:
      - id: csr-field-hpmcounter28.COUNT-effect
        normative: true
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 28
            value: true
        text: |
          When bit is set `hpmcounter28.COUNT` does not increment; when 0, `hpmcounter28.COUNT` increments normally.
      - id: hpmcounter28-not-implemented
        normative: false
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 28
            value: flase
        text: |
          Since hpmcounter28 is not implemented, this field is read-only zero.
    type(): |
      return COUNTINHIBIT_EN[28] ? CsrFieldType::RW : CsrFieldType::RO;
    reset_value(): |
      return COUNTINHIBIT_EN[28] ? UNDEFINED_LEGAL : 0;
    sw_write(csr_value): |
      if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b0) {
        if (mode() == PrivilegeMode::M) {
        raise(ExceptionCode::IllegalInstruction, mode(), $encoding);
        }
      } else if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b1) {
        if ((mode() == PrivilegeMode::VS) || (mode() == PrivilegeMode::VU)) {
        raise(ExceptionCode::VirtualInstruction, mode(), $encoding);
        }
      } else {
        CSR[mcountinhibit].HPM28 = csr_value.HPM28;
        return csr_value.HPM28;
      }
  HPM29:
    location: 29
    description:
      - id: csr-field-hpmcounter29.COUNT-effect
        normative: true
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 29
            value: true
        text: |
          When bit is set `hpmcounter29.COUNT` does not increment; when 0, `hpmcounter29.COUNT` increments normally.
      - id: hpmcounter29-not-implemented
        normative: false
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 29
            value: flase
        text: |
          Since hpmcounter29 is not implemented, this field is read-only zero.
    type(): |
      return COUNTINHIBIT_EN[29] ? CsrFieldType::RW : CsrFieldType::RO;
    reset_value(): |
      return COUNTINHIBIT_EN[29] ? UNDEFINED_LEGAL : 0;
    sw_write(csr_value): |
      if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b0) {
        if (mode() == PrivilegeMode::M) {
        raise(ExceptionCode::IllegalInstruction, mode(), $encoding);
        }
      } else if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b1) {
        if ((mode() == PrivilegeMode::VS) || (mode() == PrivilegeMode::VU)) {
        raise(ExceptionCode::VirtualInstruction, mode(), $encoding);
        }
      } else {
        CSR[mcountinhibit].HPM29 = csr_value.HPM29;
        return csr_value.HPM29;
      }
  HPM30:
    location: 30
    description:
      - id: csr-field-hpmcounter30.COUNT-effect
        normative: true
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 30
            value: true
        text: |
          When bit is set `hpmcounter30.COUNT` does not increment; when 0, `hpmcounter30.COUNT` increments normally.
      - id: hpmcounter30-not-implemented
        normative: false
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 30
            value: flase
        text: |
          Since hpmcounter30 is not implemented, this field is read-only zero.
    type(): |
      return COUNTINHIBIT_EN[30] ? CsrFieldType::RW : CsrFieldType::RO;
    reset_value(): |
      return COUNTINHIBIT_EN[30] ? UNDEFINED_LEGAL : 0;
    sw_write(csr_value): |
      if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b0) {
        if (mode() == PrivilegeMode::M) {
        raise(ExceptionCode::IllegalInstruction, mode(), $encoding);
        }
      } else if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b1) {
        if ((mode() == PrivilegeMode::VS) || (mode() == PrivilegeMode::VU)) {
        raise(ExceptionCode::VirtualInstruction, mode(), $encoding);
        }
      } else {
        CSR[mcountinhibit].HPM30 = csr_value.HPM30;
        return csr_value.30;
      }
  HPM31:
    location: 31
    description:
      - id: csr-field-hpmcounter31.COUNT-effect
        normative: true
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 31
            value: true
        text: |
          When bit is set `hpmcounter31.COUNT` does not increment; when 0, `hpmcounter31.COUNT` increments normally.
      - id: hpmcounter31-not-implemented
        normative: false
        when:
          param:
            name: COUNTINHIBIT_EN
            index: 31
            value: flase
        text: |
          Since hpmcounter31 is not implemented, this field is read-only zero.
    type(): |
      return COUNTINHIBIT_EN[31] ? CsrFieldType::RW : CsrFieldType::RO;
    reset_value(): |
      return COUNTINHIBIT_EN[31] ? UNDEFINED_LEGAL : 0;
    sw_write(csr_value): |
      if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b0) {
        if (mode() == PrivilegeMode::M) {
        raise(ExceptionCode::IllegalInstruction, mode(), $encoding);
        }
      } else if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b1) {
        if ((mode() == PrivilegeMode::VS) || (mode() == PrivilegeMode::VU)) {
        raise(ExceptionCode::VirtualInstruction, mode(), $encoding);
        }
      } else {
        CSR[mcountinhibit].HPM31 = csr_value.HPM31;
        return csr_value.HPM31;
      }
sw_read(): |
  if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b0) {
    if (mode() == PrivilegeMode::M) {
    raise(ExceptionCode::IllegalInstruction, mode(), $encoding);
    }
  } else if (implemented_csr?(CsrName::menvcfg) && CSR[menvcfg].CDE == 1'b1) {
    if ((mode() == PrivilegeMode::VS) || (mode() == PrivilegeMode::VU)) {
    raise(ExceptionCode::VirtualInstruction, mode(), $encoding);
    }
  } else {
  return ($bits(CSR[mcountinhibit]) & ($bits(CSR[scounteren]) & ~32'd2)) ;
  }
