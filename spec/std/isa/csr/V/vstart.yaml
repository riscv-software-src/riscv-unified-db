# Copyright (c) Qualcomm Technologies, Inc. and/or its subsidiaries.
# SPDX-License-Identifier: BSD-3-Clause-Clear

# yaml-language-server: $schema=../../schemas/csr_schema.json

$schema: "csr_schema.json#"
kind: csr
name: vstart
long_name: Vector Start Index
address: 0x008
writable: true
priv_mode: U
length: MXLEN
description: Specifies the index of the first element to be executed by a vector instruction.
definedBy: V
fields:
  VALUE:
    location_rv32: 31-0
    location_rv64: 63-0
    description: |
      Normally, vstart is only written by hardware on a trap on a vector instruction, with the vstart value
      representing the element on which the trap was taken (either a synchronous exception or an
      asynchronous interrupt), and at which execution should resume after a resumable trap is handled.
      All vector instructions are defined to begin execution with the element number given in the vstart
      CSR, leaving earlier elements in the destination vector undisturbed, and to reset the vstart CSR to
      zero at the end of execution.

      [NOTE]
      All vector instructions, including vset{i}vl{i}, reset the vstart CSR to zero.
      vstart is not modified by vector instructions that raise illegal-instruction exceptions.
      The vstart CSR is defined to have only enough writable bits to hold the largest element index (one
      less than the maximum VLMAX).

      [NOTE]
      The maximum vector length is obtained with the largest LMUL setting (8) and the smallest
      SEW setting (8), so VLMAX_max = 8*VLEN/8 = VLEN. For example, for VLEN=256,
      vstart would have 8 bits to represent indices from 0 through 255.

      The use of vstart values greater than the largest element index for the current vtype setting is
      reserved.

      [NOTE]
      It is recommended that implementations trap if vstart is out of bounds. It is not required
      to trap, as a possible future use of upper vstart bits is to store imprecise trap
      information.

      The vstart CSR is writable by unprivileged code, but non-zero vstart values may cause vector
      instructions to run substantially slower on some implementations, so vstart should not be used by
      application programmers. A few vector instructions cannot be executed with a non-zero vstart value
      and will raise an illegal instruction exception as defined below.

      [NOTE]
      Making vstart visible to unprivileged code supports user-level threading libraries.

      Implementations are permitted to raise illegal instruction exceptions when attempting to execute a
      vector instruction with a value of vstart that the implementation can never produce when executing
      that same instruction with the same vtype setting.

      [NOTE]
      For example, some implementations will never take interrupts during execution of a vector
      arithmetic instruction, instead waiting until the instruction completes to take the
      interrupt. Such implementations are permitted to raise an illegal instruction exception
      when attempting to execute a vector arithmetic instruction when vstart is nonzero.

      [NOTE]
      When migrating a software thread between two harts with different microarchitectures,
      the vstart value might not be supported by the new hart microarchitecture. The runtime
      on the receiving hart might then have to emulate instruction execution up to the next
      supported vstart element position. Alternatively, migration events can be constrained to
      only occur at mutually supported vstart locations.
    sw_write(csr_value): |
      return csr_value.VALUE & (VLEN - 1);
    type: RW-RH
    reset_value: UNDEFINED_LEGAL
