# Copyright (c) Qualcomm Technologies, Inc. and/or its subsidiaries.
# SPDX-License-Identifier: BSD-3-Clause-Clear

# yaml-language-server: $schema=../../schemas/csr_schema.json

$schema: "csr_schema.json#"
kind: csr
name: vtype
long_name: Vector Type
address: 0xC21
writable: false
priv_mode: U
length: MXLEN
description: Provides the default type used to interpret the contents of the vector register file.
definedBy: V
fields:
  VILL:
    location_rv32: 31
    location_rv64: 63
    description: |
      The vill bit is used to encode that a previous vset{i}vl{i} instruction attempted to write an
      unsupported value to vtype.

      [NOTE]
      The vill bit is held in bit XLEN-1 of the CSR to support checking for illegal values with a
      branch on the sign bit.

      If the vill bit is set, then any attempt to execute a vector instruction that depends upon vtype will
      raise an illegal-instruction exception.

      When the vill bit is set, the other XLEN-1 bits in vtype shall be zero.

      It is recommended that at reset, vill is set.
    type: RO-H
    reset_value(): |
      return (FOLLOW_VTYPE_RESET_RECOMMENDATION)? 1 : UNDEFINED_LEGAL;
  VMA:
    location: 7
    description: |
      Vector mask agnostic bit. Modifies the behavior of destination inactive masked-off elements during the
      execution of vector instructions.

      A value of 0 means inactive elements are undisturbed, meaning the corresponding set of destination elements
      in a vector register group retain the value they previously held.

      A value of 1 means inactive elements are agnostic, meaning the corresponding set of destination elements
      in any vector destination operand can either retain the value they previously held, or are overwritten with 1s.
      Within a single vector instruction, each destination element can be either left undisturbed or overwritten
      with 1s, in any combination, and the pattern of undisturbed or overwritten with 1s is not required to be
      deterministic when the instruction is executed with the same inputs.

      It is recommended that at reset, vill is set, and the remaining bits in vtype are zero.
    type: RO-H
    reset_value(): |
      return (FOLLOW_VTYPE_RESET_RECOMMENDATION)? 0 : UNDEFINED_LEGAL;
  VTA:
    location: 6
    description: |
      Vector tail agnostic bit. Modifies the bahavior of destination tail elements during the execution of vector
      instructions.

      A value of 0 means tail elements are undisturbed, meaning the corresponding set of destination elements
      in a vector register group retain the value they previously held.

      A value of 1 means tail elements are agnostic, meaning the corresponding set of destination elements
      in any vector destination operand can either retain the value they previously held, or are overwritten with 1s.
      Within a single vector instruction, each destination element can be either left undisturbed or overwritten
      with 1s, in any combination, and the pattern of undisturbed or overwritten with 1s is not required to be
      deterministic when the instruction is executed with the same inputs.

      It is recommended that at reset, vill is set, and the remaining bits in vtype are zero.
    type: RO-H
    reset_value(): |
      return (FOLLOW_VTYPE_RESET_RECOMMENDATION)? 0 : UNDEFINED_LEGAL;
  VSEW:
    location: 5-3
    description: |
      The value in vsew sets the dynamic selected element width (SEW).

      [separator="!"]
      !===
      ! vsew[2:0] ! SEW ! Elements per vector register
      ! 000 ! 8 ! 16
      ! 001 ! 16 ! 8
      ! 010 ! 32 ! 4
      ! 011 ! 64 ! 2
      ! 1XX ! Reserved ! Reserved
      !===

      It is recommended that at reset, vill is set, and the remaining bits in vtype are zero.
    type: RO-H
    reset_value(): |
      return (FOLLOW_VTYPE_RESET_RECOMMENDATION)? 0 : UNDEFINED_LEGAL;
  VLMUL:
    location: 2-0
    description: |
      Vector register group multiplier.

      Multiple vector registers can be grouped together, so that a single vector instruction can operate on
      multiple vector registers. The term vector register group is used herein to refer to one or more vector
      registers used as a single operand to a vector instruction. Vector register groups can be used to provide
      greater execution efficiency for longer application vectors, but the main reason for their inclusion is to
      allow double-width or larger elements to be operated on with the same vector length as single-width
      elements. The vector length multiplier, LMUL, when greater than 1, represents the default number of
      vector registers that are combined to form a vector register group. Implementations must support
      LMUL integer values of 1, 2, 4, and 8.

      [NOTE]
      The vector architecture includes instructions that take multiple source and destination
      vector operands with different element widths, but the same number of elements. The
      effective LMUL (EMUL) of each vector operand is determined by the number of registers
      required to hold the elements. For example, for a widening add operation, such as add 32-
      bit values to produce 64-bit results, a double-width result requires twice the LMUL of the
      single-width inputs.

      LMUL can also be a fractional value, reducing the number of bits used in a single vector register.
      Fractional LMUL is used to increase the number of effective usable vector register groups when
      operating on mixed-width values.

      It is recommended that at reset, vill is set, and the remaining bits in vtype are zero.
    type: RO-H
    reset_value(): |
      return (FOLLOW_VTYPE_RESET_RECOMMENDATION)? 0 : UNDEFINED_LEGAL;
