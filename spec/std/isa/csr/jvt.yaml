# Copyright (c) Katherine Hsu
# SPDX-License-Identifier: BSD-3-Clause-Clear

# yaml-language-server: $schema=../../schemas/csr_schema.json

$schema: "csr_schema.json#"
kind: csr
name: jvt
long_name: Table Jump Base Vector and Control Register
address: 0x017
writable: true
description:
  - id: csr-jvt-purpose
    normative: true
    text: |
      The `jvt` register is an XLEN-bit WARL read/write register that holds the jump table configuration,
      consisting of the jump table base address (BASE) and the jump table mode (MODE).
  - id: csr-jvt-architectural
    normative: false
    text: |
      `jvt` CSR adds architectural state to the system software context (such as an OS process), therefore
      must be saved/restored on context switches.
priv_mode: U
length: XLEN
definedBy: Zcmt
fields:
  BASE:
    location_rv64: 63-6
    location_rv32: 31-6
    description: |
      The value in the BASE field must always be aligned on a 64-byte boundary. Note that the CSR contains only
      bits XLEN-1 through 6 of the address base. When computing jump-table accesses, the lower six bits of base
      are filled with zeroes to obtain an XLEN-bit jump-table base address `jvt.base` that is always aligned on a
      64-byte boundary.

      `jvt.base` is a virtual address, whenever virtual memory is enabled.

      The memory pointed to by `jvt.base` is treated as instruction memory for the purpose of executing table
      jump instructions, implying execute access permission.
    type(): |
      if (JVT_READ_ONLY) {
        return CsrFieldType::RO;
      }
      else {
        return CsrFieldType::RW;
      }
    reset_value: UNDEFINED_LEGAL
    sw_write(csr_value): |
      if ((mode() != PrivilegeMode::M) && implemented?(ExtensionName::Smstateen)) {
        if (CSR[mstateen0].JVT == 1'b0) {
          unimplemented_csr($encoding);
        }
      }
      else if ((mode() == PrivilegeMode::U) && implemented?(ExtensionName::Ssstateen)) {
        if (CSR[sstateen0].JVT == 1'b0) {
          unimplemented_csr($encoding);
        }
      }
      else if ((mode() == PrivilegeMode::VS) && implemented?(ExtensionName::Ssstateen)) {
        if (CSR[hstateen0].JVT == 1'b0) {
          unimplemented_csr($encoding);
        }
      }
      else if ((mode() == PrivilegeMode::VU) && implemented?(ExtensionName::Ssstateen)) {
        if ((CSR[sstateen0].JVT == 1'b0) || (CSR[hstateen0].JVT == 1'b0)) {
          unimplemented_csr($encoding);
        }
      }
      else {
        if (JVT_BASE_TYPE == "custom") {
          unpredictable("jvt.BASE has custom behavior");
        } else {
          return csr_value.BASE & (JVT_BASE_MASK >> 6);
        }
        return csr_value.BASE == 0 ? 0 : UNDEFINED_LEGAL_DETERMINISTIC;
      }
  MODE:
    location: 5-0
    description: |
      `jvt.mode` is a WARL field, so can only be programmed to modes which are implemented. Therefore the
      discovery mechanism is to attempt to program different modes and read back the values to see which
      are available. Jump table mode must be implemented.
    type(): |
      if (JVT_READ_ONLY) {
        return CsrFieldType::RO;
      }
      else {
        return CsrFieldType::RW;
      }
    reset_value: 0
    sw_write(csr_value): |
      if (JVT_READ_ONLY || (csr_value.MODE != 0)) {
        raise(ExceptionCode::IllegalInstruction, mode(), $encoding);
      }
      return 0;
sw_read(): |
  # If the Smstateen extension is implemented, then bit 2 in `mstateen0`, `sstateen0`, and `hstateen0` is
  # implemented. If bit 2 of a controlling `stateen0` CSR is zero, then access to the `jvt` CSR and execution
  # of a `cm.jalt` or `cm.jt` instruction by a lower privilege level results in an illegal-instruction trap (or, if
  # appropriate, a virtual-instruction trap).

  if ((mode() != PrivilegeMode::M) && implemented?(ExtensionName::Smstateen)) {
    if (CSR[mstateen0].JVT == 1'b0) {
      raise(ExceptionCode::VirtualInstruction, mode(), $encoding);
    }
  }
  else if ((mode() == PrivilegeMode::U) && implemented?(ExtensionName::Ssstateen)) {
    if (CSR[sstateen0].JVT == 1'b0) {
      raise(ExceptionCode::IllegalInstruction, mode(), $encoding);
    }
  }
  else if ((mode() == PrivilegeMode::VS) && implemented?(ExtensionName::Ssstateen)) {
    if (CSR[hstateen0].JVT == 1'b0) {
      raise(ExceptionCode::VirtualInstruction, mode(), $encoding);
    }
  }
  else if ((mode() == PrivilegeMode::VU) && implemented?(ExtensionName::Ssstateen)) {
    if ((CSR[sstateen0].JVT == 1'b0) || (CSR[hstateen0].JVT == 1'b0)) {
      raise(ExceptionCode::VirtualInstruction, mode(), $encoding);
    }
  }
