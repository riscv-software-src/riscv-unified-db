#pragma once

#include <cstdint>
#include <map>
#include <unordered_map>

#include <nlohmann/json-schema.hpp>

#include "udb/hart.hpp"
#include "udb/cfgs/<%= cfg_arch.name %>/params.hxx"
#include "udb/cfgs/<%= cfg_arch.name %>/csr_container.hxx"
#include "udb/cfgs/<%= cfg_arch.name %>/structs.hxx"
#include "udb/enum.hxx"
#include "udb/bitfield.hxx"
#include "udb/util.hpp"

<%- hart_name = name_of(:hart, cfg_arch) -%>

namespace udb {
  class InstBase;
  class <%= hart_name -%> : public HartBase {
    <%- csrs = cfg_arch.not_prohibited_csrs -%>
    <%- csrs.each do |csr| -%>
    friend class <%= name_of(:csr, cfg_arch, csr.name) %>;
    <%- fields = cfg_arch.fully_configured? ? csr.implemented_fields(cfg_arch) : csr.fields -%>
    <%- fields.each do |field| -%>
    friend class <%= name_of(:csr_field, cfg_arch, csr.name, field.name) %>;
    <%- end -%>
    <%- end -%>
    <%- ilist = cfg_arch.possible_instructions -%>
    <%- ilist.each do |inst| -%>
    template <unsigned XLEN>
    friend class <%= name_of(:inst, cfg_arch, inst.name) %>;
    <%- end -%>

    public:
      <%- cfg_arch.globals.each do |global| -%>
      <%- if global.is_a?(Idl::GlobalWithInitializationAst) -%>
      <%- if global.type(cfg_arch.symtab).const? -%>
      static <%= global.type(cfg_arch.symtab).const? ? 'constexpr ' : '' %><%= global.type(cfg_arch.symtab).to_cxx %> <%= global.id %> = <%= global.rhs.gen_cpp(cfg_arch.symtab, 0) %>;
      <%- else -%>
      static <%= global.type(cfg_arch.symtab).to_cxx %> <%= global.id %>;
      <%- end -%>
      <%- else -%>
      static <%= global.type(cfg_arch.symtab).to_cxx %> <%= global.id %>;
      <%- end -%>
      <%- end -%>

      #include "udb/cfgs/<%= cfg_arch.name %>/func_prototypes.hxx"
      #include "udb/cfgs/<%= cfg_arch.name %>/builtin_funcs.hxx"

      static constexpr unsigned MXLEN = <%= cfg_arch.mxlen.nil? ? 64 : cfg_arch.mxlen %>;
      using XReg = Bits<MXLEN>;

      <%= hart_name -%>(uint64_t hart_id, Memory& mem, const nlohmann::json& cfg)
        : HartBase(hart_id, mem, cfg),
          m_params(<%= name_of(:params, cfg_arch) %>(cfg)),
          m_csrs(this)
      {
        m_xregs[0].makeZeroReg();
        init_csr_map();
      }

      void init_csr_map();

      bool implemented_Q_(const ExtensionName& ext, const VersionRequirement& req)
      {
          return false;
      }

      bool implemented_Q_(const ExtensionName& ext)
      {
          return false;
      }



      void set_pc(uint64_t new_pc) override {
        m_pc = new_pc;
      }

      void set_next_pc(uint64_t next_pc) override {
        m_next_pc = next_pc;
      }

      uint64_t pc() const override { return m_pc; }

      void advance_pc() override {
        m_pc = m_next_pc;
      }

      unsigned mxlen() override { return MXLEN; }

      uint64_t xreg(unsigned num) const override { return m_xregs[num].get(); }

      Bits<MXLEN> _xreg(unsigned num) const { return m_xregs[num].get(); }

      // XRegister<MXLEN>& xregRef(unsigned num) { return m_xregs[num]; }

      void set_xreg(unsigned num, uint64_t value) override {
        _set_xreg(num, value);
      }

      template <typename IdxType, typename ValType>
      void _set_xreg(const IdxType& num, const ValType& value) {
        if (num != 0) {
          m_xregs[static_cast<unsigned>(num)] = value;
        }
      }

      void printState(FILE* out = stdout) const override;

    CsrBase* csr(unsigned address) override {
      auto it = m_csr_addr_map.find(address);
      if (it == m_csr_addr_map.end()) {
         return nullptr;
      }
      return it->second;
    }

    const CsrBase* csr(unsigned address) const override {
      auto it = m_csr_addr_map.find(address);
      if (it == m_csr_addr_map.end()) {
         return nullptr;
      }
      return it->second;
    }

    CsrBase* csr(const std::string& name) override {
      auto it = m_csr_name_map.find(name);
      if (it == m_csr_name_map.end()) {
         return nullptr;
      }
      return it->second;
    }

    const CsrBase* csr(const std::string& name) const override {
      auto it = m_csr_name_map.find(name);
      if (it == m_csr_name_map.end()) {
         return nullptr;
      }
      return it->second;
    }

    const <%= name_of(:params, cfg_arch) %>& params() const {
      return m_params;
    }

    InstBase* decode(const uint64_t& pc, const uint64_t& encoding) override {
      return _decode(pc, encoding);
    }

    InstBase* _decode(const XReg& pc, const Bits<<%= cfg_arch.largest_encoding %>>& encoding);

    std::tuple<bool, <%= name_of(:struct, cfg_arch, "TranslationResult") %>> cached_translation(const XReg& vaddr, const MemoryOperation& op) const {
      return std::make_tuple<bool, <%= name_of(:struct, cfg_arch, "TranslationResult") %>>(false, {});
    }

    <%= name_of(:csr_container, cfg_arch) %>& _csrContainer() { return m_csrs; }

    private:
      XReg m_pc;
      XReg m_next_pc;
      InstBase* m_cur_inst;
      std::array<XRegister<MXLEN>, 32> m_xregs;

      <%= name_of(:params, cfg_arch) %> m_params;
      <%= name_of(:csr_container, cfg_arch) %> m_csrs;
      std::unordered_map<Bits<12>, CsrBase*> m_csr_addr_map;
      std::map<std::string, CsrBase*> m_csr_name_map;
  };

  #include "udb/cfgs/<%= cfg_arch.name %>/idl_funcs_impl.hxx"

}
