// Copyright (c) Qualcomm Technologies, Inc. and/or its subsidiaries.
// SPDX-License-Identifier: BSD-3-Clause-Clear

#pragma once

#include <any>
#include <map>
#include <stdexcept>
#include <string>
#include <string_view>
#include <vector>

#include <nlohmann/json.hpp>

#include "udb/bits.hpp"
#include "udb/enum.hxx"
#include "udb/version.hpp"

using namespace std::literals;

namespace udb {
template <unsigned N, bool Signed>
void to_json(const nlohmann::json& j, _Bits<N, Signed>& b) {
  j = nlohmann::json { b.get() };
}

template <unsigned N, bool Signed>
void to_json(const nlohmann::json& j, _PossiblyUnknownBits<N, Signed>& b) {
  j = nlohmann::json { b.get() };
}

template <unsigned N, bool Signed>
void from_json(const nlohmann::json& j, _Bits<N, Signed>& b) {
  b = _Bits<N, Signed>{j.get<typename _Bits<N, Signed>::StorageType>()};
}

template <unsigned N, bool Signed>
void from_json(const nlohmann::json& j, _PossiblyUnknownBits<N, Signed>& b) {
  b = _PossiblyUnknownBits<N, Signed>{_Bits<N, Signed>{j.get<typename _Bits<N, Signed>::StorageType>()}, 0_b};
}
}

namespace udb {
  class SatisfiedResult {
    public:
    enum class Type {
      Yes, Maybe, No
    };

    SatisfiedResult() = delete;
    constexpr SatisfiedResult(const Type &result) : m_result(result) {}
    constexpr SatisfiedResult(const SatisfiedResult&) = default;
    constexpr SatisfiedResult(SatisfiedResult&&) = default;

    // define logical operators
    SatisfiedResult operator&&(const SatisfiedResult& rhs) const {
      if (m_result == Type::No || rhs.m_result == Type::No) {
        return Type::No;
      } else if (m_result == Type::Yes && rhs.m_result == Type::Maybe) {
        return Type::Maybe;
      } else if (m_result == Type::Maybe && rhs.m_result == Type::Yes) {
        return Type::Maybe;
      } else {
        udb_assert(m_result == Type::Yes && rhs.m_result == Type::Yes, "missed a case");
        return Type::Yes;
      }
    }

    SatisfiedResult operator||(const SatisfiedResult& rhs) const {
      if (m_result == Type::Yes || rhs.m_result == Type::Yes) {
        return Type::Yes;
      } else if (m_result == Type::No && rhs.m_result == Type::Maybe) {
        return Type::Maybe;
      } else if (m_result == Type::Maybe && rhs.m_result == Type::No) {
        return Type::Maybe;
      } else {
        udb_assert(m_result == Type::No && rhs.m_result == Type::No, "missed a case");
        return Type::No;
      }
    }

    SatisfiedResult operator!() const {
      if (m_result == Type::Yes) {
        return Type::No;
      } else if (m_result == Type::No) {
        return Type::Yes;
      } else {
        return Type::Maybe;
      }
    }

    bool operator==(const SatisfiedResult& rhs) const {
      return m_result == rhs.m_result;
    }

    bool operator!=(const SatisfiedResult& rhs) const {
      return m_result != rhs.m_result;
    }

    private:
    const Type m_result;
  };

  static constexpr SatisfiedResult Yes(SatisfiedResult::Type::Yes);
  static constexpr SatisfiedResult Maybe(SatisfiedResult::Type::Maybe);
  static constexpr SatisfiedResult No(SatisfiedResult::Type::No);

  class Config;
  class Parameter {
    public:
    constexpr Parameter(const std::string& name) : m_name(name) {}

    const std::string& name() const { return m_name; }

    virtual SatisfiedResult defined(const Config& cfg) const = 0;

    virtual bool has_value() const = 0;

    protected:
    const std::string m_name;
  };

  // represents a full UDB config
  class Config {
    public:
    struct ExtensionVersion {
      std::string name;
      Version version;

      ExtensionVersion(const std::string& _name, const std::string& _version) : name(_name), version(_version) {}
      ExtensionVersion(const ExtensionVersion&) = default;
      ExtensionVersion(ExtensionVersion&&) = default;
    };

    Config(const nlohmann::json& implemented_exts, const nlohmann::json& param_values);
    Config(const Config&) = default;
    Config(Config&&) = default;

    SatisfiedResult ext_req_is_met(const ExtensionName& ext_name, const VersionRequirement& req) const;

    const std::vector<ExtensionVersion>& implemented_exts() const { return m_implemented_exts; }
    const std::map<ExtensionName, ExtensionVersion>& implemented_exts_hash() const { return m_implemented_exts_hash; }
    const ExtensionVersion& implemented_ext(const ExtensionName& name) const { return m_implemented_exts_hash.at(name); }

    bool has_param_value(const std::string& name) const { return m_param_values.contains(name); }
    const std::any& param_value(const std::string& name) const { return m_param_values.at(name); }


    private:
    std::vector<ExtensionVersion> m_implemented_exts;
    std::map<ExtensionName, ExtensionVersion> m_implemented_exts_hash;
    std::map<std::string, std::any> m_param_values;
  };

  <%- cfg_arch.params.each do |param| -%>

  // <%= param.description.gsub("\n", "\n  // ") %>
  class <%= name_of(:param, cfg_arch, param) %> : public Parameter {
    public:
    // constructor without value
    constexpr <%= name_of(:param, cfg_arch, param) %>()
      : Parameter("<%= param.name %>")
    {}

    // constructor with value
      constexpr <%= name_of(:param, cfg_arch, param) %>(const nlohmann::json& value)
      : Parameter("<%= param.name %>")
        <%- unless cfg_arch.param_values.key?(param.name) -%>
        , m_value(std::in_place, value.get<<%= param.idl_type.to_cxx_no_qualifiers %>>())
        <%- end -%>
    {
      <%- if cfg_arch.param_values.key?(param.name) -%>
      bool same = value.get<<%= param.idl_type.to_cxx_no_qualifiers %>>() == m_value;
      udb_assert(same, "Runtime parameter value must match compile-time value");
      <%- end -%>
    }

    SatisfiedResult defined(const Config& cfg) const override;

    <%- if cfg_arch.param_values.key?(param.name) -%>
    bool has_value() const override { return true; }
    <%- else -%>
    bool has_value() const override { return m_value.has_value(); }
    <%- end -%>

    <%- unless cfg_arch.param_values.key?(param.name) -%>
    void set_value(<%= param.maximal_idl_type.to_cxx_no_qualifiers %> val) {
      m_value = val;
    }
    <%- end -%>

    <%- if cfg_arch.param_values.key?(param.name) -%>
    <%# we know the value, so it's constexpr %>
    static constexpr <%= param.maximal_idl_type.to_cxx_no_qualifiers %> value() { return m_value; }
    <%- else -%>
    const <%= param.maximal_idl_type.to_cxx_no_qualifiers %> value() const { return m_value.value(); }
    <%- end -%>

    private:
    <%- if cfg_arch.param_values.key?(param.name) -%>
    static constexpr <%= param.maximal_idl_type.to_cxx_no_qualifiers %> m_value = <%= cfg_arch.param_values.fetch(param.name).to_cxx %>;
    <%- else -%>
    std::optional<<%= param.maximal_idl_type.to_cxx_no_qualifiers %>> m_value;
    <%- end -%>
  };
  <%- end -%>

  class DbData {
    DbData() = delete;

    public:
    static std::map<std::string, std::string> SCHEMAS;
  };
}
