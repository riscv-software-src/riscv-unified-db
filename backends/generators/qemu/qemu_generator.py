#!/usr/bin/env python3
"""
QEMU RISC-V Generator

Generates QEMU-compatible files from RISC-V unified database:
- insn32.decode format files for instruction decoding
- CSR tables (cpu_bits.h compatible)
- Disassembler tables (riscv.c compatible)

This generator helps automate the addition of new RISC-V extensions to QEMU.
"""

import os
import sys
import argparse
import logging
import yaml
import glob
from pathlib import Path
from typing import Dict, List, Set

# Add parent directory to path to find generator.py
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from generator import parse_match, parse_extension_requirements, load_csrs

logging.basicConfig(level=logging.INFO, format="%(levelname)s:: %(message)s")


class QemuInstructionDecoder:
    """Generate QEMU insn32.decode format entries"""

    def __init__(self):
        self.decode_entries = []
        self.stats = {
            "total": 0,
            "success": 0,
            "no_match": 0,
            "no_assembly": 0,
            "errors": 0,
        }

    def add_instruction(self, name: str, info: dict) -> bool:
        """Add an instruction to the decode table"""
        self.stats["total"] += 1

        try:
            encoding = info.get("encoding", {})
            if isinstance(encoding, dict):
                # Handle architecture-specific encodings
                if "RV64" in encoding and "RV32" in encoding:
                    # Process both encodings
                    return self._process_both_encodings(name, encoding)
                elif "RV64" in encoding:
                    return self._process_single_encoding(name, encoding["RV64"])
                elif "RV32" in encoding:
                    return self._process_single_encoding(name, encoding["RV32"])
                elif "match" in encoding:
                    return self._process_single_encoding(name, encoding)
                else:
                    self.stats["no_match"] += 1
                    return False
            else:
                self.stats["no_match"] += 1
                return False

        except Exception as e:
            logging.error(f"Error processing instruction {name}: {e}")
            self.stats["errors"] += 1
            return False

    def _process_single_encoding(self, name: str, encoding: dict) -> bool:
        """Process a single encoding and add to decode entries"""
        match_str = encoding.get("match")
        if not match_str:
            self.stats["no_match"] += 1
            return False

        # Parse the match string to determine instruction width
        width = len(match_str)

        # Extract mask and match value
        match_value = parse_match(match_str)
        mask_value = int("".join("1" if c != "-" else "0" for c in match_str), 2)

        # Create the decode entry
        entry = {
            "name": name,
            "match": f"0x{match_value:x}",
            "mask": f"0x{mask_value:x}",
            "width": width,
        }

        self.decode_entries.append(entry)
        self.stats["success"] += 1
        return True

    def _process_both_encodings(self, name: str, encoding: dict) -> bool:
        """Process both RV32 and RV64 encodings"""
        rv32_result = self._process_single_encoding(f"{name}_rv32", encoding["RV32"])
        rv64_result = self._process_single_encoding(f"{name}_rv64", encoding["RV64"])
        return rv32_result or rv64_result

    def generate_decode_file(self, output_file: str):
        """Generate QEMU-compatible insn32.decode format file"""
        prelude = """# Code generated by qemu_generator.py; DO NOT EDIT.
# This file should be placed at: qemu/target/riscv/insn32.decode
#
# Format: @name ... match mask ... args
# Generated instruction decoding table for RISC-V

"""
        with open(output_file, "w", encoding="utf-8") as f:
            f.write(prelude)

            # Sort entries by mask (most specific first)
            sorted_entries = sorted(
                self.decode_entries, key=lambda x: (-int(x["mask"], 16), x["name"])
            )

            for entry in sorted_entries:
                # QEMU format: match/mask in hex, instruction name
                f.write(f"# {entry['name']}\n")
                f.write(f"# Match: {entry['match']}, Mask: {entry['mask']}\n")
                f.write(f"# Width: {entry['width']} bits\n")
                f.write(f"@insn32_{entry['name']} {entry['match']} {entry['mask']}\n\n")

        logging.info(f"Generated QEMU decode file: {output_file}")
        logging.info(f"  Total entries: {self.stats['success']}")


class QemuCsrTable:
    """Generate QEMU-compatible CSR tables"""

    def __init__(self):
        self.csr_definitions = {}

    def add_csr(self, name: str, address: int, info: dict):
        """Add a CSR definition"""
        self.csr_definitions[address] = {"name": name, "address": address, "info": info}

    def generate_cpu_bits_h(self, output_file: str):
        """Generate CPU_BITS_H format CSR definitions"""
        content = """/* Code generated by qemu_generator.py; DO NOT EDIT. */
/* This file should be placed at: qemu/target/riscv/cpu_bits.h (append) */

#ifndef RISCV_CPU_BITS_H
#define RISCV_CPU_BITS_H

/* RISC-V Control and Status Register (CSR) Definitions */
/* Automatically generated from RISC-V Unified Database */

"""

        # Sort CSRs by address
        for address in sorted(self.csr_definitions.keys()):
            csr = self.csr_definitions[address]
            name = csr["name"].upper()

            # Generate CSR address macro
            content += f"/* {csr['name']} */\n"
            content += f"#define CSR_{name:<30} 0x{address:03x}\n"
            content += "\n"

        content += """
#endif /* RISCV_CPU_BITS_H */
"""

        with open(output_file, "w", encoding="utf-8") as f:
            f.write(content)

        logging.info(f"Generated CSR table file: {output_file}")
        logging.info(f"  Total CSRs: {len(self.csr_definitions)}")


class QemuDisassemblerTable:
    """Generate QEMU disassembler tables"""

    def __init__(self):
        self.disasm_entries = {}

    def add_instruction(self, name: str, info: dict):
        """Add instruction to disassembler table"""
        assembly = info.get("assembly", "")
        if not assembly:
            return

        if name not in self.disasm_entries:
            self.disasm_entries[name] = {"assembly_format": assembly, "info": info}

    def generate_disasm_table(self, output_file: str):
        """Generate disassembler table in riscv.c format"""
        content = """/* Code generated by qemu_generator.py; DO NOT EDIT. */
/* This file contains disassembler entries for: qemu/disas/riscv.c */
/* Add these entries to the riscv_opcodes table */

"""

        content += "/* Instruction disassembly definitions */\n"
        content += '/* Format: {"mnemonic", ... assembly info ...}, */\n\n'

        for name in sorted(self.disasm_entries.keys()):
            entry = self.disasm_entries[name]
            assembly = entry["assembly_format"]

            content += f"  /* {name} - assembly: {assembly} */\n"
            content += f'  {{"{name}", ..., /* TODO: Fill in operand format */, }},\n'
            content += "\n"

        with open(output_file, "w", encoding="utf-8") as f:
            f.write(content)

        logging.info(f"Generated disassembler table: {output_file}")
        logging.info(f"  Total entries: {len(self.disasm_entries)}")


class QemuExtensionMapper:
    """Map RISC-V extensions to QEMU extension definitions"""

    def __init__(self):
        self.extension_map = {}
        self.unsupported_extensions = set()

    def map_extension(self, defined_by) -> str:
        """Map extension definition to QEMU extension name"""
        if isinstance(defined_by, str):
            return defined_by.upper()
        elif isinstance(defined_by, dict):
            if "allOf" in defined_by:
                extensions = defined_by["allOf"]
                if isinstance(extensions, list):
                    return "_AND_".join(
                        ext.upper() if isinstance(ext, str) else str(ext)
                        for ext in extensions
                    )
            elif "anyOf" in defined_by:
                extensions = defined_by["anyOf"]
                if isinstance(extensions, list):
                    return "_OR_".join(
                        ext.upper() if isinstance(ext, str) else str(ext)
                        for ext in extensions
                    )
        return "UNKNOWN"


def load_instructions_for_qemu(
    inst_dir: str,
    enabled_extensions: List[str] = None,
    include_all: bool = False,
    target_arch: str = "RV64",
) -> Dict[str, dict]:
    """Load instructions from the unified database for QEMU generation"""
    if enabled_extensions is None:
        enabled_extensions = []

    instructions = {}
    yaml_files = glob.glob(os.path.join(inst_dir, "**/*.yaml"), recursive=True)

    logging.info(f"Found {len(yaml_files)} instruction files in {inst_dir}")

    for yaml_file in yaml_files:
        try:
            with open(yaml_file, encoding="utf-8") as f:
                data = yaml.safe_load(f)

            if not isinstance(data, dict) or data.get("kind") != "instruction":
                continue

            name = data.get("name")
            if not name:
                continue

            # Apply extension filtering
            if not include_all:
                defined_by = data.get("definedBy")
                if defined_by:
                    meets_req = parse_extension_requirements(defined_by)
                    if not meets_req(enabled_extensions):
                        logging.debug(
                            f"Skipping {name} - extension requirements not met"
                        )
                        continue

            # Apply architecture filtering
            base = data.get("base")
            if base is not None:
                if (base == 32 and target_arch not in ["RV32", "BOTH"]) or (
                    base == 64 and target_arch not in ["RV64", "BOTH"]
                ):
                    logging.debug(f"Skipping {name} - architecture mismatch")
                    continue

            instructions[name] = data

        except Exception as e:
            logging.error(f"Error loading {yaml_file}: {e}")
            continue

    logging.info(f"Loaded {len(instructions)} instructions after filtering")
    return instructions


def generate_qemu_files(
    instructions: Dict[str, dict], csrs: Dict[int, str], output_dir: str = "qemu_gen"
):
    """Generate all QEMU-compatible files"""
    Path(output_dir).mkdir(exist_ok=True)

    # Generate instruction decoder
    logging.info("Generating instruction decoder...")
    decoder = QemuInstructionDecoder()
    for name, info in sorted(instructions.items()):
        decoder.add_instruction(name, info)

    decode_file = os.path.join(output_dir, "insn32_generated.decode")
    decoder.generate_decode_file(decode_file)

    # Generate CSR table
    logging.info("Generating CSR table...")
    csr_table = QemuCsrTable()
    for address, name in sorted(csrs.items()):
        csr_table.add_csr(name, address, {})

    csr_file = os.path.join(output_dir, "cpu_bits_generated.h")
    csr_table.generate_cpu_bits_h(csr_file)

    # Generate disassembler table
    logging.info("Generating disassembler table...")
    disasm = QemuDisassemblerTable()
    for name, info in sorted(instructions.items()):
        disasm.add_instruction(name, info)

    disasm_file = os.path.join(output_dir, "riscv_disas_generated.c")
    disasm.generate_disasm_table(disasm_file)

    # Print summary statistics
    logging.info("\n" + "=" * 60)
    logging.info("QEMU Generation Summary")
    logging.info("=" * 60)
    logging.info(f"Instructions processed:  {decoder.stats['total']}")
    logging.info(f"  Successfully generated: {decoder.stats['success']}")
    logging.info(f"  Errors:                 {decoder.stats['errors']}")
    logging.info(f"  No match string:        {decoder.stats['no_match']}")
    logging.info(f"CSRs generated:          {len(csrs)}")
    logging.info(f"Disassembly entries:     {len(disasm.disasm_entries)}")
    logging.info(f"\nOutput files:")
    logging.info(f"  {decode_file}")
    logging.info(f"  {csr_file}")
    logging.info(f"  {disasm_file}")
    logging.info("=" * 60)


def parse_args():
    parser = argparse.ArgumentParser(
        description="Generate QEMU RISC-V files from unified database"
    )
    parser.add_argument(
        "--inst-dir",
        default="../../../spec/std/isa/inst/",
        help="Directory containing instruction YAML files",
    )
    parser.add_argument(
        "--csr-dir",
        default="../../../spec/std/isa/csr/",
        help="Directory containing CSR YAML files",
    )
    parser.add_argument(
        "--output-dir", default="qemu_gen", help="Output directory for generated files"
    )
    parser.add_argument(
        "--extensions",
        default="I,M,A,F,D,C",
        help="Comma-separated list of enabled extensions",
    )
    parser.add_argument(
        "--arch",
        default="RV64",
        choices=["RV32", "RV64", "BOTH"],
        help="Target architecture",
    )
    parser.add_argument(
        "--include-all",
        "-a",
        action="store_true",
        help="Include all instructions, ignoring extension filtering",
    )
    parser.add_argument(
        "--verbose", "-v", action="store_true", help="Enable verbose logging"
    )
    return parser.parse_args()


def main():
    args = parse_args()

    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)

    # Parse enabled extensions
    include_all = args.include_all or not args.extensions
    if include_all:
        enabled_extensions = []
        logging.info("Including all extensions")
    else:
        enabled_extensions = [
            ext.strip() for ext in args.extensions.split(",") if ext.strip()
        ]
        logging.info(f"Enabled extensions: {', '.join(enabled_extensions)}")

    logging.info(f"Target architecture: {args.arch}")

    # Validate directories
    if not os.path.isdir(args.inst_dir):
        logging.error(f"Instruction directory not found: {args.inst_dir}")
        sys.exit(1)

    if not os.path.isdir(args.csr_dir):
        logging.warning(f"CSR directory not found: {args.csr_dir}")

    # Load instructions
    instructions = load_instructions_for_qemu(
        args.inst_dir, enabled_extensions, include_all, args.arch
    )

    if not instructions:
        logging.error("No instructions found or all were filtered out")
        sys.exit(1)

    # Load CSRs
    csrs = load_csrs(args.csr_dir, enabled_extensions, include_all, args.arch)

    # Generate QEMU files
    generate_qemu_files(instructions, csrs, args.output_dir)


if __name__ == "__main__":
    main()
