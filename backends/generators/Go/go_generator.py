#!/usr/bin/env python3
import os
import sys
import yaml
import logging
import pprint

pp = pprint.PrettyPrinter(indent=2)
logging.basicConfig(level=logging.INFO, format="%(levelname)s:: %(message)s")


def load_instructions(root_dir):
    """
    Recursively walk through root_dir, load YAML files that define an instruction,
    and collect them into a dictionary keyed by the instruction name.

    Rules:
      - If an instruction has an 'RV64' encoding, use it.
      - If an instruction has an 'RV32' encoding only, skip it.
      - If an instruction does not have arch-specific encoding (i.e. a flat encoding with a 'match'),
        use that encoding.
    """
    instr_dict = {}
    for dirpath, _, filenames in os.walk(root_dir):
        for fname in filenames:
            if not fname.endswith(".yaml"):
                continue
            path = os.path.join(dirpath, fname)
            try:
                with open(path, encoding="utf-8") as f:
                    data = yaml.safe_load(f)
            except Exception as e:
                logging.error(f"Error parsing {path}: {e}")
                continue

            if data.get("kind") != "instruction":
                continue

            name = data.get("name")
            encoding = data.get("encoding", {})

            # Determine which encoding to use:
            if isinstance(encoding, dict):
                if "RV64" in encoding:
                    encoding_to_use = encoding["RV64"]
                elif "RV32" in encoding:
                    msg = f"Skipping {name} because it has only RV32 encoding in {path}"
                    print(msg)
                    logging.info(msg)
                    continue
                elif "match" in encoding:
                    encoding_to_use = encoding
                else:
                    msg = f"Skipping {name} because its encoding in {path} has no recognized match field."
                    print(msg)
                    logging.warning(msg)
                    continue
            else:
                msg = f"Skipping {name} because its encoding in {path} is not a dictionary."
                print(msg)
                logging.warning(msg)
                continue

            match_str = encoding_to_use.get("match")
            if name and match_str:
                instr_dict[name] = {"match": match_str}
            else:
                msg = f"Skipping {name} because 'name' or 'match' is missing in {path}"
                print(msg)
                logging.warning(msg)
    return instr_dict


def load_csrs(csr_root):
    """
    Recursively walk through csr_root, load YAML files that define a CSR,
    and collect them into a dictionary mapping each address (as an integer) to the CSR name.
    """
    csrs = {}
    for dirpath, _, filenames in os.walk(csr_root):
        for fname in filenames:
            if not fname.endswith(".yaml"):
                continue
            path = os.path.join(dirpath, fname)
            try:
                with open(path, encoding="utf-8") as f:
                    data = yaml.safe_load(f)
            except Exception as e:
                logging.error(f"Error parsing CSR file {path}: {e}")
                continue

            if data.get("kind") != "csr":
                continue

            name = data.get("name")
            address = data.get("address")
            if name and address:
                try:
                    if isinstance(address, int):
                        addr_int = address
                    else:
                        addr_int = int(address, 0)

                except Exception as e:
                    logging.error(f"Error parsing address {address} in {path}: {e}")
                    continue
                csrs[addr_int] = name.upper()
            else:
                logging.warning(f"Missing 'name' or 'address' in CSR file {path}")
    return csrs


def parse_match(match_str):
    """
    Convert the bit pattern string to an integer.
    Replace all '-' (variable bits) with '0' so that only constant bits are set.
    """
    binary_str = "".join("0" if c == "-" else c for c in match_str)
    return int(binary_str, 2)


# Returns signed interpretation of a value within a given width.
def signed(value: int, width: int) -> int:
    return value if 0 <= value < (1 << (width - 1)) else value - (1 << width)


def make_go(instr_dict, csrs):
    """
    Generate a Go source file ('inst.go') with the instruction encodings followed by
    a map of CSR names and addresses.
    """
    args = " ".join(sys.argv)
    prelude = f"// Code generated by {args}; DO NOT EDIT.\n"
    prelude += """package riscv

import "cmd/internal/obj"

type inst struct {
	opcode uint32
	funct3 uint32
	rs1    uint32
	rs2    uint32
    csr    int64
	funct7 uint32
}

func encode(a obj.As) *inst {
	switch a {
"""

    instr_str = ""
    # Process instructions in sorted order (by name)
    for name, info in sorted(instr_dict.items(), key=lambda x: x[0].upper()):
        match_str = info["match"]
        enc_match = parse_match(match_str)
        opcode = (enc_match >> 0) & ((1 << 7) - 1)
        funct3 = (enc_match >> 12) & ((1 << 3) - 1)
        rs1 = (enc_match >> 15) & ((1 << 5) - 1)
        rs2 = (enc_match >> 20) & ((1 << 5) - 1)
        csr_val = (enc_match >> 20) & ((1 << 12) - 1)
        funct7 = (enc_match >> 25) & ((1 << 7) - 1)
        # Create the instruction case name. For example, "bclri" becomes "ABCLRI"
        instr_case = f"A{name.upper().replace('.','')}"
        instr_str += f"""  case {instr_case}:
    return &inst{{ {hex(opcode)}, {hex(funct3)}, {hex(rs1)}, {hex(rs2)}, {signed(csr_val,12)}, {hex(funct7)} }}
"""
    instructions_end = """  }
	return nil
}
"""

    # Build the CSR map block.
    csrs_map_str = "var csrs = map[uint16]string {\n"
    for addr in sorted(csrs.keys()):
        csrs_map_str += f'  {hex(addr)} : "{csrs[addr]}",\n'
    csrs_map_str += "}\n"

    go_code = prelude + instr_str + instructions_end + "\n" + csrs_map_str

    with open("inst.go", "w", encoding="utf-8") as f:
        f.write(go_code)
    logging.info("Generated inst.go")


def main():
    # Use the provided directory or default to '../../arch/inst/' for instructions.
    if len(sys.argv) < 2:
        inst_root = "../../arch/inst/"
        print(
            f"No instruction directory argument provided. Using default directory: {inst_root}"
        )
    else:
        inst_root = sys.argv[1]
    instr_dict = load_instructions(inst_root)
    if not instr_dict:
        logging.error("No instructions found.")
        sys.exit(1)

    # Load CSRs from the specified directory.
    csrs_dir = "../../arch/csr"
    csrs = load_csrs(csrs_dir)
    if not csrs:
        logging.warning("No CSRs found in the directory.")

    make_go(instr_dict, csrs)


if __name__ == "__main__":
    main()
