#!/usr/bin/env python3
"""
Rust Code Generator for RISC-V Instructions and CSRs

Generates Rust struct definitions and enums from RISC-V instruction and CSR definitions.
This includes instruction encodings, CSR addresses, exception codes, and interrupt codes.
"""

import os
import sys
import argparse
import logging
from collections import defaultdict

# Add parent directory to path to find generator.py
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from generator import load_instructions, load_csrs, parse_match, signed

logging.basicConfig(level=logging.INFO, format="%(levelname)s:: %(message)s")


def make_rust(
    instr_dict, csrs, exception_codes=None, interrupt_codes=None, output_file="riscv.rs"
):
    """
    Generate a Rust source file with instruction encodings, CSR definitions,
    and related enums.
    """
    args = " ".join(sys.argv)
    prelude = f"""// Code generated by {args}; DO NOT EDIT.
//! RISC-V Architecture Definitions
//!
//! This module provides Rust definitions for RISC-V instructions, CSRs,
//! exception codes, and interrupt codes.

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]

"""

    # Generate instruction encoding structs
    instr_code = _generate_instruction_structs(instr_dict)

    # Generate CSR enum and constants
    csr_code = _generate_csr_enum(csrs)

    # Generate exception codes enum
    exception_code = _generate_exception_codes(exception_codes)

    # Generate interrupt codes enum
    interrupt_code = _generate_interrupt_codes(interrupt_codes)

    # Combine all sections
    full_code = (
        prelude
        + instr_code
        + "\n"
        + csr_code
        + "\n"
        + exception_code
        + "\n"
        + interrupt_code
    )

    # Write to output file
    with open(output_file, "w") as f:
        f.write(full_code)

    logging.info(f"Generated Rust code written to {output_file}")


def _generate_instruction_structs(instr_dict):
    """Generate Rust instruction encoding structs and enums."""

    # Create instruction enum
    enum_code = """/// RISC-V Instruction Opcodes
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum RiscvInst {
"""

    # Add instructions in sorted order
    for name in sorted(instr_dict.keys(), key=str.upper):
        # Convert instruction name to Rust enum variant
        variant_name = _to_rust_identifier(name)
        enum_code += f"    {variant_name},\n"

    enum_code += "}\n\n"

    # Create instruction encoding struct
    struct_code = """/// RISC-V Instruction Encoding
#[derive(Debug, Clone, Copy)]
pub struct InstructionEncoding {
    pub opcode: u8,
    pub funct3: Option<u8>,
    pub funct7: Option<u8>,
    pub match_pattern: u32,
}

impl InstructionEncoding {
    /// Get the encoding for a given instruction
    pub fn get(inst: RiscvInst) -> Self {
        match inst {
"""

    # Add instruction encodings
    for name, info in sorted(instr_dict.items(), key=lambda x: x[0].upper()):
        match_str = info["match"]
        enc_match = parse_match(match_str)

        # Extract encoding fields
        opcode = (enc_match >> 0) & ((1 << 7) - 1)
        funct3 = (enc_match >> 12) & ((1 << 3) - 1)
        funct7 = (enc_match >> 25) & ((1 << 7) - 1)

        variant_name = _to_rust_identifier(name)

        struct_code += f"""            RiscvInst::{variant_name} => InstructionEncoding {{
                opcode: 0x{opcode:02x},
                funct3: Some(0x{funct3:01x}),
                funct7: Some(0x{funct7:02x}),
                match_pattern: 0x{enc_match:08x},
            }},
"""

    struct_code += """        }
    }
}

"""

    return enum_code + struct_code


def _generate_csr_enum(csrs):
    """Generate Rust CSR enum and constants."""

    if not csrs:
        logging.warning("No CSRs to generate")
        return "// No CSRs defined\n"

    code = """/// RISC-V Control and Status Registers (CSRs)
pub mod csr {

"""

    # Convert CSR dict format: address -> name becomes name -> address
    csr_by_name = {}
    for addr, name in csrs.items():
        if isinstance(addr, int) and isinstance(name, str):
            csr_by_name[name] = addr

    # Group CSRs by privilege level
    csr_by_priv = defaultdict(list)
    for csr_name, addr in csr_by_name.items():
        # Extract privilege level from address
        priv = _get_privilege_level(addr)
        csr_by_priv[priv].append((csr_name, addr))

    # Generate constants for each privilege level
    for priv in sorted(csr_by_priv.keys()):
        code += f"    /// {priv.capitalize()} Privilege Level CSRs\n"
        code += f"    pub mod {priv} {{\n"

        for csr_name, addr in sorted(csr_by_priv[priv], key=lambda x: x[1]):
            # Convert CSR name to Rust constant name
            const_name = _to_rust_const_name(csr_name)
            code += f"        pub const {const_name}: u16 = 0x{addr:03x};\n"

        code += "    }\n\n"

    # Generate CSR enum
    code += """    /// CSR Address Enumeration
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    pub enum Csr {
"""

    # Filter to only string keys and sort them
    for csr_name in sorted(csr_by_name.keys(), key=str.upper):
        variant_name = _to_rust_identifier(csr_name)
        code += f"        {variant_name},\n"

    code += """    }

    impl Csr {
        /// Get the CSR address
        pub fn address(self) -> u16 {
            match self {
"""

    for csr_name in sorted(csr_by_name.keys(), key=str.upper):
        addr = csr_by_name[csr_name]
        variant_name = _to_rust_identifier(csr_name)
        code += f"                Csr::{variant_name} => 0x{addr:03x},\n"

    code += """            }
        }
    }
}

"""

    return code


def _generate_exception_codes(exception_codes):
    """Generate Rust exception codes enum."""

    if not exception_codes:
        return "// No exception codes defined\n"

    code = """/// RISC-V Exception Codes
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum ExceptionCode {
"""

    for exc in sorted(exception_codes, key=lambda x: x.get("num", 0)):
        num = exc.get("num", 0)
        name = exc.get("name", f"Unknown{num}").replace("-", "_").replace(" ", "_")
        # Ensure it's a valid Rust identifier
        variant_name = _to_rust_identifier(name)
        code += f"    {variant_name} = {num},\n"

    code += """}\n
"""

    return code


def _generate_interrupt_codes(interrupt_codes):
    """Generate Rust interrupt codes enum."""

    if not interrupt_codes:
        return "// No interrupt codes defined\n"

    code = """/// RISC-V Interrupt Codes
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum InterruptCode {
"""

    for intr in sorted(interrupt_codes, key=lambda x: x.get("num", 0)):
        num = intr.get("num", 0)
        name = intr.get("name", f"Unknown{num}").replace("-", "_").replace(" ", "_")
        # Ensure it's a valid Rust identifier
        variant_name = _to_rust_identifier(name)
        code += f"    {variant_name} = {num},\n"

    code += """}

"""

    return code


def _to_rust_identifier(name):
    """Convert a name to a valid Rust enum variant identifier."""
    # Remove dots and special characters
    name = name.replace(".", "").replace("-", "_").replace(" ", "_")

    # Capitalize first letter of each word
    parts = name.split("_")
    result = "".join(part.capitalize() for part in parts if part)

    # Handle lowercase instructions like "add", "addi", etc.
    # Keep them as CamelCase by first capitalizing the first letter
    if name[0].isalpha():
        result = name[0].upper() + name[1:]

    return result or "Unknown"


def _to_rust_const_name(name):
    """Convert a name to a valid Rust constant identifier (UPPER_CASE)."""
    # Convert to uppercase with underscores
    name = name.upper().replace(".", "_").replace("-", "_").replace(" ", "_")
    return name


def _get_privilege_level(addr):
    """Extract privilege level from CSR address."""
    # CSR address bits [9:8] encode privilege level
    # 00 = User, 01 = Supervisor, 10 = Hypervisor, 11 = Machine
    priv_bits = (addr >> 8) & 0x3
    priv_map = {0: "user", 1: "supervisor", 2: "hypervisor", 3: "machine"}
    return priv_map.get(priv_bits, "unknown")


def parse_args():
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(
        description="Generate Rust code from RISC-V instruction and CSR definitions"
    )
    parser.add_argument(
        "--inst-dir",
        required=True,
        help="Directory containing instruction definition files",
    )
    parser.add_argument(
        "--csr-dir",
        required=True,
        help="Directory containing CSR definition files",
    )
    parser.add_argument(
        "--output",
        default="riscv.rs",
        help="Output Rust file (defaults to riscv.rs)",
    )
    parser.add_argument(
        "--extensions",
        "-e",
        default="",
        help="Comma-separated list of extensions to include (defaults to all)",
    )
    parser.add_argument(
        "--arch",
        "-a",
        default="RV64",
        help="Target architecture (RV32, RV64, or BOTH). Default is RV64.",
    )
    parser.add_argument(
        "--verbose", "-v", action="store_true", help="Enable verbose logging"
    )
    parser.add_argument(
        "--include-all",
        "-ia",
        action="store_true",
        help="Include all instructions, ignoring extension filtering",
    )
    return parser.parse_args()


def main():
    """Main entry point for the Rust code generator."""
    args = parse_args()

    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)

    # Check if we should include all instructions
    include_all = args.include_all or not args.extensions

    # Parse enabled extensions
    if include_all:
        enabled_extensions = []
        logging.info(
            "Including all instructions and CSRs (extension filtering disabled)"
        )
    else:
        # Get extensions from the command line
        enabled_extensions = [
            ext.strip() for ext in args.extensions.split(",") if ext.strip()
        ]
        logging.info(f"Enabled extensions: {', '.join(enabled_extensions)}")

    # Log target architecture
    logging.info(f"Target architecture: {args.arch}")

    # Check if the directories exist
    if not os.path.isdir(args.inst_dir):
        logging.error(f"Instruction directory not found: {args.inst_dir}")
        sys.exit(1)
    if not os.path.isdir(args.csr_dir):
        logging.warning(f"CSR directory not found: {args.csr_dir}")

    # Load instructions filtered by extensions or all instructions
    instr_dict = load_instructions(
        args.inst_dir, enabled_extensions, include_all, args.arch
    )
    if not instr_dict:
        logging.error("No instructions found or all were filtered out.")
        logging.error(
            "Try using --verbose to see more details about the filtering process."
        )
        sys.exit(1)
    logging.info(f"Loaded {len(instr_dict)} instructions")

    # Load CSRs filtered by extensions or all CSRs
    csrs = load_csrs(args.csr_dir, enabled_extensions, include_all, args.arch)
    if not csrs:
        logging.warning("No CSRs found or all were filtered out.")
    else:
        logging.info(f"Loaded {len(csrs)} CSRs")

    # Generate the Rust code
    make_rust(instr_dict, csrs, None, None, args.output)


if __name__ == "__main__":
    main()
