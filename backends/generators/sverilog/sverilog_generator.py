#!/usr/bin/env python3

import argparse
import logging
import os
import sys
from pathlib import Path

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from generator import load_csrs, load_exception_codes, load_instructions


def parse_args():
    parser = argparse.ArgumentParser(
        description="Generate SystemVerilog package from RISC-V instruction definitions"
    )
    parser.add_argument(
        "--inst-dir",
        default="../../../gen/resolved_spec/_/inst/",
        help="Directory containing instruction YAML files",
    )
    parser.add_argument(
        "--csr-dir",
        default="../../../gen/resolved_spec/_/csr/",
        help="Directory containing CSR YAML files",
    )
    parser.add_argument(
        "--ext-dir",
        default="../../../arch/ext/",
        help="Directory containing extension YAML files",
    )
    parser.add_argument(
        "--output",
        default="riscv_decode_package.svh",
        help="Output SystemVerilog file name",
    )
    parser.add_argument(
        "--include-all",
        action="store_true",
        help="Include all instructions and CSRs regardless of extensions",
    )
    parser.add_argument("--debug", "-d", action="store_true", help="Enable debug logging")
    parser.add_argument(
        "--extensions",
        "-e",
        nargs="+",
        default=[],
        help="Comma-separated list of enabled extensions.",
    )
    parser.add_argument(
        "--arch",
        default="BOTH",
        choices=["RV32", "RV64", "BOTH"],
        help="Target architecture (RV32, RV64, or BOTH). Default is RV64.",
    )
    parser.add_argument(
        "--resolved-codes",
        help="JSON file containing pre-resolved exception codes",
    )
    return parser.parse_args()


def format_instruction_name(name):
    """Format instruction name for SystemVerilog (uppercase with underscores)."""
    # Replace dots with underscores and convert to uppercase
    return name.replace(".", "_").upper()


def format_csr_name(name):
    """Format CSR name for SystemVerilog (uppercase with underscores)."""
    return "CSR_" + name.replace(".", "_").upper()


def format_cause_name(name):
    """Format cause name for SystemVerilog (uppercase with underscores)."""
    return "CAUSE_" + name.replace(".", "_").upper()


def match_to_sverilog_bits(match_str):
    """Convert a match string to SystemVerilog bit pattern."""
    if not match_str:
        logging.error("Empty match string encountered.")

    # For compressed instructions (16-bit), we need to handle them differently.
    # The 16-bit pattern is in the lower 16 bits,
    # with the upper 16 bits as wildcards
    if len(match_str) == 16:
        # Pad with wildcards on the left for 16-bit instructions
        match_str = "?" * 16 + match_str
    elif len(match_str) != 32:
        logging.error(f"Match string length is {len(match_str)}, expected 32 or 16.")

    # Convert to SystemVerilog format (0, 1, or ?)
    result = match_str.replace("-", "?")

    return "32'b" + "".join(result)


def generate_sverilog(instructions, csrs, causes, output_file):
    """Generate SystemVerilog package file."""
    with open(output_file, "w") as f:
        # Write header
        f.write("/* Automatically generated by UDB */\n")
        f.write(f"package {Path(output_file).stem};\n")

        # Find the maximum name length for alignment
        max_instr_len = max(
            (len(format_instruction_name(name)) for name in instructions.keys()),
            default=0,
        )
        max_csr_len = max((len(format_csr_name(csrs[addr])) for addr in csrs.keys()), default=0)
        max_cause_len = max((len(format_cause_name(name)) for _, name in causes), default=0)
        max_len = max(max_instr_len, max_csr_len)

        # Write instruction parameters
        for name in sorted(instructions.keys()):
            encoding = instructions[name]
            sv_name = format_instruction_name(name)
            # Pad the name for alignment
            padded_name = sv_name.ljust(max_len)
            # Get the match pattern
            if isinstance(encoding, dict) and "match" in encoding:
                match = encoding["match"]
            else:
                logging.error(f"No match field for instruction {name}.")

            sv_bits = match_to_sverilog_bits(match)
            f.write(f"  localparam logic [31:0] {padded_name} = {sv_bits};\n")

        # Write CSR parameters
        # CSRs are returned as {address: name} by load_csrs
        for addr in sorted(csrs.keys()):
            csr_name = csrs[addr]
            sv_name = format_csr_name(csr_name)
            # Pad the name for alignment
            padded_name = sv_name.ljust(max_len)

            # Format CSR address as 12-bit hex
            f.write(f"  localparam logic [11:0] {padded_name} = 12'h{addr:03x};\n")

        # Write exception code parameters
        for num, name in causes:
            sv_name = format_cause_name(name)
            # Pad the name for alignment
            padded_name = sv_name.ljust(max_cause_len)
            f.write(f"  localparam logic [5:0] {padded_name} = 6'h{num:02x};\n")

        # Write footer
        f.write("\nendpackage\n")


def main():
    args = parse_args()

    # Set up logging
    log_level = logging.DEBUG if args.debug else logging.INFO
    logging.basicConfig(level=log_level, format="%(levelname)s:: %(message)s")

    # Parse extensions
    if args.include_all:
        enabled_extensions = []
        logging.info("Including all instructions and CSRs (ignoring extension filter)")
    else:
        enabled_extensions = [ext.strip() for ext in args.extensions.split(",")]
        logging.info(f"Enabled extensions: {', '.join(enabled_extensions)}")

    logging.info(f"Target architecture: {args.arch}")

    # Load instructions
    instructions = load_instructions(args.inst_dir, enabled_extensions, args.include_all, args.arch)
    logging.info(f"Loaded {len(instructions)} instructions")

    # Load CSRs
    csrs = load_csrs(args.csr_dir, enabled_extensions, args.include_all, args.arch)
    logging.info(f"Loaded {len(csrs)} CSRs")

    # Load exception codes
    causes = load_exception_codes(
        args.ext_dir,
        args.extensions,
        include_all=args.include_all,
        resolved_codes_file=args.resolved_codes,
    )
    logging.info(f"Loaded {len(causes)} exception codes")

    # Generate the SystemVerilog file
    generate_sverilog(instructions, csrs, causes, args.output)
    logging.info(
        f"Generated {args.output} with {len(instructions)} instructions and {len(csrs)} CSRs"
    )


if __name__ == "__main__":
    main()
