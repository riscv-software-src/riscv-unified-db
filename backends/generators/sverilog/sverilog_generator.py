#!/usr/bin/env python3

import argparse
import os
import sys
import logging
from pathlib import Path

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from generator import load_instructions, load_csrs


def format_instruction_name(name):
    """Format instruction name for SystemVerilog (uppercase with underscores)."""
    # Replace dots with underscores and convert to uppercase
    return name.replace(".", "_").upper()


def format_csr_name(name):
    """Format CSR name for SystemVerilog (uppercase with underscores)."""
    return "CSR_" + name.replace(".", "_").upper()


def match_to_sverilog_bits(match_str):
    """Convert a match string to SystemVerilog bit pattern."""
    if not match_str:
        logging.error(f"Empty match string encountered.")
        # return "32'b" + "?" * 32

    # For compressed instructions (16-bit), we need to handle them differently.
    # The 16-bit pattern is in the lower 16 bits,
    # with the upper 16 bits as wildcards
    if len(match_str) == 16:
        # Pad with wildcards on the left for 16-bit instructions
        match_str = "?" * 16 + match_str
    elif len(match_str) < 32:
        # For other cases, pad on the right
        logging.error(f"Match string length is {len(match_str)}, expected 32 or 16.")
        # match_str = match_str + "-" * (32 - len(match_str))

    # Convert to SystemVerilog format (0, 1, or ?)
    result = match_str.replace("-", "?")

    return "32'b" + "".join(result)


def generate_sverilog(instructions, csrs, output_file):
    """Generate SystemVerilog package file."""
    with open(output_file, "w") as f:
        # Write header
        f.write("\n/* Automatically generated by UDB */\n")
        f.write("package riscv_instr;\n")

        # Find the maximum name length for alignment
        max_instr_len = max(
            (len(format_instruction_name(name)) for name in instructions.keys()),
            default=0,
        )
        max_csr_len = max(
            (len(format_csr_name(csrs[addr])) for addr in csrs.keys()), default=0
        )
        max_len = max(max_instr_len, max_csr_len)

        # Write instruction parameters
        for name in sorted(instructions.keys()):
            encoding = instructions[name]
            sv_name = format_instruction_name(name)
            # Pad the name for alignment
            padded_name = sv_name.ljust(max_len)
            # if not name.startswith("v"):
            #     logging.info(f"Processing instruction: {name}")
            #     logging.info(f"Formatted instruction: {sv_name}")
            #     logging.info(f"Padded instruction: {padded_name}")

            # Get the match pattern
            if isinstance(encoding, dict) and "match" in encoding:
                match = encoding["match"]
            else:
                # If no match field, use all wildcards
                logging.warning(f"No match field for instruction {name}.")

            sv_bits = match_to_sverilog_bits(match)
            f.write(f"  localparam logic [31:0] {padded_name} = {sv_bits};\n")

        # Write CSR parameters
        # CSRs are returned as {address: name} by load_csrs
        for addr in sorted(csrs.keys()):
            csr_name = csrs[addr]
            sv_name = format_csr_name(csr_name)
            # Pad the name for alignment
            padded_name = sv_name.ljust(max_len)

            # Format CSR address as 12-bit hex
            f.write(f"  localparam logic [11:0] {padded_name} = 12'h{addr:03x};\n")

        # Write footer
        f.write("\nendpackage\n")


def parse_args():
    parser = argparse.ArgumentParser(
        description="Generate SystemVerilog package from RISC-V instruction definitions"
    )
    parser.add_argument(
        "--inst-dir",
        default="../../../gen/resolved_spec/_/inst/",
        help="Directory containing instruction YAML files",
    )
    parser.add_argument(
        "--csr-dir",
        default="../../../gen/resolved_spec/_/csr/",
        help="Directory containing CSR YAML files",
    )
    parser.add_argument(
        "--output",
        default="riscv_decode_package.svh",
        help="Output SystemVerilog file name",
    )
    parser.add_argument(
        "--extensions",
        default="A,D,F,I,M,Q,Zba,Zbb,Zbs,S,System,V,Zicsr,Smpmp,Sm,H,U,Zicntr,Zihpm,Smhpm",
        help="Comma-separated list of enabled extensions. Default includes standard extensions.",
    )
    parser.add_argument(
        "--arch",
        default="RV64",
        choices=["RV32", "RV64", "BOTH"],
        help="Target architecture (RV32, RV64, or BOTH). Default is RV64.",
    )
    parser.add_argument(
        "--verbose", "-v", action="store_true", help="Enable verbose logging"
    )
    parser.add_argument(
        "--include-all",
        action="store_true",
        help="Include all instructions and CSRs regardless of extensions",
    )
    return parser.parse_args()


def main():
    args = parse_args()

    # Set up logging
    log_level = logging.DEBUG if args.verbose else logging.INFO
    logging.basicConfig(level=log_level, format="%(levelname)s:: %(message)s")

    # Parse extensions
    if args.include_all:
        enabled_extensions = []
        logging.info("Including all instructions and CSRs (ignoring extension filter)")
    else:
        enabled_extensions = [ext.strip() for ext in args.extensions.split(",")]
        logging.info(f"Enabled extensions: {', '.join(enabled_extensions)}")

    logging.info(f"Target architecture: {args.arch}")

    # Load instructions
    instructions = load_instructions(
        args.inst_dir, enabled_extensions, args.include_all, args.arch
    )
    logging.info(f"Loaded {len(instructions)} instructions")

    # Load CSRs
    csrs = load_csrs(args.csr_dir, enabled_extensions, args.include_all, args.arch)
    logging.info(f"Loaded {len(csrs)} CSRs")

    # Generate the SystemVerilog file
    generate_sverilog(instructions, csrs, args.output)
    logging.info(
        f"Generated {args.output} with {len(instructions)} instructions and {len(csrs)} CSRs"
    )


if __name__ == "__main__":
    main()
