#!/usr/bin/env bash

ROOT=$(dirname "$(realpath "${BASH_SOURCE[0]}")")

help() {
  echo "Usage: chore [OPTION] COMMAND [COMMAND_OPTIONS]"
  echo ""
  echo ""
  echo "Options:"
  echo ""
  echo "  -h: Print help"
  echo ""
  echo "Commands:"
  echo ""
  echo "  gen:    Generate an artifact ('chore gen -h' for more)"
  echo "  update: Update libraries     ('chore update -h' for more)"
  echo ""
}

gen_subcmd_usage() {
  echo "Usage: chore gen [-h] TARGET"
  echo ""
  echo ""
  echo "Options:"
  echo ""
  echo "  -f:      Fail on change; exit with status 1 if the generated file changes"
  echo "  -h:      Print help"
  echo ""
  echo "Commands:"
  echo ""
  echo "  all:           Generate all development artifacts"
  echo "  container-def: Generate Singularity container def from Dockerfile"
  echo "  regress:       Generate .github/workflows/regress.yml"
  echo ""
}

update_subcmd_usage() {
  echo "Usage: chore update [-h] COMMAND"
  echo ""
  echo ""
  echo "Options:"
  echo ""
  echo "  -h:      Print help"
  echo ""
  echo "Commands:"
  echo ""
  echo "  gems:          Update Ruby Gems and regenerate type definitions"
  echo ""
}

source_setup() {
  if [ -z "$SETUP_SOURCED" ]; then
    export SETUP_SOURCED=1
    source "$ROOT"/setup
  fi
}

do_gen_regress() {
  source_setup
  echo "Generating .github/workflows/regress.yml"
  if [ $fail_on_change -eq 1 ]; then
    local sha_before
    sha_before=$(sha256sum "$ROOT"/.github/workflows/regress.yml)
  fi
  $RUBY tools/test/gen_regress.rb
  if [ $fail_on_change -eq 1 ]; then
    local sha_after
    sha_after=$(sha256sum "$ROOT"/.github/workflows/regress.yml)
    if [ "$sha_before" != "$sha_after" ]; then
      exit 1
    fi
  fi
}

do_gen_container_def() {
  source_setup
  cd "${ROOT}"/.. || exit 1

  local spython=/opt/venv/bin/spython


  rm -f container.def
  {
    echo "# This file is auto-generated by bin/chore container-def"
    echo "# DO NOT EDIT"
    echo ""
  } >> container.def
  ${RUN} ${spython} recipe .devcontainer/Dockerfile | \
    grep -v SHELL | \
    sed 's!%post!%post -c /bin/bash!g' | \
    sed '/%runscript/,$d' \
    >> container.def
  chmod 444 container.def
}

do_gen_all() {
  do_gen_regress
  do_gen_container_def
}

increment_minor_version() {
  local version=$1
  # Set Internal Field Separator to '.'
  IFS='.' read -r major minor <<<"$version"

  # Increment the minor version number using arithmetic expansion
  ((minor++))

  # Re-assemble the version string
  local new_version="${major}.${minor}"
  echo "$new_version"
}

do_update_gems() {
  # first, we update all the gems on the host, which will give us updated Gemfile.lock files
  # and sorbet definitions
  cd "${ROOT}"/../tools/ruby-gems/idlc || exit 1
  bundle update --bundler --ruby
  bundle exec tapioca gems --all
  bundle exec tapioca dsl
  bundle exec tapioca annotations
  cd - || exit 1

  cd tools/ruby-gems/udb || exit 1
  bundle update --bundler --ruby
  bundle exec tapioca gems --all
  bundle exec tapioca dsl
  bundle exec tapioca annotations
  cd - || exit 1

  cd tools/ruby-gems/udb-gen || exit 1
  bundle update --bundler --ruby
  bundle exec tapioca gems --all
  bundle exec tapioca dsl
  bundle exec tapioca annotations
  cd - || exit 1

  bundle update --bundler --ruby

  # increment container-tag
  new_version=$(increment_minor_version "$(cat bin/.container-tag)")
  echo "$new_version" > bin/.container-tag

  # now rebuild the container, using the new Gemfile.locks
  ./bin/build_container

}

while getopts ":h" opt; do # Go through the options
  case $opt in
    # help
    h )
      help
      exit 0 # Exit correctly
    ;;
    # Invalid option
    ? )
        echo "[ERROR]: Invalid option: -${OPTARG}"
        help
        exit 1 # Exit with error
    ;;
  esac
done
shift $((OPTIND-1))
subcommand=$1; shift # Get subcommand and shift to next option

case "$subcommand" in
  gen )
    fail_on_change=0
    while getopts ":hf" opt; do # Go through the options
      case $opt in
        # help
        h )
          gen_subcmd_usage
          exit 0 # Exit correctly
        ;;
        f )
          fail_on_change=1
          shift
          ;;
        # Invalid option
        ? )
            echo "[ERROR]: Invalid option: -${OPTARG}"
            gen_subcmd_usage
            exit 1 # Exit with error
        ;;
      esac
    done
    target="$1"; shift
    case "$target" in
      all )
        do_gen_all
        exit 0
        ;;
      container-def )
        do_gen_container_def
        exit 0
        ;;
      regress )
        do_gen_regress
        exit 0
        ;;
      * )
        echo "Invalid target: $subcommand"
        gen_subcmd_usage
        exit 1
    esac
    ;;
  # Invalid subcommand
  update )
    while getopts ":h" opt; do # Go through the options
      case $opt in
        # help
        h )
          update_subcmd_usage
          exit 0 # Exit correctly
        ;;
        # Invalid option
        ? )
            echo "[ERROR]: Invalid option: -${OPTARG}"
            update_subcmd_usage
            exit 1 # Exit with error
        ;;
      esac
    done
    target="$1"; shift
    case "$target" in
      gems )
        do_update_gems
        exit 0
      ;;
      * )
        echo "Invalid target: $subcommand"
        update_subcmd_usage
        exit 1
    esac
    ;;
  * )
    if [ ! -z "$subcommand" ]; then  # Don't show if no subcommand provided
      echo "Invalid subcommand: $subcommand"
    fi
    usage
    exit 1 # Exit with error
  ;;
esac
