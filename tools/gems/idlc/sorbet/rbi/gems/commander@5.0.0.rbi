# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `commander` gem.
# Please instead update this file by running `bin/tapioca gem commander`.


# source://commander//lib/commander/core_ext/array.rb#3
class Array
  include ::Enumerable

  class << self
    # Split _string_ into an array. Used in
    # conjunction with HighLine's #ask, or #ask_for_array
    # methods, which must respond to #parse.
    #
    # This method allows escaping of whitespace. For example
    # the arguments foo bar\ baz will become ['foo', 'bar baz']
    #
    # === Example
    #
    #   # ask invokes Array#parse
    #   list = ask 'Favorite cookies:', Array
    #
    #   # or use ask_for_CLASS
    #   list = ask_for_array 'Favorite cookies: '
    #
    # source://commander//lib/commander/core_ext/array.rb#21
    def parse(string); end
  end
end

# source://commander//lib/commander/blank.rb#3
module Blank
  class << self
    # @private
    #
    # source://commander//lib/commander/blank.rb#4
    def included(base); end
  end
end

# source://commander//lib/commander/version.rb#3
module Commander
  private

  # source://commander//lib/commander/configure.rb#4
  def configure(*configuration_opts, &configuration_block); end

  class << self
    # source://commander//lib/commander/configure.rb#4
    def configure(*configuration_opts, &configuration_block); end
  end
end

# source://commander//lib/commander/command.rb#6
class Commander::Command
  # Initialize new command with specified _name_.
  #
  # @return [Command] a new instance of Command
  #
  # source://commander//lib/commander/command.rb#40
  def initialize(name); end

  # Handle execution of command. The handler may be a class,
  # object, or block (see examples below).
  #
  # === Examples
  #
  #   # Simple block handling
  #   c.when_called do |args, options|
  #      # do something
  #   end
  #
  #   # Create inst of Something and pass args / options
  #   c.when_called MyLib::Command::Something
  #
  #   # Create inst of Something and use arbitrary method
  #    c.when_called MyLib::Command::Something, :some_method
  #
  #   # Pass an object to handle callback (requires method symbol)
  #   c.when_called SomeObject, :some_method
  #
  # source://commander//lib/commander/command.rb#142
  def action(*args, &block); end

  # Call the commands when_called block with _args_.
  #
  # source://commander//lib/commander/command.rb#181
  def call(args = T.unsafe(nil)); end

  # Returns the value of attribute description.
  #
  # source://commander//lib/commander/command.rb#7
  def description; end

  # Sets the attribute description
  #
  # @param value the value to set the attribute description to.
  #
  # source://commander//lib/commander/command.rb#7
  def description=(_arg0); end

  # Add a usage example for this command.
  #
  # Usage examples are later displayed in help documentation
  # created by the help formatters.
  #
  # === Examples
  #
  #   command :something do |c|
  #     c.example "Should do something", "my_command something"
  #   end
  #
  # source://commander//lib/commander/command.rb#59
  def example(description, command); end

  # Returns the value of attribute examples.
  #
  # source://commander//lib/commander/command.rb#7
  def examples; end

  # Sets the attribute examples
  #
  # @param value the value to set the attribute examples to.
  #
  # source://commander//lib/commander/command.rb#7
  def examples=(_arg0); end

  # Returns the value of attribute global_options.
  #
  # source://commander//lib/commander/command.rb#8
  def global_options; end

  # source://commander//lib/commander/command.rb#215
  def inspect; end

  # Returns the value of attribute name.
  #
  # source://commander//lib/commander/command.rb#7
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://commander//lib/commander/command.rb#7
  def name=(_arg0); end

  # Add an option.
  #
  # Options are parsed via OptionParser so view it
  # for additional usage documentation. A block may optionally be
  # passed to handle the option, otherwise the _options_ struct seen below
  # contains the results of this option. This handles common formats such as:
  #
  #   -h, --help          options.help           # => bool
  #   --[no-]feature      options.feature        # => bool
  #   --large-switch      options.large_switch   # => bool
  #   --file FILE         options.file           # => file passed
  #   --list WORDS        options.list           # => array
  #   --date [DATE]       options.date           # => date or nil when optional argument not set
  #
  # === Examples
  #
  #   command :something do |c|
  #     c.option '--recursive', 'Do something recursively'
  #     c.option '--file FILE', 'Specify a file'
  #     c.option('--info', 'Display info') { puts "handle with block" }
  #     c.option '--[no-]feature', 'With or without feature'
  #     c.option '--list FILES', Array, 'List the files specified'
  #
  #     c.when_called do |args, options|
  #       do_something_recursively if options.recursive
  #       do_something_with_file options.file if options.file
  #     end
  #   end
  #
  # === Help Formatters
  #
  # This method also parses the arguments passed in order to determine
  # which were switches, and which were descriptions for the
  # option which can later be used within help formatters
  # using option[:switches] and option[:description].
  #
  # === Input Parsing
  #
  # Since Commander utilizes OptionParser you can pre-parse and evaluate
  # option arguments. Simply require 'optparse/time', or 'optparse/date', as these
  # objects must respond to #parse.
  #
  #   c.option '--time TIME', Time
  #   c.option '--date [DATE]', Date
  #
  # source://commander//lib/commander/command.rb#110
  def option(*args, &block); end

  # Option proxy proc used when a block is not explicitly passed
  # via the #option method. This allows commander to auto-populate
  # and work with option values.
  #
  # source://commander//lib/commander/command.rb#211
  def option_proc(switches); end

  # Returns the value of attribute options.
  #
  # source://commander//lib/commander/command.rb#7
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  #
  # source://commander//lib/commander/command.rb#7
  def options=(_arg0); end

  # Parses options and calls associated procs,
  # returning the arguments remaining.
  #
  # source://commander//lib/commander/command.rb#166
  def parse_options_and_call_procs(*args); end

  # Creates an Options instance populated with the option values
  # collected by the #option_proc.
  #
  # source://commander//lib/commander/command.rb#197
  def proxy_option_struct; end

  # Returns the value of attribute proxy_options.
  #
  # source://commander//lib/commander/command.rb#7
  def proxy_options; end

  # Sets the attribute proxy_options
  #
  # @param value the value to set the attribute proxy_options to.
  #
  # source://commander//lib/commander/command.rb#7
  def proxy_options=(_arg0); end

  # Run the command with _args_.
  #
  # * parses options, call option blocks
  # * invokes when_called proc
  #
  # source://commander//lib/commander/command.rb#156
  def run(*args); end

  # Returns the value of attribute summary.
  #
  # source://commander//lib/commander/command.rb#7
  def summary; end

  # Sets the attribute summary
  #
  # @param value the value to set the attribute summary to.
  #
  # source://commander//lib/commander/command.rb#7
  def summary=(_arg0); end

  # Returns the value of attribute syntax.
  #
  # source://commander//lib/commander/command.rb#7
  def syntax; end

  # Sets the attribute syntax
  #
  # @param value the value to set the attribute syntax to.
  #
  # source://commander//lib/commander/command.rb#7
  def syntax=(_arg0); end

  # Handle execution of command. The handler may be a class,
  # object, or block (see examples below).
  #
  # === Examples
  #
  #   # Simple block handling
  #   c.when_called do |args, options|
  #      # do something
  #   end
  #
  #   # Create inst of Something and pass args / options
  #   c.when_called MyLib::Command::Something
  #
  #   # Create inst of Something and use arbitrary method
  #    c.when_called MyLib::Command::Something, :some_method
  #
  #   # Pass an object to handle callback (requires method symbol)
  #   c.when_called SomeObject, :some_method
  #
  # source://commander//lib/commander/command.rb#142
  def when_called(*args, &block); end
end

# Options struct.
#
# source://commander//lib/commander/command.rb#13
class Commander::Command::Options
  include ::Blank

  # @return [Options] a new instance of Options
  #
  # source://commander//lib/commander/command.rb#16
  def initialize; end

  # source://commander//lib/commander/command.rb#20
  def __hash__; end

  # source://commander//lib/commander/command.rb#28
  def default(defaults = T.unsafe(nil)); end

  # source://commander//lib/commander/command.rb#32
  def inspect; end

  # source://commander//lib/commander/command.rb#24
  def method_missing(meth, *args); end
end

# source://commander//lib/commander/delegates.rb#4
module Commander::Delegates
  # source://commander//lib/commander/delegates.rb#17
  def add_command(*args, &block); end

  # source://commander//lib/commander/delegates.rb#17
  def alias_command(*args, &block); end

  # source://commander//lib/commander/delegates.rb#17
  def always_trace!(*args, &block); end

  # source://commander//lib/commander/delegates.rb#17
  def command(*args, &block); end

  # source://commander//lib/commander/delegates.rb#17
  def default_command(*args, &block); end

  # source://commander//lib/commander/delegates.rb#23
  def defined_commands(*_arg0, **_arg1, &_arg2); end

  # source://commander//lib/commander/delegates.rb#17
  def global_option(*args, &block); end

  # source://commander//lib/commander/delegates.rb#17
  def never_trace!(*args, &block); end

  # source://commander//lib/commander/delegates.rb#17
  def program(*args, &block); end

  # source://commander//lib/commander/delegates.rb#17
  def run!(*args, &block); end
end

# = Help Formatter
#
# Commander's help formatters control the output when
# either the help command, or --help switch are called.
# The default formatter is Commander::HelpFormatter::Terminal.
#
# source://commander//lib/commander/help_formatters.rb#4
module Commander::HelpFormatter
  private

  # source://commander//lib/commander/help_formatters.rb#47
  def indent(amount, text); end

  class << self
    # source://commander//lib/commander/help_formatters.rb#47
    def indent(amount, text); end
  end
end

# source://commander//lib/commander/help_formatters/base.rb#12
class Commander::HelpFormatter::Base
  # @return [Base] a new instance of Base
  #
  # source://commander//lib/commander/help_formatters/base.rb#13
  def initialize(runner); end

  # source://commander//lib/commander/help_formatters/base.rb#17
  def render; end

  # source://commander//lib/commander/help_formatters/base.rb#21
  def render_command(command); end
end

# source://commander//lib/commander/help_formatters.rb#9
class Commander::HelpFormatter::Context
  # @return [Context] a new instance of Context
  #
  # source://commander//lib/commander/help_formatters.rb#10
  def initialize(target); end

  # No-op, override in subclasses.
  #
  # source://commander//lib/commander/help_formatters.rb#21
  def decorate_binding(_bind); end

  # source://commander//lib/commander/help_formatters.rb#14
  def get_binding; end
end

# source://commander//lib/commander/help_formatters.rb#25
class Commander::HelpFormatter::ProgramContext < ::Commander::HelpFormatter::Context
  # source://commander//lib/commander/help_formatters.rb#26
  def decorate_binding(bind); end

  # source://commander//lib/commander/help_formatters.rb#35
  def max_aliases_length(bind); end

  # source://commander//lib/commander/help_formatters.rb#31
  def max_command_length(bind); end

  # source://commander//lib/commander/help_formatters.rb#39
  def max_key_length(hash, default = T.unsafe(nil)); end
end

# source://commander//lib/commander/help_formatters/terminal.rb#7
class Commander::HelpFormatter::Terminal < ::Commander::HelpFormatter::Base
  # source://commander//lib/commander/help_formatters/terminal.rb#8
  def render; end

  # source://commander//lib/commander/help_formatters/terminal.rb#12
  def render_command(command); end

  # source://commander//lib/commander/help_formatters/terminal.rb#16
  def template(name); end
end

# source://commander//lib/commander/help_formatters/terminal_compact.rb#7
class Commander::HelpFormatter::TerminalCompact < ::Commander::HelpFormatter::Terminal
  # source://commander//lib/commander/help_formatters/terminal_compact.rb#8
  def template(name); end
end

# source://commander//lib/commander/methods.rb#4
module Commander::Methods
  include ::Commander::UI
  include ::Commander::UI::AskForClass
  include ::Commander::Delegates
end

# source://commander//lib/commander/platform.rb#4
module Commander::Platform
  class << self
    # @return [Boolean]
    #
    # source://commander//lib/commander/platform.rb#5
    def jruby?; end
  end
end

# source://commander//lib/commander/runner.rb#6
class Commander::Runner
  # Initialize a new command runner. Optionally
  # supplying _args_ for mocking, or arbitrary usage.
  #
  # @return [Runner] a new instance of Runner
  #
  # source://commander//lib/commander/runner.rb#21
  def initialize(args = T.unsafe(nil)); end

  # Get active command within arguments passed to this runner.
  #
  # source://commander//lib/commander/runner.rb#223
  def active_command; end

  # Add a command object to this runner.
  #
  # source://commander//lib/commander/runner.rb#200
  def add_command(command); end

  # Check if command _name_ is an alias.
  #
  # @return [Boolean]
  #
  # source://commander//lib/commander/runner.rb#207
  def alias?(name); end

  # Alias command _name_ with _alias_name_. Optionally _args_ may be passed
  # as if they were being passed straight to the original command via the command-line.
  #
  # source://commander//lib/commander/runner.rb#184
  def alias_command(alias_name, name, *args); end

  # Enable tracing on all executions (bypasses --trace)
  #
  # source://commander//lib/commander/runner.rb#89
  def always_trace!; end

  # Return arguments without the command name.
  #
  # source://commander//lib/commander/runner.rb#255
  def args_without_command_name; end

  # Creates and yields a command instance when a block is passed.
  # Otherwise attempts to return the command, raising InvalidCommandError when
  # it does not exist.
  #
  # === Examples
  #
  #   command :my_command do |c|
  #     c.when_called do |args|
  #       # Code
  #     end
  #   end
  #
  # @yield [add_command(Commander::Command.new(name))]
  #
  # source://commander//lib/commander/runner.rb#161
  def command(name, &block); end

  # Check if a command _name_ exists.
  #
  # @return [Boolean]
  #
  # source://commander//lib/commander/runner.rb#214
  def command_exists?(name); end

  # Attempts to locate a command name from within the arguments.
  # Supports multi-word commands, using the largest possible match.
  # Returns the default command, if no valid commands found in the args.
  #
  # source://commander//lib/commander/runner.rb#232
  def command_name_from_args; end

  # Returns the value of attribute commands.
  #
  # source://commander//lib/commander/runner.rb#15
  def commands; end

  # Creates default commands such as 'help' which is
  # essentially the same as using the --help switch.
  #
  # source://commander//lib/commander/runner.rb#287
  def create_default_commands; end

  # Default command _name_ to be used when no other
  # command is found in the arguments.
  #
  # source://commander//lib/commander/runner.rb#193
  def default_command(name); end

  # expand switches of the style '--[no-]blah' into both their
  # '--blah' and '--no-blah' variants, so that they can be
  # properly detected and removed
  #
  # source://commander//lib/commander/runner.rb#358
  def expand_optionally_negative_switches(switches); end

  # Add a global option; follows the same syntax as Command#option
  # This would be used for switches such as --version, --trace, etc.
  #
  # source://commander//lib/commander/runner.rb#170
  def global_option(*args, &block); end

  # Returns a proc allowing for commands to inherit global options.
  # This functionality works whether a block is present for the global
  # option or not, so simple switches such as --verbose can be used
  # without a block, and used throughout all commands.
  #
  # source://commander//lib/commander/runner.rb#393
  def global_option_proc(switches, &block); end

  # Help formatter instance.
  #
  # source://commander//lib/commander/runner.rb#248
  def help_formatter; end

  # Returns hash of help formatter alias defaults.
  #
  # source://commander//lib/commander/runner.rb#266
  def help_formatter_alias_defaults; end

  # Returns the value of attribute help_formatter_aliases.
  #
  # source://commander//lib/commander/runner.rb#15
  def help_formatter_aliases; end

  # Hide the trace option from the help menus and don't add it as a global option
  #
  # source://commander//lib/commander/runner.rb#97
  def never_trace!; end

  # Returns the value of attribute options.
  #
  # source://commander//lib/commander/runner.rb#15
  def options; end

  # Parse global command options.
  #
  # source://commander//lib/commander/runner.rb#372
  def parse_global_options; end

  # source://commander//lib/commander/runner.rb#131
  def program(key, *args, &block); end

  # Returns hash of program defaults.
  #
  # source://commander//lib/commander/runner.rb#275
  def program_defaults; end

  # Removes global _options_ from _args_. This prevents an invalid
  # option error from occurring when options are parsed
  # again for the command.
  #
  # source://commander//lib/commander/runner.rb#322
  def remove_global_options(options, args); end

  # Raises a CommandError when the program any of the _keys_ are not present, or empty.
  #
  # source://commander//lib/commander/runner.rb#405
  def require_program(*keys); end

  # Raises InvalidCommandError when a _command_ is not found.
  #
  # source://commander//lib/commander/runner.rb#313
  def require_valid_command(command = T.unsafe(nil)); end

  # Run command parsing and execution process.
  #
  # source://commander//lib/commander/runner.rb#40
  def run!; end

  # Run the active command.
  #
  # source://commander//lib/commander/runner.rb#439
  def run_active_command; end

  # source://commander//lib/commander/runner.rb#448
  def say(*args); end

  # Returns array of valid command names found within _args_.
  #
  # source://commander//lib/commander/runner.rb#239
  def valid_command_names_from(*args); end

  # Return program version.
  #
  # source://commander//lib/commander/runner.rb#82
  def version; end

  private

  # Attempts to locate a command name from within the provided arguments.
  # Supports multi-word commands, using the largest possible match.
  #
  # source://commander//lib/commander/runner.rb#458
  def longest_valid_command_name_from(args); end

  class << self
    # Return singleton Runner instance.
    #
    # source://commander//lib/commander/runner.rb#33
    def instance; end

    # Return switches and description separated from the _args_ passed.
    #
    # source://commander//lib/commander/runner.rb#414
    def separate_switches_from_description(*args); end

    # Attempts to generate a method name symbol from +switch+.
    # For example:
    #
    #   -h                 # => :h
    #   --trace            # => :trace
    #   --some-switch      # => :some_switch
    #   --[no-]feature     # => :feature
    #   --file FILE        # => :file
    #   --list of,things   # => :list
    #
    # source://commander//lib/commander/runner.rb#432
    def switch_to_sym(switch); end
  end
end

# --
# Exceptions
# ++
#
# source://commander//lib/commander/runner.rb#11
class Commander::Runner::CommandError < ::StandardError; end

# source://commander//lib/commander/runner.rb#13
class Commander::Runner::InvalidCommandError < ::Commander::Runner::CommandError; end

# = User Interaction
#
# Commander's user interaction module mixes in common
# methods which extend HighLine's functionality such
# as a #password method rather than calling #ask directly.
#
# source://commander//lib/commander/user_interaction.rb#14
module Commander::UI
  private

  # Execute apple _script_.
  #
  # source://commander//lib/commander/user_interaction.rb#193
  def applescript(script); end

  # Prompt an editor for input. Optionally supply initial
  # _input_ which is written to the editor.
  #
  # _preferred_editor_ can be hinted.
  #
  # === Examples
  #
  #   ask_editor                # => prompts EDITOR with no input
  #   ask_editor('foo')         # => prompts EDITOR with default text of 'foo'
  #   ask_editor('foo', 'mate -w')  # => prompts TextMate with default text of 'foo'
  #
  # source://commander//lib/commander/user_interaction.rb#256
  def ask_editor(input = T.unsafe(nil), preferred_editor = T.unsafe(nil)); end

  # Find an editor available in path. Optionally supply the _preferred_
  # editor. Returns the name as a string, nil if none is available.
  #
  # source://commander//lib/commander/user_interaction.rb#237
  def available_editor(preferred = T.unsafe(nil)); end

  # Choose from a set array of _choices_.
  #
  # source://commander//lib/commander/user_interaction.rb#43
  def choose(message = T.unsafe(nil), *choices, &block); end

  # 'Say' something using the specified color
  #
  # === Examples
  #   color 'I am blue', :blue
  #   color 'I am bold', :bold
  #   color 'White on Red', :white, :on_red
  #
  # === Notes
  #   You may use:
  #   * color:    black blue cyan green magenta red white yellow
  #   * style:    blink bold clear underline
  #   * highligh: on_<color>
  #
  # source://commander//lib/commander/user_interaction.rb#117
  def color(*args); end

  # Converse with speech recognition.
  #
  # Currently a "poorman's" DSL to utilize applescript and
  # the MacOS speech recognition server.
  #
  # === Examples
  #
  #   case converse 'What is the best food?', :cookies => 'Cookies', :unknown => 'Nothing'
  #   when :cookies
  #     speak 'o.m.g. you are awesome!'
  #   else
  #     case converse 'That is lame, shall I convince you cookies are the best?', :yes => 'Ok', :no => 'No', :maybe => 'Maybe another time'
  #     when :yes
  #       speak 'Well you see, cookies are just fantastic.'
  #     else
  #       speak 'Ok then, bye.'
  #     end
  #   end
  #
  # === Notes
  #
  # * MacOS only
  #
  # source://commander//lib/commander/user_interaction.rb#168
  def converse(prompt, responses = T.unsafe(nil)); end

  # Enable paging of output after called.
  #
  # source://commander//lib/commander/user_interaction.rb#272
  def enable_paging; end

  # Normalize IO streams, allowing for redirection of
  # +input+ and/or +output+, for example:
  #
  #   $ foo              # => read from terminal I/O
  #   $ foo in           # => read from 'in' file, output to terminal output stream
  #   $ foo in out       # => read from 'in' file, output to 'out' file
  #   $ foo < in > out   # => equivalent to above (essentially)
  #
  # Optionally a +block+ may be supplied, in which case
  # IO will be reset once the block has executed.
  #
  # === Examples
  #
  #   command :foo do |c|
  #     c.syntax = 'foo [input] [output]'
  #     c.when_called do |args, options|
  #       # or io(args.shift, args.shift)
  #       io *args
  #       str = $stdin.gets
  #       puts 'input was: ' + str.inspect
  #     end
  #   end
  #
  # source://commander//lib/commander/user_interaction.rb#222
  def io(input = T.unsafe(nil), output = T.unsafe(nil), &block); end

  # 'Log' an _action_ to the terminal. This is typically used
  # for verbose output regarding actions performed. For example:
  #
  #   create  path/to/file.rb
  #   remove  path/to/old_file.rb
  #   remove  path/to/old_file2.rb
  #
  # source://commander//lib/commander/user_interaction.rb#57
  def log(action, *args); end

  # Ask the user for a password. Specify a custom
  # _message_ other than 'Password: ' or override the
  # default _mask_ of '*'.
  #
  # source://commander//lib/commander/user_interaction.rb#34
  def password(message = T.unsafe(nil), mask = T.unsafe(nil)); end

  # Output progress while iterating _arr_.
  #
  # === Examples
  #
  #   uris = %w( http://vision-media.ca http://google.com )
  #   progress uris, :format => "Remaining: :time_remaining" do |uri|
  #     res = open uri
  #   end
  #
  # source://commander//lib/commander/user_interaction.rb#316
  def progress(arr, options = T.unsafe(nil)); end

  # Substitute _hash_'s keys with their associated values in _str_.
  #
  # source://commander//lib/commander/user_interaction.rb#374
  def replace_tokens(str, hash); end

  # 'Say' something using the ERROR color (red).
  #
  # === Examples
  #   say_error 'Everything is not fine'
  #   say_error 'It is not ok', 'This is not ok too'
  #
  # source://commander//lib/commander/user_interaction.rb#97
  def say_error(*args); end

  # 'Say' something using the OK color (green).
  #
  # === Examples
  #   say_ok 'Everything is fine'
  #   say_ok 'It is ok', 'This is ok too'
  #
  # source://commander//lib/commander/user_interaction.rb#69
  def say_ok(*args); end

  # 'Say' something using the WARNING color (yellow).
  #
  # === Examples
  #   say_warning 'This is a warning'
  #   say_warning 'Be careful', 'Think about it'
  #
  # source://commander//lib/commander/user_interaction.rb#83
  def say_warning(*args); end

  # Speak _message_ using _voice_ at a speaking rate of _rate_
  #
  # Voice defaults to 'Alex', which is one of the better voices.
  # Speaking rate defaults to 175 words per minute
  #
  # === Examples
  #
  #   speak 'What is your favorite food? '
  #   food = ask 'favorite food?: '
  #   speak "Wow, I like #{food} too. We have so much in common."
  #   speak "I like #{food} as well!", "Victoria", 190
  #
  # === Notes
  #
  # * MacOS only
  #
  # source://commander//lib/commander/user_interaction.rb#139
  def speak(message, voice = T.unsafe(nil), rate = T.unsafe(nil)); end

  class << self
    # Execute apple _script_.
    #
    # source://commander//lib/commander/user_interaction.rb#193
    def applescript(script); end

    # Prompt an editor for input. Optionally supply initial
    # _input_ which is written to the editor.
    #
    # _preferred_editor_ can be hinted.
    #
    # === Examples
    #
    #   ask_editor                # => prompts EDITOR with no input
    #   ask_editor('foo')         # => prompts EDITOR with default text of 'foo'
    #   ask_editor('foo', 'mate -w')  # => prompts TextMate with default text of 'foo'
    #
    # source://commander//lib/commander/user_interaction.rb#256
    def ask_editor(input = T.unsafe(nil), preferred_editor = T.unsafe(nil)); end

    # Find an editor available in path. Optionally supply the _preferred_
    # editor. Returns the name as a string, nil if none is available.
    #
    # source://commander//lib/commander/user_interaction.rb#237
    def available_editor(preferred = T.unsafe(nil)); end

    # Choose from a set array of _choices_.
    #
    # source://commander//lib/commander/user_interaction.rb#43
    def choose(message = T.unsafe(nil), *choices, &block); end

    # 'Say' something using the specified color
    #
    # === Examples
    #   color 'I am blue', :blue
    #   color 'I am bold', :bold
    #   color 'White on Red', :white, :on_red
    #
    # === Notes
    #   You may use:
    #   * color:    black blue cyan green magenta red white yellow
    #   * style:    blink bold clear underline
    #   * highligh: on_<color>
    #
    # source://commander//lib/commander/user_interaction.rb#117
    def color(*args); end

    # Converse with speech recognition.
    #
    # Currently a "poorman's" DSL to utilize applescript and
    # the MacOS speech recognition server.
    #
    # === Examples
    #
    #   case converse 'What is the best food?', :cookies => 'Cookies', :unknown => 'Nothing'
    #   when :cookies
    #     speak 'o.m.g. you are awesome!'
    #   else
    #     case converse 'That is lame, shall I convince you cookies are the best?', :yes => 'Ok', :no => 'No', :maybe => 'Maybe another time'
    #     when :yes
    #       speak 'Well you see, cookies are just fantastic.'
    #     else
    #       speak 'Ok then, bye.'
    #     end
    #   end
    #
    # === Notes
    #
    # * MacOS only
    #
    # source://commander//lib/commander/user_interaction.rb#168
    def converse(prompt, responses = T.unsafe(nil)); end

    # Enable paging of output after called.
    #
    # source://commander//lib/commander/user_interaction.rb#272
    def enable_paging; end

    # Normalize IO streams, allowing for redirection of
    # +input+ and/or +output+, for example:
    #
    #   $ foo              # => read from terminal I/O
    #   $ foo in           # => read from 'in' file, output to terminal output stream
    #   $ foo in out       # => read from 'in' file, output to 'out' file
    #   $ foo < in > out   # => equivalent to above (essentially)
    #
    # Optionally a +block+ may be supplied, in which case
    # IO will be reset once the block has executed.
    #
    # === Examples
    #
    #   command :foo do |c|
    #     c.syntax = 'foo [input] [output]'
    #     c.when_called do |args, options|
    #       # or io(args.shift, args.shift)
    #       io *args
    #       str = $stdin.gets
    #       puts 'input was: ' + str.inspect
    #     end
    #   end
    #
    # source://commander//lib/commander/user_interaction.rb#222
    def io(input = T.unsafe(nil), output = T.unsafe(nil), &block); end

    # 'Log' an _action_ to the terminal. This is typically used
    # for verbose output regarding actions performed. For example:
    #
    #   create  path/to/file.rb
    #   remove  path/to/old_file.rb
    #   remove  path/to/old_file2.rb
    #
    # source://commander//lib/commander/user_interaction.rb#57
    def log(action, *args); end

    # Ask the user for a password. Specify a custom
    # _message_ other than 'Password: ' or override the
    # default _mask_ of '*'.
    #
    # source://commander//lib/commander/user_interaction.rb#34
    def password(message = T.unsafe(nil), mask = T.unsafe(nil)); end

    # Output progress while iterating _arr_.
    #
    # === Examples
    #
    #   uris = %w( http://vision-media.ca http://google.com )
    #   progress uris, :format => "Remaining: :time_remaining" do |uri|
    #     res = open uri
    #   end
    #
    # source://commander//lib/commander/user_interaction.rb#316
    def progress(arr, options = T.unsafe(nil)); end

    # Substitute _hash_'s keys with their associated values in _str_.
    #
    # source://commander//lib/commander/user_interaction.rb#374
    def replace_tokens(str, hash); end

    # 'Say' something using the ERROR color (red).
    #
    # === Examples
    #   say_error 'Everything is not fine'
    #   say_error 'It is not ok', 'This is not ok too'
    #
    # source://commander//lib/commander/user_interaction.rb#97
    def say_error(*args); end

    # 'Say' something using the OK color (green).
    #
    # === Examples
    #   say_ok 'Everything is fine'
    #   say_ok 'It is ok', 'This is ok too'
    #
    # source://commander//lib/commander/user_interaction.rb#69
    def say_ok(*args); end

    # 'Say' something using the WARNING color (yellow).
    #
    # === Examples
    #   say_warning 'This is a warning'
    #   say_warning 'Be careful', 'Think about it'
    #
    # source://commander//lib/commander/user_interaction.rb#83
    def say_warning(*args); end

    # Speak _message_ using _voice_ at a speaking rate of _rate_
    #
    # Voice defaults to 'Alex', which is one of the better voices.
    # Speaking rate defaults to 175 words per minute
    #
    # === Examples
    #
    #   speak 'What is your favorite food? '
    #   food = ask 'favorite food?: '
    #   speak "Wow, I like #{food} too. We have so much in common."
    #   speak "I like #{food} as well!", "Victoria", 190
    #
    # === Notes
    #
    # * MacOS only
    #
    # source://commander//lib/commander/user_interaction.rb#139
    def speak(message, voice = T.unsafe(nil), rate = T.unsafe(nil)); end
  end
end

# Implements ask_for_CLASS methods.
#
# source://commander//lib/commander/user_interaction.rb#325
module Commander::UI::AskForClass
  # source://commander//lib/commander/user_interaction.rb#330
  def ask_for_array(prompt); end

  # source://commander//lib/commander/user_interaction.rb#330
  def ask_for_file(prompt); end

  # source://commander//lib/commander/user_interaction.rb#330
  def ask_for_float(prompt); end

  # source://commander//lib/commander/user_interaction.rb#330
  def ask_for_integer(prompt); end

  # source://commander//lib/commander/user_interaction.rb#330
  def ask_for_pathname(prompt); end

  # source://commander//lib/commander/user_interaction.rb#330
  def ask_for_regexp(prompt); end

  # source://commander//lib/commander/user_interaction.rb#330
  def ask_for_string(prompt); end

  # source://commander//lib/commander/user_interaction.rb#330
  def ask_for_symbol(prompt); end

  # source://commander//lib/commander/user_interaction.rb#335
  def method_missing(method_name, *arguments, &block); end

  private

  # @return [Boolean]
  #
  # source://commander//lib/commander/user_interaction.rb#366
  def respond_to_missing?(method_name, include_private = T.unsafe(nil)); end
end

# source://commander//lib/commander/user_interaction.rb#326
Commander::UI::AskForClass::DEPRECATED_CONSTANTS = T.let(T.unsafe(nil), Array)

# = Progress Bar
#
# Terminal progress bar utility. In its most basic form
# requires that the developer specifies when the bar should
# be incremented. Note that a hash of tokens may be passed to
# #increment, (or returned when using Object#progress).
#
#   uris = %w(
#     http://vision-media.ca
#     http://yahoo.com
#     http://google.com
#     )
#
#   bar = Commander::UI::ProgressBar.new uris.length, options
#   threads = []
#   uris.each do |uri|
#     threads << Thread.new do
#       begin
#         res = open uri
#         bar.increment :uri => uri
#       rescue Exception => e
#         bar.increment :uri => "#{uri} failed"
#       end
#     end
#   end
#   threads.each { |t| t.join }
#
# The Object method #progress is also available:
#
#   progress uris, :width => 10 do |uri|
#     res = open uri
#     { :uri => uri } # Can now use :uri within :format option
#   end
#
# source://commander//lib/commander/user_interaction.rb#416
class Commander::UI::ProgressBar
  # Creates a new progress bar.
  #
  # === Options
  #
  #   :title              Title, defaults to "Progress"
  #   :width              Width of :progress_bar
  #   :progress_str       Progress string, defaults to "="
  #   :incomplete_str     Incomplete bar string, defaults to '.'
  #   :format             Defaults to ":title |:progress_bar| :percent_complete% complete "
  #   :tokens             Additional tokens replaced within the format string
  #   :complete_message   Defaults to "Process complete"
  #
  # === Tokens
  #
  #   :title
  #   :percent_complete
  #   :progress_bar
  #   :step
  #   :steps_remaining
  #   :total_steps
  #   :time_elapsed
  #   :time_remaining
  #
  # @return [ProgressBar] a new instance of ProgressBar
  #
  # source://commander//lib/commander/user_interaction.rb#442
  def initialize(total, options = T.unsafe(nil)); end

  # Whether or not the operation has completed.
  #
  # @return [Boolean]
  #
  # source://commander//lib/commander/user_interaction.rb#532
  def completed?; end

  # Erase previous terminal line.
  #
  # source://commander//lib/commander/user_interaction.rb#549
  def erase_line; end

  # Whether or not the operation is complete, and we have finished.
  #
  # @return [Boolean]
  #
  # source://commander//lib/commander/user_interaction.rb#525
  def finished?; end

  # Generates tokens for this step.
  #
  # source://commander//lib/commander/user_interaction.rb#495
  def generate_tokens; end

  # Increment progress. Optionally pass _tokens_ which
  # can be displayed in the output format.
  #
  # source://commander//lib/commander/user_interaction.rb#540
  def increment(tokens = T.unsafe(nil)); end

  # Completion percentage.
  #
  # source://commander//lib/commander/user_interaction.rb#456
  def percent_complete; end

  # Formatted progress bar.
  #
  # source://commander//lib/commander/user_interaction.rb#488
  def progress_bar; end

  # Output the progress bar.
  #
  # source://commander//lib/commander/user_interaction.rb#511
  def show; end

  # Number of steps left.
  #
  # source://commander//lib/commander/user_interaction.rb#481
  def steps_remaining; end

  # Time that has elapsed since the operation started.
  #
  # source://commander//lib/commander/user_interaction.rb#467
  def time_elapsed; end

  # Estimated time remaining.
  #
  # source://commander//lib/commander/user_interaction.rb#474
  def time_remaining; end
end

# source://commander//lib/commander/version.rb#4
Commander::VERSION = T.let(T.unsafe(nil), String)

# source://commander//lib/commander/core_ext/object.rb#3
class Object < ::BasicObject
  include ::Kernel
  include ::PP::ObjectMixin

  # Return the current binding.
  #
  # source://commander//lib/commander/core_ext/object.rb#7
  def get_binding; end
end
