# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `json_schemer` gem.
# Please instead update this file by running `bin/tapioca gem json_schemer`.


# Based on code from @robacarp found in issue 48:
# https://github.com/davishmcclurg/json_schemer/issues/48
#
# source://json_schemer//lib/json_schemer/version.rb#2
module JSONSchemer
  class << self
    # source://json_schemer//lib/json_schemer.rb#58
    def schema(schema, default_schema_class: T.unsafe(nil), **options); end

    # @return [Boolean]
    #
    # source://json_schemer//lib/json_schemer.rb#84
    def valid_schema?(schema, default_schema_class: T.unsafe(nil)); end

    # source://json_schemer//lib/json_schemer.rb#88
    def validate_schema(schema, default_schema_class: T.unsafe(nil)); end
  end
end

# source://json_schemer//lib/json_schemer/cached_resolver.rb#15
class JSONSchemer::CachedRefResolver < ::JSONSchemer::CachedResolver; end

# source://json_schemer//lib/json_schemer/cached_resolver.rb#3
class JSONSchemer::CachedResolver
  # @return [CachedResolver] a new instance of CachedResolver
  #
  # source://json_schemer//lib/json_schemer/cached_resolver.rb#4
  def initialize(&resolver); end

  # source://json_schemer//lib/json_schemer/cached_resolver.rb#9
  def call(*args); end
end

# source://json_schemer//lib/json_schemer.rb#39
JSONSchemer::DEFAULT_SCHEMA_CLASS = JSONSchemer::Schema::Draft7

# source://json_schemer//lib/json_schemer/ecma_regexp.rb#3
class JSONSchemer::EcmaRegexp
  class << self
    # source://json_schemer//lib/json_schemer/ecma_regexp.rb#39
    def ruby_equivalent(pattern); end
  end
end

# source://json_schemer//lib/json_schemer/ecma_regexp.rb#27
JSONSchemer::EcmaRegexp::RUBY_EQUIVALENTS = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/ecma_regexp.rb#4
class JSONSchemer::EcmaRegexp::Syntax < ::Regexp::Syntax::Base; end

# regexp_parser >= 2.3.0 uses syntax classes directly instead of instances
# :nocov:
#
# source://json_schemer//lib/json_schemer/ecma_regexp.rb#7
JSONSchemer::EcmaRegexp::Syntax::SYNTAX = JSONSchemer::EcmaRegexp::Syntax

# source://json_schemer//lib/json_schemer/errors.rb#5
module JSONSchemer::Errors
  class << self
    # source://json_schemer//lib/json_schemer/errors.rb#7
    def pretty(error); end
  end
end

# source://json_schemer//lib/json_schemer.rb#49
JSONSchemer::FILE_URI_REF_RESOLVER = T.let(T.unsafe(nil), Proc)

# source://json_schemer//lib/json_schemer/format/hostname.rb#3
module JSONSchemer::Format
  include ::JSONSchemer::Format::Email
  include ::JSONSchemer::Format::Hostname
  include ::JSONSchemer::Format::URITemplate

  # source://json_schemer//lib/json_schemer/format.rb#101
  def iri_escape(data); end

  # @raise [URI::InvalidURIError]
  #
  # source://json_schemer//lib/json_schemer/format.rb#81
  def parse_uri_scheme(data); end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/format.rb#65
  def valid_date_time?(data); end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/format.rb#74
  def valid_ip?(data, family); end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/format.rb#58
  def valid_json?(data); end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/format.rb#112
  def valid_json_pointer?(data); end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/format.rb#120
  def valid_regex?(data); end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/format.rb#116
  def valid_relative_json_pointer?(data); end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/format.rb#17
  def valid_spec_format?(data, format); end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/format.rb#88
  def valid_uri?(data); end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/format.rb#94
  def valid_uri_reference?(data); end
end

# source://json_schemer//lib/json_schemer/format.rb#11
JSONSchemer::Format::DATE_TIME_OFFSET_REGEX = T.let(T.unsafe(nil), Regexp)

# source://json_schemer//lib/json_schemer/format/email.rb#4
module JSONSchemer::Format::Email
  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/format/email.rb#44
  def valid_email?(data); end
end

# using `valid_id?` to check ip addresses because it's complicated.     # IPv6-address-literal  = "IPv6:" IPv6-addr
#
# source://json_schemer//lib/json_schemer/format/email.rb#36
JSONSchemer::Format::Email::ADDRESS_LITERAL = T.let(T.unsafe(nil), String)

# Atom            = 1*atext
#
# source://json_schemer//lib/json_schemer/format/email.rb#30
JSONSchemer::Format::Email::ATOM = T.let(T.unsafe(nil), String)

# https://datatracker.ietf.org/doc/html/rfc5321#section-4.1.2
#
# source://json_schemer//lib/json_schemer/format/email.rb#9
JSONSchemer::Format::Email::A_TEXT = T.let(T.unsafe(nil), String)

# Dot-string      = Atom *("."  Atom)
#
# source://json_schemer//lib/json_schemer/format/email.rb#31
JSONSchemer::Format::Email::DOT_STRING = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/format/email.rb#42
JSONSchemer::Format::Email::EMAIL_REGEX = T.let(T.unsafe(nil), Regexp)

# source://json_schemer//lib/json_schemer/format/email.rb#32
JSONSchemer::Format::Email::LOCAL_PART = T.let(T.unsafe(nil), String)

# using `valid_hostname?` to check domain because it's complicated
#
# source://json_schemer//lib/json_schemer/format/email.rb#41
JSONSchemer::Format::Email::MAILBOX = T.let(T.unsafe(nil), String)

# qtextSMTP       = %d32-33 / %d35-91 / %d93-126
#                 ; i.e., within a quoted string, any
#                 ; ASCII graphic or space is permitted
#                 ; without blackslash-quoting except
#                 ; double-quote and the backslash itself.
#
# source://json_schemer//lib/json_schemer/format/email.rb#25
JSONSchemer::Format::Email::QUOTED_PAIR_SMTP = T.let(T.unsafe(nil), String)

# Quoted-string   = DQUOTE *QcontentSMTP DQUOTE
#
# source://json_schemer//lib/json_schemer/format/email.rb#29
JSONSchemer::Format::Email::QUOTED_STRING = T.let(T.unsafe(nil), String)

# quoted-pairSMTP = %d92 %d32-126
#                 ; i.e., backslash followed by any ASCII
#                 ; graphic (including itself) or SPace
#
# source://json_schemer//lib/json_schemer/format/email.rb#28
JSONSchemer::Format::Email::Q_CONTENT_SMTP = T.let(T.unsafe(nil), String)

# atext           = ALPHA / DIGIT /    ; Printable US-ASCII
#                   "!" / "#" /        ;  characters not including
#                   "$" / "%" /        ;  specials.  Used for atoms.
#                   "&" / "'" /
#                   "*" / "+" /
#                   "-" / "/" /
#                   "=" / "?" /
#                   "^" / "_" /
#                   "`" / "{" /
#                   "|" / "}" /
#                   "~"
#
# source://json_schemer//lib/json_schemer/format/email.rb#20
JSONSchemer::Format::Email::Q_TEXT_SMTP = T.let(T.unsafe(nil), String)

# https://datatracker.ietf.org/doc/html/rfc6531#section-3.3
# I think this is the same as "UTF8-non-ascii"? (https://datatracker.ietf.org/doc/html/rfc6532#section-3.1)
#
# source://json_schemer//lib/json_schemer/format/email.rb#7
JSONSchemer::Format::Email::UTF8_NON_ASCII = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/format.rb#12
JSONSchemer::Format::HOUR_24_REGEX = T.let(T.unsafe(nil), Regexp)

# source://json_schemer//lib/json_schemer/format/hostname.rb#4
module JSONSchemer::Format::Hostname
  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/format/hostname.rb#42
  def valid_hostname?(data); end
end

# source://json_schemer//lib/json_schemer/format/hostname.rb#40
JSONSchemer::Format::Hostname::ARABIC_EXTENDED_DIGITS_REGEX = T.let(T.unsafe(nil), Regexp)

# https://datatracker.ietf.org/doc/html/rfc5892#appendix-A.8
# https://datatracker.ietf.org/doc/html/rfc5892#appendix-A.9
#
# source://json_schemer//lib/json_schemer/format/hostname.rb#39
JSONSchemer::Format::Hostname::ARABIC_INDIC_DIGITS_REGEX = T.let(T.unsafe(nil), Regexp)

# source://json_schemer//lib/json_schemer/format/hostname.rb#33
JSONSchemer::Format::Hostname::CONTEXT_REGEX = T.let(T.unsafe(nil), Regexp)

# \u{00DF}\u{03C2} covered by \p{Ll}
#
# source://json_schemer//lib/json_schemer/format/hostname.rb#10
JSONSchemer::Format::Hostname::EXCEPTIONS_DISALLOWED = T.let(T.unsafe(nil), String)

# https://datatracker.ietf.org/doc/html/rfc5892#section-2.6
#
# source://json_schemer//lib/json_schemer/format/hostname.rb#9
JSONSchemer::Format::Hostname::EXCEPTIONS_PVALID = T.let(T.unsafe(nil), String)

# https://datatracker.ietf.org/doc/html/rfc5892#appendix-A.4
#
# source://json_schemer//lib/json_schemer/format/hostname.rb#29
JSONSchemer::Format::Hostname::GREEK_LOWER_NUMERAL_SIGN = T.let(T.unsafe(nil), String)

# https://datatracker.ietf.org/doc/html/rfc5892#appendix-A.5
# https://datatracker.ietf.org/doc/html/rfc5892#appendix-A.6
#
# source://json_schemer//lib/json_schemer/format/hostname.rb#32
JSONSchemer::Format::Hostname::HEBREW_PUNCTUATION = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/format/hostname.rb#15
JSONSchemer::Format::Hostname::HOSTNAME_REGEX = T.let(T.unsafe(nil), Regexp)

# source://json_schemer//lib/json_schemer/format/hostname.rb#19
JSONSchemer::Format::Hostname::JOINING_TYPE_D_CHARACTER_CLASS = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/format/hostname.rb#18
JSONSchemer::Format::Hostname::JOINING_TYPE_L_CHARACTER_CLASS = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/format/hostname.rb#21
JSONSchemer::Format::Hostname::JOINING_TYPE_R_CHARACTER_CLASS = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/format/hostname.rb#20
JSONSchemer::Format::Hostname::JOINING_TYPE_T_CHARACTER_CLASS = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/format/hostname.rb#36
JSONSchemer::Format::Hostname::KATAKANA_MIDDLE_DOT_CONTEXT_REGEX = T.let(T.unsafe(nil), Regexp)

# https://datatracker.ietf.org/doc/html/rfc5892#appendix-A.7
#
# source://json_schemer//lib/json_schemer/format/hostname.rb#35
JSONSchemer::Format::Hostname::KATAKANA_MIDDLE_DOT_REGEX = T.let(T.unsafe(nil), Regexp)

# source://json_schemer//lib/json_schemer/format/hostname.rb#11
JSONSchemer::Format::Hostname::LABEL_CHARACTER_CLASS = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/format/hostname.rb#14
JSONSchemer::Format::Hostname::LABEL_REGEX_STRING = T.let(T.unsafe(nil), String)

# https://datatracker.ietf.org/doc/html/rfc5891#section-4.2.3.2
#
# source://json_schemer//lib/json_schemer/format/hostname.rb#13
JSONSchemer::Format::Hostname::LEADING_CHARACTER_CLASS = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/format/hostname.rb#7
JSONSchemer::Format::Hostname::LETTER_DIGITS = T.let(T.unsafe(nil), String)

# https://datatracker.ietf.org/doc/html/rfc5892#section-2.1
#
# source://json_schemer//lib/json_schemer/format/hostname.rb#6
JSONSchemer::Format::Hostname::MARKS = T.let(T.unsafe(nil), String)

# https://datatracker.ietf.org/doc/html/rfc5892#appendix-A.3
#
# source://json_schemer//lib/json_schemer/format/hostname.rb#27
JSONSchemer::Format::Hostname::MIDDLE_DOT = T.let(T.unsafe(nil), String)

# bin/hostname_character_classes
#
# source://json_schemer//lib/json_schemer/format/hostname.rb#17
JSONSchemer::Format::Hostname::VIRAMA_CHARACTER_CLASS = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/format/hostname.rb#25
JSONSchemer::Format::Hostname::ZERO_WIDTH_NON_JOINER_JOINING_TYPE = T.let(T.unsafe(nil), String)

# https://datatracker.ietf.org/doc/html/rfc5892#appendix-A.1
# https://datatracker.ietf.org/doc/html/rfc5892#appendix-A.2
#
# source://json_schemer//lib/json_schemer/format/hostname.rb#24
JSONSchemer::Format::Hostname::ZERO_WIDTH_VIRAMA = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/format.rb#15
JSONSchemer::Format::INVALID_QUERY_REGEX = T.let(T.unsafe(nil), Regexp)

# source://json_schemer//lib/json_schemer/format.rb#14
JSONSchemer::Format::IP_REGEX = T.let(T.unsafe(nil), Regexp)

# source://json_schemer//lib/json_schemer/format.rb#9
JSONSchemer::Format::JSON_POINTER_REGEX = T.let(T.unsafe(nil), Regexp)

# source://json_schemer//lib/json_schemer/format.rb#8
JSONSchemer::Format::JSON_POINTER_REGEX_STRING = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/format.rb#13
JSONSchemer::Format::LEAP_SECOND_REGEX = T.let(T.unsafe(nil), Regexp)

# source://json_schemer//lib/json_schemer/format.rb#10
JSONSchemer::Format::RELATIVE_JSON_POINTER_REGEX = T.let(T.unsafe(nil), Regexp)

# source://json_schemer//lib/json_schemer/format/uri_template.rb#4
module JSONSchemer::Format::URITemplate
  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/format/uri_template.rb#29
  def valid_uri_template?(data); end
end

# pct-encoded     =  "%" HEXDIG HEXDIG
#
# source://json_schemer//lib/json_schemer/format/uri_template.rb#7
JSONSchemer::Format::URITemplate::EXPLODE = T.let(T.unsafe(nil), String)

# operator        =  op-level2 / op-level3 / op-reserve
# op-level2       =  "+" / "#"
# op-level3       =  "." / "/" / ";" / "?" / "&"
# op-reserve      =  "=" / "," / "!" / "@" / "|"
#
# source://json_schemer//lib/json_schemer/format/uri_template.rb#19
JSONSchemer::Format::URITemplate::EXPRESSION = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/format/uri_template.rb#20
JSONSchemer::Format::URITemplate::LITERALS = T.let(T.unsafe(nil), String)

# explode         =  "*"
#
# source://json_schemer//lib/json_schemer/format/uri_template.rb#8
JSONSchemer::Format::URITemplate::MAX_LENGTH = T.let(T.unsafe(nil), String)

# modifier-level4 =  prefix / explode
#
# source://json_schemer//lib/json_schemer/format/uri_template.rb#10
JSONSchemer::Format::URITemplate::MODIFIER_LEVEL4 = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/format/uri_template.rb#15
JSONSchemer::Format::URITemplate::OPERATOR = T.let(T.unsafe(nil), String)

# https://datatracker.ietf.org/doc/html/rfc6570
#
# source://json_schemer//lib/json_schemer/format/uri_template.rb#6
JSONSchemer::Format::URITemplate::PCT_ENCODED = T.let(T.unsafe(nil), String)

# max-length      =  %x31-39 0*3DIGIT   ; positive integer < 10000
#
# source://json_schemer//lib/json_schemer/format/uri_template.rb#9
JSONSchemer::Format::URITemplate::PREFIX = T.let(T.unsafe(nil), String)

# literals        =  %x21 / %x23-24 / %x26 / %x28-3B / %x3D / %x3F-5B
#                 /  %x5D / %x5F / %x61-7A / %x7E / ucschar / iprivate
#                 /  pct-encoded
#                      ; any Unicode character except: CTL, SP,
#                      ;  DQUOTE, "'", "%" (aside from pct-encoded),
#                      ;  "<", ">", "\", "^", "`", "{", "|", "}"
#
# source://json_schemer//lib/json_schemer/format/uri_template.rb#26
JSONSchemer::Format::URITemplate::URI_TEMPLATE = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/format/uri_template.rb#27
JSONSchemer::Format::URITemplate::URI_TEMPLATE_REGEX = T.let(T.unsafe(nil), Regexp)

# varchar         =  ALPHA / DIGIT / "_" / pct-encoded
#
# source://json_schemer//lib/json_schemer/format/uri_template.rb#11
JSONSchemer::Format::URITemplate::VARCHAR = T.let(T.unsafe(nil), String)

# variable-list   =  varspec *( "," varspec )
#
# source://json_schemer//lib/json_schemer/format/uri_template.rb#14
JSONSchemer::Format::URITemplate::VARIABLE_LIST = T.let(T.unsafe(nil), String)

# varname         =  varchar *( ["."] varchar )
#
# source://json_schemer//lib/json_schemer/format/uri_template.rb#12
JSONSchemer::Format::URITemplate::VARNAME = T.let(T.unsafe(nil), String)

# varspec         =  varname [ modifier-level4 ]
#
# source://json_schemer//lib/json_schemer/format/uri_template.rb#13
JSONSchemer::Format::URITemplate::VARSPEC = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer.rb#37
class JSONSchemer::InvalidEcmaRegexp < ::StandardError; end

# source://json_schemer//lib/json_schemer.rb#35
class JSONSchemer::InvalidFileURI < ::StandardError; end

# source://json_schemer//lib/json_schemer.rb#33
class JSONSchemer::InvalidRefResolution < ::StandardError; end

# source://json_schemer//lib/json_schemer.rb#34
class JSONSchemer::InvalidRegexpResolution < ::StandardError; end

# source://json_schemer//lib/json_schemer.rb#36
class JSONSchemer::InvalidSymbolKey < ::StandardError; end

# source://json_schemer//lib/json_schemer.rb#40
JSONSchemer::SCHEMA_CLASS_BY_META_SCHEMA = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/schema/base.rb#3
module JSONSchemer::Schema; end

# source://json_schemer//lib/json_schemer/schema/base.rb#4
class JSONSchemer::Schema::Base
  include ::JSONSchemer::Format::Email
  include ::JSONSchemer::Format::Hostname
  include ::JSONSchemer::Format::URITemplate
  include ::JSONSchemer::Format

  # @raise [InvalidSymbolKey]
  # @return [Base] a new instance of Base
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#51
  def initialize(schema, base_uri: T.unsafe(nil), format: T.unsafe(nil), insert_property_defaults: T.unsafe(nil), before_property_validation: T.unsafe(nil), after_property_validation: T.unsafe(nil), formats: T.unsafe(nil), keywords: T.unsafe(nil), ref_resolver: T.unsafe(nil), regexp_resolver: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#83
  def valid?(data); end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#91
  def valid_schema?; end

  # source://json_schemer//lib/json_schemer/schema/base.rb#87
  def validate(data); end

  # source://json_schemer//lib/json_schemer/schema/base.rb#95
  def validate_schema; end

  protected

  # source://json_schemer//lib/json_schemer/schema/base.rb#234
  def ids; end

  # Returns the value of attribute root.
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#101
  def root; end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#103
  def valid_instance?(instance); end

  # @yield [error(instance, 'enum')]
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#107
  def validate_instance(instance, &block); end

  private

  # source://json_schemer//lib/json_schemer/schema/base.rb#258
  def child(schema, base_uri:); end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#250
  def custom_format?(format); end

  # source://json_schemer//lib/json_schemer/schema/base.rb#271
  def error(instance, type, details = T.unsafe(nil)); end

  # source://json_schemer//lib/json_schemer/schema/base.rb#626
  def escape_json_pointer_token(token); end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#246
  def format?; end

  # Returns the value of attribute formats.
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#240
  def formats; end

  # source://json_schemer//lib/json_schemer/schema/base.rb#242
  def id_keyword; end

  # source://json_schemer//lib/json_schemer/schema/base.rb#630
  def join_uri(a, b); end

  # Returns the value of attribute keywords.
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#240
  def keywords; end

  # Returns the value of attribute ref_resolver.
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#240
  def ref_resolver; end

  # Returns the value of attribute regexp_resolver.
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#240
  def regexp_resolver; end

  # source://json_schemer//lib/json_schemer/schema/base.rb#645
  def resolve_ids(schema, ids = T.unsafe(nil), base_uri = T.unsafe(nil), pointer = T.unsafe(nil)); end

  # source://json_schemer//lib/json_schemer/schema/base.rb#668
  def resolve_ref(uri); end

  # source://json_schemer//lib/json_schemer/schema/base.rb#672
  def resolve_regexp(pattern); end

  # source://json_schemer//lib/json_schemer/schema/base.rb#620
  def safe_strict_decode64(data); end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#254
  def spec_format?(format); end

  # @yield [error(instance, 'maxItems')]
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#452
  def validate_array(instance, &block); end

  # source://json_schemer//lib/json_schemer/schema/base.rb#284
  def validate_class(instance, &block); end

  # @yield [error(instance, 'format')]
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#353
  def validate_custom_format(instance, custom_format); end

  # @yield [error(instance, 'exclusiveMaximum')]
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#357
  def validate_exclusive_maximum(instance, exclusive_maximum, maximum); end

  # @yield [error(instance, 'exclusiveMinimum')]
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#361
  def validate_exclusive_minimum(instance, exclusive_minimum, minimum); end

  # source://json_schemer//lib/json_schemer/schema/base.rb#395
  def validate_integer(instance, &block); end

  # source://json_schemer//lib/json_schemer/schema/base.rb#386
  def validate_number(instance, &block); end

  # @yield [error(instance, 'maximum')]
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#365
  def validate_numeric(instance, &block); end

  # @yield [error(instance, 'maxProperties')]
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#509
  def validate_object(instance, &block); end

  # source://json_schemer//lib/json_schemer/schema/base.rb#318
  def validate_ref(instance, ref, &block); end

  # @yield [error(instance, 'maxLength')]
  #
  # source://json_schemer//lib/json_schemer/schema/base.rb#406
  def validate_string(instance, &block); end

  # source://json_schemer//lib/json_schemer/schema/base.rb#299
  def validate_type(instance, type, &block); end

  class << self
    # source://json_schemer//lib/json_schemer/schema/base.rb#38
    def draft_name; end

    # source://json_schemer//lib/json_schemer/schema/base.rb#42
    def meta_schema; end

    # source://json_schemer//lib/json_schemer/schema/base.rb#46
    def meta_schemer; end
  end
end

# source://json_schemer//lib/json_schemer/schema/base.rb#26
JSONSchemer::Schema::Base::BOOLEANS = T.let(T.unsafe(nil), Set)

# source://json_schemer//lib/json_schemer/schema/base.rb#22
JSONSchemer::Schema::Base::DEFAULT_REF_RESOLVER = T.let(T.unsafe(nil), Proc)

# source://json_schemer//lib/json_schemer/schema/base.rb#25
JSONSchemer::Schema::Base::ECMA_REGEXP_RESOLVER = T.let(T.unsafe(nil), Proc)

# source://json_schemer//lib/json_schemer/schema/base.rb#21
JSONSchemer::Schema::Base::ID_KEYWORD = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/schema/base.rb#28
JSONSchemer::Schema::Base::INSERT_DEFAULT_PROPERTY = T.let(T.unsafe(nil), Proc)

# source://json_schemer//lib/json_schemer/schema/base.rb#7
class JSONSchemer::Schema::Base::Instance < ::Struct
  # Returns the value of attribute after_property_validation
  #
  # @return [Object] the current value of after_property_validation
  def after_property_validation; end

  # Sets the attribute after_property_validation
  #
  # @param value [Object] the value to set the attribute after_property_validation to.
  # @return [Object] the newly set value
  def after_property_validation=(_); end

  # Returns the value of attribute base_uri
  #
  # @return [Object] the current value of base_uri
  def base_uri; end

  # Sets the attribute base_uri
  #
  # @param value [Object] the value to set the attribute base_uri to.
  # @return [Object] the newly set value
  def base_uri=(_); end

  # Returns the value of attribute before_property_validation
  #
  # @return [Object] the current value of before_property_validation
  def before_property_validation; end

  # Sets the attribute before_property_validation
  #
  # @param value [Object] the value to set the attribute before_property_validation to.
  # @return [Object] the newly set value
  def before_property_validation=(_); end

  # Returns the value of attribute data
  #
  # @return [Object] the current value of data
  def data; end

  # Sets the attribute data
  #
  # @param value [Object] the value to set the attribute data to.
  # @return [Object] the newly set value
  def data=(_); end

  # Returns the value of attribute data_pointer
  #
  # @return [Object] the current value of data_pointer
  def data_pointer; end

  # Sets the attribute data_pointer
  #
  # @param value [Object] the value to set the attribute data_pointer to.
  # @return [Object] the newly set value
  def data_pointer=(_); end

  # source://json_schemer//lib/json_schemer/schema/base.rb#8
  def merge(data: T.unsafe(nil), data_pointer: T.unsafe(nil), schema: T.unsafe(nil), schema_pointer: T.unsafe(nil), base_uri: T.unsafe(nil), before_property_validation: T.unsafe(nil), after_property_validation: T.unsafe(nil)); end

  # Returns the value of attribute schema
  #
  # @return [Object] the current value of schema
  def schema; end

  # Sets the attribute schema
  #
  # @param value [Object] the value to set the attribute schema to.
  # @return [Object] the newly set value
  def schema=(_); end

  # Returns the value of attribute schema_pointer
  #
  # @return [Object] the current value of schema_pointer
  def schema_pointer; end

  # Sets the attribute schema_pointer
  #
  # @param value [Object] the value to set the attribute schema_pointer to.
  # @return [Object] the newly set value
  def schema_pointer=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://json_schemer//lib/json_schemer/schema/base.rb#34
JSONSchemer::Schema::Base::JSON_POINTER_TOKEN_ESCAPE_CHARS = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/schema/base.rb#35
JSONSchemer::Schema::Base::JSON_POINTER_TOKEN_ESCAPE_REGEX = T.let(T.unsafe(nil), Regexp)

# source://json_schemer//lib/json_schemer/schema/base.rb#23
JSONSchemer::Schema::Base::NET_HTTP_REF_RESOLVER = T.let(T.unsafe(nil), Proc)

# source://json_schemer//lib/json_schemer/schema/base.rb#24
JSONSchemer::Schema::Base::RUBY_REGEXP_RESOLVER = T.let(T.unsafe(nil), Proc)

# source://json_schemer//lib/json_schemer/schema/draft4.rb#4
class JSONSchemer::Schema::Draft4 < ::JSONSchemer::Schema::Base
  private

  # source://json_schemer//lib/json_schemer/schema/draft4.rb#18
  def id_keyword; end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/schema/draft4.rb#22
  def supported_format?(format); end

  # @yield [error(instance, 'exclusiveMaximum')]
  #
  # source://json_schemer//lib/json_schemer/schema/draft4.rb#26
  def validate_exclusive_maximum(instance, exclusive_maximum, maximum); end

  # @yield [error(instance, 'exclusiveMinimum')]
  #
  # source://json_schemer//lib/json_schemer/schema/draft4.rb#30
  def validate_exclusive_minimum(instance, exclusive_minimum, minimum); end

  # source://json_schemer//lib/json_schemer/schema/draft4.rb#34
  def validate_integer(instance, &block); end
end

# source://json_schemer//lib/json_schemer/schema/draft4.rb#5
JSONSchemer::Schema::Draft4::ID_KEYWORD = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/schema/draft4.rb#6
JSONSchemer::Schema::Draft4::SUPPORTED_FORMATS = T.let(T.unsafe(nil), Set)

# source://json_schemer//lib/json_schemer/schema/draft6.rb#4
class JSONSchemer::Schema::Draft6 < ::JSONSchemer::Schema::Base
  private

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/schema/draft6.rb#20
  def supported_format?(format); end
end

# source://json_schemer//lib/json_schemer/schema/draft6.rb#5
JSONSchemer::Schema::Draft6::SUPPORTED_FORMATS = T.let(T.unsafe(nil), Set)

# source://json_schemer//lib/json_schemer/schema/draft7.rb#4
class JSONSchemer::Schema::Draft7 < ::JSONSchemer::Schema::Base
  private

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/schema/draft7.rb#27
  def supported_format?(format); end
end

# source://json_schemer//lib/json_schemer/schema/draft7.rb#5
JSONSchemer::Schema::Draft7::SUPPORTED_FORMATS = T.let(T.unsafe(nil), Set)

# source://json_schemer//lib/json_schemer.rb#32
class JSONSchemer::UnknownFormat < ::StandardError; end

# source://json_schemer//lib/json_schemer.rb#31
class JSONSchemer::UnknownRef < ::StandardError; end

# source://json_schemer//lib/json_schemer.rb#30
class JSONSchemer::UnsupportedMetaSchema < ::StandardError; end

# source://json_schemer//lib/json_schemer/version.rb#3
JSONSchemer::VERSION = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer.rb#47
JSONSchemer::WINDOWS_URI_PATH_REGEX = T.let(T.unsafe(nil), Regexp)
