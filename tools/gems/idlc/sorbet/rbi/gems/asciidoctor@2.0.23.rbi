# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `asciidoctor` gem.
# Please instead update this file by running `bin/tapioca gem asciidoctor`.


# source://asciidoctor//lib/asciidoctor/core_ext/nil_or_empty.rb#14
class Array
  include ::Enumerable
end

# Public: The main application interface (API) for Asciidoctor. This API provides methods to parse AsciiDoc content and
# convert it to various output formats using built-in or third-party converters or Tilt-supported templates.
#
# An AsciiDoc document can be as simple as a single line of content, though it more commonly starts with a document
# header that declares the document title and document attribute definitions. The document header is then followed by
# zero or more section titles, optionally nested, to organize the paragraphs, blocks, lists, etc. of the document.
#
# By default, the processor converts the AsciiDoc document to HTML 5 using a built-in converter. However, this behavior
# can be changed by specifying a different backend (e.g., +docbook+). A backend is a keyword for an output format (e.g.,
# DocBook). That keyword, in turn, is used to select a converter, which carries out the request to convert the document
# to that format.
#
# In addition to this API, Asciidoctor also provides a command-line interface (CLI) named +asciidoctor+ for converting
# AsciiDoc content. See the provided man(ual) page for usage and options.
#
# Examples
#
#   # Convert an AsciiDoc file
#   Asciidoctor.convert_file 'document.adoc', safe: :safe
#
#   # Convert an AsciiDoc string
#   puts Asciidoctor.convert "I'm using *Asciidoctor* version {asciidoctor-version}.", safe: :safe
#
#   # Convert an AsciiDoc file using Tilt-supported templates
#   Asciidoctor.convert_file 'document.adoc', safe: :safe, template_dir: '/path/to/templates'
#
#   # Parse an AsciiDoc file into a document object
#   doc = Asciidoctor.load_file 'document.adoc', safe: :safe
#
#   # Parse an AsciiDoc string into a document object
#   doc = Asciidoctor.load "= Document Title\n\nfirst paragraph\n\nsecond paragraph", safe: :safe
#
# source://asciidoctor//lib/asciidoctor.rb#48
module Asciidoctor
  class << self
    # Internal: Automatically load the Asciidoctor::Extensions module.
    #
    # Requires the Asciidoctor::Extensions module if the name is :Extensions.
    # Otherwise, delegates to the super method.
    #
    # This method provides the same functionality as using autoload on
    # Asciidoctor::Extensions, except that the constant isn't recognized as
    # defined prior to it being loaded.
    #
    # Returns the resolved constant, if resolved, otherwise nothing.
    #
    # source://asciidoctor//lib/asciidoctor.rb#529
    def const_missing(name); end

    # Public: Parse the AsciiDoc source input into an Asciidoctor::Document and
    # convert it to the specified backend format.
    #
    # Accepts input as an IO (or StringIO), String or String Array object. If the
    # input is a File, the object is expected to be opened for reading and is not
    # closed afterwards by this method. Information about the file (filename,
    # directory name, etc) gets assigned to attributes on the Document object.
    #
    # If the :to_file option is true, and the input is a File, the output is
    # written to a file adjacent to the input file, having an extension that
    # corresponds to the backend format. Otherwise, if the :to_file option is
    # specified, the file is written to that file. If :to_file is not an absolute
    # path, it is resolved relative to :to_dir, if given, otherwise the
    # Document#base_dir. If the target directory does not exist, it will not be
    # created unless the :mkdirs option is set to true. If the file cannot be
    # written because the target directory does not exist, or because it falls
    # outside of the Document#base_dir in safe mode, an IOError is raised.
    #
    # If the output is going to be written to a file, the header and footer are
    # included unless specified otherwise (writing to a file implies creating a
    # standalone document). Otherwise, the header and footer are not included by
    # default and the converted result is returned.
    #
    # input   - the String AsciiDoc source filename
    # options - a String, Array or Hash of options to control processing (default: {})
    #           String and Array values are converted into a Hash.
    #           See Asciidoctor::Document#initialize for details about options.
    #
    # Returns the Document object if the converted String is written to a
    # file, otherwise the converted String
    #
    # source://asciidoctor//lib/asciidoctor/convert.rb#34
    def convert(input, options = T.unsafe(nil)); end

    # Public: Parse the contents of the AsciiDoc source file into an
    # Asciidoctor::Document and convert it to the specified backend format.
    #
    # input   - the String AsciiDoc source filename
    # options - a String, Array or Hash of options to control processing (default: {})
    #           String and Array values are converted into a Hash.
    #           See Asciidoctor::Document#initialize for details about options.
    #
    # Returns the Document object if the converted String is written to a
    # file, otherwise the converted String
    #
    # source://asciidoctor//lib/asciidoctor/convert.rb#189
    def convert_file(filename, options = T.unsafe(nil)); end

    # Public: Parse the AsciiDoc source input into a {Document}
    #
    # Accepts input as an IO (or StringIO), String or String Array object. If the
    # input is a File, the object is expected to be opened for reading and is not
    # closed afterwards by this method. Information about the file (filename,
    # directory name, etc) gets assigned to attributes on the Document object.
    #
    # input   - the AsciiDoc source as a IO, String or Array.
    # options - a String, Array or Hash of options to control processing (default: {})
    #           String and Array values are converted into a Hash.
    #           See {Document#initialize} for details about these options.
    #
    # Returns the Document
    #
    # source://asciidoctor//lib/asciidoctor/load.rb#17
    def load(input, options = T.unsafe(nil)); end

    # Public: Parse the contents of the AsciiDoc source file into an Asciidoctor::Document
    #
    # input   - the String AsciiDoc source filename
    # options - a String, Array or Hash of options to control processing (default: {})
    #           String and Array values are converted into a Hash.
    #           See Asciidoctor::Document#initialize for details about options.
    #
    # Returns the Asciidoctor::Document
    #
    # source://asciidoctor//lib/asciidoctor/load.rb#115
    def load_file(filename, options = T.unsafe(nil)); end

    # Public: Parse the AsciiDoc source input into an Asciidoctor::Document and
    # convert it to the specified backend format.
    #
    # Accepts input as an IO (or StringIO), String or String Array object. If the
    # input is a File, the object is expected to be opened for reading and is not
    # closed afterwards by this method. Information about the file (filename,
    # directory name, etc) gets assigned to attributes on the Document object.
    #
    # If the :to_file option is true, and the input is a File, the output is
    # written to a file adjacent to the input file, having an extension that
    # corresponds to the backend format. Otherwise, if the :to_file option is
    # specified, the file is written to that file. If :to_file is not an absolute
    # path, it is resolved relative to :to_dir, if given, otherwise the
    # Document#base_dir. If the target directory does not exist, it will not be
    # created unless the :mkdirs option is set to true. If the file cannot be
    # written because the target directory does not exist, or because it falls
    # outside of the Document#base_dir in safe mode, an IOError is raised.
    #
    # If the output is going to be written to a file, the header and footer are
    # included unless specified otherwise (writing to a file implies creating a
    # standalone document). Otherwise, the header and footer are not included by
    # default and the converted result is returned.
    #
    # input   - the String AsciiDoc source filename
    # options - a String, Array or Hash of options to control processing (default: {})
    #           String and Array values are converted into a Hash.
    #           See Asciidoctor::Document#initialize for details about options.
    #
    # Returns the Document object if the converted String is written to a
    # file, otherwise the converted String
    # Deprecated: Use {Asciidoctor.convert} instead.
    #
    # source://asciidoctor//lib/asciidoctor/convert.rb#34
    def render(input, options = T.unsafe(nil)); end

    # Public: Parse the contents of the AsciiDoc source file into an
    # Asciidoctor::Document and convert it to the specified backend format.
    #
    # input   - the String AsciiDoc source filename
    # options - a String, Array or Hash of options to control processing (default: {})
    #           String and Array values are converted into a Hash.
    #           See Asciidoctor::Document#initialize for details about options.
    #
    # Returns the Document object if the converted String is written to a
    # file, otherwise the converted String
    # Deprecated: Use {Asciidoctor.convert_file} instead.
    #
    # source://asciidoctor//lib/asciidoctor/convert.rb#189
    def render_file(filename, options = T.unsafe(nil)); end
  end
end

# source://asciidoctor//lib/asciidoctor.rb#270
Asciidoctor::ADMONITION_STYLES = T.let(T.unsafe(nil), Set)

# source://asciidoctor//lib/asciidoctor.rb#272
Asciidoctor::ADMONITION_STYLE_HEADS = T.let(T.unsafe(nil), Set)

# A map of file extensions that are recognized as AsciiDoc documents
# TODO .txt should be deprecated
#
# source://asciidoctor//lib/asciidoctor.rb#253
Asciidoctor::ASCIIDOC_EXTENSIONS = T.let(T.unsafe(nil), Hash)

# source://asciidoctor//lib/asciidoctor.rb#330
Asciidoctor::ATTR_REF_HEAD = T.let(T.unsafe(nil), String)

# source://asciidoctor//lib/asciidoctor/abstract_block.rb#3
class Asciidoctor::AbstractBlock < ::Asciidoctor::AbstractNode
  # @return [AbstractBlock] a new instance of AbstractBlock
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#36
  def initialize(parent, context, opts = T.unsafe(nil)); end

  # Public: Append a content block to this block's list of blocks.
  #
  # block - The new child block.
  #
  # Examples
  #
  #   block = Block.new(parent, :preamble, content_model: :compound)
  #
  #   block << Block.new(block, :paragraph, source: 'p1')
  #   block << Block.new(block, :paragraph, source: 'p2')
  #   block.blocks?
  #   # => true
  #   block.blocks.size
  #   # => 2
  #
  # Returns The parent Block
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#115
  def <<(block); end

  # Public: Returns the converted alt text for this block image.
  #
  # Returns the [String] value of the alt attribute with XML special character
  # and replacement substitutions applied.
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#226
  def alt; end

  # Public: Append a content block to this block's list of blocks.
  #
  # block - The new child block.
  #
  # Examples
  #
  #   block = Block.new(parent, :preamble, content_model: :compound)
  #
  #   block << Block.new(block, :paragraph, source: 'p1')
  #   block << Block.new(block, :paragraph, source: 'p2')
  #   block.blocks?
  #   # => true
  #   block.blocks.size
  #   # => 2
  #
  # Returns The parent Block
  # NOTE append alias required for adapting to a Java API
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#115
  def append(block); end

  # Public: Generate and assign caption to block if not already assigned.
  #
  # If the block has a title and a caption prefix is available for this block,
  # then build a caption from this information, assign it a number and store it
  # to the caption attribute on the block.
  #
  # If a caption has already been assigned to this block, do nothing.
  #
  # The parts of a complete caption are: <prefix> <number>. <title>
  # This partial caption represents the part the precedes the title.
  #
  # value           - The String caption to assign to this block or nil to use document attribute.
  # caption_context - The Symbol context to use when resolving caption-related attributes. If not provided, the name of
  #                   the context for this block is used. Only certain contexts allow the caption to be looked up.
  #                   (default: @context)
  #
  # Returns nothing.
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#389
  def assign_caption(value, caption_context = T.unsafe(nil)); end

  # Internal: Assign the next index (0-based) and numeral (1-based) to the section.
  # If the section is an appendix, the numeral is a letter (starting with A). This
  # method also assigns the appendix caption.
  #
  # section - The section to which to assign the next index and numeral.
  #
  # Assign to the specified section the next index and, if the section is
  # numbered, the numeral within this block (its parent).
  #
  # Returns nothing
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#408
  def assign_numeral(section); end

  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#52
  def block?; end

  # Public: Get the Array of {AbstractBlock} child blocks for this block. Only applies if content model is :compound.
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#5
  def blocks; end

  # Public: Determine whether this Block contains block content
  #
  # Returns A Boolean indicating whether this Block has block content
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#127
  def blocks?; end

  # Gets the caption for this block.
  #
  # This method routes the deprecated use of the caption method on an
  # admonition block to the textlabel attribute.
  #
  # Returns the [String] caption for this block (or the value of the textlabel
  # attribute if this is an admonition block).
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#246
  def caption; end

  # Public: Set the caption for this block.
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#8
  def caption=(_arg0); end

  # Public: Convenience method that returns the interpreted title of the Block
  # with the caption prepended.
  #
  # Concatenates the value of this Block's caption instance variable and the
  # return value of this Block's title method. No space is added between the
  # two values. If the Block does not have a caption, the interpreted title is
  # returned.
  #
  # Returns the converted String title prefixed with the caption, or just the
  # converted String title if no caption is set
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#260
  def captioned_title; end

  # Public: Get the converted result of the child blocks by converting the
  # children appropriate to content model that this block supports.
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#84
  def content; end

  # Public: Describes the type of content this block accepts and how it should be converted. Acceptable values are:
  # * :compound - this block contains other blocks
  # * :simple - this block holds a paragraph of prose that receives normal substitutions
  # * :verbatim - this block holds verbatim text (displayed "as is") that receives verbatim substitutions
  # * :raw - this block holds unprocessed content passed directly to the output with no substitutions applied
  # * :empty - this block has no content
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#16
  def content_model; end

  # Public: Describes the type of content this block accepts and how it should be converted. Acceptable values are:
  # * :compound - this block contains other blocks
  # * :simple - this block holds a paragraph of prose that receives normal substitutions
  # * :verbatim - this block holds verbatim text (displayed "as is") that receives verbatim substitutions
  # * :raw - this block holds unprocessed content passed directly to the output with no substitutions applied
  # * :empty - this block has no content
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#16
  def content_model=(_arg0); end

  # Public: Update the context of this block.
  #
  # This method changes the context of this block. It also updates the node name accordingly.
  #
  # context - the context Symbol context to assign to this block
  #
  # Returns the specified Symbol context
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#95
  def context=(context); end

  # Public: Get the converted String content for this Block.  If the block
  # has child blocks, the content method should cause them to be
  # converted and returned as content that can be included in the
  # parent block's template.
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#74
  def convert; end

  # Public: Get the source file where this block started
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#61
  def file; end

  # Public: Walk the document tree and find all block-level nodes that match the specified selector (context, style, id,
  # role, and/or custom filter).
  #
  # If a Ruby block is given, it's applied as a supplemental filter. If the filter returns true (which implies :accept),
  # the node is accepted and node traversal continues. If the filter returns false (which implies :skip), the node is
  # skipped, but its children are still visited. If the filter returns :reject, the node and all its descendants are
  # rejected. If the filter returns :prune, the node is accepted, but its descendants are rejected. If no selector
  # or filter block is supplied, all block-level nodes in the tree are returned.
  #
  # Examples
  #
  #   doc.find_by context: :section
  #   #=> Asciidoctor::Section@14459860 { level: 0, title: "Hello, AsciiDoc!", blocks: 0 }
  #   #=> Asciidoctor::Section@14505460 { level: 1, title: "First Section", blocks: 1 }
  #
  #   doc.find_by(context: :section) {|section| section.level == 1 }
  #   #=> Asciidoctor::Section@14505460 { level: 1, title: "First Section", blocks: 1 }
  #
  #   doc.find_by context: :listing, style: 'source'
  #   #=> Asciidoctor::Block@13136720 { context: :listing, content_model: :verbatim, style: "source", lines: 1 }
  #
  # Returns An Array of block-level nodes that match the filter or an empty Array if no matches are found
  # --
  # TODO support jQuery-style selector (e.g., image.thumb)
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#176
  def find_by(selector = T.unsafe(nil), &block); end

  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#56
  def inline?; end

  # Public: Set the Integer level of this {Section} or the level of the Section to which this {AbstractBlock} belongs.
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#19
  def level; end

  # Public: Set the Integer level of this {Section} or the level of the Section to which this {AbstractBlock} belongs.
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#19
  def level=(_arg0); end

  # Public: Get the source line number where this block started
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#66
  def lineno; end

  # Public: Retrieve the list marker keyword for the specified list type.
  #
  # For use in the HTML type attribute.
  #
  # list_type - the type of list; default to the @style if not specified
  #
  # Returns the single-character [String] keyword that represents the marker for the specified list type
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#271
  def list_marker_keyword(list_type = T.unsafe(nil)); end

  # Move to the next adjacent block in document order. If the current block is the last
  # item in a list, this method will return the following sibling of the list block.
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#186
  def next_adjacent_block; end

  # Deprecated: Legacy property to get the String or Integer numeral of this section.
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#143
  def number; end

  # Deprecated: Legacy property to set the numeral of this section by coercing the value to a String.
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#148
  def number=(val); end

  # Public: Get/Set the String numeral of this block (if section, relative to parent, otherwise absolute).
  # Only assigned to section if automatic section numbering is enabled.
  # Only assigned to formal block (block with title) if corresponding caption attribute is present.
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#24
  def numeral; end

  # Public: Get/Set the String numeral of this block (if section, relative to parent, otherwise absolute).
  # Only assigned to section if automatic section numbering is enabled.
  # Only assigned to formal block (block with title) if corresponding caption attribute is present.
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#24
  def numeral=(_arg0); end

  # Public: Walk the document tree and find all block-level nodes that match the specified selector (context, style, id,
  # role, and/or custom filter).
  #
  # If a Ruby block is given, it's applied as a supplemental filter. If the filter returns true (which implies :accept),
  # the node is accepted and node traversal continues. If the filter returns false (which implies :skip), the node is
  # skipped, but its children are still visited. If the filter returns :reject, the node and all its descendants are
  # rejected. If the filter returns :prune, the node is accepted, but its descendants are rejected. If no selector
  # or filter block is supplied, all block-level nodes in the tree are returned.
  #
  # Examples
  #
  #   doc.find_by context: :section
  #   #=> Asciidoctor::Section@14459860 { level: 0, title: "Hello, AsciiDoc!", blocks: 0 }
  #   #=> Asciidoctor::Section@14505460 { level: 1, title: "First Section", blocks: 1 }
  #
  #   doc.find_by(context: :section) {|section| section.level == 1 }
  #   #=> Asciidoctor::Section@14505460 { level: 1, title: "First Section", blocks: 1 }
  #
  #   doc.find_by context: :listing, style: 'source'
  #   #=> Asciidoctor::Block@13136720 { context: :listing, content_model: :verbatim, style: "source", lines: 1 }
  #
  # Returns An Array of block-level nodes that match the filter or an empty Array if no matches are found
  # --
  # TODO support jQuery-style selector (e.g., image.thumb)
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#176
  def query(selector = T.unsafe(nil), &block); end

  # Internal: Reassign the section indexes
  #
  # Walk the descendents of the current Document or Section
  # and reassign the section 0-based index value to each Section
  # as it appears in document order.
  #
  # IMPORTANT You must invoke this method on a node after removing
  # child sections or else the internal counters will be off.
  #
  # Returns nothing
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#435
  def reindex_sections; end

  # Public: Remove a substitution from this block
  #
  # sub  - The Symbol substitution name
  #
  # Returns nothing
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#324
  def remove_sub(sub); end

  # Public: Get the converted String content for this Block.  If the block
  # has child blocks, the content method should cause them to be
  # converted and returned as content that can be included in the
  # parent block's template.
  # Deprecated: Use {AbstractBlock#convert} instead.
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#74
  def render; end

  # Public: Get the Array of child Section objects
  #
  # Only applies to Document and Section instances
  #
  # Examples
  #
  #   doc << (sect1 = Section.new doc, 1)
  #   sect1.title = 'Section 1'
  #   para1 = Block.new sect1, :paragraph, source: 'Paragraph 1'
  #   para2 = Block.new sect1, :paragraph, source: 'Paragraph 2'
  #   sect1 << para1 << para2
  #   sect1 << (sect1_1 = Section.new sect1, 2)
  #   sect1_1.title = 'Section 1.1'
  #   sect1_1 << (Block.new sect1_1, :paragraph, source: 'Paragraph 3')
  #   sect1.blocks?
  #   # => true
  #   sect1.blocks.size
  #   # => 3
  #   sect1.sections.size
  #   # => 1
  #
  # Returns an [Array] of Section objects
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#218
  def sections; end

  # Public: Check whether this block has any child Section objects.
  #
  # Acts an an abstract method that always returns false unless this block is an
  # instance of Document or Section.
  # Both Document and Section provide overrides for this method.
  #
  # Returns false
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#138
  def sections?; end

  # Public: Gets/Sets the location in the AsciiDoc source where this block begins.
  # Tracking source location is not enabled by default, and is controlled by the sourcemap option.
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#28
  def source_location; end

  # Public: Gets/Sets the location in the AsciiDoc source where this block begins.
  # Tracking source location is not enabled by default, and is controlled by the sourcemap option.
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#28
  def source_location=(_arg0); end

  # Public: Get/Set the String style (block type qualifier) for this block.
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#31
  def style; end

  # Public: Get/Set the String style (block type qualifier) for this block.
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#31
  def style=(_arg0); end

  # Public: A convenience method that checks whether the specified
  # substitution is enabled for this block.
  #
  # name - The Symbol substitution name
  #
  # Returns A Boolean indicating whether the specified substitution is
  # enabled for this block
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#315
  def sub?(name); end

  # Public: Substitutions to be applied to content in this block.
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#34
  def subs; end

  # Public: Get the String title of this Block with title substitutions applied
  #
  # The following substitutions are applied to block and section titles:
  #
  # :specialcharacters, :quotes, :replacements, :macros, :attributes and :post_replacements
  #
  # Examples
  #
  #   block.title = "Foo 3^ # {two-colons} Bar(1)"
  #   block.title
  #   => "Foo 3^ # :: Bar(1)"
  #
  # Returns the converted String title for this Block, or nil if the source title is falsy
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#288
  def title; end

  # Public: Set the String block title.
  #
  # Returns the specified String title
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#303
  def title=(val); end

  # Public: A convenience method that checks whether the title of this block is defined.
  #
  # Returns a [Boolean] indicating whether this block has a title.
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#296
  def title?; end

  # Public: Generate cross reference text (xreftext) that can be used to refer
  # to this block.
  #
  # Use the explicit reftext for this block, if specified, retrieved from the
  # {#reftext} method. Otherwise, if this is a section or captioned block (a
  # block with both a title and caption), generate the xreftext according to
  # the value of the xrefstyle argument (e.g., full, short). This logic may
  # leverage the {Substitutors#sub_quotes} method to apply formatting to the
  # text. If this is not a captioned block, return the title, if present, or
  # nil otherwise.
  #
  # xrefstyle - An optional String that specifies the style to use to format
  #             the xreftext ('full', 'short', or 'basic') (default: nil).
  #
  # Returns the generated [String] xreftext used to refer to this block or
  # nothing if there isn't sufficient information to generate one.
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#345
  def xreftext(xrefstyle = T.unsafe(nil)); end

  protected

  # Internal: Performs the work for find_by, but does not handle the StopIteration exception.
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#449
  def find_by_internal(selector = T.unsafe(nil), result = T.unsafe(nil), &block); end
end

# all content segments in an AsciiDoc document.
#
# source://asciidoctor//lib/asciidoctor/abstract_node.rb#6
class Asciidoctor::AbstractNode
  include ::Asciidoctor::Logging
  include ::Asciidoctor::Substitutors
  extend ::Asciidoctor::Logging

  # @return [AbstractNode] a new instance of AbstractNode
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#28
  def initialize(parent, context, opts = T.unsafe(nil)); end

  # Public: Adds the given role directly to this node.
  #
  # Returns a [Boolean] indicating whether the role was added.
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#232
  def add_role(name); end

  # Public: Get the value of the specified attribute. If the attribute is not found on this node, fallback_name is set,
  # and this node is not the Document node, get the value of the specified attribute from the Document node.
  #
  # Look for the specified attribute in the attributes on this node and return the value of the attribute, if found.
  # Otherwise, if fallback_name is set (default: same as name) and this node is not the Document node, look for that
  # attribute on the Document node and return its value, if found. Otherwise, return the default value (default: nil).
  #
  # name          - The String or Symbol name of the attribute to resolve.
  # default_value - The Object value to return if the attribute is not found (default: nil).
  # fallback_name - The String or Symbol of the attribute to resolve on the Document if the attribute is not found on
  #                 this node (default: same as name).
  #
  # Returns the [Object] value (typically a String) of the attribute or default_value if the attribute is not found.
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#87
  def attr(name, default_value = T.unsafe(nil), fallback_name = T.unsafe(nil)); end

  # Public: Check if the specified attribute is defined using the same logic as {#attr}, optionally performing a
  # comparison with the expected value if specified.
  #
  # Look for the specified attribute in the attributes on this node. If not found, fallback_name is specified (default:
  # same as name), and this node is not the Document node, look for that attribute on the Document node. In either case,
  # if the attribute is found, and the comparison value is truthy, return whether the two values match. Otherwise,
  # return whether the attribute was found.
  #
  # name           - The String or Symbol name of the attribute to resolve.
  # expected_value - The expected Object value of the attribute (default: nil).
  # fallback_name  - The String or Symbol of the attribute to resolve on the Document if the attribute is not found on
  #                  this node (default: same as name).
  #
  # Returns a [Boolean] indicating whether the attribute exists and, if a truthy comparison value is specified, whether
  # the value of the attribute matches the comparison value.
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#106
  def attr?(name, expected_value = T.unsafe(nil), fallback_name = T.unsafe(nil)); end

  # Public: Get the Hash of attributes for this node
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#11
  def attributes; end

  # Public: Returns whether this {AbstractNode} is an instance of {Block}
  #
  # Returns [Boolean]
  #
  # @raise [::NotImplementedError]
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#44
  def block?; end

  # Public: Get the Symbol context for this node
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#14
  def context; end

  # Public: Get the Asciidoctor::Converter instance being used to convert the
  # current Asciidoctor::Document.
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#61
  def converter; end

  # Public: Get the Asciidoctor::Document to which this node belongs
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#17
  def document; end

  # Public: Retrieve the Set of option names that are enabled on this node
  #
  # Returns a [Set] of option names
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#168
  def enabled_options; end

  # Public: Generate a data URI that can be used to embed an image in the output document
  #
  # First, and foremost, the target image path is cleaned if the document safe mode level
  # is set to at least SafeMode::SAFE (a condition which is true by default) to prevent access
  # to ancestor paths in the filesystem. The image data is then read and converted to base64.
  # Finally, a data URI is built which can be used in an image tag.
  #
  # target_image - A String path to the target image
  # asset_dir_key - The String attribute key used to lookup the directory where
  #                the image is located (default: nil)
  #
  # Returns A String data URI containing the content of the target image
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#365
  def generate_data_uri(target_image, asset_dir_key = T.unsafe(nil)); end

  # Public: Read the image data from the specified URI and generate a data URI
  #
  # The image data is read from the URI and converted to Base64. A data URI is
  # constructed from the content_type header and Base64 data and returned,
  # which can then be used in an image tag.
  #
  # image_uri  - The URI from which to read the image data. Can be http://, https:// or ftp://
  # cache_uri  - A Boolean to control caching. When true, the open-uri-cached library
  #              is used to cache the image for subsequent reads. (default: false)
  #
  # Returns A data URI string built from Base64 encoded data read from the URI
  # and the mime type specified in the Content Type header.
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#401
  def generate_data_uri_from_uri(image_uri, cache_uri = T.unsafe(nil)); end

  # Public: Checks if the specified role is present in the list of roles for this node.
  #
  # name - The String name of the role to find.
  #
  # Returns a [Boolean] indicating whether this node has the specified role.
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#215
  def has_role?(name); end

  # Public: Construct a reference or data URI to an icon image for the
  # specified icon name.
  #
  # If the 'icon' attribute is set on this block, the name is ignored and the
  # value of this attribute is used as the target image path. Otherwise,
  # construct a target image path by concatenating the value of the 'iconsdir'
  # attribute, the icon name, and the value of the 'icontype' attribute
  # (defaulting to 'png').
  #
  # The target image path is then passed through the #image_uri() method. If
  # the 'data-uri' attribute is set on the document, the image will be
  # safely converted to a data URI.
  #
  # The return value of this method can be safely used in an image tag.
  #
  # name - The String name of the icon
  #
  # Returns A String reference or data URI for an icon image
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#291
  def icon_uri(name); end

  # Public: Get/Set the String id of this node
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#20
  def id; end

  # Public: Get/Set the String id of this node
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#20
  def id=(_arg0); end

  # Public: Construct a URI reference or data URI to the target image.
  #
  # If the target image is a URI reference, then leave it untouched.
  #
  # The target image is resolved relative to the directory retrieved from the
  # specified attribute key, if provided.
  #
  # If the 'data-uri' attribute is set on the document, and the safe mode level
  # is less than SafeMode::SECURE, the image will be safely converted to a data URI
  # by reading it from the same directory. If neither of these conditions
  # are satisfied, a relative path (i.e., URL) will be returned.
  #
  # The return value of this method can be safely used in an image tag.
  #
  # target_image - A String path to the target image
  # asset_dir_key - The String attribute key used to lookup the directory where
  #                the image is located (default: 'imagesdir')
  #
  # Returns A String reference or data URI for the target image
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#321
  def image_uri(target_image, asset_dir_key = T.unsafe(nil)); end

  # Public: Returns whether this {AbstractNode} is an instance of {Inline}
  #
  # Returns [Boolean]
  #
  # @raise [::NotImplementedError]
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#53
  def inline?; end

  # Deprecated: Check whether the specified String is a URI by
  # matching it against the Asciidoctor::UriSniffRx regex.
  #
  # In use by Asciidoctor PDF
  #
  # @deprecated Use Helpers.uriish? instead
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#563
  def is_uri?(str); end

  # Public: Construct a URI reference to the target media.
  #
  # If the target media is a URI reference, then leave it untouched.
  #
  # The target media is resolved relative to the directory retrieved from the
  # specified attribute key, if provided.
  #
  # The return value can be safely used in a media tag (img, audio, video).
  #
  # target        - A String reference to the target media
  # asset_dir_key - The String attribute key used to lookup the directory where
  #                 the media is located (default: 'imagesdir')
  #
  # Returns A String reference for the target media
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#349
  def media_uri(target, asset_dir_key = T.unsafe(nil)); end

  # Public: Get the String name of this node
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#23
  def node_name; end

  # Public: Normalize the asset file or directory to a concrete and rinsed path
  #
  # Delegates to normalize_system_path, with the start path set to the value of
  # the base_dir instance variable on the Document object.
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#429
  def normalize_asset_path(asset_ref, asset_name = T.unsafe(nil), autocorrect = T.unsafe(nil)); end

  # Public: Resolve and normalize a secure path from the target and start paths
  # using the PathResolver.
  #
  # See {PathResolver#system_path} for details.
  #
  # The most important functionality in this method is to prevent resolving a
  # path outside of the jail (which defaults to the directory of the source
  # file, stored in the base_dir instance variable on Document) if the document
  # safe level is set to SafeMode::SAFE or greater (a condition which is true
  # by default).
  #
  # target - the String target path
  # start  - the String start (i.e., parent) path
  # jail   - the String jail path to confine the resolved path
  # opts   - an optional Hash of options to control processing (default: {}):
  #          * :recover is used to control whether the processor should
  #            automatically recover when an illegal path is encountered
  #          * :target_name is used in messages to refer to the path being resolved
  #
  # raises a SecurityError if a jail is specified and the resolved path is
  # outside the jail.
  #
  # Returns the [String] path resolved from the start and target paths, with any
  # parent references resolved and self references removed. If a jail is provided,
  # this path will be guaranteed to be contained within the jail.
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#458
  def normalize_system_path(target, start = T.unsafe(nil), jail = T.unsafe(nil), opts = T.unsafe(nil)); end

  # Public: Normalize the web path using the PathResolver.
  #
  # See {PathResolver#web_path} for details about path resolution and encoding.
  #
  # target              - the String target path
  # start               - the String start (i.e, parent) path (optional, default: nil)
  # preserve_uri_target - a Boolean indicating whether target should be preserved if contains a URI (default: true)
  #
  # Returns the resolved [String] path
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#481
  def normalize_web_path(target, start = T.unsafe(nil), preserve_uri_target = T.unsafe(nil)); end

  # Public: A convenience method to check if the specified option attribute is
  # enabled on the current node.
  #
  # Check if the option is enabled. This method simply checks to see if the
  # <name>-option attribute is defined on the current node.
  #
  # name    - the String or Symbol name of the option
  #
  # return a Boolean indicating whether the option has been specified
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#149
  def option?(name); end

  # Public: Get the AbstractBlock parent element of this node
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#26
  def parent; end

  # Public: Associate this Block with a new parent Block
  #
  # parent - The Block to set as the parent of this Block
  #
  # Returns the the specified Block parent
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#70
  def parent=(parent); end

  # Public: Read the contents of the file at the specified path.
  # This method assumes that the path is safe to read. It checks
  # that the file is readable before attempting to read it.
  #
  # path - the String path from which to read the contents
  # opts - a Hash of options to control processing (default: {})
  #        * :warn_on_failure a Boolean that controls whether a warning
  #          is issued if the file cannot be read (default: false)
  #        * :normalize a Boolean that controls whether the lines
  #          are normalized and coerced to UTF-8 (default: false)
  #
  # Returns the [String] content of the file at the specified path, or nil
  # if the file does not exist.
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#502
  def read_asset(path, opts = T.unsafe(nil)); end

  # Public: Resolve the URI or system path to the specified target, then read and return its contents
  #
  # The URI or system path of the target is first resolved. If the resolved path is a URI, read the
  # contents from the URI if the allow-uri-read attribute is set, enabling caching if the cache-uri
  # attribute is also set. If the resolved path is not a URI, read the contents of the file from the
  # file system. If the normalize option is set, the data will be normalized.
  #
  # target - The URI or local path from which to read the data.
  # opts   - a Hash of options to control processing (default: {})
  #          * :label the String label of the target to use in warning messages (default: 'asset')
  #          * :normalize a Boolean that indicates whether the data should be normalized (default: false)
  #          * :start the String relative base path to use when resolving the target (default: nil)
  #          * :warn_on_failure a Boolean that indicates whether warnings are issued if the target cannot be read (default: true)
  #          * :warn_if_empty a Boolean that indicates whether a warning is issued if contents of target is empty (default: false)
  # Returns the contents of the resolved target or nil if the resolved target cannot be read
  # --
  # TODO refactor other methods in this class to use this method were possible (repurposing if necessary)
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#531
  def read_contents(target, opts = T.unsafe(nil)); end

  # Public: A convenience method that returns the value of the reftext attribute with substitutions applied.
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#264
  def reftext; end

  # Public: A convenience method that checks if the reftext attribute is defined.
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#269
  def reftext?; end

  # Public: Remove the attribute from the current node.
  #
  # name      - The String attribute name to remove
  #
  # Returns the previous [String] value, or nil if the attribute was not present.
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#136
  def remove_attr(name); end

  # Public: Removes the given role directly from this node.
  #
  # Returns a [Boolean] indicating whether the role was removed.
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#250
  def remove_role(name); end

  # Public: Retrieves the space-separated String role for this node.
  #
  # Returns the role as a space-separated [String].
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#188
  def role; end

  # Public: Sets the value of the role attribute on this node.
  #
  # names - A single role name, a space-separated String of role names, or an Array of role names
  #
  # Returns the specified String role name or Array of role names
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#225
  def role=(names); end

  # Public: Checks if the role attribute is set on this node and, if an expected value is given, whether the
  # space-separated role matches that value.
  #
  # expected_value - The expected String value of the role (optional, default: nil)
  #
  # Returns a [Boolean] indicating whether the role attribute is set on this node and, if an expected value is given,
  # whether the space-separated role matches that value.
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#206
  def role?(expected_value = T.unsafe(nil)); end

  # Public: Retrieves the String role names for this node as an Array.
  #
  # Returns the role names as a String [Array], which is empty if the role attribute is absent on this node.
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#195
  def roles; end

  # Public: Assign the value to the attribute name for the current node.
  #
  # name      - The String attribute name to assign
  # value     - The Object value to assign to the attribute (default: '')
  # overwrite - A Boolean indicating whether to assign the attribute
  #             if currently present in the attributes Hash (default: true)
  #
  # Returns a [Boolean] indicating whether the assignment was performed
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#122
  def set_attr(name, value = T.unsafe(nil), overwrite = T.unsafe(nil)); end

  # Public: Set the specified option on this node.
  #
  # This method sets the specified option on this node by setting the <name>-option attribute.
  #
  # name - the String name of the option
  #
  # Returns nothing
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#160
  def set_option(name); end

  # Public: Update the attributes of this node with the new values in
  # the attributes argument.
  #
  # If an attribute already exists with the same key, it's value will
  # be overwritten.
  #
  # new_attributes - A Hash of additional attributes to assign to this node.
  #
  # Returns the updated attributes [Hash] on this node.
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#181
  def update_attributes(new_attributes); end
end

# Matches an admonition label at the start of a paragraph.
#
# Examples
#
#   NOTE: Just a little note.
#   TIP: Don't forget!
#
# source://asciidoctor//lib/asciidoctor/rx.rb#201
Asciidoctor::AdmonitionParagraphRx = T.let(T.unsafe(nil), Regexp)

# Detects the start of any list item.
#
# NOTE we only have to check as far as the blank character because we know it means non-whitespace follows.
# IMPORTANT if this regexp does not agree with the regexp for each list type, the parser will hang.
#
# source://asciidoctor//lib/asciidoctor/rx.rb#274
Asciidoctor::AnyListRx = T.let(T.unsafe(nil), Regexp)

# NOTE In JavaScript, ^ and $ match the boundaries of the string when the m flag is not set
#
# source://asciidoctor//lib/asciidoctor/rx.rb#141
Asciidoctor::AttributeEntryPassMacroRx = T.let(T.unsafe(nil), Regexp)

# Matches a document attribute entry.
#
# Examples
#
#   :foo: bar
#   :First Name: Dan
#   :sectnums!:
#   :!toc:
#   :long-entry: Attribute value lines ending in ' \' \
#                are joined together as a single value, \
#                collapsing the line breaks and indentation to \
#                a single space.
#
# source://asciidoctor//lib/asciidoctor/rx.rb#124
Asciidoctor::AttributeEntryRx = T.let(T.unsafe(nil), Regexp)

# => { 'style' => 'quote', 'attribution' => 'Famous Person', 'citetitle' => 'Famous Book (2001)' }
#
# source://asciidoctor//lib/asciidoctor/attribute_list.rb#24
class Asciidoctor::AttributeList
  # @return [AttributeList] a new instance of AttributeList
  #
  # source://asciidoctor//lib/asciidoctor/attribute_list.rb#53
  def initialize(source, block = T.unsafe(nil), delimiter = T.unsafe(nil)); end

  # source://asciidoctor//lib/asciidoctor/attribute_list.rb#66
  def parse(positional_attrs = T.unsafe(nil)); end

  # source://asciidoctor//lib/asciidoctor/attribute_list.rb#62
  def parse_into(attributes, positional_attrs = T.unsafe(nil)); end

  # source://asciidoctor//lib/asciidoctor/attribute_list.rb#82
  def rekey(positional_attrs); end

  private

  # source://asciidoctor//lib/asciidoctor/attribute_list.rb#98
  def parse_attribute(index, positional_attrs); end

  # source://asciidoctor//lib/asciidoctor/attribute_list.rb#186
  def parse_attribute_value(quote); end

  # source://asciidoctor//lib/asciidoctor/attribute_list.rb#208
  def scan_name; end

  # source://asciidoctor//lib/asciidoctor/attribute_list.rb#212
  def scan_to_delimiter; end

  # source://asciidoctor//lib/asciidoctor/attribute_list.rb#216
  def scan_to_quote(quote); end

  # source://asciidoctor//lib/asciidoctor/attribute_list.rb#200
  def skip_blank; end

  # source://asciidoctor//lib/asciidoctor/attribute_list.rb#204
  def skip_delimiter; end

  class << self
    # source://asciidoctor//lib/asciidoctor/attribute_list.rb#86
    def rekey(attributes, positional_attrs); end
  end
end

# source://asciidoctor//lib/asciidoctor/attribute_list.rb#25
Asciidoctor::AttributeList::APOS = T.let(T.unsafe(nil), String)

# source://asciidoctor//lib/asciidoctor/attribute_list.rb#26
Asciidoctor::AttributeList::BACKSLASH = T.let(T.unsafe(nil), String)

# source://asciidoctor//lib/asciidoctor/attribute_list.rb#46
Asciidoctor::AttributeList::BlankRx = T.let(T.unsafe(nil), Regexp)

# Public: Regular expressions for detecting the boundary of a value
#
# source://asciidoctor//lib/asciidoctor/attribute_list.rb#30
Asciidoctor::AttributeList::BoundaryRx = T.let(T.unsafe(nil), Hash)

# Public: Regular expressions for unescaping quoted characters
#
# source://asciidoctor//lib/asciidoctor/attribute_list.rb#37
Asciidoctor::AttributeList::EscapedQuotes = T.let(T.unsafe(nil), Hash)

# Public: A regular expression for an attribute name (approx. name token from XML)
# TODO named attributes cannot contain dash characters
#
# source://asciidoctor//lib/asciidoctor/attribute_list.rb#44
Asciidoctor::AttributeList::NameRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor//lib/asciidoctor/attribute_list.rb#27
Asciidoctor::AttributeList::QUOT = T.let(T.unsafe(nil), String)

# Public: Regular expressions for skipping delimiters
#
# source://asciidoctor//lib/asciidoctor/attribute_list.rb#49
Asciidoctor::AttributeList::SkipRx = T.let(T.unsafe(nil), Hash)

# Matches an inline attribute reference.
#
# Examples
#
#   {foobar} or {app_name} or {product-version}
#   {counter:sequence-name:1}
#   {set:foo:bar}
#   {set:name!}
#
# source://asciidoctor//lib/asciidoctor/rx.rb#153
Asciidoctor::AttributeReferenceRx = T.let(T.unsafe(nil), Regexp)

# Matches an Atx (single-line) section title.
#
# Examples
#
#   == Foo
#   // ^ a level 1 (h2) section title
#
#   == Foo ==
#   // ^ also a level 1 (h2) section title
#
# source://asciidoctor//lib/asciidoctor/rx.rb#241
Asciidoctor::AtxSectionTitleRx = T.let(T.unsafe(nil), Regexp)

# Matches the delimiter that separates multiple authors.
#
# Examples
#
#   Doc Writer; Junior Writer
#
# source://asciidoctor//lib/asciidoctor/rx.rb#30
Asciidoctor::AuthorDelimiterRx = T.let(T.unsafe(nil), Regexp)

# Matches the author info line immediately following the document title.
#
# Examples
#
#   Doc Writer <doc@example.com>
#   Mary_Sue Bront
#
# source://asciidoctor//lib/asciidoctor/rx.rb#22
Asciidoctor::AuthorInfoLineRx = T.let(T.unsafe(nil), Regexp)

# Pointers to the preferred version for a given backend.
#
# source://asciidoctor//lib/asciidoctor.rb#231
Asciidoctor::BACKEND_ALIASES = T.let(T.unsafe(nil), Hash)

# source://asciidoctor//lib/asciidoctor.rb#341
Asciidoctor::BLOCK_MATH_DELIMITERS = T.let(T.unsafe(nil), Hash)

# source://asciidoctor//lib/asciidoctor.rb#208
Asciidoctor::BOM_BYTES_UTF_16BE = T.let(T.unsafe(nil), Array)

# source://asciidoctor//lib/asciidoctor.rb#207
Asciidoctor::BOM_BYTES_UTF_16LE = T.let(T.unsafe(nil), Array)

# Byte arrays for UTF-* Byte Order Marks
#
# source://asciidoctor//lib/asciidoctor.rb#206
Asciidoctor::BOM_BYTES_UTF_8 = T.let(T.unsafe(nil), Array)

# Matches consecutive blank lines.
#
# Examples
#
#   one
#
#   two
#
# source://asciidoctor//lib/asciidoctor/rx.rb#662
Asciidoctor::BlankLineRx = T.let(T.unsafe(nil), Regexp)

# => "<em>This</em> is a &lt;test&gt;"
#
# source://asciidoctor//lib/asciidoctor/block.rb#10
class Asciidoctor::Block < ::Asciidoctor::AbstractBlock
  # Public: Initialize an Asciidoctor::Block object.
  #
  # parent        - The parent AbstractBlock with a compound content model to which this Block will be appended.
  # context       - The Symbol context name for the type of content (e.g., :paragraph).
  # opts          - a Hash of options to customize block initialization: (default: {})
  #                 * :content_model indicates whether blocks can be nested in this Block (:compound), otherwise
  #                     how the lines should be processed (:simple, :verbatim, :raw, :empty). (default: :simple)
  #                 * :attributes a Hash of attributes (key/value pairs) to assign to this Block. (default: {})
  #                 * :source a String or Array of raw source for this Block. (default: nil)
  #
  # IMPORTANT: If you don't specify the `:subs` option, you must explicitly call
  # the `commit_subs` method to resolve and assign the substitutions to this
  # block (which are resolved from the `subs` attribute, if specified, or the
  # default substitutions based on this block's context). If you want to use the
  # default subs for a block, pass the option `subs: :default`. You can
  # override the default subs using the `:default_subs` option.
  # --
  # QUESTION should we store source_data as lines for blocks that have compound content models?
  #
  # @return [Block] a new instance of Block
  #
  # source://asciidoctor//lib/asciidoctor/block.rb#50
  def initialize(parent, context, opts = T.unsafe(nil)); end

  # Public: Create alias for context to be consistent w/ AsciiDoc
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#14
  def blockname; end

  # Public: Get the converted result of the child blocks by converting the
  # children appropriate to content model that this block supports.
  #
  # Examples
  #
  #   doc = Asciidoctor::Document.new
  #   block = Asciidoctor::Block.new(doc, :paragraph,
  #       source: '_This_ is what happens when you <meet> a stranger in the <alps>!')
  #   block.content
  #   => "<em>This</em> is what happens when you &lt;meet&gt; a stranger in the &lt;alps&gt;!"
  #
  # source://asciidoctor//lib/asciidoctor/block.rb#108
  def content; end

  # Public: Get/Set the original Array content for this block, if applicable
  #
  # source://asciidoctor//lib/asciidoctor/block.rb#30
  def lines; end

  # Public: Get/Set the original Array content for this block, if applicable
  #
  # source://asciidoctor//lib/asciidoctor/block.rb#30
  def lines=(_arg0); end

  # Public: Returns the preprocessed source of this block
  #
  # Returns the a String containing the lines joined together or empty string
  # if there are no lines
  #
  # source://asciidoctor//lib/asciidoctor/block.rb#135
  def source; end

  # source://asciidoctor//lib/asciidoctor/block.rb#139
  def to_s; end
end

# source://asciidoctor//lib/asciidoctor/block.rb#12
Asciidoctor::Block::DEFAULT_CONTENT_MODEL = T.let(T.unsafe(nil), Hash)

# Matches an anchor (i.e., id + optional reference text) on a line above a block.
#
# Examples
#
#   [[idname]]
#   [[idname,Reference Text]]
#
# source://asciidoctor//lib/asciidoctor/rx.rb#164
Asciidoctor::BlockAnchorRx = T.let(T.unsafe(nil), Regexp)

# A combined pattern that matches either a block anchor or a block attribute list.
#
# TODO this one gets hit a lot, should be optimized as much as possible
#
# source://asciidoctor//lib/asciidoctor/rx.rb#184
Asciidoctor::BlockAttributeLineRx = T.let(T.unsafe(nil), Regexp)

# Matches an attribute list above a block element.
#
# Examples
#
#   # strictly positional
#   [quote, Adam Smith, Wealth of Nations]
#
#   # name/value pairs
#   [NOTE, caption="Good to know"]
#
#   # as attribute reference
#   [{lead}]
#
# source://asciidoctor//lib/asciidoctor/rx.rb#179
Asciidoctor::BlockAttributeListRx = T.let(T.unsafe(nil), Regexp)

# Matches an image, video or audio block macro.
#
# Examples
#
#   image::filename.png[Caption]
#   video::http://youtube.com/12345[Cats vs Dogs]
#
# source://asciidoctor//lib/asciidoctor/rx.rb#421
Asciidoctor::BlockMediaMacroRx = T.let(T.unsafe(nil), Regexp)

# Matches a title above a block.
#
# Examples
#
#   .Title goes here
#
# source://asciidoctor//lib/asciidoctor/rx.rb#192
Asciidoctor::BlockTitleRx = T.let(T.unsafe(nil), Regexp)

# Matches the TOC block macro.
#
# Examples
#
#   toc::[]
#   toc::[levels=2]
#
# source://asciidoctor//lib/asciidoctor/rx.rb#430
Asciidoctor::BlockTocMacroRx = T.let(T.unsafe(nil), Regexp)

# NOTE the 'figure' key as a string is historical and used by image blocks
#
# source://asciidoctor//lib/asciidoctor.rb#298
Asciidoctor::CAPTION_ATTRIBUTE_NAMES = T.let(T.unsafe(nil), Hash)

# CC_ALL is any character, including newlines (must be accompanied by multiline regexp flag)
#
# source://asciidoctor//lib/asciidoctor.rb#429
Asciidoctor::CC_ALL = T.let(T.unsafe(nil), String)

# source://asciidoctor//lib/asciidoctor.rb#434
Asciidoctor::CC_ALNUM = T.let(T.unsafe(nil), String)

# source://asciidoctor//lib/asciidoctor.rb#433
Asciidoctor::CC_ALPHA = T.let(T.unsafe(nil), String)

# CC_ANY is any character except newlines
#
# source://asciidoctor//lib/asciidoctor.rb#431
Asciidoctor::CC_ANY = T.let(T.unsafe(nil), String)

# source://asciidoctor//lib/asciidoctor.rb#432
Asciidoctor::CC_EOL = T.let(T.unsafe(nil), String)

# source://asciidoctor//lib/asciidoctor.rb#436
Asciidoctor::CC_WORD = T.let(T.unsafe(nil), String)

# source://asciidoctor//lib/asciidoctor.rb#434
Asciidoctor::CG_ALNUM = T.let(T.unsafe(nil), String)

# source://asciidoctor//lib/asciidoctor.rb#433
Asciidoctor::CG_ALPHA = T.let(T.unsafe(nil), String)

# source://asciidoctor//lib/asciidoctor.rb#435
Asciidoctor::CG_BLANK = T.let(T.unsafe(nil), String)

# source://asciidoctor//lib/asciidoctor.rb#436
Asciidoctor::CG_WORD = T.let(T.unsafe(nil), String)

# Matches a callout reference inside literal text.
#
# Examples
#   <1> (optionally prefixed by //, #, -- or ;; line comment chars)
#   <1> <2> (multiple callouts on one line)
#   <!--1--> (for XML-based languages)
#   <.> (auto-numbered)
#
# NOTE extract regexps are applied line-by-line, so we can use $ as end-of-line char
#
# source://asciidoctor//lib/asciidoctor/rx.rb#369
Asciidoctor::CalloutExtractRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor//lib/asciidoctor/rx.rb#371
Asciidoctor::CalloutExtractRxMap = T.let(T.unsafe(nil), Hash)

# source://asciidoctor//lib/asciidoctor/rx.rb#370
Asciidoctor::CalloutExtractRxt = T.let(T.unsafe(nil), String)

# Matches a callout list item.
#
# Examples
#
#   <1> Explanation
#
# or
#
#   <.> Explanation with automatic number
#
# NOTE we know trailing (.*) will match at least one character because we strip trailing spaces
#
# source://asciidoctor//lib/asciidoctor/rx.rb#358
Asciidoctor::CalloutListRx = T.let(T.unsafe(nil), Regexp)

# NOTE special characters have not been replaced when scanning
#
# source://asciidoctor//lib/asciidoctor/rx.rb#373
Asciidoctor::CalloutScanRx = T.let(T.unsafe(nil), Regexp)

# NOTE special characters have already been replaced when converting to an SGML format
#
# source://asciidoctor//lib/asciidoctor/rx.rb#375
Asciidoctor::CalloutSourceRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor//lib/asciidoctor/rx.rb#377
Asciidoctor::CalloutSourceRxMap = T.let(T.unsafe(nil), Hash)

# source://asciidoctor//lib/asciidoctor/rx.rb#376
Asciidoctor::CalloutSourceRxt = T.let(T.unsafe(nil), String)

# Public: Maintains a catalog of callouts and their associations.
#
# source://asciidoctor//lib/asciidoctor/callouts.rb#4
class Asciidoctor::Callouts
  # @return [Callouts] a new instance of Callouts
  #
  # source://asciidoctor//lib/asciidoctor/callouts.rb#5
  def initialize; end

  # Public: Get a space-separated list of callout ids for the specified list item
  #
  # li_ordinal - the Integer ordinal (1-based) of the list item for which to
  #              retrieve the callouts
  #
  # Returns A space-separated String of callout ids associated with the specified list item
  #
  # source://asciidoctor//lib/asciidoctor/callouts.rb#61
  def callout_ids(li_ordinal); end

  # Public: The current list for which callouts are being collected
  #
  # Returns The Array of callouts at the position of the list index pointer
  #
  # source://asciidoctor//lib/asciidoctor/callouts.rb#68
  def current_list; end

  # Public: Advance to the next callout list in the document
  #
  # Returns nothing
  #
  # source://asciidoctor//lib/asciidoctor/callouts.rb#75
  def next_list; end

  # Public: Get the next callout index in the document
  #
  # Reads the next callout index in the document and advances the pointer.
  # This method is used during conversion to retrieve the unique id of the
  # callout that was generated during parsing.
  #
  # Returns The unique String id of the next callout in the document
  #
  # source://asciidoctor//lib/asciidoctor/callouts.rb#43
  def read_next_id; end

  # Public: Register a new callout for the given list item ordinal.
  #
  # Generates a unique id for this callout based on the index of the next callout
  # list in the document and the index of this callout since the end of the last
  # callout list.
  #
  # li_ordinal - the Integer ordinal (1-based) of the list item to which this
  #              callout is to be associated
  #
  # Examples
  #
  #  callouts = Asciidoctor::Callouts.new
  #  callouts.register(1)
  #  # => "CO1-1"
  #  callouts.next_list
  #  callouts.register(2)
  #  # => "CO2-1"
  #
  # Returns The unique String id of this callout
  #
  # source://asciidoctor//lib/asciidoctor/callouts.rb#30
  def register(li_ordinal); end

  # Public: Rewind the list index pointer, intended to be used when switching
  # from the parsing to conversion phase.
  #
  # Returns nothing
  #
  # source://asciidoctor//lib/asciidoctor/callouts.rb#90
  def rewind; end

  private

  # Internal: Generate a unique id for the callout at the specified position
  #
  # list_index - The 1-based Integer index of the callout list within the document
  # co_index   - The 1-based Integer index of the callout since the end of the last callout list
  #
  # Returns A unique String id for a callout
  #
  # source://asciidoctor//lib/asciidoctor/callouts.rb#111
  def generate_callout_id(list_index, co_index); end

  # Internal: Generate a unique id for the callout based on the internal indexes
  #
  # Returns A unique String id for this callout
  #
  # source://asciidoctor//lib/asciidoctor/callouts.rb#101
  def generate_next_callout_id; end
end

# source://asciidoctor//lib/asciidoctor/rx.rb#400
Asciidoctor::CellSpecEndRx = T.let(T.unsafe(nil), Regexp)

# Parses the start and end of a cell spec (i.e., cellspec) for a table.
#
# Examples
#
#   2.3+<.>m
#
# FIXME use step-wise scan (or treetop) rather than this mega-regexp
#
# source://asciidoctor//lib/asciidoctor/rx.rb#399
Asciidoctor::CellSpecStartRx = T.let(T.unsafe(nil), Regexp)

# Parses the column spec (i.e., colspec) for a table.
#
# Examples
#
#   1*h,2*,^3e
#
# source://asciidoctor//lib/asciidoctor/rx.rb#390
Asciidoctor::ColumnSpecRx = T.let(T.unsafe(nil), Regexp)

# Flags to control compliance with the behavior of AsciiDoc
#
# source://asciidoctor//lib/asciidoctor.rb#106
module Asciidoctor::Compliance
  class << self
    # source://asciidoctor//lib/asciidoctor.rb#114
    def attribute_missing; end

    # source://asciidoctor//lib/asciidoctor.rb#114
    def attribute_missing=(_arg0); end

    # source://asciidoctor//lib/asciidoctor.rb#114
    def attribute_undefined; end

    # source://asciidoctor//lib/asciidoctor.rb#114
    def attribute_undefined=(_arg0); end

    # source://asciidoctor//lib/asciidoctor.rb#114
    def block_terminates_paragraph; end

    # source://asciidoctor//lib/asciidoctor.rb#114
    def block_terminates_paragraph=(_arg0); end

    # Defines a new compliance key and assigns an initial value.
    #
    # source://asciidoctor//lib/asciidoctor.rb#112
    def define(key, value); end

    # Returns the value of attribute keys.
    #
    # source://asciidoctor//lib/asciidoctor.rb#109
    def keys; end

    # source://asciidoctor//lib/asciidoctor.rb#114
    def markdown_syntax; end

    # source://asciidoctor//lib/asciidoctor.rb#114
    def markdown_syntax=(_arg0); end

    # source://asciidoctor//lib/asciidoctor.rb#114
    def natural_xrefs; end

    # source://asciidoctor//lib/asciidoctor.rb#114
    def natural_xrefs=(_arg0); end

    # source://asciidoctor//lib/asciidoctor.rb#114
    def shorthand_property_syntax; end

    # source://asciidoctor//lib/asciidoctor.rb#114
    def shorthand_property_syntax=(_arg0); end

    # source://asciidoctor//lib/asciidoctor.rb#114
    def strict_verbatim_paragraphs; end

    # source://asciidoctor//lib/asciidoctor.rb#114
    def strict_verbatim_paragraphs=(_arg0); end

    # source://asciidoctor//lib/asciidoctor.rb#114
    def underline_style_section_titles; end

    # source://asciidoctor//lib/asciidoctor.rb#114
    def underline_style_section_titles=(_arg0); end

    # source://asciidoctor//lib/asciidoctor.rb#114
    def unique_id_start_index; end

    # source://asciidoctor//lib/asciidoctor.rb#114
    def unique_id_start_index=(_arg0); end

    # source://asciidoctor//lib/asciidoctor.rb#114
    def unwrap_standalone_preamble; end

    # source://asciidoctor//lib/asciidoctor.rb#114
    def unwrap_standalone_preamble=(_arg0); end
  end
end

# Matches a conditional preprocessor directive (e.g., ifdef, ifndef, ifeval and endif).
#
# Examples
#
#   ifdef::basebackend-html[]
#   ifndef::theme[]
#   ifeval::["{asciidoctor-version}" >= "0.1.0"]
#   ifdef::asciidoctor[Asciidoctor!]
#   endif::theme[]
#   endif::basebackend-html[]
#   endif::[]
#
# source://asciidoctor//lib/asciidoctor/rx.rb#75
Asciidoctor::ConditionalDirectiveRx = T.let(T.unsafe(nil), Regexp)

# puts Asciidoctor.convert_file 'sample.adoc', safe: :safe
#
# source://asciidoctor//lib/asciidoctor/converter.rb#43
module Asciidoctor::Converter
  extend ::Asciidoctor::Converter::Factory
  extend ::Asciidoctor::Converter::DefaultFactory
  include ::Asciidoctor::Converter::BackendTraits

  mixes_in_class_methods ::Asciidoctor::Converter::Config

  # Public: Creates a new instance of this {Converter}.
  #
  # backend - The String backend name (aka format) to which this converter converts.
  # opts    - An options Hash (optional, default: {})
  #
  # Returns a new [Converter] instance.
  #
  # source://asciidoctor//lib/asciidoctor/converter.rb#56
  def initialize(backend, opts = T.unsafe(nil)); end

  # Public: The String backend name that this converter is handling.
  #
  # source://asciidoctor//lib/asciidoctor/converter.rb#48
  def backend; end

  # Public: Converts an {AbstractNode} using the given transform.
  #
  # This method must be implemented by a concrete converter class.
  #
  # node      - The concrete instance of AbstractNode to convert.
  # transform - An optional String transform that hints at which transformation should be applied to this node. If a
  #             transform is not given, the transform is often derived from the value of the {AbstractNode#node_name}
  #             property. (optional, default: nil)
  # opts      - An optional Hash of options hints about how to convert the node. (optional, default: nil)
  #
  # Returns the [String] result.
  #
  # @raise [::NotImplementedError]
  #
  # source://asciidoctor//lib/asciidoctor/converter.rb#71
  def convert(node, transform = T.unsafe(nil), opts = T.unsafe(nil)); end

  # Public: Reports whether the current converter is able to convert this node (by its transform name). Used by the
  # {CompositeConverter} to select which converter to use to handle a given node. Returns true by default.
  #
  # transform - the String name of the node transformation (typically the node name).
  #
  # Returns a [Boolean] indicating whether this converter can handle the specified transform.
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/converter.rb#81
  def handles?(transform); end

  class << self
    # Public: Derive backend traits (basebackend, filetype, outfilesuffix, htmlsyntax) from the given backend.
    #
    # backend - the String backend from which to derive the traits
    # basebackend - the String basebackend to use in favor of deriving one from the backend (optional, default: nil)
    #
    # Returns the backend traits for the given backend as a [Hash].
    #
    # source://asciidoctor//lib/asciidoctor/converter.rb#91
    def derive_backend_traits(backend, basebackend = T.unsafe(nil)); end

    private

    # Internal: Mixes the {Config} module into any class that includes the {Converter} module. Additionally, mixes the
    # {BackendTraits} method into instances of this class.
    #
    # into - The Class into which the {Converter} module is being included.
    #
    # Returns nothing.
    #
    # source://asciidoctor//lib/asciidoctor/converter.rb#369
    def included(into); end
  end
end

# source://asciidoctor//lib/asciidoctor/converter.rb#103
module Asciidoctor::Converter::BackendTraits
  # source://asciidoctor//lib/asciidoctor/converter.rb#132
  def backend_info(basebackend = T.unsafe(nil)); end

  # source://asciidoctor//lib/asciidoctor/converter.rb#132
  def backend_traits(basebackend = T.unsafe(nil)); end

  # source://asciidoctor//lib/asciidoctor/converter.rb#104
  def basebackend(value = T.unsafe(nil)); end

  # source://asciidoctor//lib/asciidoctor/converter.rb#108
  def filetype(value = T.unsafe(nil)); end

  # source://asciidoctor//lib/asciidoctor/converter.rb#112
  def htmlsyntax(value = T.unsafe(nil)); end

  # source://asciidoctor//lib/asciidoctor/converter.rb#128
  def init_backend_traits(value = T.unsafe(nil)); end

  # source://asciidoctor//lib/asciidoctor/converter.rb#116
  def outfilesuffix(value = T.unsafe(nil)); end

  # source://asciidoctor//lib/asciidoctor/converter.rb#120
  def supports_templates(value = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/converter.rb#124
  def supports_templates?; end

  class << self
    # Deprecated: Use {Converter.derive_backend_traits} instead.
    #
    # source://asciidoctor//lib/asciidoctor/converter.rb#139
    def derive_backend_traits(backend, basebackend = T.unsafe(nil)); end
  end
end

# An abstract base class for defining converters that can be used to convert {AbstractNode} objects in a parsed
# AsciiDoc document to a backend format such as HTML or DocBook.
#
# source://asciidoctor//lib/asciidoctor/converter.rb#377
class Asciidoctor::Converter::Base
  include ::Asciidoctor::Logging
  include ::Asciidoctor::Converter
  include ::Asciidoctor::Converter::BackendTraits
  extend ::Asciidoctor::Logging
  extend ::Asciidoctor::Converter::Config

  # Public: Converts the {AbstractNode} using only its converted content.
  #
  # Returns the converted [String] content.
  #
  # source://asciidoctor//lib/asciidoctor/converter.rb#405
  def content_only(node); end

  # Public: Converts an {AbstractNode} by delegating to a method that matches the transform value.
  #
  # This method looks for a method whose name matches the transform prefixed with "convert_" to dispatch to. If the
  # +opts+ argument is non-nil, this method assumes the dispatch method accepts two arguments, the node and an options
  # Hash. The options Hash may be used by converters to delegate back to the top-level converter. Currently, this
  # feature is used for the outline transform. If the +opts+ argument is nil, this method assumes the dispatch method
  # accepts the node as its only argument.
  #
  # See {Converter#convert} for details about the arguments and return value.
  #
  # source://asciidoctor//lib/asciidoctor/converter.rb#390
  def convert(node, transform = T.unsafe(nil), opts = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/converter.rb#398
  def handles?(transform); end

  # Public: Skips conversion of the {AbstractNode}.
  #
  # Returns nothing.
  #
  # source://asciidoctor//lib/asciidoctor/converter.rb#412
  def skip(node); end
end

# source://asciidoctor//lib/asciidoctor/converter/composite.rb#6
class Asciidoctor::Converter::CompositeConverter < ::Asciidoctor::Converter::Base
  # source://asciidoctor//lib/asciidoctor/converter/composite.rb#10
  def initialize(backend, *converters, backend_traits_source: T.unsafe(nil)); end

  # source://asciidoctor//lib/asciidoctor/converter/composite.rb#27
  def convert(node, transform = T.unsafe(nil), opts = T.unsafe(nil)); end

  # source://asciidoctor//lib/asciidoctor/converter/composite.rb#34
  def converter_for(transform); end

  # source://asciidoctor//lib/asciidoctor/converter/composite.rb#8
  def converters; end

  # source://asciidoctor//lib/asciidoctor/converter/composite.rb#42
  def find_converter(transform); end
end

# A module that contributes the +register_for+ method for registering a converter with the default registry.
#
# source://asciidoctor//lib/asciidoctor/converter.rb#145
module Asciidoctor::Converter::Config
  # Public: Registers this {Converter} class with the default registry to handle the specified backend name(s).
  #
  # backends - One or more String backend names with which to associate this {Converter} class.
  #
  # Returns nothing.
  #
  # source://asciidoctor//lib/asciidoctor/converter.rb#151
  def register_for(*backends); end
end

# source://asciidoctor//lib/asciidoctor/converter.rb#257
class Asciidoctor::Converter::CustomFactory
  include ::Asciidoctor::Converter::Factory

  # @return [CustomFactory] a new instance of CustomFactory
  #
  # source://asciidoctor//lib/asciidoctor/converter.rb#260
  def initialize(seed_registry = T.unsafe(nil)); end

  # Public: Unregister all Converter classes that are registered with this factory. Intended for testing only.
  #
  # Returns nothing.
  #
  # source://asciidoctor//lib/asciidoctor/converter.rb#272
  def unregister_all; end

  private

  # Returns the value of attribute registry.
  #
  # source://asciidoctor//lib/asciidoctor/converter.rb#278
  def registry; end
end

# Mixed into the {Converter} module to provide the global registry of converters that are registered statically.
#
# This registry includes built-in converters for {Html5Converter HTML 5}, {DocBook5Converter DocBook 5} and
# {ManPageConverter man(ual) page}, as well as any custom converters that have been discovered or explicitly
# registered. Converter registration is synchronized (where applicable) and is thus guaranteed to be thread safe.
#
# source://asciidoctor//lib/asciidoctor/converter.rb#286
module Asciidoctor::Converter::DefaultFactory
  include ::Asciidoctor::Converter::Factory

  # source://asciidoctor//lib/asciidoctor/converter.rb#315
  def for(backend); end

  # source://asciidoctor//lib/asciidoctor/converter.rb#300
  def register(converter, *backends); end

  # source://asciidoctor//lib/asciidoctor/converter.rb#308
  def unregister_all; end

  private

  # source://asciidoctor//lib/asciidoctor/converter.rb#333
  def catch_all; end

  # source://asciidoctor//lib/asciidoctor/converter.rb#293
  def registry; end
end

# source://asciidoctor//lib/asciidoctor/converter.rb#325
Asciidoctor::Converter::DefaultFactory::PROVIDED = T.let(T.unsafe(nil), Hash)

# source://asciidoctor//lib/asciidoctor/converter.rb#342
class Asciidoctor::Converter::DefaultFactoryProxy < ::Asciidoctor::Converter::CustomFactory
  include ::Asciidoctor::Converter::DefaultFactory

  # source://asciidoctor//lib/asciidoctor/converter.rb#351
  def for(backend); end

  # source://asciidoctor//lib/asciidoctor/converter.rb#346
  def unregister_all; end

  private

  # source://asciidoctor//lib/asciidoctor/converter.rb#357
  def catch_all; end
end

# A reusable module for registering and instantiating {Converter Converter} classes used to convert an {AbstractNode}
# to an output (aka backend) format such as HTML or DocBook.
#
# {Converter Converter} objects are instantiated by passing a String backend name and, optionally, an options Hash to
# the {Factory#create} method. The backend can be thought of as an intent to convert a document to a specified format.
#
# Applications interact with the factory either through the global, static registry mixed into the {Converter
# Converter} module or a concrete class that includes this module such as {CustomFactory}. For example:
#
# Examples
#
#   converter = Asciidoctor::Converter.create 'html5', htmlsyntax: 'xml'
#
# source://asciidoctor//lib/asciidoctor/converter.rb#168
module Asciidoctor::Converter::Factory
  # Public: Get the Hash of Converter classes keyed by backend name. Intended for testing only.
  #
  # source://asciidoctor//lib/asciidoctor/converter.rb#246
  def converters; end

  # Public: Create a new Converter object that can be used to convert {AbstractNode}s to the format associated with
  # the backend. This method accepts an optional Hash of options that are passed to the converter's constructor.
  #
  # If a custom Converter is found to convert the specified backend, it's instantiated (if necessary) and returned
  # immediately. If a custom Converter is not found, an attempt is made to find a built-in converter. If the
  # +:template_dirs+ key is found in the Hash passed as the second argument, a {CompositeConverter} is created that
  # delegates to a {TemplateConverter} and, if found, the built-in converter. If the +:template_dirs+ key is not
  # found, the built-in converter is returned or nil if no converter is found.
  #
  # backend - the String backend name.
  # opts    - a Hash of options to customize creation; also passed to the converter's constructor:
  #           :template_dirs - a String Array of directories used to instantiate a {TemplateConverter} (optional).
  #           :delegate_backend - a backend String of the last converter in the {CompositeConverter} chain (optional).
  #
  # Returns the [Converter] instance.
  #
  # source://asciidoctor//lib/asciidoctor/converter.rb#227
  def create(backend, opts = T.unsafe(nil)); end

  # Public: Lookup the custom converter registered with this factory to handle the specified backend.
  #
  # backend - The String backend name.
  #
  # Returns the [Converter] class registered to convert the specified backend or nil if no match is found.
  #
  # source://asciidoctor//lib/asciidoctor/converter.rb#208
  def for(backend); end

  # Public: Register a custom converter with this factory to handle conversion for the specified backends. If the
  # backend is an asterisk (i.e., +*+), the converter will handle any backend for which a converter is not registered.
  #
  # converter - The Converter class to register.
  # backends  - One or more String backend names that this converter should be registered to handle.
  #
  # Returns nothing
  #
  # source://asciidoctor//lib/asciidoctor/converter.rb#199
  def register(converter, *backends); end

  private

  # @raise [::NotImplementedError]
  #
  # source://asciidoctor//lib/asciidoctor/converter.rb#252
  def registry; end

  class << self
    # Deprecated: Maps the create method on the old default factory instance holder to the Converter module.
    #
    # source://asciidoctor//lib/asciidoctor/converter.rb#188
    def create(backend, opts = T.unsafe(nil)); end

    # Deprecated: Maps the old default factory instance holder to the Converter module.
    #
    # source://asciidoctor//lib/asciidoctor/converter.rb#183
    def default(*args); end

    # Public: Create an instance of DefaultProxyFactory or CustomFactory, depending on whether the proxy_default keyword
    # arg is set (true by default), and optionally seed it with the specified converters map. If proxy_default is set,
    # entries in the proxy registry are preferred over matching entries from the default registry.
    #
    # converters    - An optional Hash of converters to use in place of ones in the default registry. The keys are
    #                 backend names and the values are converter classes or instances.
    # proxy_default - A Boolean keyword arg indicating whether to proxy the default registry (optional, default: true).
    #
    # Returns a Factory instance (DefaultFactoryProxy or CustomFactory) seeded with the optional converters map.
    #
    # source://asciidoctor//lib/asciidoctor/converter.rb#178
    def new(converters = T.unsafe(nil), proxy_default: T.unsafe(nil)); end
  end
end

# source://asciidoctor//lib/asciidoctor/converter/template.rb#27
class Asciidoctor::Converter::TemplateConverter < ::Asciidoctor::Converter::Base
  # source://asciidoctor//lib/asciidoctor/converter/template.rb#52
  def initialize(backend, template_dirs, opts = T.unsafe(nil)); end

  # source://asciidoctor//lib/asciidoctor/converter/template.rb#97
  def convert(node, template_name = T.unsafe(nil), opts = T.unsafe(nil)); end

  # source://asciidoctor//lib/asciidoctor/converter/template.rb#119
  def handles?(name); end

  # source://asciidoctor//lib/asciidoctor/converter/template.rb#136
  def register(name, template); end

  # source://asciidoctor//lib/asciidoctor/converter/template.rb#126
  def templates; end

  private

  # source://asciidoctor//lib/asciidoctor/converter/template.rb#256
  def load_eruby(name); end

  # source://asciidoctor//lib/asciidoctor/converter/template.rb#150
  def scan; end

  # source://asciidoctor//lib/asciidoctor/converter/template.rb#196
  def scan_dir(template_dir, pattern, template_cache = T.unsafe(nil)); end

  class << self
    # source://asciidoctor//lib/asciidoctor/converter/template.rb#44
    def caches; end

    # source://asciidoctor//lib/asciidoctor/converter/template.rb#46
    def clear_caches; end
  end
end

# source://asciidoctor//lib/asciidoctor/converter/template.rb#28
Asciidoctor::Converter::TemplateConverter::DEFAULT_ENGINE_OPTIONS = T.let(T.unsafe(nil), Hash)

# Matches the custom block macro pattern.
#
# Examples
#
#   gist::123456[]
#
# --
# NOTE we've relaxed the match for target to accommodate the short format (e.g., name::[attrlist])
#
# source://asciidoctor//lib/asciidoctor/rx.rb#412
Asciidoctor::CustomBlockMacroRx = T.let(T.unsafe(nil), Regexp)

# The absolute data directory of the Asciidoctor RubyGem
#
# source://asciidoctor//lib/asciidoctor.rb#184
Asciidoctor::DATA_DIR = T.let(T.unsafe(nil), String)

# source://asciidoctor//lib/asciidoctor.rb#363
Asciidoctor::DEFAULT_ATTRIBUTES = T.let(T.unsafe(nil), Hash)

# The backend determines the format of the converted output, default to html5
#
# source://asciidoctor//lib/asciidoctor.rb#224
Asciidoctor::DEFAULT_BACKEND = T.let(T.unsafe(nil), String)

# The default document type
# Can influence markup generated by the converters
#
# source://asciidoctor//lib/asciidoctor.rb#221
Asciidoctor::DEFAULT_DOCTYPE = T.let(T.unsafe(nil), String)

# Default extensions for the respective base backends
#
# source://asciidoctor//lib/asciidoctor.rb#242
Asciidoctor::DEFAULT_EXTENSIONS = T.let(T.unsafe(nil), Hash)

# Default page widths for calculating absolute widths
#
# source://asciidoctor//lib/asciidoctor.rb#237
Asciidoctor::DEFAULT_PAGE_WIDTHS = T.let(T.unsafe(nil), Hash)

# source://asciidoctor//lib/asciidoctor.rb#226
Asciidoctor::DEFAULT_STYLESHEET_KEYS = T.let(T.unsafe(nil), Set)

# source://asciidoctor//lib/asciidoctor.rb#228
Asciidoctor::DEFAULT_STYLESHEET_NAME = T.let(T.unsafe(nil), String)

# source://asciidoctor//lib/asciidoctor.rb#278
Asciidoctor::DELIMITED_BLOCKS = T.let(T.unsafe(nil), Hash)

# source://asciidoctor//lib/asciidoctor.rb#294
Asciidoctor::DELIMITED_BLOCK_HEADS = T.let(T.unsafe(nil), Hash)

# source://asciidoctor//lib/asciidoctor.rb#295
Asciidoctor::DELIMITED_BLOCK_TAILS = T.let(T.unsafe(nil), Hash)

# Matches a description list entry.
#
# Examples
#
#   foo::
#   bar:::
#   baz::::
#   blah;;
#
#   # the term may be followed by a description on the same line...
#
#   foo:: The metasyntactic variable that commonly accompanies 'bar' (see also, <<bar>>).
#
#   # ...or on a separate line, which may optionally be indented
#
#   foo::
#     The metasyntactic variable that commonly accompanies 'bar' (see also, <<bar>>).
#
#   # attribute references may be used in both the term and the description
#
#   {foo-term}:: {foo-desc}
#
# NOTE we know trailing (.*) will match at least one character because we strip trailing spaces
# NOTE must skip line comment when looking for next list item inside list
#
# source://asciidoctor//lib/asciidoctor/rx.rb#336
Asciidoctor::DescriptionListRx = T.let(T.unsafe(nil), Regexp)

# Matches a sibling description list item (excluding the delimiter specified by the key).
# NOTE must skip line comment when looking for sibling list item
#
# source://asciidoctor//lib/asciidoctor/rx.rb#340
Asciidoctor::DescriptionListSiblingRx = T.let(T.unsafe(nil), Hash)

# can take the process to completion by calling the {Document#convert} method.
#
# source://asciidoctor//lib/asciidoctor/document.rb#83
class Asciidoctor::Document < ::Asciidoctor::AbstractBlock
  # Public: Initialize a {Document} object.
  #
  # data    - The AsciiDoc source data as a String or String Array. (default: nil)
  # options - A Hash of options to control processing (e.g., safe mode value (:safe), backend (:backend),
  #           standalone enclosure (:standalone), custom attributes (:attributes)). (default: {})
  #
  # Duplication of the options Hash is handled in the enclosing API.
  #
  # Examples
  #
  #   data = File.read filename
  #   doc = Asciidoctor::Document.new data
  #   puts doc.convert
  #
  # @return [Document] a new instance of Document
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#253
  def initialize(data = T.unsafe(nil), options = T.unsafe(nil)); end

  # Public: Append a content Block to this Document.
  #
  # If the child block is a Section, assign an index to it.
  #
  # block - The child Block to append to this parent Block
  #
  # Returns The parent Block
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#807
  def <<(block); end

  # source://asciidoctor-pdf/2.3.19/lib/asciidoctor/pdf/ext/asciidoctor/document.rb#28
  def attr_unspecified?(name); end

  # Public: Determine if the attribute has been locked by being assigned in document options
  #
  # key - The attribute key to check
  #
  # Returns true if the attribute is locked, false otherwise
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#900
  def attribute_locked?(name); end

  # Public: Convenience method to retrieve the document attribute 'author'
  #
  # returns the full name of the author as a String
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#747
  def author; end

  # Public: Convenience method to retrieve the authors of this document as an Array of Author objects.
  #
  # This method is backed by the author-related attributes on the document.
  #
  # returns the authors of this document as an Array
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#756
  def authors; end

  # Public: Get the cached value of the backend attribute for this document
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#190
  def backend; end

  # Public: Get the String base directory for converting this document.
  #
  # Defaults to directory of the source file.
  # If the source is a string, defaults to the current directory.
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#214
  def base_dir; end

  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#676
  def basebackend?(base); end

  # source://asciidoctor//lib/asciidoctor/document.rb#650
  def callouts; end

  # Public: Get the document catalog Hash
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#199
  def catalog; end

  # Public: Get the Boolean AsciiDoc compatibility mode
  #
  # enabling this attribute activates the following syntax changes:
  #
  #   * single quotes as constrained emphasis formatting marks
  #   * single backticks parsed as inline literal, formatted as monospace
  #   * single plus parsed as constrained, monospaced inline formatting
  #   * double plus parsed as constrained, monospaced inline formatting
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#187
  def compat_mode; end

  # source://asciidoctor//lib/asciidoctor/document.rb#1009
  def content; end

  # Public: Convert the AsciiDoc document using the templates
  # loaded by the Converter. If a :template_dir is not specified,
  # or a template is missing, the converter will fall back to
  # using the appropriate built-in template.
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#929
  def convert(opts = T.unsafe(nil)); end

  # Public: Get the Converter associated with this document
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#232
  def converter; end

  # Public: Get the named counter and take the next number in the sequence.
  #
  # name  - the String name of the counter
  # seed  - the initial value as a String or Integer
  #
  # returns the next number in the sequence for the specified counter
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#567
  def counter(name, seed = T.unsafe(nil)); end

  # Public: Increment the specified counter and store it in the block's attributes
  #
  # counter_name - the String name of the counter attribute
  # block        - the Block on which to save the counter
  #
  # returns the next number in the sequence for the specified counter
  # Deprecated: Map old counter_increment method to increment_counter for backwards compatibility
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#586
  def counter_increment(counter_name, block); end

  # Public: Get the Hash of document counters
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#205
  def counters; end

  # Public: Delete the specified attribute from the document if the name is not locked
  #
  # If the attribute is locked, false is returned. Otherwise, the attribute is deleted.
  #
  # name  - the String attribute name
  #
  # returns true if the attribute was deleted, false if it was not because it's locked
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#885
  def delete_attribute(name); end

  # Public: Read the docinfo file(s) for inclusion in the document template
  #
  # If the docinfo1 attribute is set, read the docinfo.ext file. If the docinfo
  # attribute is set, read the doc-name.docinfo.ext file. If the docinfo2
  # attribute is set, read both files in that order.
  #
  # location - The Symbol location of the docinfo (e.g., :head, :footer, etc). (default: :head)
  # suffix   - The suffix of the docinfo file(s). If not set, the extension
  #            will be set to the outfilesuffix. (default: nil)
  #
  # returns The contents of the docinfo file(s) or empty string if no files are
  # found or the safe mode is secure or greater.
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#1027
  def docinfo(location = T.unsafe(nil), suffix = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#1075
  def docinfo_processors?(location = T.unsafe(nil)); end

  # Public: Resolves the primary title for the document
  #
  # Searches the locations to find the first non-empty
  # value:
  #
  #  * document-level attribute named title
  #  * header title (known as the document title)
  #  * title of the first section
  #  * document-level attribute named untitled-label (if :use_fallback option is set)
  #
  # If no value can be resolved, nil is returned.
  #
  # If the :partition attribute is specified, the value is parsed into an Document::Title object.
  # If the :sanitize attribute is specified, XML elements are removed from the value.
  #
  # TODO separate sanitization by type (:cdata for HTML/XML, :plain_text for non-SGML, false for none)
  #
  # Returns the resolved title as a [Title] if the :partition option is passed or a [String] if not
  # or nil if no value can be resolved.
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#721
  def doctitle(opts = T.unsafe(nil)); end

  # Public: Get the cached value of the doctype attribute for this document
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#193
  def doctype; end

  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#658
  def embedded?; end

  # Public: Get the activated Extensions::Registry associated with this document.
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#238
  def extensions; end

  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#662
  def extensions?; end

  # Internal: Called by the parser after parsing the header and before parsing
  # the body, even if no header is found.
  # --
  # QUESTION should we invoke the TreeProcessors here, passing in a phase?
  # QUESTION is finalize_header the right name?
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#817
  def finalize_header(unrooted_attributes, header_valid = T.unsafe(nil)); end

  # source://asciidoctor//lib/asciidoctor/document.rb#791
  def first_section; end

  # source://asciidoctor//lib/asciidoctor/document.rb#646
  def footnotes; end

  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#642
  def footnotes?; end

  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#795
  def has_header?; end

  # Public: Get the level-0 Section (i.e., doctitle). (Only stores the title, not the header attributes).
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#208
  def header; end

  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#795
  def header?; end

  # Public: Increment the specified counter and store it in the block's attributes
  #
  # counter_name - the String name of the counter attribute
  # block        - the Block on which to save the counter
  #
  # returns the next number in the sequence for the specified counter
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#586
  def increment_and_store_counter(counter_name, block); end

  # Public: Resolves the primary title for the document
  #
  # Searches the locations to find the first non-empty
  # value:
  #
  #  * document-level attribute named title
  #  * header title (known as the document title)
  #  * title of the first section
  #  * document-level attribute named untitled-label (if :use_fallback option is set)
  #
  # If no value can be resolved, nil is returned.
  #
  # If the :partition attribute is specified, the value is parsed into an Document::Title object.
  # If the :sanitize attribute is specified, XML elements are removed from the value.
  #
  # TODO separate sanitization by type (:cdata for HTML/XML, :plain_text for non-SGML, false for none)
  #
  # Returns the resolved title as a [Title] if the :partition option is passed or a [String] if not
  # or nil if no value can be resolved.
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#721
  def name(opts = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#654
  def nested?; end

  # source://asciidoctor//lib/asciidoctor/document.rb#787
  def nofooter; end

  # source://asciidoctor//lib/asciidoctor/document.rb#783
  def noheader; end

  # source://asciidoctor//lib/asciidoctor/document.rb#779
  def notitle; end

  # Public: Get the Hash of resolved options used to initialize this Document
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#217
  def options; end

  # Public: Get the outfilesuffix defined at the end of the header.
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#220
  def outfilesuffix; end

  # Public: Get a reference to the parent Document of this nested document.
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#223
  def parent_document; end

  # Public: Parse the AsciiDoc source stored in the {Reader} into an abstract syntax tree.
  #
  # If the data parameter is not nil, create a new {PreprocessorReader} and assigned it to the reader
  # property of this object. Otherwise, continue with the reader that was created in {#initialize}.
  # Pass the reader to {Parser.parse} to parse the source data into an abstract syntax tree.
  #
  # If parsing has already been performed, this method returns without performing any processing.
  #
  # data - The optional replacement AsciiDoc source data as a String or String Array. (default: nil)
  #
  # Returns this [Document]
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#520
  def parse(data = T.unsafe(nil)); end

  # Public: Returns whether the source lines of the document have been parsed.
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#557
  def parsed?; end

  # Public: Get/Set the PathResolver instance used to resolve paths in this Document.
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#229
  def path_resolver; end

  # Public: Replay attribute assignments at the block level
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#825
  def playback_attributes(block_attributes); end

  # source://asciidoctor-pdf/2.3.19/lib/asciidoctor/pdf/ext/asciidoctor/document.rb#6
  def promote_preface_block; end

  # Public: Get the Reader associated with this document
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#226
  def reader; end

  # Public: Get the document catalog Hash
  # Public: Alias catalog property as references for backwards compatibility
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#199
  def references; end

  # Public: Register a reference in the document catalog
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#593
  def register(type, value); end

  # Public: Convert the AsciiDoc document using the templates
  # loaded by the Converter. If a :template_dir is not specified,
  # or a template is missing, the converter will fall back to
  # using the appropriate built-in template.
  # Deprecated: Use {Document#convert} instead.
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#929
  def render(opts = T.unsafe(nil)); end

  # Public: Scan registered references and return the ID of the first reference that matches the specified reference text.
  #
  # text - The String reference text to compare to the converted reference text of each registered reference.
  #
  # Returns the String ID of the first reference with matching reference text or nothing if no reference is found.
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#612
  def resolve_id(text); end

  # Public: Restore the attributes to the previously saved state (attributes in header)
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#841
  def restore_attributes; end

  # Public: Convenience method to retrieve the document attribute 'revdate'
  #
  # returns the date of last revision for the document as a String
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#775
  def revdate; end

  # Public A read-only integer value indicating the level of security that
  # should be enforced while processing this document. The value must be
  # set in the Document constructor using the :safe option.
  #
  # A value of 0 (UNSAFE) disables any of the security features enforced
  # by Asciidoctor (Ruby is still subject to its own restrictions).
  #
  # A value of 1 (SAFE) closely parallels safe mode in AsciiDoc. In particular,
  # it prevents access to files which reside outside of the parent directory
  # of the source file and disables any macro other than the include directive.
  #
  # A value of 10 (SERVER) disallows the document from setting attributes that
  # would affect the conversion of the document, in addition to all the security
  # features of SafeMode::SAFE. For instance, this level forbids changing the
  # backend or source-highlighter using an attribute defined in the source
  # document header. This is the most fundamental level of security for server
  # deployments (hence the name).
  #
  # A value of 20 (SECURE) disallows the document from attempting to read files
  # from the file system and including the contents of them into the document,
  # in addition to all the security features of SafeMode::SECURE. In
  # particular, it disallows use of the include::[] directive and the embedding of
  # binary content (data uri), stylesheets and JavaScripts referenced by the
  # document. (Asciidoctor and trusted extensions may still be allowed to embed
  # trusted content into the document).
  #
  # Since Asciidoctor is aiming for wide adoption, 20 (SECURE) is the default
  # value and is recommended for server deployments.
  #
  # A value of 100 (PARANOID) is planned to disallow the use of passthrough
  # macros and prevents the document from setting any known attributes in
  # addition to all the security features of SafeMode::SECURE. Please note that
  # this level is not currently implemented (and therefore not enforced)!
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#176
  def safe; end

  # Public: Check whether this Document has any child Section objects.
  #
  # Returns A [Boolean] to indicate whether this Document has child Section objects
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#638
  def sections?; end

  # Public: Set the specified attribute on the document if the name is not locked
  #
  # If the attribute is locked, false is returned. Otherwise, the value is
  # assigned to the attribute name after first performing attribute
  # substitutions on the value. If the attribute name is 'backend' or
  # 'doctype', then the value of backend-related attributes are updated.
  #
  # name  - the String attribute name
  # value - the String attribute value; must not be nil (optional, default: '')
  #
  # Returns the substituted value if the attribute was set or nil if it was not because it's locked.
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#857
  def set_attribute(name, value = T.unsafe(nil)); end

  # Public: Assign a value to the specified attribute in the document header.
  #
  # The assignment will be visible when the header attributes are restored,
  # typically between processor phases (e.g., between parse and convert).
  #
  # name      - The String attribute name to assign
  # value     - The Object value to assign to the attribute (default: '')
  # overwrite - A Boolean indicating whether to assign the attribute
  #             if already present in the attributes Hash (default: true)
  #
  # Returns a [Boolean] indicating whether the assignment was performed
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#915
  def set_header_attribute(name, value = T.unsafe(nil), overwrite = T.unsafe(nil)); end

  # Make the raw source for the Document available.
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#667
  def source; end

  # Make the raw source lines for the Document available.
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#672
  def source_lines; end

  # Public: Get or set the Boolean flag that indicates whether source map information should be tracked by the parser
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#196
  def sourcemap; end

  # Public: Get or set the Boolean flag that indicates whether source map information should be tracked by the parser
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#196
  def sourcemap=(_arg0); end

  # Public: Get the SyntaxHighlighter associated with this document
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#235
  def syntax_highlighter; end

  # Public: Return the doctitle as a String
  #
  # Returns the resolved doctitle as a [String] or nil if a doctitle cannot be resolved
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#683
  def title; end

  # Public: Set the title on the document header
  #
  # Set the title of the document header to the specified value. If the header
  # does not exist, it is first created.
  #
  # title - the String title to assign as the title of the document header
  #
  # Returns the specified [String] title
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#695
  def title=(title); end

  # source://asciidoctor//lib/asciidoctor/document.rb#1086
  def to_s; end

  # Public: Write the output to the specified file
  #
  # If the converter responds to :write, delegate the work of writing the output
  # to that method. Otherwise, write the output to the specified file. In the
  # latter case, this method ensures the output has a trailing newline if the
  # target responds to write and the output is not empty.
  #
  # output - The output to write. Unless the converter responds to write, this
  #          object is expected to be a String.
  # target - The file to write, either a File object or a String path.
  #
  # Returns nothing
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#986
  def write(output, target); end

  # source://asciidoctor//lib/asciidoctor/document.rb#740
  def xreftext(xrefstyle = T.unsafe(nil)); end

  private

  # Internal: Apply substitutions to the attribute value
  #
  # If the value is an inline passthrough macro (e.g., pass:<subs>[value]),
  # apply the substitutions defined in <subs> to the value, or leave the value
  # unmodified if no substitutions are specified.  If the value is not an
  # inline passthrough macro, apply header substitutions to the value.
  #
  # value - The String attribute value on which to perform substitutions
  #
  # Returns The String value with substitutions performed
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#1102
  def apply_attribute_value_subs(value); end

  # Internal: Delete any attributes stored for playback
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#1160
  def clear_playback_attributes(attributes); end

  # Internal: Create and initialize an instance of the converter for this document
  # --
  # QUESTION is there any additional information we should be passing to the converter?
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#1141
  def create_converter(backend, delegate_backend); end

  # Internal: Assign the local and document datetime attributes, which includes localdate, localyear, localtime,
  # localdatetime, docdate, docyear, doctime, and docdatetime. Honor the SOURCE_DATE_EPOCH environment variable, if set.
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#1257
  def fill_datetime_attributes(attrs, input_mtime); end

  # Internal: Safely truncates a string to the specified number of bytes.
  #
  # If a multibyte char gets split, the dangling fragment is dropped.
  #
  # str - The String the truncate.
  # max - The maximum allowable size of the String, in bytes.
  #
  # Returns the String truncated to the specified bytesize.
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#1120
  def limit_bytesize(str, max); end

  # Internal: Resolve the list of comma-delimited subs to apply to docinfo files.
  #
  # Resolve the list of substitutions from the value of the docinfosubs
  # document attribute, if specified. Otherwise, return an Array containing
  # the Symbol :attributes.
  #
  # Returns an [Array] of substitution [Symbol]s
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#1134
  def resolve_docinfo_subs; end

  # Internal: Branch the attributes so that the original state can be restored
  # at a future time.
  #
  # Returns the duplicated attributes, which will later be restored
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#1168
  def save_attributes; end

  # Internal: Update the backend attributes to reflect a change in the active backend.
  #
  # This method also handles updating the related doctype attributes if the
  # doctype attribute is assigned at the time this method is called.
  #
  # Returns the resolved String backend if updated, nothing otherwise.
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#1289
  def update_backend_attributes(new_backend, init = T.unsafe(nil)); end

  # Internal: Update the doctype and backend attributes to reflect a change in the active doctype.
  #
  # Returns the String doctype if updated, nothing otherwise.
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#1372
  def update_doctype_attributes(new_doctype); end
end

# source://asciidoctor//lib/asciidoctor/document.rb#91
class Asciidoctor::Document::AttributeEntry
  # @return [AttributeEntry] a new instance of AttributeEntry
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#94
  def initialize(name, value, negate = T.unsafe(nil)); end

  # Returns the value of attribute name.
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#92
  def name; end

  # Returns the value of attribute negate.
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#92
  def negate; end

  # source://asciidoctor//lib/asciidoctor/document.rb#100
  def save_to(block_attributes); end

  # Returns the value of attribute value.
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#92
  def value; end
end

# Public: The Author class represents information about an author extracted from document attributes
#
# source://asciidoctor//lib/asciidoctor/document.rb#141
class Asciidoctor::Document::Author < ::Struct
  # Returns the value of attribute email
  #
  # @return [Object] the current value of email
  def email; end

  # Sets the attribute email
  #
  # @param value [Object] the value to set the attribute email to.
  # @return [Object] the newly set value
  def email=(_); end

  # Returns the value of attribute firstname
  #
  # @return [Object] the current value of firstname
  def firstname; end

  # Sets the attribute firstname
  #
  # @param value [Object] the value to set the attribute firstname to.
  # @return [Object] the newly set value
  def firstname=(_); end

  # Returns the value of attribute initials
  #
  # @return [Object] the current value of initials
  def initials; end

  # Sets the attribute initials
  #
  # @param value [Object] the value to set the attribute initials to.
  # @return [Object] the newly set value
  def initials=(_); end

  # Returns the value of attribute lastname
  #
  # @return [Object] the current value of lastname
  def lastname; end

  # Sets the attribute lastname
  #
  # @param value [Object] the value to set the attribute lastname to.
  # @return [Object] the newly set value
  def lastname=(_); end

  # Returns the value of attribute middlename
  #
  # @return [Object] the current value of middlename
  def middlename; end

  # Sets the attribute middlename
  #
  # @param value [Object] the value to set the attribute middlename to.
  # @return [Object] the newly set value
  def middlename=(_); end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  def name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://asciidoctor//lib/asciidoctor/document.rb#89
class Asciidoctor::Document::Footnote < ::Struct
  # Returns the value of attribute id
  #
  # @return [Object] the current value of id
  def id; end

  # Sets the attribute id
  #
  # @param value [Object] the value to set the attribute id to.
  # @return [Object] the newly set value
  def id=(_); end

  # Returns the value of attribute index
  #
  # @return [Object] the current value of index
  def index; end

  # Sets the attribute index
  #
  # @param value [Object] the value to set the attribute index to.
  # @return [Object] the newly set value
  def index=(_); end

  # Returns the value of attribute text
  #
  # @return [Object] the current value of text
  def text; end

  # Sets the attribute text
  #
  # @param value [Object] the value to set the attribute text to.
  # @return [Object] the newly set value
  def text=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://asciidoctor//lib/asciidoctor/document.rb#85
class Asciidoctor::Document::ImageReference < ::Struct
  # Returns the value of attribute imagesdir
  #
  # @return [Object] the current value of imagesdir
  def imagesdir; end

  # Sets the attribute imagesdir
  #
  # @param value [Object] the value to set the attribute imagesdir to.
  # @return [Object] the newly set value
  def imagesdir=(_); end

  # Returns the value of attribute target
  #
  # @return [Object] the current value of target
  def target; end

  # Sets the attribute target
  #
  # @param value [Object] the value to set the attribute target to.
  # @return [Object] the newly set value
  def target=(_); end

  # Returns the value of attribute target
  #
  # @return [Object] the current value of target
  def to_s; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Public Parsed and stores a partitioned title (i.e., title & subtitle).
#
# source://asciidoctor//lib/asciidoctor/document.rb#107
class Asciidoctor::Document::Title
  # @return [Title] a new instance of Title
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#113
  def initialize(val, opts = T.unsafe(nil)); end

  # Returns the value of attribute combined.
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#111
  def combined; end

  # Returns the value of attribute main.
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#108
  def main; end

  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#127
  def sanitized?; end

  # Returns the value of attribute subtitle.
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#110
  def subtitle; end

  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#131
  def subtitle?; end

  # Returns the value of attribute main.
  #
  # source://asciidoctor//lib/asciidoctor/document.rb#108
  def title; end

  # source://asciidoctor//lib/asciidoctor/document.rb#135
  def to_s; end
end

# Matches whitespace (space, tab, newline) escaped by a backslash.
#
# Examples
#
#   three\ blind\ mice
#
# source://asciidoctor//lib/asciidoctor/rx.rb#679
Asciidoctor::EscapedSpaceRx = T.let(T.unsafe(nil), Regexp)

# Matches a restricted (read as safe) eval expression.
#
# Examples
#
#   "{asciidoctor-version}" >= "0.1.0"
#
# source://asciidoctor//lib/asciidoctor/rx.rb#83
Asciidoctor::EvalExpressionRx = T.let(T.unsafe(nil), Regexp)

# Matches an extended Atx section title that includes support for the Markdown variant.
#
# source://asciidoctor//lib/asciidoctor/rx.rb#244
Asciidoctor::ExtAtxSectionTitleRx = T.let(T.unsafe(nil), Regexp)

# Matches an AsciiDoc or Markdown horizontal rule or AsciiDoc page break.
#
# Examples
#
#   ''' (horizontal rule)
#   <<< (page break)
#   --- or - - - (horizontal rule, Markdown)
#   *** or * * * (horizontal rule, Markdown)
#   ___ or _ _ _ (horizontal rule, Markdown)
#
# source://asciidoctor//lib/asciidoctor/rx.rb#650
Asciidoctor::ExtLayoutBreakRx = T.let(T.unsafe(nil), Regexp)

# Asciidoctor processor.
#
# source://asciidoctor//lib/asciidoctor/extensions.rb#25
module Asciidoctor::Extensions
  class << self
    # source://asciidoctor//lib/asciidoctor/extensions.rb#1491
    def create(name = T.unsafe(nil), &block); end

    # source://asciidoctor//lib/asciidoctor/extensions.rb#1478
    def generate_name; end

    # source://asciidoctor//lib/asciidoctor/extensions.rb#1487
    def groups; end

    # source://asciidoctor//lib/asciidoctor/extensions.rb#1482
    def next_auto_id; end

    # Public: Registers an extension Group that subsequently registers a
    # collection of extensions.
    #
    # Registers the extension Group specified under the given name. If a name is
    # not given, one is calculated by appending the next value in a 0-based
    # index to the string "extgrp". For instance, the first unnamed extension
    # group to be registered is assigned the name "extgrp0" if a name is not
    # specified.
    #
    # The names are not yet used, but are intended for selectively activating
    # extensions in the future.
    #
    # If the extension group argument is a String or a Symbol, it gets resolved
    # to a Class before being registered.
    #
    # name    - The name under which this extension group is registered (optional, default: nil)
    # group   - A block (Proc), a Class, a String or Symbol name of a Class or
    #           an Object instance of a Class.
    #
    # Examples
    #
    #   Asciidoctor::Extensions.register UmlExtensions
    #
    #   Asciidoctor::Extensions.register :uml, UmlExtensions
    #
    #   Asciidoctor::Extensions.register do
    #     block_processor :plantuml, PlantUmlBlock
    #   end
    #
    #   Asciidoctor::Extensions.register :uml do
    #     block_processor :plantuml, PlantUmlBlock
    #   end
    #
    # Returns the [Proc, Class or Object] instance, matching the type passed to this method.
    #
    # source://asciidoctor//lib/asciidoctor/extensions.rb#1533
    def register(*args, &block); end

    # Public: Unregister statically-registered extension groups by name.
    #
    # names - one or more Symbol or String group names to unregister
    #
    # Returns nothing
    #
    # source://asciidoctor//lib/asciidoctor/extensions.rb#1563
    def unregister(*names); end

    # Public: Unregister all statically-registered extension groups.
    #
    # Returns nothing
    #
    # source://asciidoctor//lib/asciidoctor/extensions.rb#1553
    def unregister_all; end
  end
end

# Public: BlockMacroProcessors are used to handle block macros that have a
# custom name.
#
# If the process method returns an instance of Block, the content model of that
# Block is :compound, and the Block contains at least one line, the parser will
# parse those lines into blocks an assigned them to the returned block.
#
# BlockMacroProcessor implementations must extend BlockMacroProcessor.
#
# source://asciidoctor//lib/asciidoctor/extensions.rb#611
class Asciidoctor::Extensions::BlockMacroProcessor < ::Asciidoctor::Extensions::MacroProcessor
  # @raise [::ArgumentError]
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#612
  def name; end
end

# source://asciidoctor//lib/asciidoctor/extensions.rb#617
Asciidoctor::Extensions::BlockMacroProcessor::DSL = Asciidoctor::Extensions::MacroProcessorDsl

# Public: BlockProcessors are used to handle delimited blocks and paragraphs
# that have a custom name.
#
# When Asciidoctor encounters a delimited block or paragraph with an
# unrecognized name while parsing the document, it looks for a BlockProcessor
# registered to handle this name and, if found, invokes its {Processor#process}
# method to build a corresponding node in the document tree.
#
# If the process method returns an instance of Block, the content model of that
# Block is :compound, and the Block contains at least one line, the parser will
# parse those lines into blocks and append them to the returned block.
#
# If your custom block can be applied to a paragraph or delimited block, and you
# want to preserve the content model of the input, check whether the value of
# the cloaked-context attribute is :paragraph. If it is, set the content model of
# the returned block to :simple. Otherwise, set the content model to :compound.
#
# AsciiDoc example:
#
#   [shout]
#   Get a move on.
#
# Recognized options:
#
# * :named - The name of the block (required: true)
# * :contexts - The blocks contexts on which this style can be used (default: [:paragraph, :open]
# * :content_model - The structure of the content supported in this block (default: :compound)
# * :positional_attrs - A list of attribute names used to map positional attributes (default: nil)
# * :default_attrs - A hash of attribute names and values used to seed the attributes hash (default: nil)
# * ...
#
# BlockProcessor implementations must extend BlockProcessor.
#
# source://asciidoctor//lib/asciidoctor/extensions.rb#538
class Asciidoctor::Extensions::BlockProcessor < ::Asciidoctor::Extensions::Processor
  # @return [BlockProcessor] a new instance of BlockProcessor
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#541
  def initialize(name = T.unsafe(nil), config = T.unsafe(nil)); end

  # Returns the value of attribute name.
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#539
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#539
  def name=(_arg0); end

  # @raise [::NotImplementedError]
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#557
  def process(parent, reader, attributes); end
end

# source://asciidoctor//lib/asciidoctor/extensions.rb#572
Asciidoctor::Extensions::BlockProcessor::DSL = Asciidoctor::Extensions::BlockProcessorDsl

# source://asciidoctor//lib/asciidoctor/extensions.rb#562
module Asciidoctor::Extensions::BlockProcessorDsl
  include ::Asciidoctor::Extensions::ProcessorDsl
  include ::Asciidoctor::Extensions::SyntaxProcessorDsl

  # source://asciidoctor//lib/asciidoctor/extensions.rb#565
  def bind_to(*value); end

  # source://asciidoctor//lib/asciidoctor/extensions.rb#565
  def contexts(*value); end

  # source://asciidoctor//lib/asciidoctor/extensions.rb#565
  def on_context(*value); end

  # source://asciidoctor//lib/asciidoctor/extensions.rb#565
  def on_contexts(*value); end
end

# Public: DocinfoProcessors are used to add additional content to
# the header and/or footer of the generated document.
#
# The placement of docinfo content is controlled by the converter.
#
# DocinfoProcessors implementations must extend DocinfoProcessor.
# If a location is not specified, the DocinfoProcessor is assumed
# to add content to the header.
#
# source://asciidoctor//lib/asciidoctor/extensions.rb#486
class Asciidoctor::Extensions::DocinfoProcessor < ::Asciidoctor::Extensions::Processor
  # @return [DocinfoProcessor] a new instance of DocinfoProcessor
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#487
  def initialize(config = T.unsafe(nil)); end

  # @raise [::NotImplementedError]
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#492
  def process(document); end
end

# source://asciidoctor//lib/asciidoctor/extensions.rb#504
Asciidoctor::Extensions::DocinfoProcessor::DSL = Asciidoctor::Extensions::DocinfoProcessorDsl

# source://asciidoctor//lib/asciidoctor/extensions.rb#497
module Asciidoctor::Extensions::DocinfoProcessorDsl
  include ::Asciidoctor::Extensions::ProcessorDsl
  include ::Asciidoctor::Extensions::DocumentProcessorDsl

  # source://asciidoctor//lib/asciidoctor/extensions.rb#500
  def at_location(value); end
end

# source://asciidoctor//lib/asciidoctor/extensions.rb#286
module Asciidoctor::Extensions::DocumentProcessorDsl
  include ::Asciidoctor::Extensions::ProcessorDsl

  # source://asciidoctor//lib/asciidoctor/extensions.rb#289
  def prefer; end
end

# Public: Extension is a proxy object for an extension implementation such as
# a processor. It allows the preparation of the extension instance to be
# separated from its usage to provide consistency between different
# interfaces and avoid tight coupling with the extension type.
#
# The proxy encapsulates the extension kind (e.g., :block), its config Hash
# and the extension instance. This Proxy is what gets stored in the extension
# registry when activated.
# --
# QUESTION call this ExtensionInfo?
#
# source://asciidoctor//lib/asciidoctor/extensions.rb#668
class Asciidoctor::Extensions::Extension
  # @return [Extension] a new instance of Extension
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#673
  def initialize(kind, instance, config); end

  # Returns the value of attribute config.
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#670
  def config; end

  # Returns the value of attribute instance.
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#671
  def instance; end

  # Returns the value of attribute kind.
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#669
  def kind; end
end

# Public: A Group is used to register one or more extensions with the Registry.
#
# The Group should be subclassed and registered with the Registry either by
# invoking the {Group.register} method or passing the subclass to the
# {Extensions.register} method. Extensions are registered with the Registry
# inside the {Group#activate} method.
#
# source://asciidoctor//lib/asciidoctor/extensions.rb#698
class Asciidoctor::Extensions::Group
  # @raise [::NotImplementedError]
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#705
  def activate(registry); end

  class << self
    # source://asciidoctor//lib/asciidoctor/extensions.rb#700
    def register(name = T.unsafe(nil)); end
  end
end

# Public: IncludeProcessors are used to process `include::<target>[]`
# directives in the source document.
#
# When Asciidoctor comes across a `include::<target>[]` directive in the
# source document, it iterates through the IncludeProcessors and delegates
# the work of reading the content to the first processor that identifies
# itself as capable of handling that target.
#
# IncludeProcessor implementations must extend IncludeProcessor.
# --
# TODO add file extension or regexp as shortcut for handles? method
#
# source://asciidoctor//lib/asciidoctor/extensions.rb#447
class Asciidoctor::Extensions::IncludeProcessor < ::Asciidoctor::Extensions::Processor
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#452
  def handles?(target); end

  # @raise [::NotImplementedError]
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#448
  def process(document, reader, target, attributes); end
end

# source://asciidoctor//lib/asciidoctor/extensions.rb#476
Asciidoctor::Extensions::IncludeProcessor::DSL = Asciidoctor::Extensions::IncludeProcessorDsl

# source://asciidoctor//lib/asciidoctor/extensions.rb#457
module Asciidoctor::Extensions::IncludeProcessorDsl
  include ::Asciidoctor::Extensions::ProcessorDsl
  include ::Asciidoctor::Extensions::DocumentProcessorDsl

  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#460
  def handles?(*args, &block); end
end

# Public: InlineMacroProcessors are used to handle block macros that have a
# custom name.
#
# InlineMacroProcessor implementations must extend InlineMacroProcessor.
# --
# TODO break this out into different pattern types
# for example, FullInlineMacro, ShortInlineMacro (no target) and other patterns
# FIXME for inline macro, we need to have some way to specify the text as a passthrough
#
# source://asciidoctor//lib/asciidoctor/extensions.rb#627
class Asciidoctor::Extensions::InlineMacroProcessor < ::Asciidoctor::Extensions::MacroProcessor
  # Lookup the regexp option, resolving it first if necessary.
  # Once this method is called, the regexp is considered frozen.
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#632
  def regexp; end

  # @raise [::ArgumentError]
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#636
  def resolve_regexp(name, format); end
end

# source://asciidoctor//lib/asciidoctor/extensions.rb#656
Asciidoctor::Extensions::InlineMacroProcessor::DSL = Asciidoctor::Extensions::InlineMacroProcessorDsl

# source://asciidoctor//lib/asciidoctor/extensions.rb#642
module Asciidoctor::Extensions::InlineMacroProcessorDsl
  include ::Asciidoctor::Extensions::ProcessorDsl
  include ::Asciidoctor::Extensions::SyntaxProcessorDsl
  include ::Asciidoctor::Extensions::MacroProcessorDsl

  # source://asciidoctor//lib/asciidoctor/extensions.rb#645
  def format(value); end

  # source://asciidoctor//lib/asciidoctor/extensions.rb#652
  def match(value); end

  # source://asciidoctor//lib/asciidoctor/extensions.rb#645
  def match_format(value); end

  # NOTE using_format alias is deprecated
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#645
  def using_format(value); end
end

# source://asciidoctor//lib/asciidoctor/extensions.rb#574
class Asciidoctor::Extensions::MacroProcessor < ::Asciidoctor::Extensions::Processor
  # @return [MacroProcessor] a new instance of MacroProcessor
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#577
  def initialize(name = T.unsafe(nil), config = T.unsafe(nil)); end

  # Returns the value of attribute name.
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#575
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#575
  def name=(_arg0); end

  # @raise [::NotImplementedError]
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#583
  def process(parent, target, attributes); end
end

# source://asciidoctor//lib/asciidoctor/extensions.rb#588
module Asciidoctor::Extensions::MacroProcessorDsl
  include ::Asciidoctor::Extensions::ProcessorDsl
  include ::Asciidoctor::Extensions::SyntaxProcessorDsl

  # source://asciidoctor//lib/asciidoctor/extensions.rb#591
  def resolve_attributes(*args); end

  # NOTE resolves_attributes alias is deprecated
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#591
  def resolves_attributes(*args); end
end

# Public: Postprocessors are run after the document is converted, but before
# it is written to the output stream.
#
# Asciidoctor passes a reference to the converted String to the {Processor#process}
# method of each registered Postprocessor. The Preprocessor modifies the
# String as necessary and returns the String replacement.
#
# The markup format in the String is determined by the backend used to convert
# the Document. The backend and be looked up using the backend method on the
# Document object, as well as various backend-related document attributes.
#
# TIP: Postprocessors can also be used to relocate assets needed by the published
# document.
#
# Postprocessor implementations must extend Postprocessor.
#
# source://asciidoctor//lib/asciidoctor/extensions.rb#429
class Asciidoctor::Extensions::Postprocessor < ::Asciidoctor::Extensions::Processor
  # @raise [::NotImplementedError]
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#430
  def process(document, output); end
end

# source://asciidoctor//lib/asciidoctor/extensions.rb#434
Asciidoctor::Extensions::Postprocessor::DSL = Asciidoctor::Extensions::DocumentProcessorDsl

# Public: Preprocessors are run after the source text is split into lines and
# normalized, but before parsing begins.
#
# Prior to invoking the preprocessor, Asciidoctor splits the source text into
# lines and normalizes them. The normalize process strips trailing whitespace
# and the end of line character sequence from each line.
#
# Asciidoctor passes the document and the document's Reader to the
# {Processor#process} method of the Preprocessor instance. The Preprocessor
# can modify the Reader as necessary and either return the same Reader (or
# falsy, which is equivalent) or a reference to a substitute Reader.
#
# Preprocessor implementations must extend the Preprocessor class.
#
# source://asciidoctor//lib/asciidoctor/extensions.rb#387
class Asciidoctor::Extensions::Preprocessor < ::Asciidoctor::Extensions::Processor
  # @raise [::NotImplementedError]
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#388
  def process(document, reader); end
end

# source://asciidoctor//lib/asciidoctor/extensions.rb#392
Asciidoctor::Extensions::Preprocessor::DSL = Asciidoctor::Extensions::DocumentProcessorDsl

# Public: An abstract base class for document and syntax processors.
#
# This class provides access to a class-level Hash for holding default
# configuration options defined using the {Processor.option} method. This
# style of default configuration is specific to the native Ruby environment
# and is only consulted inside the initializer. An overriding configuration
# Hash can be passed to the initializer. Once the processor is initialized,
# the configuration is accessed using the {Processor#config} instance variable.
#
# Instances of the Processor class provide convenience methods for creating
# AST nodes, such as Block and Inline, and for parsing child content.
#
# source://asciidoctor//lib/asciidoctor/extensions.rb#38
class Asciidoctor::Extensions::Processor
  # @return [Processor] a new instance of Processor
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#81
  def initialize(config = T.unsafe(nil)); end

  # Public: Get the configuration Hash for this processor instance.
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#79
  def config; end

  # source://asciidoctor//lib/asciidoctor/extensions.rb#246
  def create_anchor(*args); end

  # source://asciidoctor//lib/asciidoctor/extensions.rb#155
  def create_block(parent, context, source, attrs, opts = T.unsafe(nil)); end

  # source://asciidoctor//lib/asciidoctor/extensions.rb#246
  def create_example_block(*args); end

  # Public: Creates an image block node and links it to the specified parent.
  #
  # parent - The parent Block (Block, Section, or Document) of this new image block.
  # attrs  - A Hash of attributes to control how the image block is built.
  #          Use the target attribute to set the source of the image.
  #          Use the alt attribute to specify an alternative text for the image.
  # opts   - An optional Hash of options (default: {})
  #
  # Returns a [Block] node with all properties properly initialized.
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#191
  def create_image_block(parent, attrs, opts = T.unsafe(nil)); end

  # source://asciidoctor//lib/asciidoctor/extensions.rb#205
  def create_inline(parent, context, text, opts = T.unsafe(nil)); end

  # source://asciidoctor//lib/asciidoctor/extensions.rb#246
  def create_inline_pass(*args); end

  # Public: Creates a list node and links it to the specified parent.
  #
  # parent - The parent Block (Block, Section, or Document) of this new list block.
  # context - The list context (e.g., :ulist, :olist, :colist, :dlist)
  # attrs  - A Hash of attributes to set on this list block
  #
  # Returns a [List] node with all properties properly initialized.
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#166
  def create_list(parent, context, attrs = T.unsafe(nil)); end

  # Public: Creates a list item node and links it to the specified parent.
  #
  # parent - The parent List of this new list item block.
  # text   - The text of the list item.
  #
  # Returns a [ListItem] node with all properties properly initialized.
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#178
  def create_list_item(parent, text = T.unsafe(nil)); end

  # source://asciidoctor//lib/asciidoctor/extensions.rb#246
  def create_listing_block(*args); end

  # source://asciidoctor//lib/asciidoctor/extensions.rb#246
  def create_literal_block(*args); end

  # source://asciidoctor//lib/asciidoctor/extensions.rb#246
  def create_open_block(*args); end

  # source://asciidoctor//lib/asciidoctor/extensions.rb#246
  def create_paragraph(*args); end

  # source://asciidoctor//lib/asciidoctor/extensions.rb#246
  def create_pass_block(*args); end

  # Public: Creates a new Section node.
  #
  # Creates a Section node in the same manner as the parser.
  #
  # parent - The parent Section (or Document) of this new Section.
  # title  - The String title of the new Section.
  # attrs  - A Hash of attributes to control how the section is built.
  #          Use the style attribute to set the name of a special section (ex. appendix).
  #          Use the id attribute to assign an explicit ID or set the value to false to
  #          disable automatic ID generation (when sectids document attribute is set).
  # opts   - An optional Hash of options (default: {}):
  #          :level    - [Integer] The level to assign to this section; defaults to
  #                      one greater than the parent level (optional).
  #          :numbered - [Boolean] A flag to force numbering, which falls back to the
  #                      state of the sectnums document attribute (optional).
  #
  # Returns a [Section] node with all properties properly initialized.
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#112
  def create_section(parent, title, attrs, opts = T.unsafe(nil)); end

  # Public: Parses the attrlist String into a Hash of attributes
  #
  # block    - the current AbstractBlock or the parent AbstractBlock if there is no current block (used for applying subs)
  # attrlist - the list of attributes as a String
  # opts     - an optional Hash of options to control processing:
  #            :positional_attributes - an Array of attribute names to map positional arguments to (optional, default: false)
  #            :sub_attributes - enables attribute substitution on the attrlist argument (optional, default: false)
  #
  # Returns a Hash of parsed attributes
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#229
  def parse_attributes(block, attrlist, opts = T.unsafe(nil)); end

  # Public: Parses blocks in the content and attaches the block to the parent.
  #
  # Returns The parent node into which the blocks are parsed.
  # --
  # QUESTION is parse_content the right method name? should we wrap in open block automatically?
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#214
  def parse_content(parent, content, attributes = T.unsafe(nil)); end

  # @raise [::NotImplementedError]
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#89
  def process(*args); end

  # source://asciidoctor//lib/asciidoctor/extensions.rb#85
  def update_config(config); end

  class << self
    # Public: Get the static configuration for this processor class.
    #
    # Returns a configuration [Hash]
    #
    # source://asciidoctor//lib/asciidoctor/extensions.rb#43
    def config; end

    # Mixes the DSL class for this processor into this processor class or instance.
    #
    # This method automatically detects whether to use the include or extend keyword to mix in the module.
    #
    # NOTE Inspiration for this DSL design comes from https://corcoran.io/2013/09/04/simple-pattern-ruby-dsl/
    #
    # Returns self
    #
    # source://asciidoctor//lib/asciidoctor/extensions.rb#66
    def enable_dsl; end

    # Public: Assigns a default value for the specified option that gets
    # applied to all instances of this processor.
    #
    # Examples
    #
    #   option :contexts, [:open, :paragraph]
    #
    # Returns nothing
    #
    # source://asciidoctor//lib/asciidoctor/extensions.rb#55
    def option(key, default_value); end

    # Mixes the DSL class for this processor into this processor class or instance.
    #
    # This method automatically detects whether to use the include or extend keyword to mix in the module.
    #
    # NOTE Inspiration for this DSL design comes from https://corcoran.io/2013/09/04/simple-pattern-ruby-dsl/
    #
    # Returns self
    #
    # source://asciidoctor//lib/asciidoctor/extensions.rb#66
    def use_dsl; end
  end
end

# Internal: Overlays a builder DSL for configuring the Processor instance.
# Includes a method to define configuration options and another to define the
# {Processor#process} method.
#
# source://asciidoctor//lib/asciidoctor/extensions.rb#256
module Asciidoctor::Extensions::ProcessorDsl
  # source://asciidoctor//lib/asciidoctor/extensions.rb#257
  def option(key, value); end

  # source://asciidoctor//lib/asciidoctor/extensions.rb#261
  def process(*args, &block); end

  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#281
  def process_block_given?; end
end

# Public: A specialization of the Extension proxy that additionally stores a
# reference to the {Processor#process} method. By storing this reference, its
# possible to accommodate both concrete extension implementations and Procs.
#
# source://asciidoctor//lib/asciidoctor/extensions.rb#683
class Asciidoctor::Extensions::ProcessorExtension < ::Asciidoctor::Extensions::Extension
  # @return [ProcessorExtension] a new instance of ProcessorExtension
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#686
  def initialize(kind, instance, process_method = T.unsafe(nil)); end

  # Returns the value of attribute process_method.
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#684
  def process_method; end
end

# Public: The primary entry point into the extension system.
#
# Registry holds the extensions which have been registered and activated, has
# methods for registering or defining a processor and looks up extensions
# stored in the registry during parsing.
#
# source://asciidoctor//lib/asciidoctor/extensions.rb#715
class Asciidoctor::Extensions::Registry
  # @return [Registry] a new instance of Registry
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#722
  def initialize(groups = T.unsafe(nil)); end

  # Public: Activates all the global extension {Group}s and the extension {Group}s
  # associated with this registry.
  #
  # document - the {Asciidoctor::Document} on which the extensions are to be used.
  #
  # Returns the instance of this [Registry].
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#735
  def activate(document); end

  # Public: Registers a {BlockProcessor} with the extension registry to
  # process the block content (i.e., delimited block or paragraph) in the
  # AsciiDoc source annotated with the specified block name (i.e., style).
  #
  # The BlockProcessor may be one of four types:
  #
  # * A BlockProcessor subclass
  # * An instance of a BlockProcessor subclass
  # * The String name of a BlockProcessor subclass
  # * A method block (i.e., Proc) that conforms to the BlockProcessor contract
  #
  # Unless the BlockProcessor is passed as the method block, it must be the
  # first argument to this method. The second argument is the name (coersed
  # to a Symbol) of the AsciiDoc block content (i.e., delimited block or
  # paragraph) that this processor is registered to handle. If a block name
  # is not passed as an argument, it gets read from the name property of the
  # BlockProcessor instance. If a name still cannot be determined, an error
  # is raised.
  #
  # Examples
  #
  #   # as a BlockProcessor subclass
  #   block ShoutBlock
  #
  #   # as a BlockProcessor subclass with an explicit block name
  #   block ShoutBlock, :shout
  #
  #   # as an instance of a BlockProcessor subclass
  #   block ShoutBlock.new
  #
  #   # as an instance of a BlockProcessor subclass with an explicit block name
  #   block ShoutBlock.new, :shout
  #
  #   # as a name of a BlockProcessor subclass
  #   block 'ShoutBlock'
  #
  #   # as a name of a BlockProcessor subclass with an explicit block name
  #   block 'ShoutBlock', :shout
  #
  #   # as a method block
  #   block do
  #     named :shout
  #     process do |parent, reader, attrs|
  #       ...
  #     end
  #   end
  #
  #   # as a method block with an explicit block name
  #   block :shout do
  #     process do |parent, reader, attrs|
  #       ...
  #     end
  #   end
  #
  # Returns an instance of the [Extension] proxy object that is stored in the
  # registry and manages the instance of this BlockProcessor.
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#1098
  def block(*args, &block); end

  # Public: Registers a {BlockMacroProcessor} with the extension registry to
  # process a block macro with the specified name.
  #
  # The BlockMacroProcessor may be one of four types:
  #
  # * A BlockMacroProcessor subclass
  # * An instance of a BlockMacroProcessor subclass
  # * The String name of a BlockMacroProcessor subclass
  # * A method block (i.e., Proc) that conforms to the BlockMacroProcessor contract
  #
  # Unless the BlockMacroProcessor is passed as the method block, it must be
  # the first argument to this method. The second argument is the name
  # (coersed to a Symbol) of the AsciiDoc block macro that this processor is
  # registered to handle. If a block macro name is not passed as an argument,
  # it gets read from the name property of the BlockMacroProcessor instance.
  # If a name still cannot be determined, an error is raised.
  #
  # Examples
  #
  #   # as a BlockMacroProcessor subclass
  #   block_macro GistBlockMacro
  #
  #   # as a BlockMacroProcessor subclass with an explicit macro name
  #   block_macro GistBlockMacro, :gist
  #
  #   # as an instance of a BlockMacroProcessor subclass
  #   block_macro GistBlockMacro.new
  #
  #   # as an instance of a BlockMacroProcessor subclass with an explicit macro name
  #   block_macro GistBlockMacro.new, :gist
  #
  #   # as a name of a BlockMacroProcessor subclass
  #   block_macro 'GistBlockMacro'
  #
  #   # as a name of a BlockMacroProcessor subclass with an explicit macro name
  #   block_macro 'GistBlockMacro', :gist
  #
  #   # as a method block
  #   block_macro do
  #     named :gist
  #     process do |parent, target, attrs|
  #       ...
  #     end
  #   end
  #
  #   # as a method block with an explicit macro name
  #   block_macro :gist do
  #     process do |parent, target, attrs|
  #       ...
  #     end
  #   end
  #
  # Returns an instance of the [Extension] proxy object that is stored in the
  # registry and manages the instance of this BlockMacroProcessor.
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#1193
  def block_macro(*args, &block); end

  # Public: Checks whether any {BlockMacroProcessor} extensions have been registered.
  #
  # Returns a [Boolean] indicating whether any BlockMacroProcessor extensions are registered.
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#1200
  def block_macros?; end

  # Public: Checks whether any {BlockProcessor} extensions have been registered.
  #
  # Returns a [Boolean] indicating whether any BlockProcessor extensions are registered.
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#1105
  def blocks?; end

  # Public: Registers an {DocinfoProcessor} with the extension registry to
  # add additional docinfo to the document.
  #
  # The DocinfoProcessor may be one of four types:
  #
  # * A DocinfoProcessor subclass
  # * An instance of a DocinfoProcessor subclass
  # * The String name of a DocinfoProcessor subclass
  # * A method block (i.e., Proc) that conforms to the DocinfoProcessor contract
  #
  # Unless the DocinfoProcessor is passed as the method block, it must be the
  # first argument to this method.
  #
  # Examples
  #
  #   # as an DocinfoProcessor subclass
  #   docinfo_processor MetaRobotsDocinfoProcessor
  #
  #   # as an instance of a DocinfoProcessor subclass with an explicit location
  #   docinfo_processor JQueryDocinfoProcessor.new, location: :footer
  #
  #   # as a name of a DocinfoProcessor subclass
  #   docinfo_processor 'MetaRobotsDocinfoProcessor'
  #
  #   # as a method block
  #   docinfo_processor do
  #     process do |doc|
  #       at_location :footer
  #       'footer content'
  #     end
  #   end
  #
  # Returns the [Extension] stored in the registry that proxies the
  # instance of this DocinfoProcessor.
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#1005
  def docinfo_processor(*args, &block); end

  # Public: Retrieves the {Extension} proxy objects for all the
  # DocinfoProcessor instances stored in this registry.
  #
  # location - A Symbol for selecting docinfo extensions at a given location (:head or :footer) (default: nil)
  #
  # Returns an [Array] of Extension proxy objects.
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#1032
  def docinfo_processors(location = T.unsafe(nil)); end

  # Public: Checks whether any {DocinfoProcessor} extensions have been registered.
  #
  # location - A Symbol for selecting docinfo extensions at a given location (:head or :footer) (default: nil)
  #
  # Returns a [Boolean] indicating whether any DocinfoProcessor extensions are registered.
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#1014
  def docinfo_processors?(location = T.unsafe(nil)); end

  # Public: Returns the {Asciidoctor::Document} on which the extensions in this registry are being used.
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#717
  def document; end

  # Public: Retrieves the {Extension} proxy object for the BlockProcessor registered
  # to handle block content with the name.
  #
  # name - the String or Symbol (coersed to a Symbol) macro name
  #
  # This method assumes you've called blocks? first to check whether any
  # block extensions are registered.
  #
  # Returns the [Extension] object stored in the registry that proxies the
  # corresponding BlockProcessor or nil if a match is not found.
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#1135
  def find_block_extension(name); end

  # Public: Retrieves the {Extension} proxy object for the BlockMacroProcessor registered
  # to handle a block macro with the specified name.
  #
  # name - the String or Symbol (coersed to a Symbol) macro name
  #
  # This method assumes you've called block_macros? first to check whether any
  # block macro extensions are registered.
  #
  # Returns the [Extension] object stored in the registry that proxies the
  # corresponding BlockMacroProcessor or nil if a match is not found.
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#1230
  def find_block_macro_extension(name); end

  # Public: Retrieves the {Extension} proxy object for the InlineMacroProcessor registered
  # to handle an inline macro with the specified name.
  #
  # name - the String or Symbol (coersed to a Symbol) macro name
  #
  # This method assumes you've called inline_macros? first to check whether any
  # inline macro extensions are registered.
  #
  # Returns the [Extension] object stored in the registry that proxies the
  # corresponding InlineMacroProcessor or nil if a match is not found.
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#1323
  def find_inline_macro_extension(name); end

  # Public: Returns the Hash of {Group} classes, instances, and/or Procs that have been registered with this registry.
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#720
  def groups; end

  # Public: Registers an {IncludeProcessor} with the extension registry to have
  # a shot at handling the include directive.
  #
  # The IncludeProcessor may be one of four types:
  #
  # * A IncludeProcessor subclass
  # * An instance of a IncludeProcessor subclass
  # * The String name of a IncludeProcessor subclass
  # * A method block (i.e., Proc) that conforms to the IncludeProcessor contract
  #
  # Unless the IncludeProcessor is passed as the method block, it must be the
  # first argument to this method.
  #
  # Examples
  #
  #   # as an IncludeProcessor subclass
  #   include_processor GitIncludeProcessor
  #
  #   # as an instance of a Postprocessor subclass
  #   include_processor GitIncludeProcessor.new
  #
  #   # as a name of a Postprocessor subclass
  #   include_processor 'GitIncludeProcessor'
  #
  #   # as a method block
  #   include_processor do
  #     process do |document, output|
  #       ...
  #     end
  #   end
  #
  # Returns the [Extension] stored in the registry that proxies the
  # instance of this IncludeProcessor.
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#952
  def include_processor(*args, &block); end

  # Public: Retrieves the {Extension} proxy objects for all the
  # IncludeProcessor instances stored in this registry.
  #
  # Returns an [Array] of Extension proxy objects.
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#967
  def include_processors; end

  # Public: Checks whether any {IncludeProcessor} extensions have been registered.
  #
  # Returns a [Boolean] indicating whether any IncludeProcessor extensions are registered.
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#959
  def include_processors?; end

  # Public: Registers a {InlineMacroProcessor} with the extension registry to
  # process an inline macro with the specified name.
  #
  # The InlineMacroProcessor may be one of four types:
  #
  # * An InlineMacroProcessor subclass
  # * An instance of an InlineMacroProcessor subclass
  # * The String name of an InlineMacroProcessor subclass
  # * A method block (i.e., Proc) that conforms to the InlineMacroProcessor contract
  #
  # Unless the InlineMacroProcessor is passed as the method block, it must be
  # the first argument to this method. The second argument is the name
  # (coersed to a Symbol) of the AsciiDoc block macro that this processor is
  # registered to handle. If a block macro name is not passed as an argument,
  # it gets read from the name property of the InlineMacroProcessor instance.
  # If a name still cannot be determined, an error is raised.
  #
  # Examples
  #
  #   # as an InlineMacroProcessor subclass
  #   inline_macro ChromeInlineMacro
  #
  #   # as an InlineMacroProcessor subclass with an explicit macro name
  #   inline_macro ChromeInlineMacro, :chrome
  #
  #   # as an instance of an InlineMacroProcessor subclass
  #   inline_macro ChromeInlineMacro.new
  #
  #   # as an instance of an InlineMacroProcessor subclass with an explicit macro name
  #   inline_macro ChromeInlineMacro.new, :chrome
  #
  #   # as a name of an InlineMacroProcessor subclass
  #   inline_macro 'ChromeInlineMacro'
  #
  #   # as a name of an InlineMacroProcessor subclass with an explicit macro name
  #   inline_macro 'ChromeInlineMacro', :chrome
  #
  #   # as a method block
  #   inline_macro do
  #     named :chrome
  #     process do |parent, target, attrs|
  #       ...
  #     end
  #   end
  #
  #   # as a method block with an explicit macro name
  #   inline_macro :chrome do
  #     process do |parent, target, attrs|
  #       ...
  #     end
  #   end
  #
  # Returns an instance of the [Extension] proxy object that is stored in the
  # registry and manages the instance of this InlineMacroProcessor.
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#1288
  def inline_macro(*args, &block); end

  # Public: Retrieves the {Extension} proxy objects for all
  # InlineMacroProcessor instances in this registry.
  #
  # This method assumes you've called inline_macros? first to check whether any
  # inline macro extensions are registered.
  #
  # Returns an [Array] of Extension proxy objects.
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#1334
  def inline_macros; end

  # Public: Checks whether any {InlineMacroProcessor} extensions have been registered.
  #
  # Returns a [Boolean] indicating whether any IncludeMacroProcessor extensions are registered.
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#1295
  def inline_macros?; end

  # Public: Registers a {Postprocessor} with the extension registry to process
  # the output after conversion is complete.
  #
  # The Postprocessor may be one of four types:
  #
  # * A Postprocessor subclass
  # * An instance of a Postprocessor subclass
  # * The String name of a Postprocessor subclass
  # * A method block (i.e., Proc) that conforms to the Postprocessor contract
  #
  # Unless the Postprocessor is passed as the method block, it must be the
  # first argument to this method.
  #
  # Examples
  #
  #   # as a Postprocessor subclass
  #   postprocessor AnalyticsPostprocessor
  #
  #   # as an instance of a Postprocessor subclass
  #   postprocessor AnalyticsPostprocessor.new
  #
  #   # as a name of a Postprocessor subclass
  #   postprocessor 'AnalyticsPostprocessor'
  #
  #   # as a method block
  #   postprocessor do
  #     process do |document, output|
  #       ...
  #     end
  #   end
  #
  # Returns the [Extension] stored in the registry that proxies the
  # instance of this Postprocessor.
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#900
  def postprocessor(*args, &block); end

  # Public: Retrieves the {Extension} proxy objects for all
  # Postprocessor instances in this registry.
  #
  # Returns an [Array] of Extension proxy objects.
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#915
  def postprocessors; end

  # Public: Checks whether any {Postprocessor} extensions have been registered.
  #
  # Returns a [Boolean] indicating whether any Postprocessor extensions are registered.
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#907
  def postprocessors?; end

  # Public: Inserts the document processor {Extension} instance as the first
  # processor of its kind in the extension registry.
  #
  # Examples
  #
  #   prefer :include_processor do
  #     process do |document, reader, target, attrs|
  #       ...
  #     end
  #   end
  #
  # Returns the [Extension] stored in the registry that proxies the instance
  # of this processor.
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#1351
  def prefer(*args, &block); end

  # Public: Registers a {Preprocessor} with the extension registry to process
  # the AsciiDoc source before parsing begins.
  #
  # The Preprocessor may be one of four types:
  #
  # * A Preprocessor subclass
  # * An instance of a Preprocessor subclass
  # * The String name of a Preprocessor subclass
  # * A method block (i.e., Proc) that conforms to the Preprocessor contract
  #
  # Unless the Preprocessor is passed as the method block, it must be the
  # first argument to this method.
  #
  # Examples
  #
  #   # as a Preprocessor subclass
  #   preprocessor FrontMatterPreprocessor
  #
  #   # as an instance of a Preprocessor subclass
  #   preprocessor FrontMatterPreprocessor.new
  #
  #   # as a name of a Preprocessor subclass
  #   preprocessor 'FrontMatterPreprocessor'
  #
  #   # as a method block
  #   preprocessor do
  #     process do |doc, reader|
  #       ...
  #     end
  #   end
  #
  # Returns the [Extension] stored in the registry that proxies the
  # instance of this Preprocessor.
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#791
  def preprocessor(*args, &block); end

  # Public: Retrieves the {Extension} proxy objects for all
  # Preprocessor instances in this registry.
  #
  # Returns an [Array] of Extension proxy objects.
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#806
  def preprocessors; end

  # Public: Checks whether any {Preprocessor} extensions have been registered.
  #
  # Returns a [Boolean] indicating whether any Preprocessor extensions are registered.
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#798
  def preprocessors?; end

  # Public: Checks whether any {BlockProcessor} extensions are registered to
  # handle the specified block name appearing on the specified context.
  #
  # This method assumes you've called blocks? first to check whether any
  # block extensions are registered.
  #
  # Returns the [Extension] proxy object for the BlockProcessor that matches
  # the block name and context or false if no match is found.
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#1117
  def registered_for_block?(name, context); end

  # Public: Checks whether any {BlockMacroProcessor} extensions are registered to
  # handle the block macro with the specified name.
  #
  # name - the String or Symbol (coersed to a Symbol) macro name
  #
  # This method assumes you've called block_macros? first to check whether any
  # block macro extensions are registered.
  #
  # Returns the [Extension] proxy object for the BlockMacroProcessor that matches
  # the macro name or false if no match is found.
  # --
  # TODO only allow blank target if format is :short
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#1216
  def registered_for_block_macro?(name); end

  # Public: Checks whether any {InlineMacroProcessor} extensions are registered to
  # handle the inline macro with the specified name.
  #
  # name - the String or Symbol (coersed to a Symbol) macro name
  #
  # This method assumes you've called inline_macros? first to check whether any
  # inline macro extensions are registered.
  #
  # Returns the [Extension] proxy object for the InlineMacroProcessor that matches
  # the macro name or false if no match is found.
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#1309
  def registered_for_inline_macro?(name); end

  # Public: Registers a {TreeProcessor} with the extension registry to process
  # the AsciiDoc source after parsing is complete.
  #
  # The TreeProcessor may be one of four types:
  #
  # * A TreeProcessor subclass
  # * An instance of a TreeProcessor subclass
  # * The String name of a TreeProcessor subclass
  # * A method block (i.e., Proc) that conforms to the TreeProcessor contract
  #
  # Unless the TreeProcessor is passed as the method block, it must be the
  # first argument to this method.
  #
  # Examples
  #
  #   # as a TreeProcessor subclass
  #   tree_processor ShellTreeProcessor
  #
  #   # as an instance of a TreeProcessor subclass
  #   tree_processor ShellTreeProcessor.new
  #
  #   # as a name of a TreeProcessor subclass
  #   tree_processor 'ShellTreeProcessor'
  #
  #   # as a method block
  #   tree_processor do
  #     process do |document|
  #       ...
  #     end
  #   end
  #
  # Returns the [Extension] stored in the registry that proxies the
  # instance of this TreeProcessor.
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#843
  def tree_processor(*args, &block); end

  # Public: Retrieves the {Extension} proxy objects for all
  # TreeProcessor instances in this registry.
  #
  # Returns an [Array] of Extension proxy objects.
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#858
  def tree_processors; end

  # Public: Checks whether any {TreeProcessor} extensions have been registered.
  #
  # Returns a [Boolean] indicating whether any TreeProcessor extensions are registered.
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#850
  def tree_processors?; end

  # Public: Registers a {TreeProcessor} with the extension registry to process
  # the AsciiDoc source after parsing is complete.
  #
  # The TreeProcessor may be one of four types:
  #
  # * A TreeProcessor subclass
  # * An instance of a TreeProcessor subclass
  # * The String name of a TreeProcessor subclass
  # * A method block (i.e., Proc) that conforms to the TreeProcessor contract
  #
  # Unless the TreeProcessor is passed as the method block, it must be the
  # first argument to this method.
  #
  # Examples
  #
  #   # as a TreeProcessor subclass
  #   tree_processor ShellTreeProcessor
  #
  #   # as an instance of a TreeProcessor subclass
  #   tree_processor ShellTreeProcessor.new
  #
  #   # as a name of a TreeProcessor subclass
  #   tree_processor 'ShellTreeProcessor'
  #
  #   # as a method block
  #   tree_processor do
  #     process do |document|
  #       ...
  #     end
  #   end
  #
  # Returns the [Extension] stored in the registry that proxies the
  # instance of this TreeProcessor.
  # Alias deprecated methods for backwards compatibility
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#843
  def treeprocessor(*args, &block); end

  # Public: Retrieves the {Extension} proxy objects for all
  # TreeProcessor instances in this registry.
  #
  # Returns an [Array] of Extension proxy objects.
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#858
  def treeprocessors; end

  # Public: Checks whether any {TreeProcessor} extensions have been registered.
  #
  # Returns a [Boolean] indicating whether any TreeProcessor extensions are registered.
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#850
  def treeprocessors?; end

  private

  # source://asciidoctor//lib/asciidoctor/extensions.rb#1360
  def add_document_processor(kind, args, &block); end

  # source://asciidoctor//lib/asciidoctor/extensions.rb#1404
  def add_syntax_processor(kind, args, &block); end

  # source://asciidoctor//lib/asciidoctor/extensions.rb#1472
  def as_symbol(name); end

  # source://asciidoctor//lib/asciidoctor/extensions.rb#1455
  def reset; end

  # source://asciidoctor//lib/asciidoctor/extensions.rb#1460
  def resolve_args(args, expect); end
end

# source://asciidoctor//lib/asciidoctor/extensions.rb#294
module Asciidoctor::Extensions::SyntaxProcessorDsl
  include ::Asciidoctor::Extensions::ProcessorDsl

  # source://asciidoctor//lib/asciidoctor/extensions.rb#306
  def content_model(value); end

  # source://asciidoctor//lib/asciidoctor/extensions.rb#318
  def default_attributes(value); end

  # NOTE default_attrs alias is deprecated
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#318
  def default_attrs(value); end

  # source://asciidoctor//lib/asciidoctor/extensions.rb#311
  def name_positional_attributes(*value); end

  # source://asciidoctor//lib/asciidoctor/extensions.rb#297
  def named(value); end

  # source://asciidoctor//lib/asciidoctor/extensions.rb#306
  def parse_content_as(value); end

  # source://asciidoctor//lib/asciidoctor/extensions.rb#311
  def positional_attributes(*value); end

  # NOTE positional_attrs alias is deprecated
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#311
  def positional_attrs(*value); end

  # source://asciidoctor//lib/asciidoctor/extensions.rb#324
  def resolve_attributes(*args); end

  # NOTE resolves_attributes alias is deprecated
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#324
  def resolves_attributes(*args); end
end

# Public: TreeProcessors are run on the Document after the source has been
# parsed into an abstract syntax tree (AST), as represented by the Document
# object and its child Node objects (e.g., Section, Block, List, ListItem).
#
# Asciidoctor invokes the {Processor#process} method on an instance of each
# registered TreeProcessor.
#
# TreeProcessor implementations must extend TreeProcessor.
# --
# QUESTION should the tree processor get invoked after parse header too?
#
# source://asciidoctor//lib/asciidoctor/extensions.rb#404
class Asciidoctor::Extensions::TreeProcessor < ::Asciidoctor::Extensions::Processor
  # @raise [::NotImplementedError]
  #
  # source://asciidoctor//lib/asciidoctor/extensions.rb#405
  def process(document); end
end

# source://asciidoctor//lib/asciidoctor/extensions.rb#409
Asciidoctor::Extensions::TreeProcessor::DSL = Asciidoctor::Extensions::DocumentProcessorDsl

# Alias deprecated class name for backwards compatibility
#
# source://asciidoctor//lib/asciidoctor/extensions.rb#412
Asciidoctor::Extensions::Treeprocessor = Asciidoctor::Extensions::TreeProcessor

# The mode to use when opening a file for reading
#
# source://asciidoctor//lib/asciidoctor.rb#211
Asciidoctor::FILE_READ_MODE = T.let(T.unsafe(nil), String)

# The mode to use when opening a file for writing
#
# source://asciidoctor//lib/asciidoctor.rb#217
Asciidoctor::FILE_WRITE_MODE = T.let(T.unsafe(nil), String)

# attributes which be changed throughout the flow of the document (e.g., sectnums)
#
# source://asciidoctor//lib/asciidoctor.rb#390
Asciidoctor::FLEXIBLE_ATTRIBUTES = T.let(T.unsafe(nil), Array)

# source://asciidoctor//lib/asciidoctor.rb#357
Asciidoctor::FONT_AWESOME_VERSION = T.let(T.unsafe(nil), String)

# NOTE AsciiDoc.py allows + to be preceded by TAB; Asciidoctor does not
#
# source://asciidoctor//lib/asciidoctor.rb#335
Asciidoctor::HARD_LINE_BREAK = T.let(T.unsafe(nil), String)

# source://asciidoctor//lib/asciidoctor.rb#359
Asciidoctor::HIGHLIGHT_JS_VERSION = T.let(T.unsafe(nil), String)

# source://asciidoctor//lib/asciidoctor.rb#311
Asciidoctor::HYBRID_LAYOUT_BREAK_CHARS = T.let(T.unsafe(nil), Hash)

# NOTE In Ruby, ^ and $ always match start and end of line
#
# source://asciidoctor//lib/asciidoctor/rx.rb#627
Asciidoctor::HardLineBreakRx = T.let(T.unsafe(nil), Regexp)

# Internal: Except where noted, a module that contains internal helper functions.
#
# source://asciidoctor//lib/asciidoctor/helpers.rb#4
module Asciidoctor::Helpers
  private

  # Public: Retrieves the basename of the filename, optionally removing the extension, if present
  #
  # filename - The String file name to process.
  # drop_ext - A Boolean flag indicating whether to drop the extension
  #            or an explicit String extension to drop (default: nil).
  #
  # Examples
  #
  #   Helpers.basename 'images/tiger.png', true
  #   # => "tiger"
  #
  #   Helpers.basename 'images/tiger.png', '.png'
  #   # => "tiger"
  #
  # Returns the String filename with leading directories removed and, if specified, the extension removed
  #
  # source://asciidoctor//lib/asciidoctor/helpers.rb#200
  def basename(filename, drop_ext = T.unsafe(nil)); end

  # Internal: Resolves a Class object (not a Module) for the qualified name.
  #
  # Returns Class
  #
  # source://asciidoctor//lib/asciidoctor/helpers.rb#306
  def class_for_name(qualified_name); end

  # Internal: Apply URI path encoding to spaces in the specified string (i.e., convert spaces to %20).
  #
  # str - the String to encode
  #
  # Returns the specified String with all spaces replaced with %20.
  #
  # source://asciidoctor//lib/asciidoctor/helpers.rb#163
  def encode_spaces_in_uri(str); end

  # source://asciidoctor//lib/asciidoctor/helpers.rb#149
  def encode_uri_component(str); end

  # source://asciidoctor//lib/asciidoctor/helpers.rb#235
  def extname(path, fallback = T.unsafe(nil)); end

  # Public: Returns whether this path has a file extension.
  #
  # path - The path String to check; expects a posix path
  #
  # Returns true if the path has a file extension, false otherwise
  #
  # source://asciidoctor//lib/asciidoctor/helpers.rb#213
  def extname?(path); end

  # Internal: Converts an integer to a Roman numeral.
  #
  # val - the [Integer] value to convert
  #
  # Returns the [String] roman numeral for this integer
  #
  # source://asciidoctor//lib/asciidoctor/helpers.rb#269
  def int_to_roman(val); end

  # Internal: Make a directory, ensuring all parent directories exist.
  #
  # source://asciidoctor//lib/asciidoctor/helpers.rb#245
  def mkdir_p(dir); end

  # Internal: Get the next value in the sequence.
  #
  # Handles both integer and character sequences.
  #
  # current - the value to increment as a String or Integer
  #
  # returns the next value in the sequence according to the current value's type
  #
  # source://asciidoctor//lib/asciidoctor/helpers.rb#283
  def nextval(current); end

  # Internal: Prepare the source data Array for parsing.
  #
  # Encodes the data to UTF-8, if necessary, and removes any trailing
  # whitespace from every line.
  #
  # If a BOM is found at the beginning of the data, a best attempt is made to
  # encode it to UTF-8 from the specified source encoding.
  #
  # data     - the source data Array to prepare (no nil entries allowed)
  # trim_end - whether to trim whitespace from the end of each line;
  #            (true cleans all whitespace; false only removes trailing newline) (default: true)
  #
  # returns a String Array of prepared lines
  #
  # source://asciidoctor//lib/asciidoctor/helpers.rb#64
  def prepare_source_array(data, trim_end = T.unsafe(nil)); end

  # Internal: Prepare the source data String for parsing.
  #
  # Encodes the data to UTF-8, if necessary, splits it into an array, and
  # removes any trailing whitespace from every line.
  #
  # If a BOM is found at the beginning of the data, a best attempt is made to
  # encode it to UTF-8 from the specified source encoding.
  #
  # data     - the source data String to prepare
  # trim_end - whether to trim whitespace from the end of each line;
  #            (true cleans all whitespace; false only removes trailing newline) (default: true)
  #
  # returns a String Array of prepared lines
  #
  # source://asciidoctor//lib/asciidoctor/helpers.rb#96
  def prepare_source_string(data, trim_end = T.unsafe(nil)); end

  # Public: Require the specified library using Kernel#require.
  #
  # Attempts to load the library specified in the first argument using the
  # Kernel#require. Rescues the LoadError if the library is not available and
  # passes a message to Kernel#raise if on_failure is :abort or Kernel#warn if
  # on_failure is :warn to communicate to the user that processing is being
  # aborted or functionality is disabled, respectively. If a gem_name is
  # specified, the message communicates that a required gem is not available.
  #
  # name       - the String name of the library to require.
  # gem_name   - a Boolean that indicates whether this library is provided by a RubyGem,
  #              or the String name of the RubyGem if it differs from the library name
  #              (default: true)
  # on_failure - a Symbol that indicates how to handle a load failure (:abort, :warn, :ignore) (default: :abort)
  #
  # Returns The [Boolean] return value of Kernel#require if the library can be loaded.
  # Otherwise, if on_failure is :abort, Kernel#raise is called with an appropriate message.
  # Otherwise, if on_failure is :warn, Kernel#warn is called with an appropriate message and nil returned.
  # Otherwise, nil is returned.
  #
  # source://asciidoctor//lib/asciidoctor/helpers.rb#26
  def require_library(name, gem_name = T.unsafe(nil), on_failure = T.unsafe(nil)); end

  # Internal: Resolve the specified object as a Class
  #
  # object - The Object to resolve as a Class
  #
  # Returns a Class if the specified object is a Class (but not a Module) or
  # a String that resolves to a Class; otherwise, nil
  #
  # source://asciidoctor//lib/asciidoctor/helpers.rb#299
  def resolve_class(object); end

  # Public: Removes the file extension from filename and returns the result
  #
  # filename - The String file name to process; expected to be a posix path
  #
  # Examples
  #
  #   Helpers.rootname 'part1/chapter1.adoc'
  #   # => "part1/chapter1"
  #
  # Returns the String filename with the file extension removed
  #
  # source://asciidoctor//lib/asciidoctor/helpers.rb#177
  def rootname(filename); end

  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/helpers.rb#128
  def uriish?(str); end

  class << self
    # Public: Retrieves the basename of the filename, optionally removing the extension, if present
    #
    # filename - The String file name to process.
    # drop_ext - A Boolean flag indicating whether to drop the extension
    #            or an explicit String extension to drop (default: nil).
    #
    # Examples
    #
    #   Helpers.basename 'images/tiger.png', true
    #   # => "tiger"
    #
    #   Helpers.basename 'images/tiger.png', '.png'
    #   # => "tiger"
    #
    # Returns the String filename with leading directories removed and, if specified, the extension removed
    #
    # source://asciidoctor//lib/asciidoctor/helpers.rb#200
    def basename(filename, drop_ext = T.unsafe(nil)); end

    # Internal: Resolves a Class object (not a Module) for the qualified name.
    #
    # Returns Class
    #
    # source://asciidoctor//lib/asciidoctor/helpers.rb#306
    def class_for_name(qualified_name); end

    # Internal: Apply URI path encoding to spaces in the specified string (i.e., convert spaces to %20).
    #
    # str - the String to encode
    #
    # Returns the specified String with all spaces replaced with %20.
    #
    # source://asciidoctor//lib/asciidoctor/helpers.rb#163
    def encode_spaces_in_uri(str); end

    # source://asciidoctor//lib/asciidoctor/helpers.rb#149
    def encode_uri_component(str); end

    # source://asciidoctor//lib/asciidoctor/helpers.rb#235
    def extname(path, fallback = T.unsafe(nil)); end

    # Public: Returns whether this path has a file extension.
    #
    # path - The path String to check; expects a posix path
    #
    # Returns true if the path has a file extension, false otherwise
    #
    # @return [Boolean]
    #
    # source://asciidoctor//lib/asciidoctor/helpers.rb#213
    def extname?(path); end

    # Internal: Converts an integer to a Roman numeral.
    #
    # val - the [Integer] value to convert
    #
    # Returns the [String] roman numeral for this integer
    #
    # source://asciidoctor//lib/asciidoctor/helpers.rb#269
    def int_to_roman(val); end

    # Internal: Make a directory, ensuring all parent directories exist.
    #
    # source://asciidoctor//lib/asciidoctor/helpers.rb#245
    def mkdir_p(dir); end

    # Internal: Get the next value in the sequence.
    #
    # Handles both integer and character sequences.
    #
    # current - the value to increment as a String or Integer
    #
    # returns the next value in the sequence according to the current value's type
    #
    # source://asciidoctor//lib/asciidoctor/helpers.rb#283
    def nextval(current); end

    # Internal: Prepare the source data Array for parsing.
    #
    # Encodes the data to UTF-8, if necessary, and removes any trailing
    # whitespace from every line.
    #
    # If a BOM is found at the beginning of the data, a best attempt is made to
    # encode it to UTF-8 from the specified source encoding.
    #
    # data     - the source data Array to prepare (no nil entries allowed)
    # trim_end - whether to trim whitespace from the end of each line;
    #            (true cleans all whitespace; false only removes trailing newline) (default: true)
    #
    # returns a String Array of prepared lines
    #
    # source://asciidoctor//lib/asciidoctor/helpers.rb#64
    def prepare_source_array(data, trim_end = T.unsafe(nil)); end

    # Internal: Prepare the source data String for parsing.
    #
    # Encodes the data to UTF-8, if necessary, splits it into an array, and
    # removes any trailing whitespace from every line.
    #
    # If a BOM is found at the beginning of the data, a best attempt is made to
    # encode it to UTF-8 from the specified source encoding.
    #
    # data     - the source data String to prepare
    # trim_end - whether to trim whitespace from the end of each line;
    #            (true cleans all whitespace; false only removes trailing newline) (default: true)
    #
    # returns a String Array of prepared lines
    #
    # source://asciidoctor//lib/asciidoctor/helpers.rb#96
    def prepare_source_string(data, trim_end = T.unsafe(nil)); end

    # Public: Require the specified library using Kernel#require.
    #
    # Attempts to load the library specified in the first argument using the
    # Kernel#require. Rescues the LoadError if the library is not available and
    # passes a message to Kernel#raise if on_failure is :abort or Kernel#warn if
    # on_failure is :warn to communicate to the user that processing is being
    # aborted or functionality is disabled, respectively. If a gem_name is
    # specified, the message communicates that a required gem is not available.
    #
    # name       - the String name of the library to require.
    # gem_name   - a Boolean that indicates whether this library is provided by a RubyGem,
    #              or the String name of the RubyGem if it differs from the library name
    #              (default: true)
    # on_failure - a Symbol that indicates how to handle a load failure (:abort, :warn, :ignore) (default: :abort)
    #
    # Returns The [Boolean] return value of Kernel#require if the library can be loaded.
    # Otherwise, if on_failure is :abort, Kernel#raise is called with an appropriate message.
    # Otherwise, if on_failure is :warn, Kernel#warn is called with an appropriate message and nil returned.
    # Otherwise, nil is returned.
    #
    # source://asciidoctor//lib/asciidoctor/helpers.rb#26
    def require_library(name, gem_name = T.unsafe(nil), on_failure = T.unsafe(nil)); end

    # Internal: Resolve the specified object as a Class
    #
    # object - The Object to resolve as a Class
    #
    # Returns a Class if the specified object is a Class (but not a Module) or
    # a String that resolves to a Class; otherwise, nil
    #
    # source://asciidoctor//lib/asciidoctor/helpers.rb#299
    def resolve_class(object); end

    # Public: Removes the file extension from filename and returns the result
    #
    # filename - The String file name to process; expected to be a posix path
    #
    # Examples
    #
    #   Helpers.rootname 'part1/chapter1.adoc'
    #   # => "part1/chapter1"
    #
    # Returns the String filename with the file extension removed
    #
    # source://asciidoctor//lib/asciidoctor/helpers.rb#177
    def rootname(filename); end

    # source://asciidoctor//lib/asciidoctor/helpers.rb#128
    def uriish?(str); end
  end
end

# source://asciidoctor//lib/asciidoctor/helpers.rb#148
Asciidoctor::Helpers::CGI = CGI

# source://asciidoctor//lib/asciidoctor/helpers.rb#258
Asciidoctor::Helpers::ROMAN_NUMERALS = T.let(T.unsafe(nil), Hash)

# source://asciidoctor//lib/asciidoctor.rb#346
Asciidoctor::INLINE_MATH_DELIMITERS = T.let(T.unsafe(nil), Hash)

# source://asciidoctor//lib/asciidoctor.rb#392
Asciidoctor::INTRINSIC_ATTRIBUTES = T.let(T.unsafe(nil), Hash)

# Matches an include preprocessor directive.
#
# Examples
#
#   include::chapter1.ad[]
#   include::example.txt[lines=1;2;5..10]
#
# source://asciidoctor//lib/asciidoctor/rx.rb#92
Asciidoctor::IncludeDirectiveRx = T.let(T.unsafe(nil), Regexp)

# Public: Methods for managing inline elements in AsciiDoc block
#
# source://asciidoctor//lib/asciidoctor/inline.rb#4
class Asciidoctor::Inline < ::Asciidoctor::AbstractNode
  # @return [Inline] a new instance of Inline
  #
  # source://asciidoctor//lib/asciidoctor/inline.rb#14
  def initialize(parent, context, text = T.unsafe(nil), opts = T.unsafe(nil)); end

  # Public: Returns the converted alt text for this inline image.
  #
  # Returns the [String] value of the alt attribute.
  #
  # source://asciidoctor//lib/asciidoctor/inline.rb#41
  def alt; end

  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/inline.rb#23
  def block?; end

  # source://asciidoctor//lib/asciidoctor/inline.rb#31
  def convert; end

  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/inline.rb#27
  def inline?; end

  # For a reference node (:ref or :bibref), the text is the reftext (and the reftext attribute is not set).
  #
  # (see AbstractNode#reftext)
  #
  # source://asciidoctor//lib/asciidoctor/inline.rb#55
  def reftext; end

  # For a reference node (:ref or :bibref), the text is the reftext (and the reftext attribute is not set).
  #
  # (see AbstractNode#reftext?)
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/inline.rb#48
  def reftext?; end

  # Deprecated: Use {Inline#convert} instead.
  #
  # source://asciidoctor//lib/asciidoctor/inline.rb#31
  def render; end

  # Public: Get/Set the target (e.g., uri) of this inline element
  #
  # source://asciidoctor//lib/asciidoctor/inline.rb#12
  def target; end

  # Public: Get/Set the target (e.g., uri) of this inline element
  #
  # source://asciidoctor//lib/asciidoctor/inline.rb#12
  def target=(_arg0); end

  # Public: Get the text of this inline element
  #
  # source://asciidoctor//lib/asciidoctor/inline.rb#6
  def text; end

  # Public: Get the text of this inline element
  #
  # source://asciidoctor//lib/asciidoctor/inline.rb#6
  def text=(_arg0); end

  # Public: Get the type (qualifier) of this inline element
  #
  # source://asciidoctor//lib/asciidoctor/inline.rb#9
  def type; end

  # Public: Generate cross reference text (xreftext) that can be used to refer
  # to this inline node.
  #
  # Use the explicit reftext for this inline node, if specified, retrieved by
  # calling the reftext method. Otherwise, returns nil.
  #
  # xrefstyle - Not currently used (default: nil).
  #
  # Returns the [String] reftext to refer to this inline node or nothing if no
  # reftext is defined.
  #
  # source://asciidoctor//lib/asciidoctor/inline.rb#69
  def xreftext(xrefstyle = T.unsafe(nil)); end
end

# Matches an anchor (i.e., id + optional reference text) in the flow of text.
#
# Examples
#
#   [[idname]]
#   [[idname,Reference Text]]
#   anchor:idname[]
#   anchor:idname[Reference Text]
#
# source://asciidoctor//lib/asciidoctor/rx.rb#443
Asciidoctor::InlineAnchorRx = T.let(T.unsafe(nil), Regexp)

# Scans for a non-escaped anchor (i.e., id + optional reference text) in the flow of text.
#
# source://asciidoctor//lib/asciidoctor/rx.rb#446
Asciidoctor::InlineAnchorScanRx = T.let(T.unsafe(nil), Regexp)

# Matches a bibliography anchor at the start of the list item text (in a bibliography list).
#
# Examples
#
#   [[[Fowler_1997]]] Fowler M. ...
#
# source://asciidoctor//lib/asciidoctor/rx.rb#457
Asciidoctor::InlineBiblioAnchorRx = T.let(T.unsafe(nil), Regexp)

# Matches an inline e-mail address.
#
#   doc.writer@example.com
#
# source://asciidoctor//lib/asciidoctor/rx.rb#463
Asciidoctor::InlineEmailRx = T.let(T.unsafe(nil), Regexp)

# Matches an inline footnote macro, which is allowed to span multiple lines.
#
# Examples
#   footnote:[text] (not referenceable)
#   footnote:id[text] (referenceable)
#   footnote:id[] (reference)
#   footnoteref:[id,text] (legacy)
#   footnoteref:[id] (legacy)
#
# source://asciidoctor//lib/asciidoctor/rx.rb#474
Asciidoctor::InlineFootnoteMacroRx = T.let(T.unsafe(nil), Regexp)

# Matches an image or icon inline macro.
#
# Examples
#
#   image:filename.png[Alt Text]
#   image:http://example.com/images/filename.png[Alt Text]
#   image:filename.png[More [Alt\] Text] (alt text becomes "More [Alt] Text")
#   icon:github[large]
#
# NOTE be as non-greedy as possible by not allowing newline or left square bracket in target
#
# source://asciidoctor//lib/asciidoctor/rx.rb#486
Asciidoctor::InlineImageMacroRx = T.let(T.unsafe(nil), Regexp)

# Matches an indexterm inline macro, which may span multiple lines.
#
# Examples
#
#   indexterm:[Tigers,Big cats]
#   (((Tigers,Big cats)))
#   indexterm2:[Tigers]
#   ((Tigers))
#
# source://asciidoctor//lib/asciidoctor/rx.rb#497
Asciidoctor::InlineIndextermMacroRx = T.let(T.unsafe(nil), Regexp)

# Matches either the kbd or btn inline macro.
#
# Examples
#
#   kbd:[F3]
#   kbd:[Ctrl+Shift+T]
#   kbd:[Ctrl+\]]
#   kbd:[Ctrl,T]
#   btn:[Save]
#
# source://asciidoctor//lib/asciidoctor/rx.rb#509
Asciidoctor::InlineKbdBtnMacroRx = T.let(T.unsafe(nil), Regexp)

# Match a link or e-mail inline macro.
#
# Examples
#
#   link:path[label]
#   mailto:doc.writer@example.com[]
#
# NOTE be as non-greedy as possible by not allowing space or left square bracket in target
#
# source://asciidoctor//lib/asciidoctor/rx.rb#537
Asciidoctor::InlineLinkMacroRx = T.let(T.unsafe(nil), Regexp)

# NOTE In JavaScript, a back reference succeeds if not set; invert the logic to give it a match to refute
#
# source://asciidoctor//lib/asciidoctor/rx.rb#526
Asciidoctor::InlineLinkRx = T.let(T.unsafe(nil), Regexp)

# Matches a menu inline macro.
#
# Examples
#
#   menu:File[Save As...]
#   menu:Edit[]
#   menu:View[Page Style > No Style]
#   menu:View[Page Style, No Style]
#
# source://asciidoctor//lib/asciidoctor/rx.rb#562
Asciidoctor::InlineMenuMacroRx = T.let(T.unsafe(nil), Regexp)

# Matches an implicit menu inline macro.
#
# Examples
#
#   "File > New..."
#
# source://asciidoctor//lib/asciidoctor/rx.rb#570
Asciidoctor::InlineMenuRx = T.let(T.unsafe(nil), Regexp)

# Matches several variants of the passthrough inline macro, which may span multiple lines.
#
# Examples
#
#   +++text+++
#   $$text$$
#   pass:quotes[text]
#
# NOTE we have to support an empty pass:[] for compatibility with AsciiDoc.py
#
# source://asciidoctor//lib/asciidoctor/rx.rb#597
Asciidoctor::InlinePassMacroRx = T.let(T.unsafe(nil), Regexp)

# Matches an inline passthrough, which may span multiple lines.
#
# Examples
#
#   +text+
#   [x-]+text+
#   [x-]`text`
#   `text` (compat only)
#   [role]`text` (compat only)
#
# NOTE we always capture the attributes so we know when to use compatible (i.e., legacy) behavior
#
# source://asciidoctor//lib/asciidoctor/rx.rb#583
Asciidoctor::InlinePassRx = T.let(T.unsafe(nil), Hash)

# Matches an anchor (i.e., id + optional reference text) inside a section title.
#
# Examples
#
#   Section Title [[idname]]
#   Section Title [[idname,Reference Text]]
#
# source://asciidoctor//lib/asciidoctor/rx.rb#257
Asciidoctor::InlineSectionAnchorRx = T.let(T.unsafe(nil), Regexp)

# Matches a stem (and alternatives, asciimath and latexmath) inline macro, which may span multiple lines.
#
# Examples
#
#   stem:[x != 0]
#   asciimath:[x != 0]
#   latexmath:[\sqrt{4} = 2]
#
# source://asciidoctor//lib/asciidoctor/rx.rb#551
Asciidoctor::InlineStemMacroRx = T.let(T.unsafe(nil), Regexp)

# Matches an xref (i.e., cross-reference) inline macro, which may span multiple lines.
#
# Examples
#
#   <<id,reftext>>
#   xref:id[reftext]
#
# NOTE special characters have already been escaped, hence the entity references
# NOTE { is included in start characters to support target that begins with attribute reference in title content
#
# source://asciidoctor//lib/asciidoctor/rx.rb#608
Asciidoctor::InlineXrefMacroRx = T.let(T.unsafe(nil), Regexp)

# Matches invalid characters in an attribute name.
#
# source://asciidoctor//lib/asciidoctor/rx.rb#127
Asciidoctor::InvalidAttributeNameCharsRx = T.let(T.unsafe(nil), Regexp)

# Matches invalid ID characters in a section title.
#
# NOTE uppercase chars not included since expression is only run on a lowercase string
#
# source://asciidoctor//lib/asciidoctor/rx.rb#262
Asciidoctor::InvalidSectionIdCharsRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor//lib/asciidoctor.rb#300
Asciidoctor::LAYOUT_BREAK_CHARS = T.let(T.unsafe(nil), Hash)

# The newline character used for output; stored in constant table as an optimization
#
# source://asciidoctor//lib/asciidoctor.rb#191
Asciidoctor::LF = T.let(T.unsafe(nil), String)

# The absolute lib directory of the Asciidoctor RubyGem
#
# source://asciidoctor//lib/asciidoctor.rb#181
Asciidoctor::LIB_DIR = T.let(T.unsafe(nil), String)

# source://asciidoctor//lib/asciidoctor.rb#337
Asciidoctor::LINE_CONTINUATION = T.let(T.unsafe(nil), String)

# source://asciidoctor//lib/asciidoctor.rb#339
Asciidoctor::LINE_CONTINUATION_LEGACY = T.let(T.unsafe(nil), String)

# source://asciidoctor//lib/asciidoctor.rb#332
Asciidoctor::LIST_CONTINUATION = T.let(T.unsafe(nil), String)

# Scans for a leading, non-escaped anchor (i.e., id + optional reference text).
#
# source://asciidoctor//lib/asciidoctor/rx.rb#449
Asciidoctor::LeadingInlineAnchorRx = T.let(T.unsafe(nil), Regexp)

# Public: Methods for managing AsciiDoc lists (ordered, unordered and description lists)
#
# source://asciidoctor//lib/asciidoctor/list.rb#4
class Asciidoctor::List < ::Asciidoctor::AbstractBlock
  # @return [List] a new instance of List
  #
  # source://asciidoctor//lib/asciidoctor/list.rb#13
  def initialize(parent, context, opts = T.unsafe(nil)); end

  # Public: Get the items in this list as an Array
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#5
  def content; end

  # source://asciidoctor//lib/asciidoctor/list.rb#24
  def convert; end

  # Public: Create alias for blocks
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#5
  def items; end

  # Public: Create alias to check if this list has blocks
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#127
  def items?; end

  # source://asciidoctor-pdf/2.3.19/lib/asciidoctor/pdf/ext/asciidoctor/list.rb#18
  def list_level; end

  # source://asciidoctor-pdf/2.3.19/lib/asciidoctor/pdf/ext/asciidoctor/list.rb#8
  def nested?; end

  # Check whether this list is an outline list (unordered or ordered).
  #
  # Return true if this list is an outline list. Otherwise, return false.
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/list.rb#20
  def outline?; end

  # Deprecated: Use {List#convert} instead.
  #
  # source://asciidoctor//lib/asciidoctor/list.rb#24
  def render; end

  # source://asciidoctor//lib/asciidoctor/list.rb#37
  def to_s; end
end

# Public: Methods for managing items for AsciiDoc olists, ulist, and dlists.
#
# In a description list (dlist), each item is a tuple that consists of a 2-item Array of ListItem terms and a ListItem
# description (i.e., [[term, term, ...], desc]. If a description is not set, then the second entry in the tuple is nil.
#
# source://asciidoctor//lib/asciidoctor/list.rb#47
class Asciidoctor::ListItem < ::Asciidoctor::AbstractBlock
  # Public: Initialize an Asciidoctor::ListItem object.
  #
  # parent - The parent list block for this list item
  # text - the String text (default nil)
  #
  # @return [ListItem] a new instance of ListItem
  #
  # source://asciidoctor//lib/asciidoctor/list.rb#59
  def initialize(parent, text = T.unsafe(nil)); end

  # Check whether this list item has compound content (nested blocks aside from a single outline list).
  # Primarily relevant for outline lists.
  #
  # Return true if the list item contains blocks other than a single outline list. Otherwise, return false.
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/list.rb#98
  def compound?; end

  # Internal: Fold the adjacent paragraph block into the list item text
  #
  # Returns nothing
  #
  # source://asciidoctor//lib/asciidoctor/list.rb#105
  def fold_first; end

  # A contextual alias for the list parent node; counterpart to the items alias on List
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#26
  def list; end

  # Public: Get/Set the String used to mark this list item
  #
  # source://asciidoctor//lib/asciidoctor/list.rb#53
  def marker; end

  # Public: Get/Set the String used to mark this list item
  #
  # source://asciidoctor//lib/asciidoctor/list.rb#53
  def marker=(_arg0); end

  # Check whether this list item has simple content (no nested blocks aside from a single outline list).
  # Primarily relevant for outline lists.
  #
  # Return true if the list item contains no blocks or it contains a single outline list. Otherwise, return false.
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/list.rb#90
  def simple?; end

  # Public: Get the String text of this ListItem with substitutions applied.
  #
  # By default, normal substitutions are applied to the text. The substitutions
  # can be modified by altering the subs property of this object.
  #
  # Returns the converted String text for this ListItem
  #
  # source://asciidoctor//lib/asciidoctor/list.rb#78
  def text; end

  # Public: Set the String text assigned to this ListItem
  #
  # source://asciidoctor//lib/asciidoctor/list.rb#84
  def text=(_arg0); end

  # Public: A convenience method that checks whether the text of this list item
  # is not blank (i.e., not nil or empty string).
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/list.rb#68
  def text?; end

  # source://asciidoctor//lib/asciidoctor/list.rb#110
  def to_s; end
end

# A Hash of regexps for lists used for dynamic access.
#
# source://asciidoctor//lib/asciidoctor/rx.rb#380
Asciidoctor::ListRxMap = T.let(T.unsafe(nil), Hash)

# Matches a literal paragraph, which is a line of text preceded by at least one space.
#
# Examples
#
#   <SPACE>Foo
#   <TAB>Foo
#
# source://asciidoctor//lib/asciidoctor/rx.rb#209
Asciidoctor::LiteralParagraphRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor//lib/asciidoctor/logging.rb#5
class Asciidoctor::Logger < ::Logger
  # @return [Logger] a new instance of Logger
  #
  # source://asciidoctor//lib/asciidoctor/logging.rb#8
  def initialize(*args); end

  # source://asciidoctor//lib/asciidoctor/logging.rb#15
  def add(severity, message = T.unsafe(nil), progname = T.unsafe(nil)); end

  # Returns the value of attribute max_severity.
  #
  # source://asciidoctor//lib/asciidoctor/logging.rb#6
  def max_severity; end
end

# source://asciidoctor//lib/asciidoctor/logging.rb#30
module Asciidoctor::Logger::AutoFormattingMessage
  # source://asciidoctor//lib/asciidoctor/logging.rb#31
  def inspect; end
end

# source://asciidoctor//lib/asciidoctor/logging.rb#22
class Asciidoctor::Logger::BasicFormatter < ::Logger::Formatter
  # source://asciidoctor//lib/asciidoctor/logging.rb#25
  def call(severity, _, progname, msg); end
end

# source://asciidoctor//lib/asciidoctor/logging.rb#23
Asciidoctor::Logger::BasicFormatter::SEVERITY_LABEL_SUBSTITUTES = T.let(T.unsafe(nil), Hash)

# source://asciidoctor//lib/asciidoctor/logging.rb#83
module Asciidoctor::LoggerManager
  class << self
    # NOTE subsequent calls to logger access the logger via the logger property directly
    #
    # source://asciidoctor//lib/asciidoctor/logging.rb#89
    def logger(pipe = T.unsafe(nil)); end

    # Returns the specified Logger
    #
    # source://asciidoctor//lib/asciidoctor/logging.rb#95
    def logger=(new_logger); end

    # Returns the value of attribute logger_class.
    #
    # source://asciidoctor//lib/asciidoctor/logging.rb#86
    def logger_class; end

    # Sets the attribute logger_class
    #
    # @param value the value to set the attribute logger_class to.
    #
    # source://asciidoctor//lib/asciidoctor/logging.rb#86
    def logger_class=(_arg0); end

    private

    # source://asciidoctor//lib/asciidoctor/logging.rb#101
    def memoize_logger; end
  end
end

# source://asciidoctor//lib/asciidoctor/logging.rb#110
module Asciidoctor::Logging
  # source://asciidoctor//lib/asciidoctor/logging.rb#121
  def logger; end

  # source://asciidoctor//lib/asciidoctor/logging.rb#125
  def message_with_context(text, context = T.unsafe(nil)); end

  class << self
    private

    # Private: Mixes the {Logging} module as static methods into any class that includes the {Logging} module.
    #
    # into - The Class that includes the {Logging} module
    #
    # Returns nothing
    #
    # source://asciidoctor//lib/asciidoctor/logging.rb#116
    def included(into); end
  end
end

# source://asciidoctor//lib/asciidoctor.rb#305
Asciidoctor::MARKDOWN_THEMATIC_BREAK_CHARS = T.let(T.unsafe(nil), Hash)

# source://asciidoctor//lib/asciidoctor.rb#361
Asciidoctor::MATHJAX_VERSION = T.let(T.unsafe(nil), String)

# Maximum integer value for "boundless" operations; equal to MAX_SAFE_INTEGER in JavaScript
#
# source://asciidoctor//lib/asciidoctor.rb#200
Asciidoctor::MAX_INT = T.let(T.unsafe(nil), Integer)

# Matches the name of a macro.
#
# source://asciidoctor//lib/asciidoctor/rx.rb#541
Asciidoctor::MacroNameRx = T.let(T.unsafe(nil), Regexp)

# Matches the name and purpose in the manpage doctype.
#
# Examples
#
#   asciidoctor - converts AsciiDoc source files to HTML, DocBook and other formats
#
# source://asciidoctor//lib/asciidoctor/rx.rb#59
Asciidoctor::ManpageNamePurposeRx = T.let(T.unsafe(nil), Regexp)

# Matches the title and volnum in the manpage doctype.
#
# Examples
#
#   = asciidoctor(1)
#   = asciidoctor ( 1 )
#
# source://asciidoctor//lib/asciidoctor/rx.rb#51
Asciidoctor::ManpageTitleVolnumRx = T.let(T.unsafe(nil), Regexp)

# Matches a Markdown horizontal rule.
#
# Examples
#
#   --- or - - -
#   *** or * * *
#   ___ or _ _ _
#
# source://asciidoctor//lib/asciidoctor/rx.rb#638
Asciidoctor::MarkdownThematicBreakRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor//lib/asciidoctor/logging.rb#37
class Asciidoctor::MemoryLogger < ::Logger
  # @return [MemoryLogger] a new instance of MemoryLogger
  #
  # source://asciidoctor//lib/asciidoctor/logging.rb#42
  def initialize; end

  # source://asciidoctor//lib/asciidoctor/logging.rb#48
  def add(severity, message = T.unsafe(nil), progname = T.unsafe(nil)); end

  # source://asciidoctor//lib/asciidoctor/logging.rb#54
  def clear; end

  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/logging.rb#58
  def empty?; end

  # source://asciidoctor//lib/asciidoctor/logging.rb#62
  def max_severity; end

  # Returns the value of attribute messages.
  #
  # source://asciidoctor//lib/asciidoctor/logging.rb#40
  def messages; end
end

# source://asciidoctor//lib/asciidoctor/logging.rb#38
Asciidoctor::MemoryLogger::SEVERITY_SYMBOL_BY_VALUE = T.let(T.unsafe(nil), Hash)

# LIST_CONTEXTS = [:ulist, :olist, :dlist, :colist]
#
# source://asciidoctor//lib/asciidoctor.rb#315
Asciidoctor::NESTABLE_LIST_CONTEXTS = T.let(T.unsafe(nil), Array)

# The null character to use for splitting attribute values
#
# source://asciidoctor//lib/asciidoctor.rb#194
Asciidoctor::NULL = T.let(T.unsafe(nil), String)

# source://asciidoctor//lib/asciidoctor/logging.rb#67
class Asciidoctor::NullLogger < ::Logger
  # @return [NullLogger] a new instance of NullLogger
  #
  # source://asciidoctor//lib/asciidoctor/logging.rb#70
  def initialize; end

  # source://asciidoctor//lib/asciidoctor/logging.rb#75
  def add(severity, message = T.unsafe(nil), progname = T.unsafe(nil)); end

  # Returns the value of attribute max_severity.
  #
  # source://asciidoctor//lib/asciidoctor/logging.rb#68
  def max_severity; end
end

# source://asciidoctor//lib/asciidoctor.rb#320
Asciidoctor::ORDERED_LIST_KEYWORDS = T.let(T.unsafe(nil), Hash)

# TODO validate use of explicit style name above ordered list (this list is for selecting an implicit style)
#
# source://asciidoctor//lib/asciidoctor.rb#318
Asciidoctor::ORDERED_LIST_STYLES = T.let(T.unsafe(nil), Array)

# Matches the ordinals for each type of ordered list.
#
# source://asciidoctor//lib/asciidoctor/rx.rb#303
Asciidoctor::OrderedListMarkerRxMap = T.let(T.unsafe(nil), Hash)

# Matches an ordered list item (explicit numbering or up to 5 consecutive dots).
#
# Examples
#
#   . Foo
#   .. Foo
#   1. Foo (arabic, default)
#   a. Foo (loweralpha)
#   A. Foo (upperalpha)
#   i. Foo (lowerroman)
#   I. Foo (upperroman)
#
# NOTE leading space match is not always necessary, but is used for list reader
# NOTE we know trailing (.*) will match at least one character because we strip trailing spaces
#
# source://asciidoctor//lib/asciidoctor/rx.rb#300
Asciidoctor::OrderedListRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor//lib/asciidoctor.rb#274
Asciidoctor::PARAGRAPH_STYLES = T.let(T.unsafe(nil), Set)

# # => Asciidoctor::Block
#
# source://asciidoctor//lib/asciidoctor/parser.rb#25
class Asciidoctor::Parser
  include ::Asciidoctor::Logging
  extend ::Asciidoctor::Logging

  class << self
    # Remove the block indentation (the amount of whitespace of the least indented line), replace tabs with spaces (using
    # proper tab expansion logic) and, finally, indent the lines by the margin width. Modifies the input Array directly.
    #
    # This method preserves the significant indentation (that exceeding the block indent) on each line.
    #
    # lines       - The Array of String lines to process (no trailing newlines)
    # indent_size - The Integer number of spaces to readd to the start of non-empty lines after removing the indentation.
    #               If this value is < 0, the existing indentation is preserved (optional, default: 0)
    # tab_size    - the Integer number of spaces to use in place of a tab. A value of <= 0 disables the replacement
    #               (optional, default: 0)
    #
    # Examples
    #
    #   source = <<EOS
    #       def names
    #         @name.split
    #       end
    #   EOS
    #
    #   source.split ?\n
    #   # => ["    def names", "      @names.split", "    end"]
    #
    #   puts (Parser.adjust_indentation! source.split ?\n).join ?\n
    #   # => def names
    #   # =>   @names.split
    #   # => end
    #
    # returns Nothing
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#2675
    def adjust_indentation!(lines, indent_size = T.unsafe(nil), tab_size = T.unsafe(nil)); end

    # Checks whether the line given is an atx section title.
    #
    # The level returned is 1 less than number of leading markers.
    #
    # line - [String] candidate title with leading atx marker.
    #
    # Returns the [Integer] section level if this line is an atx section title, otherwise nothing.
    #
    # @return [Boolean]
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#1709
    def atx_section_title?(line); end

    # whether a block supports compound content should be a config setting
    # if terminator is false, that means the all the lines in the reader should be parsed
    # NOTE could invoke filter in here, before and after parsing
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#1016
    def build_block(block_context, content_model, terminator, parent, reader, attributes, options = T.unsafe(nil)); end

    # Internal: Catalog any callouts found in the text, but don't process them
    #
    # text     - The String of text in which to look for callouts
    # document - The current document in which the callouts are stored
    #
    # Returns A Boolean indicating whether callouts were found
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#1137
    def catalog_callouts(text, document); end

    # Internal: Catalog a matched inline anchor.
    #
    # id       - The String id of the anchor
    # reftext  - The optional String reference text of the anchor
    # node     - The AbstractNode parent node of the anchor node
    # location - The source location (file and line) where the anchor was found
    # doc      - The document to which the node belongs; computed from node if not specified
    #
    # Returns nothing
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#1157
    def catalog_inline_anchor(id, reftext, node, location, doc = T.unsafe(nil)); end

    # Internal: Catalog any inline anchors found in the text (but don't convert)
    #
    # text     - The String text in which to look for inline anchors
    # block    - The block in which the references should be searched
    # document - The current Document on which the references are stored
    #
    # Returns nothing
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#1173
    def catalog_inline_anchors(text, block, document, reader); end

    # Internal: Catalog the bibliography inline anchor found in the start of the list item (but don't convert)
    #
    # id      - The String id of the anchor
    # reftext - The optional String reference text of the anchor
    # node    - The AbstractNode parent node of the anchor node
    # reader  - The source Reader for the current Document, positioned at the current list item
    #
    # Returns nothing
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#1207
    def catalog_inline_biblio_anchor(id, reftext, node, reader); end

    # Internal: Initialize a new Section object and assign any attributes provided
    #
    # The information for this section is retrieved by parsing the lines at the
    # current position of the reader.
    #
    # reader     - the source reader
    # parent     - the parent Section or Document of this Section
    # attributes - a Hash of attributes to assign to this section (default: {})
    #
    # Returns the section [Block]
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#1604
    def initialize_section(reader, parent, attributes = T.unsafe(nil)); end

    # Public: Determines whether this line is the start of a known delimited block.
    #
    # Returns the BlockMatchData (if return_match_data is true) or true (if return_match_data is false) if this line is
    # the start of a delimited block, otherwise nothing.
    #
    # @return [Boolean]
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#976
    def is_delimited_block?(line, return_match_data = T.unsafe(nil)); end

    # Internal: Convenience API for checking if the next line on the Reader is the document title
    #
    # reader      - the source Reader
    # attributes  - a Hash of attributes collected above the current line
    # leveloffset - an Integer (or integer String value) the represents the current leveloffset
    #
    # returns true if the Reader is positioned at the document title, false otherwise
    #
    # @return [Boolean]
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#1684
    def is_next_line_doctitle?(reader, attributes, leveloffset); end

    # Internal: Checks if the next line on the Reader is a section title
    #
    # reader     - the source Reader
    # attributes - a Hash of attributes collected above the current line
    #
    # Returns the Integer section level if the Reader is positioned at a section title or nil otherwise
    #
    # @return [Boolean]
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#1667
    def is_next_line_section?(reader, attributes); end

    # Public: Checks whether the lines given are an atx or setext section title.
    #
    # line1 - [String] candidate title.
    # line2 - [String] candidate underline (default: nil).
    #
    # Returns the [Integer] section level if these lines are a section title, otherwise nothing.
    #
    # @return [Boolean]
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#1698
    def is_section_title?(line1, line2 = T.unsafe(nil)); end

    # Internal: Determine whether the this line is a sibling list item
    # according to the list type and trait (marker) provided.
    #
    # line          - The String line to check
    # list_type     - The context of the list (:olist, :ulist, :colist, :dlist)
    # sibling_trait - The String marker for the list or the Regexp to match a sibling
    #
    # Returns a Boolean indicating whether this line is a sibling list item given the criteria provided
    #
    # @return [Boolean]
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#2280
    def is_sibling_list_item?(line, list_type, sibling_trait); end

    # Public: Parse and return the next Block at the Reader's current location
    #
    # This method begins by skipping over blank lines to find the start of the
    # next block (paragraph, block macro, or delimited block). If a block is
    # found, that block is parsed, initialized as a Block object, and returned.
    # Otherwise, the method returns nothing.
    #
    # Regular expressions from the Asciidoctor module are used to match block
    # boundaries. The ensuing lines are then processed according to the content
    # model.
    #
    # reader     - The Reader from which to retrieve the next Block.
    # parent     - The Document, Section or Block to which the next Block belongs.
    # attributes - A Hash of attributes that will become the attributes
    #              associated with the parsed Block (default: {}).
    # options    - An options Hash to control parsing (default: {}):
    #              * :text_only indicates that the parser is only looking for text content
    #              * :list_type indicates this block will be attached to a list item in a list of the specified type
    #
    # Returns a Block object built from the parsed content of the processed
    # lines, or nothing if no block is found.
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#503
    def next_block(reader, parent, attributes = T.unsafe(nil), options = T.unsafe(nil)); end

    # Public: Return the next section from the Reader.
    #
    # This method process block metadata, content and subsections for this
    # section and returns the Section object and any orphaned attributes.
    #
    # If the parent is a Document and has a header (document title), then
    # this method will put any non-section blocks at the start of document
    # into a preamble Block. If there are no such blocks, the preamble is
    # dropped.
    #
    # Since we are reading line-by-line, there's a chance that metadata
    # that should be associated with the following block gets consumed.
    # To deal with this case, the method returns a running Hash of
    # "orphaned" attributes that get passed to the next Section or Block.
    #
    # reader     - the source Reader
    # parent     - the parent Section or Document of this new section
    # attributes - a Hash of metadata that was left orphaned from the
    #              previous Section.
    #
    # Examples
    #
    #   source
    #   # => "= Greetings\n\nThis is my doc.\n\n== Salutations\n\nIt is awesome."
    #
    #   reader = Reader.new source, nil, normalize: true
    #   # create empty document to parent the section
    #   # and hold attributes extracted from header
    #   doc = Document.new
    #
    #   Parser.next_section(reader, doc)[0].title
    #   # => "Greetings"
    #
    #   Parser.next_section(reader, doc)[0].title
    #   # => "Salutations"
    #
    # returns a two-element Array containing the Section and Hash of orphaned attributes
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#321
    def next_section(reader, parent, attributes = T.unsafe(nil)); end

    # Public: Parses AsciiDoc source read from the Reader into the Document
    #
    # This method is the main entry-point into the Parser when parsing a full document.
    # It first looks for and, if found, processes the document title. It then
    # proceeds to iterate through the lines in the Reader, parsing the document
    # into nested Sections and Blocks.
    #
    # reader   - the Reader holding the source lines of the document
    # document - the empty Document into which the lines will be parsed
    # options  - a Hash of options to control processing
    #
    # returns the Document object
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#97
    def parse(reader, document, options = T.unsafe(nil)); end

    # Internal: Parse the next line if it contains metadata for the following block
    #
    # This method handles lines with the following content:
    #
    # * line or block comment
    # * anchor
    # * attribute list
    # * block title
    #
    # Any attributes found will be inserted into the attributes argument.
    # If the line contains block metadata, the method returns true, otherwise false.
    #
    # reader     - the source reader
    # document   - the current Document
    # attributes - a Hash of attributes in which any metadata found will be stored
    # options    - a Hash of options to control processing: (default: {})
    #              *  :text_only indicates the parser is only looking for text content,
    #                   thus neither a block title or attribute entry should be captured
    #
    # returns true if the line contains metadata, otherwise falsy
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#2043
    def parse_block_metadata_line(reader, document, attributes, options = T.unsafe(nil)); end

    # Internal: Parse lines of metadata until a line of metadata is not found.
    #
    # This method processes sequential lines containing block metadata, ignoring
    # blank lines and comments.
    #
    # reader     - the source reader
    # document   - the current Document
    # attributes - a Hash of attributes in which any metadata found will be stored (default: {})
    # options    - a Hash of options to control processing: (default: {})
    #              *  :text_only indicates that parser is only looking for text content
    #                   and thus the block title should not be captured
    #
    # returns the Hash of attributes including any metadata found
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#2014
    def parse_block_metadata_lines(reader, document, attributes = T.unsafe(nil), options = T.unsafe(nil)); end

    # Public: Parse blocks from this reader until there are no more lines.
    #
    # This method calls Parser#next_block until there are no more lines in the
    # Reader. It does not consider sections because it's assumed the Reader only
    # has lines which are within a delimited block region.
    #
    # reader - The Reader containing the lines to process
    # parent - The parent Block to which to attach the parsed blocks
    #
    # Returns nothing.
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#1098
    def parse_blocks(reader, parent, attributes = T.unsafe(nil)); end

    # Internal: Parse and construct a callout list Block from the current position of the Reader and
    # advance the document callouts catalog to the next list.
    #
    # reader   - The Reader from which to retrieve the callout list.
    # match    - The Regexp match containing the head of the list.
    # parent   - The parent Block to which this callout list belongs.
    # callouts - The document callouts catalog.
    #
    # Returns the Block that represents the parsed callout list.
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#1250
    def parse_callout_list(reader, match, parent, callouts); end

    # Internal: Parse the cell specs for the current cell.
    #
    # The cell specs dictate the cell's alignments, styles or filters,
    # colspan, rowspan and/or repeating content.
    #
    # The default spec when pos == :end is {} since we already know we're at a
    # delimiter. When pos == :start, we *may* be at a delimiter, nil indicates
    # we're not.
    #
    # returns the Hash of attributes that indicate how to layout
    # and style this cell in the table.
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#2495
    def parse_cellspec(line, pos = T.unsafe(nil), delimiter = T.unsafe(nil)); end

    # Internal: Parse the column specs for this table.
    #
    # The column specs dictate the number of columns, relative
    # width of columns, default alignments for cells in each
    # column, and/or default styles or filters applied to the cells in
    # the column.
    #
    # Every column spec is guaranteed to have a width
    #
    # returns a Hash of attributes that specify how to format
    # and layout the cells in the table.
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#2436
    def parse_colspecs(records); end

    # Internal: Parse and construct a description list Block from the current position of the Reader
    #
    # reader    - The Reader from which to retrieve the description list
    # match     - The Regexp match for the head of the list
    # parent    - The parent Block to which this description list belongs
    #
    # Returns the Block encapsulating the parsed description list
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#1222
    def parse_description_list(reader, match, parent); end

    # Public: Parses the document header of the AsciiDoc source read from the Reader
    #
    # Reads the AsciiDoc source from the Reader until the end of the document
    # header is reached. The Document object is populated with information from
    # the header (document title, document attributes, etc). The document
    # attributes are then saved to establish a save point to which to rollback
    # after parsing is complete.
    #
    # This method assumes that there are no blank lines at the start of the document,
    # which are automatically removed by the reader.
    #
    # returns the Hash of orphan block attributes captured above the header
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#126
    def parse_document_header(reader, document, header_only = T.unsafe(nil)); end

    # Public: Consume and parse the two header lines (line 1 = author info, line 2 = revision info).
    #
    # Returns the Hash of header metadata. If a Document object is supplied, the metadata
    # is applied directly to the attributes of the Document.
    #
    # reader   - the Reader holding the source lines of the document
    # document - the Document we are building (default: nil)
    #
    # Examples
    #
    #  data = ["Author Name <author@example.org>\n", "v1.0, 2012-12-21: Coincide w/ end of world.\n"]
    #  parse_header_metadata(Reader.new data, nil, normalize: true)
    #  # => { 'author' => 'Author Name', 'firstname' => 'Author', 'lastname' => 'Name', 'email' => 'author@example.org',
    #  #       'revnumber' => '1.0', 'revdate' => '2012-12-21', 'revremark' => 'Coincide w/ end of world.' }
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#1815
    def parse_header_metadata(reader, document = T.unsafe(nil), retrieve = T.unsafe(nil)); end

    # Internal: Parse and construct an ordered or unordered list at the current position of the Reader
    #
    # reader    - The Reader from which to retrieve the list
    # list_type - A Symbol representing the list type (:olist for ordered, :ulist for unordered)
    # parent    - The parent Block to which this list belongs
    # style     - The block style assigned to this list (optional, default: nil)
    #
    # Returns the Block encapsulating the parsed unordered or ordered list
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#1115
    def parse_list(reader, list_type, parent, style); end

    # Internal: Parse and construct the next ListItem (unordered, ordered, or callout list) or next
    # term ListItem and description ListItem pair (description list) for the specified list Block.
    #
    # First, collect and process all the lines that constitute the next list item for the specified
    # list (according to its type). Next, create a ListItem (in the case of a description list, a
    # description ListItem), parse the lines into blocks, and associate those blocks with that
    # ListItem. Finally, fold the first block into the item's text attribute according to rules
    # described in ListItem.
    #
    # reader        - The Reader from which to retrieve the next list item
    # list_block    - The parent list Block for this ListItem. Also provides access to the list type.
    # match         - The MatchData that contains the list item marker and first line text of the ListItem
    # sibling_trait - The trait to match a sibling list item. For ordered and unordered lists, this is
    #                 a String marker (e.g., '**' or 'ii)'). For description lists, this is a Regexp
    #                 marker pattern.
    # style         - The block style assigned to this list (optional, default: nil)
    #
    # Returns the next ListItem or [[ListItem], ListItem] pair (description list) for the parent list Block.
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#1297
    def parse_list_item(reader, list_block, match, sibling_trait, style = T.unsafe(nil)); end

    # Public: Parses the manpage header of the AsciiDoc source read from the Reader
    #
    # returns Nothing
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#211
    def parse_manpage_header(reader, document, block_attributes, header_only = T.unsafe(nil)); end

    # Internal: Parse the section title from the current position of the reader
    #
    # Parse an atx (single-line) or setext (underlined) section title. After this method is called,
    # the Reader will be positioned at the line after the section title.
    #
    # For efficiency, we don't reuse methods internally that check for a section title.
    #
    # reader   - the source [Reader], positioned at a section title.
    # document - the current [Document].
    #
    # Examples
    #
    #   reader.lines
    #   # => ["Foo", "~~~"]
    #
    #   id, reftext, title, level, atx = parse_section_title(reader, document)
    #
    #   title
    #   # => "Foo"
    #   level
    #   # => 2
    #   id
    #   # => nil
    #   atx
    #   # => false
    #
    #   line1
    #   # => "==== Foo"
    #
    #   id, reftext, title, level, atx = parse_section_title(reader, document)
    #
    #   title
    #   # => "Foo"
    #   level
    #   # => 3
    #   id
    #   # => nil
    #   atx
    #   # => true
    #
    # Returns an 5-element [Array] containing the id (String), reftext (String),
    # title (String), level (Integer), and flag (Boolean) indicating whether an
    # atx section title was matched, or nothing.
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#1772
    def parse_section_title(reader, document, sect_id = T.unsafe(nil)); end

    # Public: Parse the first positional attribute and assign named attributes
    #
    # Parse the first positional attribute to extract the style, role and id
    # parts, assign the values to their corresponding attribute keys and return
    # the parsed style from the first positional attribute.
    #
    # attributes - The Hash of attributes to process and update
    #
    # Examples
    #
    #   puts attributes
    #   => { 1 => "abstract#intro.lead%fragment", "style" => "preamble" }
    #
    #   parse_style_attribute(attributes)
    #   => "abstract"
    #
    #   puts attributes
    #   => { 1 => "abstract#intro.lead%fragment", "style" => "abstract", "id" => "intro",
    #         "role" => "lead", "options" => "fragment", "fragment-option" => '' }
    #
    # Returns the String style parsed from the first positional attribute
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#2569
    def parse_style_attribute(attributes, reader = T.unsafe(nil)); end

    # Internal: Parse the table contained in the provided Reader
    #
    # table_reader - a Reader containing the source lines of an AsciiDoc table
    # parent       - the parent Block of this Asciidoctor::Table
    # attributes   - attributes captured from above this Block
    #
    # returns an instance of Asciidoctor::Table parsed from the provided reader
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#2295
    def parse_table(table_reader, parent, attributes); end

    # Process consecutive attribute entry lines, ignoring adjacent line comments and comment blocks.
    #
    # Returns nothing
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#2094
    def process_attribute_entries(reader, document, attributes = T.unsafe(nil)); end

    # source://asciidoctor//lib/asciidoctor/parser.rb#2103
    def process_attribute_entry(reader, document, attributes = T.unsafe(nil), match = T.unsafe(nil)); end

    # Internal: Parse the author line into a Hash of author metadata
    #
    # author_line  - the String author line
    # names_only   - a Boolean flag that indicates whether to process line as
    #                names only or names with emails (default: false)
    # multiple     - a Boolean flag that indicates whether to process multiple
    #                semicolon-separated entries in the author line (default: true)
    #
    # returns a Hash of author metadata
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#1938
    def process_authors(author_line, names_only = T.unsafe(nil), multiple = T.unsafe(nil)); end

    # Internal: Collect the lines belonging to the current list item, navigating
    # through all the rules that determine what comprises a list item.
    #
    # Grab lines until a sibling list item is found, or the block is broken by a
    # terminator (such as a line comment). Description lists are more greedy if
    # they don't have optional inline item text...they want that text
    #
    # reader          - The Reader from which to retrieve the lines.
    # list_type       - The Symbol context of the list (:ulist, :olist, :colist or :dlist)
    # sibling_trait   - A Regexp that matches a sibling of this list item or String list marker
    #                   of the items in this list (default: nil)
    # has_text        - Whether the list item has text defined inline (always true except for description lists)
    #
    # Returns an Array of lines belonging to the current list item.
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#1404
    def read_lines_for_list_item(reader, list_type, sibling_trait = T.unsafe(nil), has_text = T.unsafe(nil)); end

    # source://asciidoctor//lib/asciidoctor/parser.rb#962
    def read_paragraph_lines(reader, break_at_list, opts = T.unsafe(nil)); end

    # Internal: Resolve the 0-index marker for this list item
    #
    # For ordered lists, match the marker used for this list item against the
    # known list markers and determine which marker is the first (0-index) marker
    # in its number series.
    #
    # For callout lists, return <1>.
    #
    # For bulleted lists, return the marker as passed to this method.
    #
    # list_type  - The Symbol context of the list
    # marker     - The String marker for this list item
    # ordinal    - The position of this list item in the list
    # validate   - Whether to validate the value of the marker
    #
    # Returns the String 0-index marker for this list item
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#2192
    def resolve_list_marker(list_type, marker, ordinal = T.unsafe(nil), validate = T.unsafe(nil), reader = T.unsafe(nil)); end

    # Internal: Resolve the 0-index marker for this ordered list item
    #
    # Match the marker used for this ordered list item against the
    # known ordered list markers and determine which marker is
    # the first (0-index) marker in its number series.
    #
    # The purpose of this method is to normalize the implicit numbered markers
    # so that they can be compared against other list items.
    #
    # marker   - The marker used for this list item
    # ordinal  - The 0-based index of the list item (default: 0)
    # validate - Perform validation that the marker provided is the proper
    #            marker in the sequence (default: false)
    #
    # Examples
    #
    #  marker = 'B.'
    #  Parser.resolve_ordered_list_marker(marker, 1, true, reader)
    #  # => ['A.', :upperalpha]
    #
    #  marker = '.'
    #  Parser.resolve_ordered_list_marker(marker, 1, true, reader)
    #  # => ['.']
    #
    # Returns a tuple that contains the String of the first marker in this number
    # series and the implicit list style, if applicable
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#2229
    def resolve_ordered_list_marker(marker, ordinal = T.unsafe(nil), validate = T.unsafe(nil), reader = T.unsafe(nil)); end

    # Internal: Convert a string to a legal attribute name.
    #
    # name  - the String name of the attribute
    #
    # Returns a String with the legal AsciiDoc attribute name.
    #
    # Examples
    #
    #   sanitize_attribute_name('Foo Bar')
    #   => 'foobar'
    #
    #   sanitize_attribute_name('foo')
    #   => 'foo'
    #
    #   sanitize_attribute_name('Foo 3 #-Billy')
    #   => 'foo3-billy'
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#2770
    def sanitize_attribute_name(name); end

    # Checks whether the lines given are an setext section title.
    #
    # line1 - [String] candidate title
    # line2 - [String] candidate underline
    #
    # Returns the [Integer] section level if these lines are an setext section title, otherwise nothing.
    #
    # @return [Boolean]
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#1722
    def setext_section_title?(line1, line2); end

    # Public: Store the attribute in the document and register attribute entry if accessible
    #
    # name  - the String name of the attribute to store;
    #         if name begins or ends with !, it signals to remove the attribute with that root name
    # value - the String value of the attribute to store
    # doc   - the Document being parsed
    # attrs - the attributes for the current context
    #
    # returns a 2-element array containing the resolved attribute name (minus the ! indicator) and value
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#2131
    def store_attribute(name, value, doc = T.unsafe(nil), attrs = T.unsafe(nil)); end

    # @return [Boolean]
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#2750
    def uniform?(str, chr, len); end

    # Internal: Save the collected attribute (:id, :option, :role, or nil for :style) in the attribute Hash.
    #
    # source://asciidoctor//lib/asciidoctor/parser.rb#2621
    def yield_buffered_attribute(attrs, name, value, reader); end

    private

    def new(*_arg0); end
  end
end

# source://asciidoctor//lib/asciidoctor/parser.rb#44
Asciidoctor::Parser::AuthorKeys = T.let(T.unsafe(nil), Array)

# source://asciidoctor//lib/asciidoctor/parser.rb#28
class Asciidoctor::Parser::BlockMatchData < ::Struct
  # Returns the value of attribute context
  #
  # @return [Object] the current value of context
  def context; end

  # Sets the attribute context
  #
  # @param value [Object] the value to set the attribute context to.
  # @return [Object] the newly set value
  def context=(_); end

  # Returns the value of attribute masq
  #
  # @return [Object] the current value of masq
  def masq; end

  # Sets the attribute masq
  #
  # @param value [Object] the value to set the attribute masq to.
  # @return [Object] the newly set value
  def masq=(_); end

  # Returns the value of attribute terminator
  #
  # @return [Object] the current value of terminator
  def terminator; end

  # Sets the attribute terminator
  #
  # @param value [Object] the value to set the attribute terminator to.
  # @return [Object] the newly set value
  def terminator=(_); end

  # Returns the value of attribute tip
  #
  # @return [Object] the current value of tip
  def tip; end

  # Sets the attribute tip
  #
  # @param value [Object] the value to set the attribute tip to.
  # @return [Object] the newly set value
  def tip=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://asciidoctor//lib/asciidoctor/parser.rb#46
module Asciidoctor::Parser::ListContinuationMarker; end

# source://asciidoctor//lib/asciidoctor/parser.rb#48
Asciidoctor::Parser::ListContinuationPlaceholder = T.let(T.unsafe(nil), String)

# source://asciidoctor//lib/asciidoctor/parser.rb#50
Asciidoctor::Parser::ListContinuationString = T.let(T.unsafe(nil), String)

# source://asciidoctor//lib/asciidoctor/parser.rb#42
Asciidoctor::Parser::NoOp = T.let(T.unsafe(nil), T.untyped)

# source://asciidoctor//lib/asciidoctor/parser.rb#40
Asciidoctor::Parser::StartOfBlockOrListProc = T.let(T.unsafe(nil), Proc)

# source://asciidoctor//lib/asciidoctor/parser.rb#36
Asciidoctor::Parser::StartOfBlockProc = T.let(T.unsafe(nil), Proc)

# source://asciidoctor//lib/asciidoctor/parser.rb#38
Asciidoctor::Parser::StartOfListProc = T.let(T.unsafe(nil), Proc)

# String for matching tab character
#
# source://asciidoctor//lib/asciidoctor/parser.rb#31
Asciidoctor::Parser::TAB = T.let(T.unsafe(nil), String)

# Regexp for leading tab indentation
#
# source://asciidoctor//lib/asciidoctor/parser.rb#34
Asciidoctor::Parser::TabIndentRx = T.let(T.unsafe(nil), Regexp)

# Internal: A Hash mapping horizontal alignment abbreviations to alignments
# that can be applied to a table cell (or to all cells in a column)
#
# source://asciidoctor//lib/asciidoctor/parser.rb#54
Asciidoctor::Parser::TableCellHorzAlignments = T.let(T.unsafe(nil), Hash)

# Internal: A Hash mapping styles abbreviations to styles that can be applied
# to a table cell (or to all cells in a column)
#
# source://asciidoctor//lib/asciidoctor/parser.rb#70
Asciidoctor::Parser::TableCellStyles = T.let(T.unsafe(nil), Hash)

# Internal: A Hash mapping vertical alignment abbreviations to alignments
# that can be applied to a table cell (or to all cells in a column)
#
# source://asciidoctor//lib/asciidoctor/parser.rb#62
Asciidoctor::Parser::TableCellVertAlignments = T.let(T.unsafe(nil), Hash)

# => start path /etc is outside of jail: /path/to/docs'
#
# source://asciidoctor//lib/asciidoctor/path_resolver.rb#103
class Asciidoctor::PathResolver
  include ::Asciidoctor::Logging
  extend ::Asciidoctor::Logging

  # Public: Construct a new instance of PathResolver, optionally specifying the
  # file separator (to override the system default) and the working directory
  # (to override the present working directory). The working directory will be
  # expanded to an absolute path inside the constructor.
  #
  # file_separator - the String file separator to use for path operations
  #                  (optional, default: File::ALT_SEPARATOR or File::SEPARATOR)
  # working_dir    - the String working directory (optional, default: Dir.pwd)
  #
  # @return [PathResolver] a new instance of PathResolver
  #
  # source://asciidoctor//lib/asciidoctor/path_resolver.rb#127
  def initialize(file_separator = T.unsafe(nil), working_dir = T.unsafe(nil)); end

  # Public: Check whether the specified path is an absolute path.
  #
  # This operation considers both posix paths and Windows paths. The path does
  # not have to be posixified beforehand. This operation does not handle URIs.
  #
  # Unix absolute paths start with a slash. UNC paths can start with a slash or
  # backslash. Windows roots can start with a drive letter.
  #
  # path - the String path to check
  #
  # returns a Boolean indicating whether the path is an absolute root path
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/path_resolver.rb#145
  def absolute_path?(path); end

  # Public: Determine whether path descends from base.
  #
  # If path equals base, or base is a parent of path, return true.
  #
  # path - The String path to check. Can be relative.
  # base - The String base path to check against. Can be relative.
  #
  # returns If path descends from base, return the offset, otherwise false.
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/path_resolver.rb#203
  def descends_from?(path, base); end

  # Public: Expand the specified path by converting the path to a posix path, resolving parent
  # references (..), and removing self references (.).
  #
  # path - the String path to expand
  #
  # returns a String path as a posix path with parent references resolved and self references removed.
  # The result will be relative if the path is relative and absolute if the path is absolute.
  #
  # source://asciidoctor//lib/asciidoctor/path_resolver.rb#260
  def expand_path(path); end

  # Returns the value of attribute file_separator.
  #
  # source://asciidoctor//lib/asciidoctor/path_resolver.rb#115
  def file_separator; end

  # Sets the attribute file_separator
  #
  # @param value the value to set the attribute file_separator to.
  #
  # source://asciidoctor//lib/asciidoctor/path_resolver.rb#115
  def file_separator=(_arg0); end

  # Public: Join the segments using the posix file separator (since Ruby knows
  # how to work with paths specified this way, regardless of OS). Use the root,
  # if specified, to construct an absolute path. Otherwise join the segments as
  # a relative path.
  #
  # segments - a String Array of path segments
  # root     - a String path root (optional, default: nil)
  #
  # returns a String path formed by joining the segments using the posix file
  # separator and prepending the root, if specified
  #
  # source://asciidoctor//lib/asciidoctor/path_resolver.rb#337
  def join_path(segments, root = T.unsafe(nil)); end

  # Public: Partition the path into path segments and remove self references (.) and the trailing
  # slash, if present. Prior to being partitioned, the path is converted to a posix path.
  #
  # Parent references are not resolved by this method since the consumer often needs to handle this
  # resolution in a certain context (checking for the breach of a jail, for instance).
  #
  # path - the String path to partition
  # web  - a Boolean indicating whether the path should be handled
  #        as a web path (optional, default: false)
  #
  # Returns a 2-item Array containing the Array of String path segments and the
  # path root (e.g., '/', './', 'c:/', or '//'), which is nil unless the path is absolute.
  #
  # source://asciidoctor//lib/asciidoctor/path_resolver.rb#285
  def partition_path(path, web = T.unsafe(nil)); end

  # Public: Normalize path by converting any backslashes to forward slashes
  #
  # path - the String path to normalize
  #
  # returns a String path with any backslashes replaced with forward slashes
  #
  # source://asciidoctor//lib/asciidoctor/path_resolver.rb#244
  def posixfy(path); end

  # Public: Normalize path by converting any backslashes to forward slashes
  #
  # path - the String path to normalize
  #
  # returns a String path with any backslashes replaced with forward slashes
  #
  # source://asciidoctor//lib/asciidoctor/path_resolver.rb#244
  def posixify(path); end

  # Public: Calculate the relative path to this absolute path from the specified base directory
  #
  # If neither path or base are absolute paths, the path is not contained
  # within the base directory, or the relative path cannot be computed, the
  # original path is returned work is done.
  #
  # path - [String] an absolute filename.
  # base - [String] an absolute base directory.
  #
  # Return the [String] relative path of the specified path calculated from the base directory.
  #
  # source://asciidoctor//lib/asciidoctor/path_resolver.rb#223
  def relative_path(path, base); end

  # Public: Check whether the specified path is an absolute path.
  #
  # This operation considers both posix paths and Windows paths. The path does
  # not have to be posixified beforehand. This operation does not handle URIs.
  #
  # Unix absolute paths start with a slash. UNC paths can start with a slash or
  # backslash. Windows roots can start with a drive letter.
  #
  # path - the String path to check
  #
  # returns a Boolean indicating whether the path is an absolute root path
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/path_resolver.rb#145
  def root?(path); end

  # Public: Securely resolve a system path
  #
  # Resolves the target to an absolute path on the current filesystem. The target is assumed to be
  # relative to the start path, jail path, or working directory (specified in the constructor), in
  # that order. If a jail path is specified, the resolved path is forced to descend from the jail
  # path. If a jail path is not provided, the resolved path may be any location on the system. If
  # the target is an absolute path, use it as is (unless it breaches the jail path). Expands all
  # parent and self references in the resolved path.
  #
  # target - the String target path
  # start  - the String start path from which to resolve a relative target; falls back to jail, if
  #          specified, or the working directory specified in the constructor (default: nil)
  # jail   - the String jail path to which to confine the resolved path, if specified; must be an
  #          absolute path (default: nil)
  # opts   - an optional Hash of options to control processing (default: {}):
  #          * :recover is used to control whether the processor should
  #            automatically recover when an illegal path is encountered
  #          * :target_name is used in messages to refer to the path being resolved
  #
  # Returns an absolute String path relative to the start path, if specified, and confined to the
  # jail path, if specified. The path is posixified and all parent and self references in the path
  # are expanded.
  #
  # source://asciidoctor//lib/asciidoctor/path_resolver.rb#363
  def system_path(target, start = T.unsafe(nil), jail = T.unsafe(nil), opts = T.unsafe(nil)); end

  # Public: Determine if the path is a UNC (root) path
  #
  # path - the String path to check
  #
  # returns a Boolean indicating whether the path is a UNC path
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/path_resolver.rb#182
  def unc?(path); end

  # Public: Resolve a web path from the target and start paths.
  # The main function of this operation is to resolve any parent
  # references and remove any self references.
  #
  # The target is assumed to be a path, not a qualified URI.
  # That check should happen before this method is invoked.
  #
  # target - the String target path
  # start  - the String start (i.e., parent) path
  #
  # returns a String path that joins the target path with the
  # start path with any parent references resolved and self
  # references removed
  #
  # source://asciidoctor//lib/asciidoctor/path_resolver.rb#487
  def web_path(target, start = T.unsafe(nil)); end

  # Public: Determine if the path is an absolute (root) web path
  #
  # path - the String path to check
  #
  # returns a Boolean indicating whether the path is an absolute (root) web path
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/path_resolver.rb#191
  def web_root?(path); end

  # Returns the value of attribute working_dir.
  #
  # source://asciidoctor//lib/asciidoctor/path_resolver.rb#116
  def working_dir; end

  # Sets the attribute working_dir
  #
  # @param value the value to set the attribute working_dir to.
  #
  # source://asciidoctor//lib/asciidoctor/path_resolver.rb#116
  def working_dir=(_arg0); end

  private

  # Internal: Efficiently extracts the URI prefix from the specified String if the String is a URI
  #
  # Uses the Asciidoctor::UriSniffRx regex to match the URI prefix in the specified String (e.g., http://). If present,
  # the prefix is removed.
  #
  # str - the String to check
  #
  # returns a tuple containing the specified string without the URI prefix, if present, and the extracted URI prefix.
  #
  # source://asciidoctor//lib/asciidoctor/path_resolver.rb#536
  def extract_uri_prefix(str); end
end

# source://asciidoctor//lib/asciidoctor/path_resolver.rb#110
Asciidoctor::PathResolver::BACKSLASH = T.let(T.unsafe(nil), String)

# source://asciidoctor//lib/asciidoctor/path_resolver.rb#106
Asciidoctor::PathResolver::DOT = T.let(T.unsafe(nil), String)

# source://asciidoctor//lib/asciidoctor/path_resolver.rb#107
Asciidoctor::PathResolver::DOT_DOT = T.let(T.unsafe(nil), String)

# source://asciidoctor//lib/asciidoctor/path_resolver.rb#108
Asciidoctor::PathResolver::DOT_SLASH = T.let(T.unsafe(nil), String)

# source://asciidoctor//lib/asciidoctor/path_resolver.rb#111
Asciidoctor::PathResolver::DOUBLE_SLASH = T.let(T.unsafe(nil), String)

# source://asciidoctor//lib/asciidoctor/path_resolver.rb#109
Asciidoctor::PathResolver::SLASH = T.let(T.unsafe(nil), String)

# source://asciidoctor//lib/asciidoctor/path_resolver.rb#112
Asciidoctor::PathResolver::URI_CLASSLOADER = T.let(T.unsafe(nil), String)

# source://asciidoctor//lib/asciidoctor/path_resolver.rb#113
Asciidoctor::PathResolver::WindowsRootRx = T.let(T.unsafe(nil), Regexp)

# Public: Methods for retrieving lines from AsciiDoc source files, evaluating preprocessor
# directives as each line is read off the Array of lines.
#
# source://asciidoctor//lib/asciidoctor/reader.rb#617
class Asciidoctor::PreprocessorReader < ::Asciidoctor::Reader
  # Public: Initialize the PreprocessorReader object
  #
  # @return [PreprocessorReader] a new instance of PreprocessorReader
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#621
  def initialize(document, data = T.unsafe(nil), cursor = T.unsafe(nil), opts = T.unsafe(nil)); end

  # source://asciidoctor//lib/asciidoctor/reader.rb#784
  def create_include_cursor(file, path, lineno); end

  # Public: Check whether this reader is empty (contains no lines)
  #
  # Returns true if there are no more lines to peek, otherwise false.
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#644
  def empty?; end

  # Public: Check whether this reader is empty (contains no lines)
  #
  # Returns true if there are no more lines to peek, otherwise false.
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#644
  def eof?; end

  # Public: Reports whether pushing an include on the include stack exceeds the max include depth.
  #
  # Returns nil if no max depth is set and includes are disabled (max-include-depth=0), false if the current max depth
  # will not be exceeded, and the relative max include depth if the current max depth will be exceed.
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#755
  def exceeded_max_depth?; end

  # Public: Reports whether pushing an include on the include stack exceeds the max include depth.
  #
  # Returns nil if no max depth is set and includes are disabled (max-include-depth=0), false if the current max depth
  # will not be exceeded, and the relative max include depth if the current max depth will be exceed.
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#755
  def exceeds_max_depth?; end

  # Public: Check whether there are any lines left to read.
  #
  # If a previous call to this method resulted in a value of false,
  # immediately returned the cached value. Otherwise, delegate to
  # peek_line to determine if there is a next line available.
  #
  # Returns True if there are more lines, False if there are not.
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#639
  def has_more_lines?; end

  # source://asciidoctor//lib/asciidoctor/reader.rb#747
  def include_depth; end

  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#772
  def include_processors?; end

  # Returns the value of attribute include_stack.
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#618
  def include_stack; end

  # Public: Override the Reader#peek_line method to pop the include
  # stack if the last line has been reached and there's at least
  # one include on the stack.
  #
  # Returns the next line of the source data as a String if there are lines remaining
  # in the current include context or a parent include context.
  # Returns nothing if there are no more lines remaining and the include stack is empty.
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#656
  def peek_line(direct = T.unsafe(nil)); end

  # Public: Push source onto the front of the reader and switch the context
  # based on the file, document-relative path and line information given.
  #
  # This method is typically used in an IncludeProcessor to add source
  # read from the target specified.
  #
  # Examples
  #
  #    path = 'partial.adoc'
  #    file = File.expand_path path
  #    data = File.read file
  #    reader.push_include data, file, path
  #
  # Returns this Reader object.
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#681
  def push_include(data, file = T.unsafe(nil), path = T.unsafe(nil), lineno = T.unsafe(nil), attributes = T.unsafe(nil)); end

  # TODO Document this override
  # also, we now have the field in the super class, so perhaps
  # just implement the logic there?
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#763
  def shift; end

  # source://asciidoctor//lib/asciidoctor/reader.rb#796
  def to_s; end

  private

  # source://asciidoctor//lib/asciidoctor/reader.rb#1279
  def pop_include; end

  # source://asciidoctor//lib/asciidoctor/reader.rb#802
  def prepare_lines(data, opts = T.unsafe(nil)); end

  # Internal: Preprocess the directive to conditionally include or exclude content.
  #
  # Preprocess the conditional directive (ifdef, ifndef, ifeval, endif) under
  # the cursor. If Reader is currently skipping content, then simply track the
  # open and close delimiters of any nested conditional blocks. If Reader is
  # not skipping, mark whether the condition is satisfied and continue
  # preprocessing recursively until the next line of available content is
  # found.
  #
  # keyword   - The conditional inclusion directive (ifdef, ifndef, ifeval, endif)
  # target    - The target, which is the name of one or more attributes that are
  #             used in the condition (blank in the case of the ifeval directive)
  # delimiter - The conditional delimiter for multiple attributes ('+' means all
  #             attributes must be defined or undefined, ',' means any of the attributes
  #             can be defined or undefined.
  # text      - The text associated with this directive (occurring between the square brackets)
  #             Used for a single-line conditional block in the case of the ifdef or
  #             ifndef directives, and for the conditional expression for the ifeval directive.
  #
  # Returns a Boolean indicating whether the cursor should be advanced
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#904
  def preprocess_conditional_directive(keyword, target, delimiter, text); end

  # Internal: Preprocess the directive to include lines from another document.
  #
  # Preprocess the directive to include the target document. The scenarios
  # are as follows:
  #
  # If SafeMode is SECURE or greater, the directive is ignore and the include
  # directive line is emitted verbatim.
  #
  # Otherwise, if an include processor is specified pass the target and
  # attributes to that processor and expect an Array of String lines in return.
  #
  # Otherwise, if the max depth is greater than 0, and is not exceeded by the
  # stack size, normalize the target path and read the lines onto the beginning
  # of the Array of source data.
  #
  # If none of the above apply, emit the include directive line verbatim.
  #
  # target   - The unsubstituted String name of the target document to include as specified in the
  #            target slot of the include directive.
  # attrlist - An attribute list String, which is the text between the square brackets of the
  #            include directive.
  #
  # Returns a [Boolean] indicating whether the line under the cursor was changed. To skip over the
  # directive, call shift and return true.
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#1021
  def preprocess_include_directive(target, attrlist); end

  # source://asciidoctor//lib/asciidoctor/reader.rb#819
  def process_line(line); end

  # Private: Resolve the value of one side of the expression
  #
  # Examples
  #
  #   expr = '"value"'
  #   resolve_expr_val expr
  #   # => "value"
  #
  #   expr = '"value'
  #   resolve_expr_val expr
  #   # => "\"value"
  #
  #   expr = '"{undefined}"'
  #   resolve_expr_val expr
  #   # => ""
  #
  #   expr = '{undefined}'
  #   resolve_expr_val expr
  #   # => nil
  #
  #   expr = '2'
  #   resolve_expr_val expr
  #   # => 2
  #
  #   @document.attributes['name'] = 'value'
  #   expr = '"{name}"'
  #   resolve_expr_val expr
  #   # => "value"
  #
  # Returns The value of the expression, coerced to the appropriate type
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#1346
  def resolve_expr_val(val); end

  # Internal: Resolve the target of an include directive.
  #
  # An internal method to resolve the target of an include directive. This method must return an
  # Array containing the resolved (absolute) path of the target, the target type (:file or :uri),
  # and the path of the target relative to the outermost document. Alternately, the method may
  # return a boolean to halt processing of the include directive line and to indicate whether the
  # cursor should be advanced beyond this line (true) or the line should be reprocessed (false).
  #
  # This method is overridden in Asciidoctor.js to resolve the target of an include in the browser
  # environment.
  #
  # target     - A String containing the unresolved include target.
  #              (Attribute references in target value have already been resolved).
  # attrlist   - An attribute list String (i.e., the text between the square brackets).
  # attributes - A Hash of attributes parsed from attrlist.
  #
  # Returns An Array containing the resolved (absolute) include path, the target type, and the path
  # relative to the outermost document. May also return a boolean to halt processing of the include.
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#1243
  def resolve_include_path(target, attrlist, attributes); end

  # Private: Ignore front-matter, commonly used in static site generators
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#1296
  def skip_front_matter!(data, increment_linenos = T.unsafe(nil)); end

  # Private: Split delimited value on comma (if found), otherwise semi-colon
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#1291
  def split_delimited_value(val); end
end

# source://asciidoctor//lib/asciidoctor.rb#439
Asciidoctor::QUOTE_SUBS = T.let(T.unsafe(nil), Hash)

# NOTE order of replacements is significant
#
# source://asciidoctor//lib/asciidoctor.rb#489
Asciidoctor::REPLACEMENTS = T.let(T.unsafe(nil), Array)

# The absolute root directory of the Asciidoctor RubyGem
#
# source://asciidoctor//lib/asciidoctor.rb#178
Asciidoctor::ROOT_DIR = T.let(T.unsafe(nil), String)

# source://asciidoctor//lib/asciidoctor.rb#50
Asciidoctor::RUBY_ENGINE = T.let(T.unsafe(nil), String)

# alias the RUBY_ENGINE constant inside the Asciidoctor namespace and define a precomputed alias for runtime
#
# source://asciidoctor//lib/asciidoctor.rb#50
Asciidoctor::RUBY_ENGINE_OPAL = T.let(T.unsafe(nil), FalseClass)

# Public: Methods for retrieving lines from AsciiDoc source files
#
# source://asciidoctor//lib/asciidoctor/reader.rb#4
class Asciidoctor::Reader
  include ::Asciidoctor::Logging
  extend ::Asciidoctor::Logging

  # Public: Initialize the Reader object
  #
  # @return [Reader] a new instance of Reader
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#42
  def initialize(data = T.unsafe(nil), cursor = T.unsafe(nil), opts = T.unsafe(nil)); end

  # Public: Advance to the next line by discarding the line at the front of the stack
  #
  # Returns a Boolean indicating whether there was a line to discard.
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#216
  def advance; end

  # source://asciidoctor//lib/asciidoctor/reader.rb#484
  def cursor; end

  # source://asciidoctor//lib/asciidoctor/reader.rb#488
  def cursor_at_line(lineno); end

  # source://asciidoctor//lib/asciidoctor/reader.rb#492
  def cursor_at_mark; end

  # source://asciidoctor//lib/asciidoctor/reader.rb#505
  def cursor_at_prev_line; end

  # source://asciidoctor//lib/asciidoctor/reader.rb#496
  def cursor_before_mark; end

  # Returns the value of attribute dir.
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#26
  def dir; end

  # Internal: Discard a previous saved state
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#560
  def discard_save; end

  # Public: Check whether this reader is empty (contains no lines)
  #
  # Returns true if there are no more lines to peek, otherwise false.
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#90
  def empty?; end

  # Public: Check whether this reader is empty (contains no lines)
  #
  # Returns true if there are no more lines to peek, otherwise false.
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#90
  def eof?; end

  # Returns the value of attribute file.
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#25
  def file; end

  # Public: Check whether there are any lines left to read.
  #
  # If a previous call to this method resulted in a value of false,
  # immediately returned the cached value. Otherwise, delegate to
  # peek_line to determine if there is a next line available.
  #
  # Returns True if there are more lines, False if there are not.
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#78
  def has_more_lines?; end

  # Public: Get information about the last line read, including file name and line number.
  #
  # Returns A String summary of the last line read
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#516
  def line_info; end

  # Public: Get the 1-based offset of the current line.
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#30
  def lineno; end

  # Public: Get a copy of the remaining Array of String lines managed by this Reader
  #
  # Returns A copy of the String Array of lines remaining in this Reader
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#523
  def lines; end

  # source://asciidoctor//lib/asciidoctor/reader.rb#509
  def mark; end

  # Public: Peek at the next line and check if it's empty (i.e., whitespace only)
  #
  # This method Does not consume the line from the stack.
  #
  # Returns True if the there are no more lines or if the next line is empty
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#105
  def next_line_empty?; end

  # Returns the value of attribute path.
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#27
  def path; end

  # Public: Peek at the next line of source data. Processes the line if not
  # already marked as processed, but does not consume it.
  #
  # This method will probe the reader for more lines. If there is a next line
  # that has not previously been visited, the line is passed to the
  # Reader#process_line method to be initialized. This call gives
  # sub-classes the opportunity to do preprocessing. If the return value of
  # the Reader#process_line is nil, the data is assumed to be changed and
  # Reader#peek_line is invoked again to perform further processing.
  #
  # If has_more_lines? is called immediately before peek_line, the direct flag
  # is implicitly true (since the line is flagged as visited).
  #
  # direct  - A Boolean flag to bypasses the check for more lines and immediately
  #           returns the first element of the internal @lines Array. (default: false)
  #
  # Returns the next line of the source data as a String if there are lines remaining.
  # Returns nothing if there is no more data.
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#127
  def peek_line(direct = T.unsafe(nil)); end

  # Public: Peek at the next multiple lines of source data. Processes the lines if not
  # already marked as processed, but does not consume them.
  #
  # This method delegates to Reader#read_line to process and collect the line, then
  # restores the lines to the stack before returning them. This allows the lines to
  # be processed and marked as such so that subsequent reads will not need to process
  # the lines again.
  #
  # num    - The positive Integer number of lines to peek or nil to peek all lines (default: nil).
  # direct - A Boolean indicating whether processing should be disabled when reading lines (default: false).
  #
  # Returns A String Array of the next multiple lines of source data, or an empty Array
  # if there are no more lines in this Reader.
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#159
  def peek_lines(num = T.unsafe(nil), direct = T.unsafe(nil)); end

  # Public: Control whether lines are processed using Reader#process_line on first visit (default: true)
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#36
  def process_lines; end

  # Public: Control whether lines are processed using Reader#process_line on first visit (default: true)
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#36
  def process_lines=(_arg0); end

  # Public: Get the remaining lines of source data joined as a String.
  #
  # Delegates to Reader#read_lines, then joins the result.
  #
  # Returns the lines read joined as a String
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#209
  def read; end

  # Public: Get the next line of source data. Consumes the line returned.
  #
  # Returns the String of the next line of the source data if data is present.
  # Returns nothing if there is no more data.
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#183
  def read_line; end

  # Public: Get the remaining lines of source data.
  #
  # This method calls Reader#read_line repeatedly until all lines are consumed
  # and returns the lines as a String Array. This method differs from
  # Reader#lines in that it processes each line in turn, hence triggering
  # any preprocessors implemented in sub-classes.
  #
  # Returns the lines read as a String Array
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#196
  def read_lines; end

  # Public: Return all the lines from `@lines` until we (1) run out them,
  #   (2) find a blank line with `break_on_blank_lines: true`, or (3) find
  #   a line for which the given block evals to true.
  #
  # options - an optional Hash of processing options:
  #           * :terminator may be used to specify the contents of the line
  #               at which the reader should stop
  #           * :break_on_blank_lines may be used to specify to break on
  #               blank lines
  #           * :break_on_list_continuation may be used to specify to break
  #               on a list continuation line
  #           * :skip_first_line may be used to tell the reader to advance
  #               beyond the first line before beginning the scan
  #           * :preserve_last_line may be used to specify that the String
  #               causing the method to stop processing lines should be
  #               pushed back onto the `lines` Array.
  #           * :read_last_line may be used to specify that the String
  #               causing the method to stop processing lines should be
  #               included in the lines being returned
  #           * :skip_line_comments may be used to look for and skip
  #               line comments
  #           * :skip_processing is used to disable line (pre)processing
  #               for the duration of this method
  #
  # Returns the Array of lines forming the next segment.
  #
  # Examples
  #
  #   data = [
  #     "First line\n",
  #     "Second line\n",
  #     "\n",
  #     "Third line\n",
  #   ]
  #   reader = Reader.new data, nil, normalize: true
  #
  #   reader.read_lines_until
  #   => ["First line", "Second line"]
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#396
  def read_lines_until(options = T.unsafe(nil)); end

  # Public: Get the remaining lines of source data.
  #
  # This method calls Reader#read_line repeatedly until all lines are consumed
  # and returns the lines as a String Array. This method differs from
  # Reader#lines in that it processes each line in turn, hence triggering
  # any preprocessors implemented in sub-classes.
  #
  # Returns the lines read as a String Array
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#196
  def readlines; end

  # Public: Replace the next line with the specified line.
  #
  # Calls Reader#advance to consume the current line, then calls
  # Reader#unshift to push the replacement onto the top of the
  # line stack.
  #
  # replacement - The String line to put in place of the next line (i.e., the line at the cursor).
  #
  # Returns true.
  # deprecated
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#258
  def replace_line(replacement); end

  # Public: Replace the next line with the specified line.
  #
  # Calls Reader#advance to consume the current line, then calls
  # Reader#unshift to push the replacement onto the top of the
  # line stack.
  #
  # replacement - The String line to put in place of the next line (i.e., the line at the cursor).
  #
  # Returns true.
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#258
  def replace_next_line(replacement); end

  # Public: Push the String line onto the beginning of the Array of source data.
  #
  # A line pushed on the reader using this method is not processed again. The
  # method assumes the line was previously retrieved from the reader or does
  # not otherwise contain preprocessor directives. Therefore, it is marked as
  # processed immediately.
  #
  # line_to_restore - the line to restore onto the stack
  #
  # Returns nothing.
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#230
  def restore_line(line_to_restore); end

  # Public: Push an Array of lines onto the front of the Array of source data.
  #
  # Lines pushed on the reader using this method are not processed again. The
  # method assumes the lines were previously retrieved from the reader or do
  # not otherwise contain preprocessor directives. Therefore, they are marked
  # as processed immediately.
  #
  # Returns nothing.
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#244
  def restore_lines(lines_to_restore); end

  # Internal: Restore the state of the reader at cursor
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#550
  def restore_save; end

  # Internal: Save the state of the reader at cursor
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#538
  def save; end

  # Internal: Shift the line off the stack and increment the lineno
  #
  # This method can be used directly when you've already called peek_line
  # and determined that you do, in fact, want to pluck that line off the stack.
  # Use read_line if the line hasn't (or many not have been) visited yet.
  #
  # Returns The String line at the top of the stack
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#448
  def shift; end

  # Public: Skip blank lines at the cursor.
  #
  # Examples
  #
  #   reader.lines
  #   => ["", "", "Foo", "Bar", ""]
  #   reader.skip_blank_lines
  #   => 2
  #   reader.lines
  #   => ["Foo", "Bar", ""]
  #
  # Returns the [Integer] number of lines skipped or nothing if all lines have
  # been consumed (even if lines were skipped by this method).
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#279
  def skip_blank_lines; end

  # Public: Skip consecutive comment lines and block comments.
  #
  # Examples
  #   @lines
  #   => ["// foo", "bar"]
  #
  #   comment_lines = skip_comment_lines
  #   => nil
  #
  #   @lines
  #   => ["bar"]
  #
  # Returns nothing
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#307
  def skip_comment_lines; end

  # Public: Skip consecutive comment lines and return them.
  #
  # This method assumes the reader only contains simple lines (no blocks).
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#332
  def skip_line_comments; end

  # Public: Get the source lines for this Reader joined as a String
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#533
  def source; end

  # Public: Get the document source as a String Array of lines.
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#33
  def source_lines; end

  # Public: Get a copy of the remaining lines managed by this Reader joined as a String
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#528
  def string; end

  # Public: Advance to the end of the reader, consuming all remaining lines
  #
  # Returns nothing.
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#351
  def terminate; end

  # source://asciidoctor//lib/asciidoctor/reader.rb#564
  def to_s; end

  # Internal: Restore the line to the stack and decrement the lineno
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#455
  def unshift(line); end

  # Internal: Restore the lines to the stack and decrement the lineno
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#476
  def unshift_all(lines_to_restore); end

  # Public: Push the String line onto the beginning of the Array of source data.
  #
  # A line pushed on the reader using this method is not processed again. The
  # method assumes the line was previously retrieved from the reader or does
  # not otherwise contain preprocessor directives. Therefore, it is marked as
  # processed immediately.
  #
  # line_to_restore - the line to restore onto the stack
  #
  # Returns nothing.
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#230
  def unshift_line(line_to_restore); end

  # Public: Push an Array of lines onto the front of the Array of source data.
  #
  # Lines pushed on the reader using this method are not processed again. The
  # method assumes the lines were previously retrieved from the reader or do
  # not otherwise contain preprocessor directives. Therefore, they are marked
  # as processed immediately.
  #
  # Returns nothing.
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#244
  def unshift_lines(lines_to_restore); end

  # Public: Indicates that the end of the reader was reached with a delimited block still open.
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#39
  def unterminated; end

  # Public: Indicates that the end of the reader was reached with a delimited block still open.
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#39
  def unterminated=(_arg0); end

  private

  # Internal: Prepare the source data for parsing.
  #
  # Converts the source data into an Array of lines ready for parsing. If the +:normalize+ option is set, this method
  # coerces the encoding of each line to UTF-8 and strips trailing whitespace, including the newline. (This whitespace
  # cleaning is very important to how Asciidoctor works). Subclasses may choose to perform additional preparation.
  #
  # data - A String Array or String of source data to be normalized.
  # opts - A Hash of options to control how lines are prepared.
  #        :normalize - Enables line normalization, which coerces the encoding to UTF-8 and removes trailing whitespace;
  #        :rstrip removes all trailing whitespace; :chomp removes trailing newline only (optional, not set).
  #
  # Returns A String Array of source lines. If the source data is an Array, this method returns a copy.
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#582
  def prepare_lines(data, opts = T.unsafe(nil)); end

  # Internal: Processes a previously unvisited line
  #
  # By default, this method marks the line as processed
  # by incrementing the look_ahead counter and returns
  # the line unmodified.
  #
  # Returns The String line the Reader should make available to the next
  # invocation of Reader#read_line or nil if the Reader should drop the line,
  # advance to the next line and process it.
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#609
  def process_line(line); end
end

# source://asciidoctor//lib/asciidoctor/reader.rb#7
class Asciidoctor::Reader::Cursor
  # @return [Cursor] a new instance of Cursor
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#10
  def initialize(file, dir = T.unsafe(nil), path = T.unsafe(nil), lineno = T.unsafe(nil)); end

  # source://asciidoctor//lib/asciidoctor/reader.rb#14
  def advance(num); end

  # Returns the value of attribute dir.
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#8
  def dir; end

  # Returns the value of attribute file.
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#8
  def file; end

  # source://asciidoctor//lib/asciidoctor/reader.rb#18
  def line_info; end

  # Returns the value of attribute lineno.
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#8
  def lineno; end

  # Returns the value of attribute path.
  #
  # source://asciidoctor//lib/asciidoctor/reader.rb#8
  def path; end

  # source://asciidoctor//lib/asciidoctor/reader.rb#18
  def to_s; end
end

# Detects if text is a possible candidate for the replacements substitution.
#
# source://asciidoctor//lib/asciidoctor/rx.rb#683
Asciidoctor::ReplaceableTextRx = T.let(T.unsafe(nil), Regexp)

# Matches the revision info line, which appears immediately following
# the author info line beneath the document title.
#
# Examples
#
#   v1.0
#   2013-01-01
#   v1.0, 2013-01-01: Ring in the new year release
#   1.0, Jan 01, 2013
#
# source://asciidoctor//lib/asciidoctor/rx.rb#42
Asciidoctor::RevisionInfoLineRx = T.let(T.unsafe(nil), Regexp)

# A collection of regular expression constants used by the parser. (For speed, these are not defined in the Rx module,
# but rather directly in the Asciidoctor module).
#
# NOTE The following pattern, which appears frequently, captures the contents between square brackets, ignoring
# escaped closing brackets (closing brackets prefixed with a backslash '\' character)
#
#   Pattern: \[(|#{CC_ALL}*?[^\\])\]
#   Matches: [enclosed text] and [enclosed [text\]], not [enclosed text \\] or [\\] (as these require a trailing space)
#
# source://asciidoctor//lib/asciidoctor/rx.rb#11
module Asciidoctor::Rx; end

# source://asciidoctor//lib/asciidoctor.rb#262
Asciidoctor::SETEXT_SECTION_LEVELS = T.let(T.unsafe(nil), Hash)

# source://asciidoctor//lib/asciidoctor.rb#351
Asciidoctor::STEM_TYPE_ALIASES = T.let(T.unsafe(nil), Hash)

# source://asciidoctor//lib/asciidoctor.rb#52
module Asciidoctor::SafeMode
  class << self
    # source://asciidoctor//lib/asciidoctor.rb#96
    def name_for_value(value); end

    # source://asciidoctor//lib/asciidoctor.rb#100
    def names; end

    # source://asciidoctor//lib/asciidoctor.rb#92
    def value_for_name(name); end
  end
end

# A safe mode level that closely parallels safe mode in AsciiDoc. This value
# prevents access to files which reside outside of the parent directory of
# the source file and disables any macro other than the include::[] directive.
#
# source://asciidoctor//lib/asciidoctor.rb#60
Asciidoctor::SafeMode::SAFE = T.let(T.unsafe(nil), Integer)

# A safe mode level that disallows the document from attempting to read
# files from the file system and including the contents of them into the
# document, in additional to all the security features of SafeMode::SERVER.
# For instance, this level disallows use of the include::[] directive and the
# embedding of binary content (data uri), stylesheets and JavaScripts
# referenced by the document. (Asciidoctor and trusted extensions may still
# be allowed to embed trusted content into the document).
#
# Since Asciidoctor is aiming for wide adoption, this level is the default
# and is recommended for server deployments.
#
# source://asciidoctor//lib/asciidoctor.rb#80
Asciidoctor::SafeMode::SECURE = T.let(T.unsafe(nil), Integer)

# A safe mode level that disallows the document from setting attributes
# that would affect the conversion of the document, in addition to all the
# security features of SafeMode::SAFE. For instance, this level forbids
# changing the backend or source-highlighter using an attribute defined
# in the source document header. This is the most fundamental level of
# security for server deployments (hence the name).
#
# source://asciidoctor//lib/asciidoctor.rb#68
Asciidoctor::SafeMode::SERVER = T.let(T.unsafe(nil), Integer)

# A safe mode level that disables any of the security features enforced
# by Asciidoctor (Ruby is still subject to its own restrictions).
#
# source://asciidoctor//lib/asciidoctor.rb#55
Asciidoctor::SafeMode::UNSAFE = T.let(T.unsafe(nil), Integer)

# => 1
#
# source://asciidoctor//lib/asciidoctor/section.rb#22
class Asciidoctor::Section < ::Asciidoctor::AbstractBlock
  # Public: Initialize an Asciidoctor::Section object.
  #
  # parent   - The parent AbstractBlock. If set, must be a Document or Section object (default: nil)
  # level    - The Integer level of this section (default: 1 more than parent level or 1 if parent not defined)
  # numbered - A Boolean indicating whether numbering is enabled for this Section (default: false)
  # opts     - An optional Hash of options (default: {})
  #
  # @return [Section] a new instance of Section
  #
  # source://asciidoctor//lib/asciidoctor/section.rb#46
  def initialize(parent = T.unsafe(nil), level = T.unsafe(nil), numbered = T.unsafe(nil), opts = T.unsafe(nil)); end

  # Public: Append a content block to this block's list of blocks.
  #
  # If the child block is a Section, assign an index to it.
  #
  # block - The child Block to append to this parent Block
  #
  # Returns The parent Block
  #
  # source://asciidoctor//lib/asciidoctor/section.rb#166
  def <<(block); end

  # Public: Get the caption for this section (only relevant for appendices)
  #
  # source://asciidoctor//lib/asciidoctor/section.rb#38
  def caption; end

  # source://asciidoctor-pdf/2.3.19/lib/asciidoctor/pdf/ext/asciidoctor/section.rb#37
  def first_section_of_part?; end

  # Public: Generate a String ID from the title of this section.
  #
  # See Section.generate_id for details.
  #
  # source://asciidoctor//lib/asciidoctor/section.rb#63
  def generate_id; end

  # Public: Get/Set the 0-based index order of this section within the parent block
  #
  # source://asciidoctor//lib/asciidoctor/section.rb#25
  def index; end

  # Public: Get/Set the 0-based index order of this section within the parent block
  #
  # source://asciidoctor//lib/asciidoctor/section.rb#25
  def index=(_arg0); end

  # Public: The name of this section, an alias of the section title
  #
  # source://asciidoctor//lib/asciidoctor/abstract_block.rb#288
  def name; end

  # Public: Get/Set the flag to indicate whether this section should be numbered.
  # The sectnum method should only be called if this flag is true.
  #
  # source://asciidoctor//lib/asciidoctor/section.rb#35
  def numbered; end

  # Public: Get/Set the flag to indicate whether this section should be numbered.
  # The sectnum method should only be called if this flag is true.
  #
  # source://asciidoctor//lib/asciidoctor/section.rb#35
  def numbered=(_arg0); end

  # source://asciidoctor-pdf/2.3.19/lib/asciidoctor/pdf/ext/asciidoctor/section.rb#4
  def numbered_title(opts = T.unsafe(nil)); end

  # Public: Check whether this Section has any child Section objects.
  #
  # Returns A [Boolean] to indicate whether this Section has child Section objects
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/section.rb#70
  def sections?; end

  # Public: Get/Set the section name of this section
  #
  # source://asciidoctor//lib/asciidoctor/section.rb#28
  def sectname; end

  # Public: Get/Set the section name of this section
  #
  # source://asciidoctor//lib/asciidoctor/section.rb#28
  def sectname=(_arg0); end

  # Public: Get the section number for the current Section
  #
  # The section number is a dot-separated String that uniquely describes the position of this
  # Section in the document. Each entry represents a level of nesting. The value of each entry is
  # the 1-based outline number of the Section amongst its numbered sibling Sections.
  #
  # This method assumes that both the @level and @parent instance variables have been assigned.
  # The method also assumes that the value of @parent is either a Document or Section.
  #
  # delimiter - the delimiter to separate the number for each level
  # append    - the String to append at the end of the section number
  #             or Boolean to indicate the delimiter should not be
  #             appended to the final level
  #             (default: nil)
  #
  # Examples
  #
  #   sect1 = Section.new(document)
  #   sect1.level = 1
  #   sect1_1 = Section.new(sect1)
  #   sect1_1.level = 2
  #   sect1_2 = Section.new(sect1)
  #   sect1_2.level = 2
  #   sect1 << sect1_1
  #   sect1 << sect1_2
  #   sect1_1_1 = Section.new(sect1_1)
  #   sect1_1_1.level = 3
  #   sect1_1 << sect1_1_1
  #
  #   sect1.sectnum
  #   # => 1.
  #
  #   sect1_1.sectnum
  #   # => 1.1.
  #
  #   sect1_2.sectnum
  #   # => 1.2.
  #
  #   sect1_1_1.sectnum
  #   # => 1.1.1.
  #
  #   sect1_1_1.sectnum(',', false)
  #   # => 1,1,1
  #
  # Returns the section number as a String
  #
  # source://asciidoctor//lib/asciidoctor/section.rb#119
  def sectnum(delimiter = T.unsafe(nil), append = T.unsafe(nil)); end

  # Public: Get/Set the flag to indicate whether this is a special section or a child of one
  #
  # source://asciidoctor//lib/asciidoctor/section.rb#31
  def special; end

  # Public: Get/Set the flag to indicate whether this is a special section or a child of one
  #
  # source://asciidoctor//lib/asciidoctor/section.rb#31
  def special=(_arg0); end

  # source://asciidoctor//lib/asciidoctor/section.rb#171
  def to_s; end

  # Public: Generate cross reference text (xreftext) that can be used to refer
  # to this block.
  #
  # Use the explicit reftext for this block, if specified, retrieved from the
  # {#reftext} method. Otherwise, if this is a section or captioned block (a
  # block with both a title and caption), generate the xreftext according to
  # the value of the xrefstyle argument (e.g., full, short). This logic may
  # leverage the {Substitutors#sub_quotes} method to apply formatting to the
  # text. If this is not a captioned block, return the title, if present, or
  # nil otherwise.
  #
  # xrefstyle - An optional String that specifies the style to use to format
  #             the xreftext ('full', 'short', or 'basic') (default: nil).
  #
  # Returns the generated [String] xreftext used to refer to this block or
  # nothing if there isn't sufficient information to generate one.
  #
  # source://asciidoctor//lib/asciidoctor/section.rb#125
  def xreftext(xrefstyle = T.unsafe(nil)); end

  class << self
    # Public: Generate a String ID from the given section title.
    #
    # The generated ID is prefixed with value of the 'idprefix' attribute, which
    # is an underscore (_) by default. Invalid characters are then removed and
    # spaces are replaced with the value of the 'idseparator' attribute, which is
    # an underscore (_) by default.
    #
    # If the generated ID is already in use in the document, a count is appended,
    # offset by the separator, until a unique ID is found.
    #
    # Section ID generation can be disabled by unsetting the 'sectids' document attribute.
    #
    # Examples
    #
    #   Section.generate_id 'Foo', document
    #   => "_foo"
    #
    # Returns the generated [String] ID.
    #
    # source://asciidoctor//lib/asciidoctor/section.rb#198
    def generate_id(title, document); end
  end
end

# Matches an explicit section level style like sect1
#
# source://asciidoctor//lib/asciidoctor/rx.rb#266
Asciidoctor::SectionLevelStyleRx = T.let(T.unsafe(nil), Regexp)

# Matches the title only (first line) of an Setext (two-line) section title.
# The title cannot begin with a dot and must have at least one alphanumeric character.
#
# source://asciidoctor//lib/asciidoctor/rx.rb#248
Asciidoctor::SetextSectionTitleRx = T.let(T.unsafe(nil), Regexp)

# Matches a whitespace delimiter, a sequence of spaces, tabs, and/or newlines.
# Matches the parsing rules of %w strings in Ruby.
#
# Examples
#
#   one two	 three   four
#   five	six
#
# TODO change to /(?<!\\)[ \t\n]+/ once lookbehind assertions are implemented in all modern browsers
#
# source://asciidoctor//lib/asciidoctor/rx.rb#694
Asciidoctor::SpaceDelimiterRx = T.let(T.unsafe(nil), Regexp)

# QUESTION create method for user stylesheet?
#
# source://asciidoctor//lib/asciidoctor/stylesheets.rb#7
class Asciidoctor::Stylesheets
  # Public: Read the contents of the default CodeRay stylesheet
  #
  # returns the [String] CodeRay stylesheet data
  #
  # source://asciidoctor//lib/asciidoctor/stylesheets.rb#48
  def coderay_stylesheet_data; end

  # source://asciidoctor//lib/asciidoctor/stylesheets.rb#41
  def coderay_stylesheet_name; end

  # Deprecated: Generate code to embed the CodeRay stylesheet
  #
  # Returns the [String] CodeRay stylesheet data wrapped in a <style> tag
  #
  # source://asciidoctor//lib/asciidoctor/stylesheets.rb#55
  def embed_coderay_stylesheet; end

  # Deprecated: Generate code to embed the primary stylesheet
  #
  # Returns the [String] primary stylesheet data wrapped in a <style> tag
  #
  # source://asciidoctor//lib/asciidoctor/stylesheets.rb#31
  def embed_primary_stylesheet; end

  # Deprecated: Generate code to embed the Pygments stylesheet
  #
  # Returns the [String] Pygments stylesheet data for the specified style wrapped in a <style> tag
  #
  # source://asciidoctor//lib/asciidoctor/stylesheets.rb#79
  def embed_pygments_stylesheet(style = T.unsafe(nil)); end

  # Public: Read the contents of the default Asciidoctor stylesheet
  #
  # returns the [String] Asciidoctor stylesheet data
  #
  # source://asciidoctor//lib/asciidoctor/stylesheets.rb#24
  def primary_stylesheet_data; end

  # source://asciidoctor//lib/asciidoctor/stylesheets.rb#17
  def primary_stylesheet_name; end

  # Public: Generate the Pygments stylesheet with the specified style.
  #
  # returns the [String] Pygments stylesheet data
  #
  # source://asciidoctor//lib/asciidoctor/stylesheets.rb#72
  def pygments_stylesheet_data(style = T.unsafe(nil)); end

  # source://asciidoctor//lib/asciidoctor/stylesheets.rb#65
  def pygments_stylesheet_name(style = T.unsafe(nil)); end

  # source://asciidoctor//lib/asciidoctor/stylesheets.rb#61
  def write_coderay_stylesheet(target_dir = T.unsafe(nil)); end

  # source://asciidoctor//lib/asciidoctor/stylesheets.rb#37
  def write_primary_stylesheet(target_dir = T.unsafe(nil)); end

  # source://asciidoctor//lib/asciidoctor/stylesheets.rb#85
  def write_pygments_stylesheet(target_dir = T.unsafe(nil), style = T.unsafe(nil)); end

  class << self
    # source://asciidoctor//lib/asciidoctor/stylesheets.rb#13
    def instance; end
  end
end

# source://asciidoctor//lib/asciidoctor/stylesheets.rb#8
Asciidoctor::Stylesheets::DEFAULT_STYLESHEET_NAME = T.let(T.unsafe(nil), String)

# source://asciidoctor//lib/asciidoctor/stylesheets.rb#9
Asciidoctor::Stylesheets::STYLESHEETS_DIR = T.let(T.unsafe(nil), String)

# Matches a + or - modifier in a subs list
#
# source://asciidoctor//lib/asciidoctor/rx.rb#698
Asciidoctor::SubModifierSniffRx = T.let(T.unsafe(nil), Regexp)

# the necessary substitutions.
#
# source://asciidoctor//lib/asciidoctor/substitutors.rb#6
module Asciidoctor::Substitutors
  # Public: Apply substitutions for header metadata and attribute assignments
  #
  # text    - String containing the text process
  #
  # Returns A String with header substitutions performed
  #
  # source://asciidoctor//lib/asciidoctor/substitutors.rb#141
  def apply_header_subs(text); end

  # Public: Apply normal substitutions.
  #
  # An alias for apply_subs with default remaining arguments.
  #
  # text  - The String text to which to apply normal substitutions
  #
  # Returns the String with normal substitutions applied.
  #
  # source://asciidoctor//lib/asciidoctor/substitutors.rb#132
  def apply_normal_subs(text); end

  # Public: Apply substitutions for reftext.
  #
  # text - The String to process
  #
  # Returns a String with all substitutions from the reftext substitution group applied
  #
  # source://asciidoctor//lib/asciidoctor/substitutors.rb#157
  def apply_reftext_subs(text); end

  # Public: Apply the specified substitutions to the text.
  #
  # text  - The String or String Array of text to process; must not be nil.
  # subs  - The substitutions to perform; must be a Symbol Array or nil (default: NORMAL_SUBS).
  #
  # Returns a String or String Array to match the type of the text argument with substitutions applied.
  #
  # source://asciidoctor//lib/asciidoctor/substitutors.rb#75
  def apply_subs(text, subs = T.unsafe(nil)); end

  # Public: Apply the specified substitutions to the text.
  #
  # text  - The String or String Array of text to process; must not be nil.
  # subs  - The substitutions to perform; must be a Symbol Array or nil (default: NORMAL_SUBS).
  #
  # Returns a String or String Array to match the type of the text argument with substitutions applied.
  # Public: Apply substitutions for titles.
  #
  # title  - The String title to process
  #
  # Returns A String with title substitutions performed
  #
  # source://asciidoctor//lib/asciidoctor/substitutors.rb#75
  def apply_title_subs(text, subs = T.unsafe(nil)); end

  # Internal: Commit the requested substitutions to this block.
  #
  # Looks for an attribute named "subs". If present, resolves substitutions
  # from the value of that attribute and assigns them to the subs property on
  # this block. Otherwise, uses the substitutions assigned to the default_subs
  # property, if specified, or selects a default set of substitutions based on
  # the content model of the block.
  #
  # Returns nothing
  #
  # source://asciidoctor//lib/asciidoctor/substitutors.rb#1285
  def commit_subs; end

  # Public: Expand all groups in the subs list and return. If no subs are resolved, return nil.
  #
  # subs - The substitutions to expand; can be a Symbol, Symbol Array, or String
  # subject - The String to use in log messages to communicate the subject for which subs are being resolved (default: nil)
  #
  # Returns a Symbol Array of substitutions to pass to apply_subs or nil if no substitutions were resolved.
  #
  # source://asciidoctor//lib/asciidoctor/substitutors.rb#1255
  def expand_subs(subs, subject = T.unsafe(nil)); end

  # Public: Extract the passthrough text from the document for reinsertion after processing.
  #
  # text - The String from which to extract passthrough fragments
  #
  # Returns the String text with passthrough regions substituted with placeholders
  #
  # source://asciidoctor//lib/asciidoctor/substitutors.rb#1018
  def extract_passthroughs(text); end

  # Public: Highlight (i.e., colorize) the source code during conversion using a syntax highlighter, if activated by the
  # source-highlighter document attribute. Otherwise return the text with verbatim substitutions applied.
  #
  # If the process_callouts argument is true, this method will extract the callout marks from the source before passing
  # it to the syntax highlighter, then subsequently restore those callout marks to the highlighted source so the callout
  # marks don't confuse the syntax highlighter.
  #
  # source - the source code String to syntax highlight
  # process_callouts - a Boolean flag indicating whether callout marks should be located and substituted
  #
  # Returns the highlighted source code, if a syntax highlighter is defined on the document, otherwise the source with
  # verbatim substitutions applied
  #
  # source://asciidoctor//lib/asciidoctor/substitutors.rb#946
  def highlight_source(source, process_callouts); end

  # Internal: Parse attributes in name or name=value format from a comma-separated String
  #
  # attrlist - A comma-separated String list of attributes in name or name=value format.
  # posattrs - An Array of positional attribute names (default: []).
  # opts     - A Hash of options to control how the string is parsed (default: {}):
  #            :into           - The Hash to parse the attributes into (optional, default: false).
  #            :sub_input      - A Boolean that indicates whether to substitute attributes prior to
  #                              parsing (optional, default: false).
  #            :sub_result     - A Boolean that indicates whether to apply substitutions
  #                              single-quoted attribute values (optional, default: true).
  #            :unescape_input - A Boolean that indicates whether to unescape square brackets prior
  #                              to parsing (optional, default: false).
  #
  # Returns an empty Hash if attrlist is nil or empty, otherwise a Hash of parsed attributes.
  #
  # source://asciidoctor//lib/asciidoctor/substitutors.rb#1330
  def parse_attributes(attrlist, posattrs = T.unsafe(nil), opts = T.unsafe(nil)); end

  # Public: Call resolve_subs for the :block type.
  #
  # source://asciidoctor//lib/asciidoctor/substitutors.rb#1240
  def resolve_block_subs(subs, defaults, subject); end

  # Public: Resolve the line numbers in the specified source to highlight from the provided spec.
  #
  # e.g., highlight="1-5, !2, 10" or highlight=1-5;!2,10
  #
  # source - The String source.
  # spec   - The lines specifier (e.g., "1-5, !2, 10" or "1..5;!2;10")
  # start  - The line number of the first line (optional, default: false)
  #
  # Returns an [Array] of unique, sorted line numbers.
  #
  # source://asciidoctor//lib/asciidoctor/substitutors.rb#984
  def resolve_lines_to_highlight(source, spec, start = T.unsafe(nil)); end

  # Public: Call resolve_subs for the :inline type with the subject set as passthrough macro.
  #
  # source://asciidoctor//lib/asciidoctor/substitutors.rb#1245
  def resolve_pass_subs(subs); end

  # Public: Resolve the list of comma-delimited subs against the possible options.
  #
  # subs     - The comma-delimited String of substitution names or aliases.
  # type     - A Symbol representing the context for which the subs are being resolved (default: :block).
  # defaults - An Array of substitutions to start with when computing incremental substitutions (default: nil).
  # subject  - The String to use in log messages to communicate the subject for which subs are being resolved (default: nil)
  #
  # Returns An Array of Symbols representing the substitution operation or nothing if no subs are found.
  #
  # source://asciidoctor//lib/asciidoctor/substitutors.rb#1177
  def resolve_subs(subs, type = T.unsafe(nil), defaults = T.unsafe(nil), subject = T.unsafe(nil)); end

  # Public: Restore the passthrough text by reinserting into the placeholder positions
  #
  # text  - The String text into which to restore the passthrough text
  #
  # returns The String text with the passthrough text restored
  #
  # source://asciidoctor//lib/asciidoctor/substitutors.rb#1150
  def restore_passthroughs(text); end

  # Public: Substitutes attribute references in the specified text
  #
  # Attribute references are in the format +{name}+.
  #
  # If an attribute referenced in the line is missing or undefined, the line may be dropped
  # based on the attribute-missing or attribute-undefined setting, respectively.
  #
  # text - The String text to process
  # opts - A Hash of options to control processing: (default: {})
  #        * :attribute_missing controls how to handle a missing attribute (see Compliance.attribute_missing for values)
  #        * :drop_line_severity the severity level at which to log a dropped line (:info or :ignore)
  #
  # Returns the [String] text with the attribute references replaced with resolved values
  #
  # source://asciidoctor//lib/asciidoctor/substitutors.rb#211
  def sub_attributes(text, opts = T.unsafe(nil)); end

  # Public: Substitute callout source references
  #
  # text - The String text to process
  #
  # Returns the converted String text
  #
  # source://asciidoctor//lib/asciidoctor/substitutors.rb#920
  def sub_callouts(text); end

  # Public: Substitute inline macros (e.g., links, images, etc)
  #
  # Replace inline macros, which may span multiple lines, in the provided text
  #
  # source - The String text to process
  #
  # returns The converted String text
  #
  # source://asciidoctor//lib/asciidoctor/substitutors.rb#296
  def sub_macros(text); end

  # Public: Substitute post replacements
  #
  # text - The String text to process
  #
  # Returns the converted String text
  #
  # source://asciidoctor//lib/asciidoctor/substitutors.rb#889
  def sub_post_replacements(text); end

  # Public: Substitute quoted text (includes emphasis, strong, monospaced, etc.)
  #
  # text - The String text to process
  #
  # returns The converted [String] text
  #
  # source://asciidoctor//lib/asciidoctor/substitutors.rb#189
  def sub_quotes(text); end

  # source://asciidoctor//lib/asciidoctor/substitutors.rb#282
  def sub_replacements(text); end

  # Public: Apply verbatim substitutions on source (for use when highlighting is disabled).
  #
  # source - the source code String on which to apply verbatim substitutions
  # process_callouts - a Boolean flag indicating whether callout marks should be substituted
  #
  # Returns the substituted source
  #
  # source://asciidoctor//lib/asciidoctor/substitutors.rb#911
  def sub_source(source, process_callouts); end

  # source://asciidoctor//lib/asciidoctor/substitutors.rb#174
  def sub_specialcharacters(text); end

  # source://asciidoctor//lib/asciidoctor/substitutors.rb#174
  def sub_specialchars(text); end

  private

  # Internal: Convert a quoted text region
  #
  # match  - The MatchData for the quoted text region
  # type   - The quoting type (single, double, strong, emphasis, monospaced, etc)
  # scope  - The scope of the quoting (constrained or unconstrained)
  #
  # Returns The converted String text for the quoted text region
  #
  # source://asciidoctor//lib/asciidoctor/substitutors.rb#1419
  def convert_quoted_text(match, type, scope); end

  # Internal: Substitute replacement text for matched location
  #
  # returns The String text with the replacement characters substituted
  #
  # source://asciidoctor//lib/asciidoctor/substitutors.rb#1450
  def do_replacement(m, replacement, restore); end

  # This method is used in cases when the attrlist can be mixed with the text of a macro.
  # If no attributes are detected aside from the first positional attribute, and the first positional
  # attribute matches the attrlist, then the original text is returned.
  #
  # source://asciidoctor//lib/asciidoctor/substitutors.rb#1348
  def extract_attributes_from_text(text, default_text = T.unsafe(nil)); end

  # Internal: Extract the callout numbers from the source to prepare it for syntax highlighting.
  #
  # source://asciidoctor//lib/asciidoctor/substitutors.rb#1359
  def extract_callouts(source); end

  # Internal: Normalize text to prepare it for parsing.
  #
  # If normalize_whitespace is true, strip surrounding whitespace and fold newlines. If unescape_closing_square_bracket
  # is set, unescape any escaped closing square brackets.
  #
  # Returns the normalized text String
  #
  # source://asciidoctor//lib/asciidoctor/substitutors.rb#1510
  def normalize_text(text, normalize_whitespace = T.unsafe(nil), unescape_closing_square_brackets = T.unsafe(nil)); end

  # Internal: Parse the attributes that are defined on quoted (aka formatted) text
  #
  # str - A non-nil String of unprocessed attributes;
  #       space-separated roles (e.g., role1 role2) or the id/role shorthand syntax (e.g., #idname.role)
  #
  # Returns a Hash of attributes (role and id only)
  #
  # source://asciidoctor//lib/asciidoctor/substitutors.rb#1475
  def parse_quoted_text_attributes(str); end

  # Internal: Restore the callout numbers to the highlighted source.
  #
  # source://asciidoctor//lib/asciidoctor/substitutors.rb#1388
  def restore_callouts(source, callout_marks, source_offset = T.unsafe(nil)); end

  # Internal: Split text formatted as CSV with support
  # for double-quoted values (in which commas are ignored)
  #
  # source://asciidoctor//lib/asciidoctor/substitutors.rb#1520
  def split_simple_csv(str); end

  # Internal: Inserts text into a formatted text enclosure; used by xreftext
  def sub_placeholder(*_arg0); end
end

# source://asciidoctor//lib/asciidoctor/substitutors.rb#13
Asciidoctor::Substitutors::BASIC_SUBS = T.let(T.unsafe(nil), Array)

# source://asciidoctor//lib/asciidoctor/substitutors.rb#43
Asciidoctor::Substitutors::CAN = T.let(T.unsafe(nil), String)

# source://asciidoctor//lib/asciidoctor/substitutors.rb#173
Asciidoctor::Substitutors::CGI = CGI

# source://asciidoctor//lib/asciidoctor/substitutors.rb#44
Asciidoctor::Substitutors::DEL = T.let(T.unsafe(nil), String)

# source://asciidoctor//lib/asciidoctor/substitutors.rb#65
Asciidoctor::Substitutors::ESC_R_SB = T.let(T.unsafe(nil), String)

# source://asciidoctor//lib/asciidoctor/substitutors.rb#14
Asciidoctor::Substitutors::HEADER_SUBS = T.let(T.unsafe(nil), Array)

# fix passthrough slot after syntax highlighting
#
# source://asciidoctor//lib/asciidoctor/substitutors.rb#59
Asciidoctor::Substitutors::HighlightedPassSlotRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor//lib/asciidoctor/substitutors.rb#16
Asciidoctor::Substitutors::NORMAL_SUBS = T.let(T.unsafe(nil), Array)

# source://asciidoctor//lib/asciidoctor/substitutors.rb#15
Asciidoctor::Substitutors::NO_SUBS = T.let(T.unsafe(nil), Array)

# EPA, end of guarded protected area (\u0097)
#
# source://asciidoctor//lib/asciidoctor/substitutors.rb#53
Asciidoctor::Substitutors::PASS_END = T.let(T.unsafe(nil), String)

# SPA, start of guarded protected area (\u0096)
#
# source://asciidoctor//lib/asciidoctor/substitutors.rb#50
Asciidoctor::Substitutors::PASS_START = T.let(T.unsafe(nil), String)

# source://asciidoctor//lib/asciidoctor/substitutors.rb#67
Asciidoctor::Substitutors::PLUS = T.let(T.unsafe(nil), String)

# match passthrough slot
#
# source://asciidoctor//lib/asciidoctor/substitutors.rb#56
Asciidoctor::Substitutors::PassSlotRx = T.let(T.unsafe(nil), Regexp)

# Detects if text is a possible candidate for the quotes substitution.
#
# source://asciidoctor//lib/asciidoctor/substitutors.rb#11
Asciidoctor::Substitutors::QuotedTextSniffRx = T.let(T.unsafe(nil), Hash)

# source://asciidoctor//lib/asciidoctor/substitutors.rb#17
Asciidoctor::Substitutors::REFTEXT_SUBS = T.let(T.unsafe(nil), Array)

# source://asciidoctor//lib/asciidoctor/substitutors.rb#61
Asciidoctor::Substitutors::RS = T.let(T.unsafe(nil), String)

# source://asciidoctor//lib/asciidoctor/substitutors.rb#63
Asciidoctor::Substitutors::R_SB = T.let(T.unsafe(nil), String)

# source://asciidoctor//lib/asciidoctor/substitutors.rb#20
Asciidoctor::Substitutors::SUB_GROUPS = T.let(T.unsafe(nil), Hash)

# source://asciidoctor//lib/asciidoctor/substitutors.rb#27
Asciidoctor::Substitutors::SUB_HINTS = T.let(T.unsafe(nil), Hash)

# source://asciidoctor//lib/asciidoctor/substitutors.rb#38
Asciidoctor::Substitutors::SUB_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://asciidoctor//lib/asciidoctor/substitutors.rb#7
Asciidoctor::Substitutors::SpecialCharsRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor//lib/asciidoctor/substitutors.rb#8
Asciidoctor::Substitutors::SpecialCharsTr = T.let(T.unsafe(nil), Hash)

# source://asciidoctor//lib/asciidoctor/substitutors.rb#18
Asciidoctor::Substitutors::VERBATIM_SUBS = T.let(T.unsafe(nil), Array)

# prettify. Additional adapters can be registered using SyntaxHighlighter.register or by supplying a custom factory.
#
# source://asciidoctor//lib/asciidoctor/syntax_highlighter.rb#14
module Asciidoctor::SyntaxHighlighter
  extend ::Asciidoctor::SyntaxHighlighter::Factory
  extend ::Asciidoctor::SyntaxHighlighter::DefaultFactory

  mixes_in_class_methods ::Asciidoctor::SyntaxHighlighter::Config

  # source://asciidoctor//lib/asciidoctor/syntax_highlighter.rb#18
  def initialize(name, backend = T.unsafe(nil), opts = T.unsafe(nil)); end

  # Public: Generates docinfo markup for this syntax highlighter to insert at the specified location in the output document.
  # Should be called by converter after main content has been converted.
  #
  # location - The Symbol representing the location slot (:head or :footer).
  # doc      - The Document in which this syntax highlighter is being used.
  # opts     - A Hash of options that configure the syntax highlighting:
  #            :linkcss - A Boolean indicating whether the stylesheet should be linked instead of embedded (optional).
  #            :cdn_base_url - The String base URL for assets loaded from the CDN.
  #            :self_closing_tag_slash - The String '/' if the converter calling this method emits self-closing tags.
  #
  # Return the [String] markup to insert.
  #
  # @raise [::NotImplementedError]
  #
  # source://asciidoctor//lib/asciidoctor/syntax_highlighter.rb#41
  def docinfo(location, doc, opts); end

  # Public: Indicates whether this syntax highlighter has docinfo (i.e., markup) to insert into the output document at
  # the specified location. Should be called by converter after main content has been converted.
  #
  # location - The Symbol representing the location slot (:head or :footer).
  #
  # Returns a [Boolean] indicating whether the docinfo method should be called for this location.
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/syntax_highlighter.rb#28
  def docinfo?(location); end

  # Public: Format the highlighted source for inclusion in an HTML document.
  #
  # node   - The source Block being processed.
  # lang   - The source language String for this Block (e.g., ruby).
  # opts   - A Hash of options that control syntax highlighting:
  #          :nowrap - A Boolean that indicates whether wrapping should be disabled (optional).
  #
  # Returns the highlighted source [String] wrapped in preformatted tags (e.g., pre and code)
  #
  # @raise [::NotImplementedError]
  #
  # source://asciidoctor//lib/asciidoctor/syntax_highlighter.rb#80
  def format(node, lang, opts); end

  # Public: Highlights the specified source when this source block is being converted.
  #
  # If the source contains callout marks, the caller assumes the source remains on the same lines and no closing tags
  # are added to the end of each line. If the source gets shifted by one or more lines, this method must return a
  # tuple containing the highlighted source and the number of lines by which the source was shifted.
  #
  # node   - The source Block to syntax highlight.
  # source - The raw source text String of this source block (after preprocessing).
  # lang   - The source language String specified on this block (e.g., ruby).
  # opts   - A Hash of options that configure the syntax highlighting:
  #          :callouts - A Hash of callouts extracted from the source, indexed by line number (1-based) (optional).
  #          :css_mode - The Symbol CSS mode (:class or :inline).
  #          :highlight_lines - A 1-based Array of Integer line numbers to highlight (aka emphasize) (optional).
  #          :number_lines - A Symbol indicating whether lines should be numbered (:table or :inline) (optional).
  #          :start_line_number - The starting Integer (1-based) line number (optional, default: 1).
  #          :style - The String style (aka theme) to use for colorizing the code (optional).
  #
  # Returns the highlighted source String or a tuple of the highlighted source String and an Integer line offset.
  #
  # @raise [::NotImplementedError]
  #
  # source://asciidoctor//lib/asciidoctor/syntax_highlighter.rb#68
  def highlight(node, source, lang, opts); end

  # Public: Indicates whether highlighting is handled by this syntax highlighter or by the client.
  #
  # Returns a [Boolean] indicating whether the highlight method should be used to handle the :specialchars substitution.
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/syntax_highlighter.rb#48
  def highlight?; end

  # Public: Returns the String name of this syntax highlighter for referencing it in messages and option names.
  #
  # source://asciidoctor//lib/asciidoctor/syntax_highlighter.rb#16
  def name; end

  # Public: Writes the stylesheet to support the highlighted source(s) to disk.
  #
  # doc    - The Document in which this syntax highlighter is being used.
  # to_dir - The absolute String path of the stylesheet output directory.
  #
  # Returns nothing.
  #
  # @raise [::NotImplementedError]
  #
  # source://asciidoctor//lib/asciidoctor/syntax_highlighter.rb#98
  def write_stylesheet(doc, to_dir); end

  # Public: Indicates whether this syntax highlighter wants to write a stylesheet to disk. Only called if both the
  # linkcss and copycss attributes are set on the document.
  #
  # doc - The Document in which this syntax highlighter is being used.
  #
  # Returns a [Boolean] indicating whether the write_stylesheet method should be called.
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/syntax_highlighter.rb#90
  def write_stylesheet?(doc); end

  class << self
    private

    # @private
    #
    # source://asciidoctor//lib/asciidoctor/syntax_highlighter.rb#102
    def included(into); end
  end
end

# source://asciidoctor//lib/asciidoctor/syntax_highlighter.rb#230
class Asciidoctor::SyntaxHighlighter::Base
  include ::Asciidoctor::SyntaxHighlighter
  extend ::Asciidoctor::SyntaxHighlighter::Config

  # source://asciidoctor//lib/asciidoctor/syntax_highlighter.rb#233
  def format(node, lang, opts); end
end

# source://asciidoctor//lib/asciidoctor/syntax_highlighter.rb#107
module Asciidoctor::SyntaxHighlighter::Config
  # Public: Statically register the current class in the registry for the specified names.
  #
  # names - one or more String or Symbol names with which to register the current class as a syntax highlighter
  #         implementation. Symbol arguments are coerced to Strings.
  #
  # Returns nothing.
  #
  # source://asciidoctor//lib/asciidoctor/syntax_highlighter.rb#114
  def register_for(*names); end
end

# source://asciidoctor//lib/asciidoctor/syntax_highlighter.rb#162
class Asciidoctor::SyntaxHighlighter::CustomFactory
  include ::Asciidoctor::SyntaxHighlighter::Factory

  # @return [CustomFactory] a new instance of CustomFactory
  #
  # source://asciidoctor//lib/asciidoctor/syntax_highlighter.rb#165
  def initialize(seed_registry = T.unsafe(nil)); end

  private

  # Returns the value of attribute registry.
  #
  # source://asciidoctor//lib/asciidoctor/syntax_highlighter.rb#171
  def registry; end
end

# source://asciidoctor//lib/asciidoctor/syntax_highlighter.rb#174
module Asciidoctor::SyntaxHighlighter::DefaultFactory
  include ::Asciidoctor::SyntaxHighlighter::Factory

  # This method will lazy require and register additional built-in implementations, which include coderay,
  # pygments, rouge, and prettify. Refer to {Factory#for} for parameters and return value.
  #
  # source://asciidoctor//lib/asciidoctor/syntax_highlighter.rb#195
  def for(name); end

  # source://asciidoctor//lib/asciidoctor/syntax_highlighter.rb#188
  def register(syntax_highlighter, *names); end

  private

  # source://asciidoctor//lib/asciidoctor/syntax_highlighter.rb#181
  def registry; end
end

# source://asciidoctor//lib/asciidoctor/syntax_highlighter.rb#211
Asciidoctor::SyntaxHighlighter::DefaultFactory::PROVIDED = T.let(T.unsafe(nil), Hash)

# source://asciidoctor//lib/asciidoctor/syntax_highlighter.rb#222
class Asciidoctor::SyntaxHighlighter::DefaultFactoryProxy < ::Asciidoctor::SyntaxHighlighter::CustomFactory
  include ::Asciidoctor::SyntaxHighlighter::DefaultFactory

  # source://asciidoctor//lib/asciidoctor/syntax_highlighter.rb#225
  def for(name); end
end

# source://asciidoctor//lib/asciidoctor/syntax_highlighter.rb#119
module Asciidoctor::SyntaxHighlighter::Factory
  # Public: Resolves the name to a syntax highlighter instance, if found in the registry.
  #
  # name    - The String name of the syntax highlighter to create.
  # backend - The String name of the backend for which this syntax highlighter is being used (default: 'html5').
  # opts    - A Hash of options providing information about the context in which this syntax highlighter is used:
  #           :document - The Document for which this syntax highlighter was created.
  #
  # Returns a [SyntaxHighlighter] instance for the specified name.
  #
  # source://asciidoctor//lib/asciidoctor/syntax_highlighter.rb#147
  def create(name, backend = T.unsafe(nil), opts = T.unsafe(nil)); end

  # Public: Retrieves the syntax highlighter class or object registered for the specified name.
  #
  # name - The String name of the syntax highlighter to retrieve.
  #
  # Returns the SyntaxHighlighter Class or Object instance registered for this name.
  #
  # source://asciidoctor//lib/asciidoctor/syntax_highlighter.rb#135
  def for(name); end

  # Public: Associates the syntax highlighter class or object with the specified names.
  #
  # syntax_highlighter - the syntax highlighter implementation to register
  # names              - one or more String names with which to register this syntax highlighter implementation.
  #
  # Returns nothing.
  #
  # source://asciidoctor//lib/asciidoctor/syntax_highlighter.rb#126
  def register(syntax_highlighter, *names); end

  private

  # @raise [::NotImplementedError]
  #
  # source://asciidoctor//lib/asciidoctor/syntax_highlighter.rb#157
  def registry; end
end

# source://asciidoctor//lib/asciidoctor/syntax_highlighter/highlightjs.rb#3
class Asciidoctor::SyntaxHighlighter::HighlightJsAdapter < ::Asciidoctor::SyntaxHighlighter::Base
  # source://asciidoctor//lib/asciidoctor/syntax_highlighter/highlightjs.rb#6
  def initialize(*args); end

  # source://asciidoctor//lib/asciidoctor/syntax_highlighter/highlightjs.rb#19
  def docinfo(location, doc, opts); end

  # source://asciidoctor//lib/asciidoctor/syntax_highlighter/highlightjs.rb#15
  def docinfo?(location); end

  # source://asciidoctor//lib/asciidoctor/syntax_highlighter/highlightjs.rb#11
  def format(node, lang, opts); end
end

# source://asciidoctor//lib/asciidoctor/syntax_highlighter/html_pipeline.rb#3
class Asciidoctor::SyntaxHighlighter::HtmlPipelineAdapter < ::Asciidoctor::SyntaxHighlighter::Base
  # source://asciidoctor//lib/asciidoctor/syntax_highlighter/html_pipeline.rb#6
  def format(node, lang, opts); end
end

# String for matching tab character
#
# source://asciidoctor//lib/asciidoctor.rb#197
Asciidoctor::TAB = T.let(T.unsafe(nil), String)

# It supports all three of AsciiDoc's table formats: psv, dsv and csv.
#
# source://asciidoctor//lib/asciidoctor/table.rb#5
class Asciidoctor::Table < ::Asciidoctor::AbstractBlock
  # @return [Table] a new instance of Table
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#56
  def initialize(parent, attributes); end

  # Internal: Assign column widths to columns
  #
  # This method rounds the percentage width values to 4 decimal places and
  # donates the balance to the final column.
  #
  # This method assumes there's at least one column in the columns array.
  #
  # width_base - the total of the relative column values used for calculating percentage widths (default: nil)
  #
  # returns nothing
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#121
  def assign_column_widths(width_base = T.unsafe(nil), autowidth_cols = T.unsafe(nil)); end

  # Public: Get the caption for this table
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#54
  def caption; end

  # Public: Get/Set the columns for this table
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#44
  def columns; end

  # Public: Get/Set the columns for this table
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#44
  def columns=(_arg0); end

  # Internal: Creates the Column objects from the column spec
  #
  # returns nothing
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#90
  def create_columns(colspecs); end

  # Public: Boolean specifies whether this table has a header row
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#51
  def has_header_option; end

  # Public: Boolean specifies whether this table has a header row
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#51
  def has_header_option=(_arg0); end

  # Internal: Returns the current state of the header option (true or :implicit) if
  # the row being processed is (or is assumed to be) the header row, otherwise nil
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#83
  def header_row?; end

  # Internal: Partition the rows into header, footer and body as determined
  # by the options on the table
  #
  # returns nothing
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#155
  def partition_header_footer(attrs); end

  # Public: Get/Set the Rows struct for this table (encapsulates head, foot
  # and body rows)
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#48
  def rows; end

  # Public: Get/Set the Rows struct for this table (encapsulates head, foot
  # and body rows)
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#48
  def rows=(_arg0); end
end

# Public: Methods for managing the a cell in an AsciiDoc table.
#
# source://asciidoctor//lib/asciidoctor/table.rb#220
class Asciidoctor::Table::Cell < ::Asciidoctor::AbstractBlock
  # @return [Cell] a new instance of Cell
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#235
  def initialize(column, cell_text, attributes = T.unsafe(nil), opts = T.unsafe(nil)); end

  # source://asciidoctor//lib/asciidoctor/table.rb#342
  def catalog_inline_anchor(cell_text = T.unsafe(nil), cursor = T.unsafe(nil)); end

  # Public: An Integer of the number of columns this cell will span (default: nil)
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#224
  def colspan; end

  # Public: An Integer of the number of columns this cell will span (default: nil)
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#224
  def colspan=(_arg0); end

  # Public: An alias to the parent block (which is always a Column)
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#26
  def column; end

  # Public: Handles the body data (tbody, tfoot), applying styles and partitioning into paragraphs
  #
  # This method should not be used for cells in the head row or that have the literal style.
  #
  # Returns the converted String for this Cell
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#371
  def content; end

  # Public: Get the source file where this block started
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#396
  def file; end

  # Public: Returns the nested Document in an AsciiDoc table cell (only set when style is :asciidoc)
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#233
  def inner_document; end

  # Public: Get the source line number where this block started
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#401
  def lineno; end

  # source://asciidoctor//lib/asciidoctor/table.rb#387
  def lines; end

  # source://asciidoctor//lib/asciidoctor/table.rb#330
  def reinitialize(has_header); end

  # Public: An Integer of the number of rows this cell will span (default: nil)
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#227
  def rowspan; end

  # Public: An Integer of the number of rows this cell will span (default: nil)
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#227
  def rowspan=(_arg0); end

  # source://asciidoctor//lib/asciidoctor/table.rb#391
  def source; end

  # Public: Get the String text of this cell with substitutions applied.
  #
  # Used for cells in the head row as well as text-only (non-AsciiDoc) cells in
  # the foot row and body.
  #
  # This method shouldn't be used for cells that have the AsciiDoc style.
  #
  # Returns the converted String text for this Cell
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#357
  def text; end

  # Public: Set the String text for this cell.
  #
  # This method shouldn't be used for cells that have the AsciiDoc style.
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#364
  def text=(_arg0); end

  # source://asciidoctor//lib/asciidoctor/table.rb#405
  def to_s; end
end

# source://asciidoctor//lib/asciidoctor/table.rb#221
Asciidoctor::Table::Cell::DOUBLE_LF = T.let(T.unsafe(nil), String)

# Public: Methods to manage the columns of an AsciiDoc table. In particular, it
# keeps track of the column specs
#
# source://asciidoctor//lib/asciidoctor/table.rb#177
class Asciidoctor::Table::Column < ::Asciidoctor::AbstractNode
  # @return [Column] a new instance of Column
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#181
  def initialize(table, index, attributes = T.unsafe(nil)); end

  # Internal: Calculate and assign the widths (percentage and absolute) for this column
  #
  # This method assigns the colpcwidth and colabswidth attributes.
  #
  # returns the resolved colpcwidth value
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#199
  def assign_width(col_pcwidth, width_base, precision); end

  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#210
  def block?; end

  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#214
  def inline?; end

  # Public: Get/Set the style Symbol for this column.
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#179
  def style; end

  # Public: Get/Set the style Symbol for this column.
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#179
  def style=(_arg0); end

  # Public: An alias to the parent block (which is always a Table)
  #
  # source://asciidoctor//lib/asciidoctor/abstract_node.rb#26
  def table; end
end

# precision of column widths
#
# source://asciidoctor//lib/asciidoctor/table.rb#7
Asciidoctor::Table::DEFAULT_PRECISION = T.let(T.unsafe(nil), Integer)

# Public: Methods for managing the parsing of an AsciiDoc table. Instances of this
# class are primarily responsible for tracking the buffer of a cell as the parser
# moves through the lines of the table using tail recursion. When a cell boundary
# is located, the previous cell is closed, an instance of Table::Cell is
# instantiated, the row is closed if the cell satisfies the column count and,
# finally, a new buffer is allocated to track the next cell.
#
# source://asciidoctor//lib/asciidoctor/table.rb#416
class Asciidoctor::Table::ParserContext
  include ::Asciidoctor::Logging
  extend ::Asciidoctor::Logging

  # @return [ParserContext] a new instance of ParserContext
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#455
  def initialize(reader, table, attributes = T.unsafe(nil)); end

  # Public: The String buffer of the currently open cell
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#447
  def buffer; end

  # Public: The String buffer of the currently open cell
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#447
  def buffer=(_arg0); end

  # Public: Determines whether the buffer has unclosed quotes. Used for CSV data.
  #
  # returns true if the buffer has unclosed quotes, false if it doesn't or it
  # isn't quoted data
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#534
  def buffer_has_unclosed_quotes?(append = T.unsafe(nil), q = T.unsafe(nil)); end

  # Public: Checks whether the current cell has been marked as closed
  #
  # returns true if the cell is marked as closed, false otherwise
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#596
  def cell_closed?; end

  # Public: Checks whether the current cell is still open
  #
  # returns true if the cell is marked as open, false otherwise
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#589
  def cell_open?; end

  # Public: Close the current cell, instantiate a new Table::Cell, add it to
  # the current row and, if the number of expected columns for the current
  # row has been met, close the row and begin a new one.
  #
  # returns nothing
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#617
  def close_cell(eol = T.unsafe(nil)); end

  # Public: If the current cell is open, close it. In additional, push the
  # cell spec captured from the end of this cell onto the stack for use
  # by the next cell.
  #
  # returns nothing
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#605
  def close_open_cell(next_cellspec = T.unsafe(nil)); end

  # source://asciidoctor//lib/asciidoctor/table.rb#685
  def close_table; end

  # Public: Get the expected column count for a row
  #
  # colcount is the number of columns to pull into a row
  # A value of -1 means we use the number of columns found
  # in the first line as the colcount
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#444
  def colcount; end

  # Public: The cell delimiter for this table.
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#450
  def delimiter; end

  # Public: The cell delimiter compiled Regexp for this table.
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#453
  def delimiter_re; end

  # Public: The AsciiDoc table format (psv, dsv, or csv)
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#437
  def format; end

  # Public: The AsciiDoc table format (psv, dsv, or csv)
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#437
  def format=(_arg0); end

  # Public: Marks that the cell should be kept open. Used when the end of the line is
  # reached and the cell may contain additional text.
  #
  # returns nothing
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#572
  def keep_cell_open; end

  # Public: Marks the cell as closed so that the parser knows to instantiate a new cell
  # instance and add it to the current row.
  #
  # returns nothing
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#581
  def mark_cell_closed; end

  # Public: Checks whether the line provided contains the cell delimiter
  # used by this table.
  #
  # returns Regexp MatchData if the line contains the delimiter, false otherwise
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#510
  def match_delimiter(line); end

  # Public: Puts a cell spec onto the stack. Cell specs precede the delimiter, so a
  # stack is used to carry over the spec to the next cell.
  #
  # returns nothing
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#562
  def push_cellspec(cellspec = T.unsafe(nil)); end

  # Public: Skip past the matched delimiter because it's inside quoted text.
  #
  # Returns nothing
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#517
  def skip_past_delimiter(pre); end

  # Public: Skip past the matched delimiter because it's escaped.
  #
  # Returns nothing
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#525
  def skip_past_escaped_delimiter(pre); end

  # Public: Checks whether the line provided starts with the cell delimiter
  # used by this table.
  #
  # returns true if the line starts with the delimiter, false otherwise
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#502
  def starts_with_delimiter?(line); end

  # Public: The Table currently being parsed
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#434
  def table; end

  # Public: The Table currently being parsed
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#434
  def table=(_arg0); end

  # Public: Takes a cell spec from the stack. Cell specs precede the delimiter, so a
  # stack is used to carry over the spec from the previous cell to the current cell
  # when the cell is being closed.
  #
  # returns The cell spec Hash captured from parsing the previous cell
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#554
  def take_cellspec; end

  private

  # Internal: Activate a rowspan. The rowspan Array is consulted when
  # determining the effective number of cells in the current row.
  #
  # returns nothing
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#713
  def activate_rowspan(rowspan, colspan); end

  # Internal: Advance to the next line (which may come after the parser begins processing
  # the next line if the last cell had wrapped content).
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#733
  def advance; end

  # Internal: Close the row by adding it to the Table and resetting the row
  # Array and counter variables.
  #
  # returns nothing
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#697
  def close_row(drop = T.unsafe(nil)); end

  # Internal: Calculate the effective column visits, which consists of the number of
  # cells plus any active rowspans.
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#727
  def effective_column_visits; end

  # Internal: Check whether we've met the number of effective columns for the current row.
  #
  # returns -1 if not at end of row, 0 if exactly at end of row, and 1 if overruns end of row
  #
  # @return [Boolean]
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#721
  def end_of_row?; end
end

# Public: A Hash mapping the AsciiDoc table formats to default delimiters
#
# source://asciidoctor//lib/asciidoctor/table.rb#425
Asciidoctor::Table::ParserContext::DELIMITERS = T.let(T.unsafe(nil), Hash)

# Public: An Array of String keys that represent the table formats in AsciiDoc
# --
# QUESTION should we recognize !sv as a valid format value?
#
# source://asciidoctor//lib/asciidoctor/table.rb#422
Asciidoctor::Table::ParserContext::FORMATS = T.let(T.unsafe(nil), Set)

# Public: A data object that encapsulates the collection of rows (head, foot, body) for a table
#
# source://asciidoctor//lib/asciidoctor/table.rb#10
class Asciidoctor::Table::Rows
  # @return [Rows] a new instance of Rows
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#13
  def initialize(head = T.unsafe(nil), foot = T.unsafe(nil), body = T.unsafe(nil)); end

  def [](*_arg0); end

  # Returns the value of attribute body.
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#11
  def body; end

  # Sets the attribute body
  #
  # @param value the value to set the attribute body to.
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#11
  def body=(_arg0); end

  # Public: Retrieve the rows grouped by section as a nested Array.
  #
  # Creates a 2-dimensional array of two element entries. The first element
  # is the section name as a symbol. The second element is the Array of rows
  # in that section. The entries are in document order (head, foot, body).
  #
  # Returns a 2-dimentional Array of rows grouped by section.
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#28
  def by_section; end

  # Returns the value of attribute foot.
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#11
  def foot; end

  # Sets the attribute foot
  #
  # @param value the value to set the attribute foot to.
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#11
  def foot=(_arg0); end

  # Returns the value of attribute head.
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#11
  def head; end

  # Sets the attribute head
  #
  # @param value the value to set the attribute head to.
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#11
  def head=(_arg0); end

  # Public: Retrieve the rows as a Hash.
  #
  # The keys are the names of the section groups and the values are the Array of rows in that section.
  # The keys are in document order (head, foot, body).
  #
  # Returns a Hash of rows grouped by section.
  #
  # source://asciidoctor//lib/asciidoctor/table.rb#38
  def to_h; end
end

# Matches a trailing tag directive in an include file.
#
# Examples
#
#   // tag::try-catch[]
#   try {
#     someMethod();
#   catch (Exception e) {
#     log(e);
#   }
#   // end::try-catch[]
# NOTE m flag is required for Asciidoctor.js
# NOTE the regex checks for \r to account of include files that use Windows newlines
#
# source://asciidoctor//lib/asciidoctor/rx.rb#107
Asciidoctor::TagDirectiveRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor//lib/asciidoctor/timings.rb#3
class Asciidoctor::Timings
  # @return [Timings] a new instance of Timings
  #
  # source://asciidoctor//lib/asciidoctor/timings.rb#4
  def initialize; end

  # source://asciidoctor//lib/asciidoctor/timings.rb#34
  def convert; end

  # source://asciidoctor//lib/asciidoctor/timings.rb#26
  def parse; end

  # source://asciidoctor//lib/asciidoctor/timings.rb#50
  def print_report(to = T.unsafe(nil), subject = T.unsafe(nil)); end

  # source://asciidoctor//lib/asciidoctor/timings.rb#22
  def read; end

  # source://asciidoctor//lib/asciidoctor/timings.rb#30
  def read_parse; end

  # source://asciidoctor//lib/asciidoctor/timings.rb#38
  def read_parse_convert; end

  # source://asciidoctor//lib/asciidoctor/timings.rb#13
  def record(key); end

  # source://asciidoctor//lib/asciidoctor/timings.rb#9
  def start(key); end

  # source://asciidoctor//lib/asciidoctor/timings.rb#17
  def time(*keys); end

  # source://asciidoctor//lib/asciidoctor/timings.rb#46
  def total; end

  # source://asciidoctor//lib/asciidoctor/timings.rb#42
  def write; end

  private

  # source://asciidoctor//lib/asciidoctor/timings.rb#61
  def now; end
end

# source://asciidoctor//lib/asciidoctor/timings.rb#60
Asciidoctor::Timings::CLOCK_ID = T.let(T.unsafe(nil), Integer)

# Matches one or more consecutive digits at the end of a line.
#
# Examples
#
#   docbook5
#   html5
#
# source://asciidoctor//lib/asciidoctor/rx.rb#707
Asciidoctor::TrailingDigitsRx = T.let(T.unsafe(nil), Regexp)

# The mode to use when opening a URI for reading
#
# source://asciidoctor//lib/asciidoctor.rb#214
Asciidoctor::URI_READ_MODE = T.let(T.unsafe(nil), String)

# The user's home directory, as best we can determine it
# IMPORTANT this rescue is required for running Asciidoctor on GitHub.com
#
# source://asciidoctor//lib/asciidoctor.rb#188
Asciidoctor::USER_HOME = T.let(T.unsafe(nil), String)

# Alias UTF_8 encoding for convenience / speed
#
# source://asciidoctor//lib/asciidoctor.rb#203
Asciidoctor::UTF_8 = T.let(T.unsafe(nil), Encoding)

# Matches an unordered list item (one level for hyphens, up to 5 levels for asterisks).
#
# Examples
#
#   * Foo
#   - Foo
#
# NOTE we know trailing (.*) will match at least one character because we strip trailing spaces
#
# source://asciidoctor//lib/asciidoctor/rx.rb#284
Asciidoctor::UnorderedListRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor//lib/asciidoctor/rx.rb#722
Asciidoctor::UriSniffRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor//lib/asciidoctor.rb#276
Asciidoctor::VERBATIM_STYLES = T.let(T.unsafe(nil), Set)

# source://asciidoctor//lib/asciidoctor/version.rb#3
Asciidoctor::VERSION = T.let(T.unsafe(nil), String)

# source://asciidoctor//lib/asciidoctor/writer.rb#24
module Asciidoctor::VoidWriter
  include ::Asciidoctor::Writer

  # Public: Does not write output
  #
  # source://asciidoctor//lib/asciidoctor/writer.rb#28
  def write(output, target); end
end

# control how the output is written to disk.
#
# source://asciidoctor//lib/asciidoctor/writer.rb#5
module Asciidoctor::Writer
  # Public: Writes the output to the specified target file name or stream.
  #
  # output - The output String to write
  # target - The String file name or stream object to which the output should be written.
  #
  # Returns nothing
  #
  # source://asciidoctor//lib/asciidoctor/writer.rb#12
  def write(output, target); end
end

# Detects XML tags
#
# source://asciidoctor//lib/asciidoctor/rx.rb#726
Asciidoctor::XmlSanitizeRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor//lib/asciidoctor/core_ext/nil_or_empty.rb#18
class Hash
  include ::Enumerable
end

# A core library extension that defines the method nil_or_empty? as an alias to
# optimize checks for nil? or empty? on common object types such as NilClass,
# String, Array, Hash, and Numeric.
#
# source://asciidoctor//lib/asciidoctor/core_ext/nil_or_empty.rb#6
class NilClass
  include ::Treetop::Compiler::Metagrammar::LabeledExpressionSequenceBody0
end

# source://asciidoctor//lib/asciidoctor/core_ext/nil_or_empty.rb#22
class Numeric
  include ::Comparable
end

# source://asciidoctor//lib/asciidoctor/core_ext/nil_or_empty.rb#10
class String
  include ::Comparable
end
