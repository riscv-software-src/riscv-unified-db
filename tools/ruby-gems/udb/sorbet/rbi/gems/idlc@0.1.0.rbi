# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `idlc` gem.
# Please instead update this file by running `bin/tapioca gem idlc`.


# source://idlc//lib/idlc/syntax_node.rb#48
module Idl
  include ::Treetop::Runtime

  def _nt_ary_access; end
  def _nt_ary_eligible_expression; end
  def _nt_ary_size_decl; end
  def _nt_assignment; end
  def _nt_bitfield_definition; end
  def _nt_bits_cast; end
  def _nt_body_function_definition; end
  def _nt_builtin_function_definition; end
  def _nt_builtin_read_only_var; end
  def _nt_builtin_read_write_var; end
  def _nt_builtin_type_name; end
  def _nt_comment; end
  def _nt_concatenation_expression; end
  def _nt_constraint_body; end
  def _nt_csr_field_access_expression; end
  def _nt_csr_field_name; end
  def _nt_csr_name; end
  def _nt_csr_register_access_expression; end
  def _nt_declaration; end
  def _nt_dontcare_lvalue; end
  def _nt_dontcare_return; end
  def _nt_enum_definition; end
  def _nt_enum_ref; end
  def _nt_execute_if_block; end
  def _nt_expression; end
  def _nt_fetch; end
  def _nt_field_access_eligible_expression; end
  def _nt_field_access_expression; end
  def _nt_field_name; end
  def _nt_for_loop; end
  def _nt_function_arg_list; end
  def _nt_function_body; end
  def _nt_function_call; end
  def _nt_function_call_template_arguments; end
  def _nt_function_definition; end
  def _nt_function_if_block; end
  def _nt_function_name; end
  def _nt_function_statement; end
  def _nt_global_definition; end
  def _nt_id; end
  def _nt_implication_expression; end
  def _nt_implication_for_loop; end
  def _nt_implication_statement; end
  def _nt_include_statement; end
  def _nt_instruction_operation; end
  def _nt_int; end
  def _nt_isa; end
  def _nt_keyword; end
  def _nt_p0_binary_expression; end
  def _nt_p0_binary_operator; end
  def _nt_p1_binary_expression; end
  def _nt_p1_binary_operator; end
  def _nt_p2_binary_expression; end
  def _nt_p2_binary_operator; end
  def _nt_p3_binary_expression; end
  def _nt_p3_binary_operator; end
  def _nt_p3_template_binary_operator; end
  def _nt_p4_binary_expression; end
  def _nt_p4_binary_operator; end
  def _nt_p5_binary_expression; end
  def _nt_p5_binary_operator; end
  def _nt_p6_binary_expression; end
  def _nt_p6_binary_operator; end
  def _nt_p7_binary_expression; end
  def _nt_p7_binary_operator; end
  def _nt_p8_binary_expression; end
  def _nt_p8_binary_operator; end
  def _nt_p9_binary_expression; end
  def _nt_p9_binary_operator; end
  def _nt_paren_expression; end
  def _nt_post_dec; end
  def _nt_post_inc; end
  def _nt_replication_expression; end
  def _nt_reserved; end
  def _nt_return_expression; end
  def _nt_return_statement; end
  def _nt_rval; end
  def _nt_single_declaration; end
  def _nt_single_declaration_with_initialization; end
  def _nt_space; end
  def _nt_statement; end
  def _nt_string; end
  def _nt_struct_definition; end
  def _nt_template_safe_expression; end
  def _nt_template_safe_p3_binary_expression; end
  def _nt_template_safe_p4_binary_expression; end
  def _nt_template_safe_p5_binary_expression; end
  def _nt_template_safe_p6_binary_expression; end
  def _nt_template_safe_p7_binary_expression; end
  def _nt_template_safe_p8_binary_expression; end
  def _nt_template_safe_p9_binary_expression; end
  def _nt_template_safe_ternary_expression; end
  def _nt_ternary_expression; end
  def _nt_type_name; end
  def _nt_unary_expression; end
  def _nt_unary_operator; end
  def _nt_user_type_name; end
  def _nt_var_write; end
  def _nt_version_string; end
  def root; end
end

# source://idlc//lib/idlc/ast.rb#1056
class Idl::ArrayIncludesAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#1066
  sig do
    params(
      input: ::String,
      interval: T::Range[::Integer],
      var: ::Idl::IdAst,
      value: T.all(::Idl::AstNode, ::Idl::Rvalue)
    ).void
  end
  def initialize(input, interval, var, value); end

  # source://idlc//lib/idlc/ast.rb#1094
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1063
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def expr; end

  # source://idlc//lib/idlc/ast.rb#1097
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1084
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1071
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#1089
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def value(symtab); end

  # source://idlc//lib/idlc/ast.rb#1060
  sig { returns(::Idl::IdAst) }
  def var; end
end

# source://idlc//lib/idlc/ast.rb#1050
class Idl::ArrayIncludesSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1051
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#4131
class Idl::ArrayLiteralAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#4135
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#4139
  def element_nodes; end

  # source://idlc//lib/idlc/ast.rb#4137
  def entries; end

  # source://idlc//lib/idlc/ast.rb#4163
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#4154
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#4144
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#4158
  def value(symtab); end
end

# source://idlc//lib/idlc/ast.rb#4125
class Idl::ArrayLiteralSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#4126
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#1106
class Idl::ArraySizeAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#1115
  def initialize(input, interval, expression); end

  # source://idlc//lib/idlc/ast.rb#1113
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1110
  def expression; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#287
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#1144
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1126
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1119
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#1137
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Integer) }
  def value(symtab); end
end

# source://idlc//lib/idlc/ast.rb#1100
class Idl::ArraySizeSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1101
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#1796
class Idl::AryAccessSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1800
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#1816
class Idl::AryElementAccessAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#1831
  def initialize(input, interval, var, index); end

  # source://idlc//lib/idlc/ast.rb#1820
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#218
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#1829
  def index; end

  # source://idlc//lib/idlc/ast.rb#1897
  sig { override.returns(::String) }
  def to_idl; end

  # source://udb/0.1.0/lib/udb/idl/condition_to_udb.rb#95
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Hash[::String, T.untyped]) }
  def to_udb_h(symtab); end

  # source://idlc//lib/idlc/ast.rb#1866
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1836
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#1877
  def value(symtab); end

  # source://idlc//lib/idlc/ast.rb#1828
  def var; end
end

# source://idlc//lib/idlc/ast.rb#2115
class Idl::AryElementAssignmentAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#2137
  def initialize(input, interval, lhs, idx, rhs); end

  # source://idlc//lib/idlc/ast.rb#2119
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#2176
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#2206
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#242
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#2134
  def idx; end

  # source://idlc//lib/idlc/ast.rb#2133
  def lhs; end

  # source://idlc//lib/idlc/ast.rb#2135
  def rhs; end

  # source://idlc//lib/idlc/ast.rb#2241
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#2142
  def type_check(symtab); end
end

# source://idlc//lib/idlc/ast.rb#2105
class Idl::AryElementAssignmentSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#2106
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#1900
class Idl::AryRangeAccessAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#1916
  def initialize(input, interval, var, msb, lsb); end

  # source://idlc//lib/idlc/ast.rb#1904
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#157
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#1914
  def lsb; end

  # source://idlc//lib/idlc/ast.rb#1913
  def msb; end

  # source://idlc//lib/idlc/ast.rb#1965
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1946
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1921
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#1958
  def value(symtab); end

  # source://idlc//lib/idlc/ast.rb#1912
  def var; end
end

# source://idlc//lib/idlc/ast.rb#2254
class Idl::AryRangeAssignmentAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#2277
  def initialize(input, interval, variable, msb, lsb, write_value); end

  # source://idlc//lib/idlc/ast.rb#2258
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#2314
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#2342
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#19
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#2274
  def lsb; end

  # source://idlc//lib/idlc/ast.rb#2273
  def msb; end

  # source://idlc//lib/idlc/ast.rb#2309
  def rhs; end

  # source://idlc//lib/idlc/ast.rb#2348
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#2282
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#2272
  def variable; end

  # source://idlc//lib/idlc/ast.rb#2275
  def write_value; end
end

# source://idlc//lib/idlc/ast.rb#2244
class Idl::AryRangeAssignmentSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#2245
  def to_ast; end
end

# source://idlc//lib/idlc/type.rb#11
class Idl::AstNode
  abstract!

  # source://idlc//lib/idlc/ast.rb#194
  sig { params(input: ::String, interval: T::Range[T.untyped], children: T::Array[::Idl::AstNode]).void }
  def initialize(input, interval, children); end

  # source://idlc//lib/idlc/ast.rb#70
  sig { returns(T::Array[::Idl::AstNode]) }
  def children; end

  # source://idlc//lib/idlc/ast.rb#188
  sig { abstract.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#246
  sig { params(klass: ::Class).returns(T.nilable(::Idl::AstNode)) }
  def find_ancestor(klass); end

  # source://idlc//lib/idlc/ast.rb#423
  sig { params(global_symtab: ::Idl::SymbolTable).returns(::Idl::AstNode) }
  def freeze_tree(global_symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#9
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#15
  def gen_option_adoc; end

  # source://idlc//lib/idlc/ast.rb#53
  sig { returns(::String) }
  def input; end

  # source://idlc//lib/idlc/ast.rb#45
  sig { returns(::Pathname) }
  def input_file; end

  # source://idlc//lib/idlc/ast.rb#470
  sig { returns(::String) }
  def inspect; end

  # source://idlc//lib/idlc/ast.rb#357
  sig { params(reason: ::String).returns(T.noreturn) }
  def internal_error(reason); end

  # source://idlc//lib/idlc/ast.rb#57
  sig { returns(T::Range[T.untyped]) }
  def interval; end

  # source://idlc//lib/idlc/ast.rb#239
  sig { returns(::Integer) }
  def lineno; end

  # source://idlc//lib/idlc/ast.rb#264
  sig { returns(::Idl::AstNode::LinesDescriptor) }
  def lines_around; end

  # source://idlc//lib/idlc/passes/prune.rb#63
  def nullify_assignments(symtab); end

  # source://idlc//lib/idlc/ast.rb#66
  sig { returns(T.nilable(::Idl::AstNode)) }
  def parent; end

  # source://idlc//lib/idlc/passes/find_return_values.rb#11
  def pass_find_return_values(values, current_conditions); end

  # source://idlc//lib/idlc/ast.rb#432
  sig { returns(::String) }
  def path; end

  # source://idlc//lib/idlc/ast.rb#406
  sig { params(indent: ::Integer, indent_size: ::Integer, io: ::IO).void }
  def print_ast(indent = T.unsafe(nil), indent_size: T.unsafe(nil), io: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/prune.rb#44
  def prune(symtab); end

  # source://idlc//lib/idlc/passes/reachable_exceptions.rb#13
  def reachable_exceptions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/reachable_functions.rb#11
  def reachable_functions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#228
  sig { params(filename: T.any(::Pathname, ::String), starting_line: ::Integer).void }
  def set_input_file(filename, starting_line = T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#212
  sig { params(filename: T.any(::Pathname, ::String), starting_line: ::Integer).void }
  def set_input_file_unless_already_set(filename, starting_line = T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#49
  sig { returns(::Integer) }
  def starting_line; end

  # source://idlc//lib/idlc/ast.rb#61
  sig { returns(::String) }
  def text_value; end

  # source://idlc//lib/idlc/ast.rb#464
  sig { abstract.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#467
  sig { overridable.returns(::String) }
  def to_idl_verbose; end

  # source://udb/0.1.0/lib/udb/idl/condition_to_udb.rb#16
  sig { overridable.params(symtab: ::Idl::SymbolTable).returns(T::Hash[::String, T.untyped]) }
  def to_udb_h(symtab); end

  # source://idlc//lib/idlc/ast.rb#292
  sig { params(reason: ::String).void }
  def truncation_warn(reason); end

  # source://idlc//lib/idlc/ast.rb#454
  sig { abstract.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#308
  sig { params(reason: ::String).returns(T.noreturn) }
  def type_error(reason); end

  # source://idlc//lib/idlc/ast.rb#396
  sig { params(s: ::String).returns(::String) }
  def unindent(s); end

  # source://idlc//lib/idlc/ast.rb#182
  sig { params(value_result: T.untyped, block: T.proc.returns(T.untyped)).returns(T.untyped) }
  def value_else(value_result, &block); end

  # source://idlc//lib/idlc/ast.rb#387
  sig { params(reason: ::String).returns(T.noreturn) }
  def value_error(reason); end

  # source://idlc//lib/idlc/ast.rb#172
  sig { params(block: T.proc.params(arg0: ::Object).returns(T.untyped)).returns(T.untyped) }
  def value_try(&block); end

  class << self
    # source://idlc//lib/idlc/ast.rb#175
    sig { params(value_result: T.untyped, _block: T.proc.returns(T.untyped)).returns(T.untyped) }
    def value_else(value_result, &_block); end

    # source://idlc//lib/idlc/ast.rb#378
    sig { params(reason: ::String, ast: T.nilable(::Idl::AstNode)).returns(T.noreturn) }
    def value_error(reason, ast = T.unsafe(nil)); end

    # source://idlc//lib/idlc/ast.rb#370
    def value_error_ast; end

    # source://idlc//lib/idlc/ast.rb#370
    def value_error_ast=(_arg0); end

    # source://idlc//lib/idlc/ast.rb#370
    def value_error_reason; end

    # source://idlc//lib/idlc/ast.rb#370
    def value_error_reason=(_arg0); end

    # source://idlc//lib/idlc/ast.rb#168
    sig { params(block: T.proc.params(arg0: ::Object).returns(T.untyped)).returns(T.untyped) }
    def value_try(&block); end
  end
end

# source://idlc//lib/idlc/ast.rb#103
class Idl::AstNode::InternalError < ::StandardError
  # source://idlc//lib/idlc/ast.rb#119
  sig { params(what: ::String).void }
  def initialize(what); end

  # source://idlc//lib/idlc/ast.rb#116
  sig { returns(T::Array[::String]) }
  def bt; end

  # source://idlc//lib/idlc/ast.rb#108
  sig { returns(::String) }
  def what; end
end

# source://idlc//lib/idlc/ast.rb#256
class Idl::AstNode::LinesDescriptor < ::T::Struct
  const :lines, ::String
  const :problem_interval, T::Range[T.untyped]
  const :lines_interval, T::Range[T.untyped]

  class << self
    # source://sorbet-runtime/0.6.12550/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://idlc//lib/idlc/ast.rb#73
class Idl::AstNode::TypeError < ::StandardError
  # source://idlc//lib/idlc/ast.rb#90
  sig { params(what: ::String).void }
  def initialize(what); end

  # source://idlc//lib/idlc/ast.rb#86
  sig { returns(T::Array[::String]) }
  def bt; end

  # source://idlc//lib/idlc/ast.rb#78
  sig { returns(::String) }
  def what; end
end

# source://idlc//lib/idlc/ast.rb#133
class Idl::AstNode::ValueError < ::StandardError
  # source://idlc//lib/idlc/ast.rb#146
  sig { params(lineno: ::Integer, file: ::String, reason: ::String).void }
  def initialize(lineno, file, reason); end

  # source://idlc//lib/idlc/ast.rb#140
  sig { returns(::String) }
  def file; end

  # source://idlc//lib/idlc/ast.rb#137
  sig { returns(::Integer) }
  def lineno; end

  # source://idlc//lib/idlc/ast.rb#157
  sig { returns(::String) }
  def message; end

  # source://idlc//lib/idlc/ast.rb#143
  sig { returns(::String) }
  def reason; end

  # source://idlc//lib/idlc/ast.rb#154
  sig { returns(::String) }
  def what; end
end

# source://idlc//lib/idlc/ast.rb#16
Idl::BasicValueRbType = T.type_alias { T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean) }

# source://idlc//lib/idlc/ast.rb#3363
class Idl::BinaryExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#3382
  def initialize(input, interval, lhs, op, rhs); end

  # source://idlc//lib/idlc/ast.rb#3572
  def bits_needed(value, signed); end

  # source://idlc//lib/idlc/ast.rb#3372
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#224
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#3389
  def invert(symtab); end

  # source://idlc//lib/idlc/ast.rb#3378
  def lhs; end

  # source://idlc//lib/idlc/ast.rb#3599
  def max_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#3742
  def min_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#4086
  def op; end

  # source://idlc//lib/idlc/passes/prune.rb#237
  def prune(symtab); end

  # source://idlc//lib/idlc/ast.rb#3379
  def rhs; end

  # source://idlc//lib/idlc/ast.rb#3420
  sig { override.returns(::String) }
  def to_idl; end

  # source://udb/0.1.0/lib/udb/idl/condition_to_udb.rb#149
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Hash[::String, T.untyped]) }
  def to_udb_h(symtab); end

  # source://idlc//lib/idlc/ast.rb#3425
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#3493
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#3892
  def value(symtab); end
end

# source://idlc//lib/idlc/ast.rb#3368
Idl::BinaryExpressionAst::ARITH_OPS = T.let(T.unsafe(nil), Array)

# source://idlc//lib/idlc/ast.rb#3367
Idl::BinaryExpressionAst::BIT_OPS = T.let(T.unsafe(nil), Array)

# source://idlc//lib/idlc/ast.rb#3366
Idl::BinaryExpressionAst::LOGICAL_OPS = T.let(T.unsafe(nil), Array)

# source://idlc//lib/idlc/ast.rb#3369
Idl::BinaryExpressionAst::OPS = T.let(T.unsafe(nil), Array)

# source://idlc//lib/idlc/ast.rb#3026
class Idl::BinaryExpressionRightSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#3030
  def to_ast; end

  # source://idlc//lib/idlc/ast.rb#3047
  def type_check(_symtab); end
end

# source://idlc//lib/idlc/ast.rb#1578
class Idl::BitfieldDefinitionAst < ::Idl::AstNode
  include ::Idl::Declaration

  # source://idlc//lib/idlc/ast.rb#1584
  def initialize(input, interval, name, size, fields); end

  # source://idlc//lib/idlc/ast.rb#1637
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#1582
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1609
  def element_names; end

  # source://idlc//lib/idlc/ast.rb#1617
  def element_ranges(symtab); end

  # source://idlc//lib/idlc/ast.rb#1593
  def freeze_tree(global_symtab); end

  # source://idlc//lib/idlc/ast.rb#1659
  def name; end

  # source://idlc//lib/idlc/ast.rb#1604
  def size(symtab); end

  # source://idlc//lib/idlc/ast.rb#1666
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1647
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1624
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#1662
  def value(_symtab); end
end

# source://idlc//lib/idlc/ast.rb#1547
class Idl::BitfieldDefinitionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1548
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#1487
class Idl::BitfieldFieldDefinitionAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#1494
  def initialize(input, interval, name, msb, lsb); end

  # source://idlc//lib/idlc/ast.rb#1492
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1489
  def name; end

  # source://idlc//lib/idlc/ast.rb#1529
  def range(symtab); end

  # source://idlc//lib/idlc/ast.rb#1538
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1507
  def type_check(symtab); end
end

# source://idlc//lib/idlc/type.rb#668
class Idl::BitfieldType < ::Idl::Type
  # source://idlc//lib/idlc/type.rb#669
  def initialize(type_name, width, field_names, field_ranges); end

  # source://idlc//lib/idlc/type.rb#689
  def clone; end

  # source://idlc//lib/idlc/type.rb#685
  def field_names; end

  # source://idlc//lib/idlc/type.rb#678
  def range(field_name); end
end

# source://idlc//lib/idlc/type.rb#953
Idl::Bits1Type = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/type.rb#954
Idl::Bits32Type = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/type.rb#955
Idl::Bits64Type = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/ast.rb#3294
class Idl::BitsCastAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#3305
  def initialize(input, interval, exp); end

  # source://idlc//lib/idlc/ast.rb#3298
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#3303
  def expr; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#101
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#3360
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#3317
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#3308
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#3337
  def value(symtab); end
end

# source://idlc//lib/idlc/ast.rb#3283
class Idl::BitsCastSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#3284
  def to_ast; end
end

# source://idlc//lib/idlc/type.rb#956
Idl::BitsUnknownType = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/type.rb#959
Idl::BoolType = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/ast.rb#1442
class Idl::BuiltinEnumDefinitionAst < ::Idl::AstNode
  include ::Idl::Declaration

  # source://idlc//lib/idlc/ast.rb#1448
  def initialize(input, interval, user_type); end

  # source://idlc//lib/idlc/ast.rb#1475
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#1446
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1461
  def element_names(symtab); end

  # source://idlc//lib/idlc/ast.rb#1465
  def element_values(symtab); end

  # source://idlc//lib/idlc/ast.rb#1480
  def name; end

  # source://idlc//lib/idlc/ast.rb#1484
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1470
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1454
  def type_check(symtab); end
end

# source://idlc//lib/idlc/ast.rb#1431
class Idl::BuiltinEnumDefinitionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1432
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#5328
class Idl::BuiltinTypeNameAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#5335
  def initialize(input, interval, type_name, bits_expression); end

  # source://idlc//lib/idlc/ast.rb#5333
  def bits_expression; end

  # source://idlc//lib/idlc/ast.rb#5331
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#5360
  def freeze_tree(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#181
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#5411
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#5379
  sig { params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#5345
  def type_check(symtab); end
end

# source://idlc//lib/idlc/ast.rb#5307
class Idl::BuiltinTypeNameSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5308
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#4348
class Idl::BuiltinVariableAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#4364
  def initialize(input, interval); end

  # source://idlc//lib/idlc/ast.rb#4351
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#202
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#4362
  def name; end

  # source://idlc//lib/idlc/ast.rb#4392
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#4372
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#4368
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#4387
  def value(symtab); end
end

# source://idlc//lib/idlc/ast.rb#4342
class Idl::BuiltinVariableSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#4343
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#5286
class Idl::CommentAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#5290
  def initialize(input, interval); end

  # source://idlc//lib/idlc/ast.rb#5288
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#5300
  def content; end

  # source://idlc//lib/idlc/ast.rb#5303
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#5295
  def type_check(symtab); end
end

# source://idlc//lib/idlc/ast.rb#5281
class Idl::CommentSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5282
  def to_ast; end
end

# source://idlc//lib/idlc.rb#47
class Idl::Compiler
  # source://idlc//lib/idlc.rb#52
  def initialize; end

  # source://idlc//lib/idlc.rb#299
  sig { params(body: ::String, symtab: ::Idl::SymbolTable, pass_error: T::Boolean).returns(::Idl::ConstraintBodyAst) }
  def compile_constraint(body, symtab, pass_error: T.unsafe(nil)); end

  # source://idlc//lib/idlc.rb#255
  def compile_expression(expression, symtab, pass_error: T.unsafe(nil)); end

  # source://idlc//lib/idlc.rb#56
  def compile_file(path); end

  # source://idlc//lib/idlc.rb#127
  def compile_func_body(body, return_type: T.unsafe(nil), symtab: T.unsafe(nil), name: T.unsafe(nil), input_file: T.unsafe(nil), input_line: T.unsafe(nil), no_rescue: T.unsafe(nil), extra_syms: T.unsafe(nil), type_check: T.unsafe(nil)); end

  # source://idlc//lib/idlc.rb#216
  def compile_inst_operation(inst, symtab:, input_file: T.unsafe(nil), input_line: T.unsafe(nil)); end

  # source://idlc//lib/idlc.rb#189
  def compile_inst_scope(idl, symtab:, input_file:, input_line: T.unsafe(nil)); end

  # source://idlc//lib/idlc.rb#50
  def parser; end

  # source://idlc//lib/idlc.rb#227
  def type_check(ast, symtab, what); end

  class << self
    # source://idlc//lib/idlc/version.rb#8
    def version; end
  end
end

# source://idlc//lib/idlc/ast.rb#4176
class Idl::ConcatenationExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#4180
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#4182
  def expressions; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#96
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#4222
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#4198
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#4185
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#4210
  def value(symtab); end
end

# source://idlc//lib/idlc/ast.rb#4166
class Idl::ConcatenationExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#4167
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#5222
class Idl::ConditionalReturnStatementAst < ::Idl::AstNode
  include ::Idl::Returns

  # source://idlc//lib/idlc/ast.rb#5231
  def initialize(input, interval, return_expression, condition); end

  # source://idlc//lib/idlc/ast.rb#5229
  def condition; end

  # source://idlc//lib/idlc/ast.rb#5226
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#24
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/prune.rb#411
  def prune(symtab); end

  # source://idlc//lib/idlc/passes/reachable_exceptions.rb#150
  def reachable_exceptions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/reachable_functions.rb#130
  def reachable_functions(symtab, cache); end

  # source://idlc//lib/idlc/ast.rb#5228
  def return_expression; end

  # source://idlc//lib/idlc/ast.rb#5243
  def return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#5248
  def return_types(symtab); end

  # source://idlc//lib/idlc/ast.rb#5254
  def return_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#5263
  def return_values(symtab); end

  # source://idlc//lib/idlc/ast.rb#5277
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#5236
  def type_check(symtab); end
end

# source://idlc//lib/idlc/ast.rb#5216
class Idl::ConditionalReturnStatementSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5217
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#4924
class Idl::ConditionalStatementAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#4931
  def initialize(input, interval, action, condition); end

  # source://idlc//lib/idlc/ast.rb#4925
  def action; end

  # source://idlc//lib/idlc/ast.rb#4926
  def condition; end

  # source://idlc//lib/idlc/ast.rb#4929
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#4945
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#4961
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#272
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/prune.rb#426
  def prune(symtab); end

  # source://idlc//lib/idlc/passes/reachable_exceptions.rb#166
  def reachable_exceptions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/reachable_functions.rb#147
  def reachable_functions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#4967
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#4936
  def type_check(symtab); end
end

# source://idlc//lib/idlc/ast.rb#4914
class Idl::ConditionalStatementSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#4915
  def to_ast; end
end

# source://idlc//lib/idlc/type.rb#957
Idl::ConstBitsUnknownType = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/type.rb#958
Idl::ConstBoolType = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/ast.rb#3154
class Idl::ConstraintBodyAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#3162
  sig do
    params(
      input: ::String,
      interval: T::Range[::Integer],
      stmts: T::Array[T.any(::Idl::ForLoopAst, ::Idl::ImplicationStatementAst)]
    ).void
  end
  def initialize(input, interval, stmts); end

  # source://idlc//lib/idlc/ast.rb#3167
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#3180
  sig { params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def satisfied?(symtab); end

  # source://idlc//lib/idlc/ast.rb#3170
  sig { returns(T::Array[T.any(::Idl::ForLoopAst, ::Idl::ImplicationStatementAst)]) }
  def stmts; end

  # source://idlc//lib/idlc/ast.rb#3187
  sig { override.returns(::String) }
  def to_idl; end

  # source://udb/0.1.0/lib/udb/idl/condition_to_udb.rb#47
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Hash[::String, T.untyped]) }
  def to_udb_h(symtab); end

  # source://idlc//lib/idlc/ast.rb#3173
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end
end

# source://idlc//lib/idlc/ast.rb#3143
class Idl::ConstraintBodySyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#3145
  sig { override.returns(::Idl::ConstraintBodyAst) }
  def to_ast; end
end

# source://idlc//lib/idlc/interfaces.rb#105
module Idl::Csr
  interface!

  # source://idlc//lib/idlc/interfaces.rb#120
  sig { abstract.returns(T::Boolean) }
  def dynamic_length?; end

  # source://idlc//lib/idlc/interfaces.rb#123
  sig { abstract.returns(T::Array[::Idl::CsrField]) }
  def fields; end

  # source://idlc//lib/idlc/interfaces.rb#114
  sig { abstract.params(base: T.nilable(::Integer)).returns(T.nilable(::Integer)) }
  def length(base); end

  # source://idlc//lib/idlc/interfaces.rb#117
  sig { abstract.returns(::Integer) }
  def max_length; end

  # source://idlc//lib/idlc/interfaces.rb#111
  sig { abstract.returns(::String) }
  def name; end

  # source://idlc//lib/idlc/interfaces.rb#128
  sig { abstract.returns(T.nilable(::Integer)) }
  def value; end
end

# source://idlc//lib/idlc/interfaces.rb#68
module Idl::CsrField
  interface!

  # source://idlc//lib/idlc/interfaces.rb#92
  sig { abstract.returns(T::Boolean) }
  def base32_only?; end

  # source://idlc//lib/idlc/interfaces.rb#88
  sig { abstract.returns(T::Boolean) }
  def base64_only?; end

  # source://idlc//lib/idlc/interfaces.rb#78
  sig { abstract.returns(T::Boolean) }
  def defined_in_all_bases?; end

  # source://idlc//lib/idlc/interfaces.rb#81
  sig { abstract.returns(T::Boolean) }
  def defined_in_base32?; end

  # source://idlc//lib/idlc/interfaces.rb#84
  sig { abstract.returns(T::Boolean) }
  def defined_in_base64?; end

  # source://idlc//lib/idlc/interfaces.rb#102
  sig { abstract.returns(T::Boolean) }
  def exists?; end

  # source://idlc//lib/idlc/interfaces.rb#97
  sig { abstract.params(base: T.nilable(::Integer)).returns(T::Range[::Integer]) }
  def location(base); end

  # source://idlc//lib/idlc/interfaces.rb#74
  sig { abstract.returns(::String) }
  def name; end
end

# source://idlc//lib/idlc/ast.rb#2475
class Idl::CsrFieldAssignmentAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#2484
  def initialize(input, interval, csr_field, write_value); end

  # source://idlc//lib/idlc/ast.rb#2479
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#2481
  def csr_field; end

  # source://idlc//lib/idlc/ast.rb#2516
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#2521
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/ast.rb#2504
  def field(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#111
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#2524
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#2488
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#2508
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#2482
  def write_value; end
end

# source://idlc//lib/idlc/ast.rb#2469
class Idl::CsrFieldAssignmentSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#2470
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#7255
class Idl::CsrFieldReadExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#7261
  def initialize(input, interval, csr, field_name); end

  # source://idlc//lib/idlc/ast.rb#7322
  def calc_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#7350
  def calc_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#7259
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#7297
  def csr_def(symtab); end

  # source://idlc//lib/idlc/ast.rb#7301
  def csr_name; end

  # source://idlc//lib/idlc/ast.rb#7303
  def field_def(symtab); end

  # source://idlc//lib/idlc/ast.rb#7307
  def field_name(symtab); end

  # source://idlc//lib/idlc/ast.rb#7268
  def freeze_tree(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#299
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#7313
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#7318
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#7289
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#7342
  def value(symtab); end
end

# source://idlc//lib/idlc/ast.rb#7371
class Idl::CsrFieldReadExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#7372
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#7500
class Idl::CsrFunctionCallAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#7518
  def initialize(input, interval, function_name, csr, args); end

  # source://idlc//lib/idlc/ast.rb#7516
  def args; end

  # source://idlc//lib/idlc/ast.rb#7504
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#7515
  def csr; end

  # source://idlc//lib/idlc/ast.rb#7556
  def csr_def(symtab); end

  # source://idlc//lib/idlc/ast.rb#7550
  def csr_known?(symtab); end

  # source://idlc//lib/idlc/ast.rb#7554
  def csr_name; end

  # source://idlc//lib/idlc/ast.rb#7513
  def function_name; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#75
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#7580
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#7533
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#7523
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#7561
  def value(symtab); end
end

# source://idlc//lib/idlc/ast.rb#7485
class Idl::CsrFunctionCallSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#7486
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#7377
class Idl::CsrReadExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#7385
  def initialize(input, interval, csr_name); end

  # source://idlc//lib/idlc/ast.rb#7381
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#7411
  def csr_def(symtab); end

  # source://idlc//lib/idlc/ast.rb#7415
  def csr_known?(symtab); end

  # source://idlc//lib/idlc/ast.rb#7383
  def csr_name; end

  # source://idlc//lib/idlc/ast.rb#7391
  def freeze_tree(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#305
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#7430
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#7404
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#7407
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#7420
  def value(symtab); end
end

# source://idlc//lib/idlc/ast.rb#7365
class Idl::CsrReadExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#7366
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#7439
class Idl::CsrSoftwareWriteAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#7448
  def initialize(input, interval, csr, expression); end

  # source://idlc//lib/idlc/ast.rb#7443
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#7445
  def csr; end

  # source://idlc//lib/idlc/ast.rb#7462
  def csr_known?(symtab); end

  # source://idlc//lib/idlc/ast.rb#7466
  def csr_name; end

  # source://idlc//lib/idlc/ast.rb#7474
  def execute(_symtab); end

  # source://idlc//lib/idlc/ast.rb#7477
  def execute_unknown(_symtab); end

  # source://idlc//lib/idlc/ast.rb#7446
  def expression; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#81
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#7481
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#7452
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#7469
  def value(_symtab); end
end

# source://idlc//lib/idlc/ast.rb#7433
class Idl::CsrSoftwareWriteSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#7434
  def to_ast; end
end

# source://idlc//lib/idlc/type.rb#701
class Idl::CsrType < ::Idl::Type
  # source://idlc//lib/idlc/type.rb#708
  sig { params(csr: ::Idl::Csr, qualifiers: T::Array[::Symbol]).void }
  def initialize(csr, qualifiers: T.unsafe(nil)); end

  # source://idlc//lib/idlc/type.rb#705
  sig { returns(::Idl::Csr) }
  def csr; end

  # source://idlc//lib/idlc/type.rb#713
  sig { returns(T::Array[::Idl::CsrField]) }
  def fields; end
end

# source://idlc//lib/idlc/ast.rb#7589
class Idl::CsrWriteAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#7597
  def initialize(input, interval, idx); end

  # source://idlc//lib/idlc/ast.rb#7593
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#7613
  def csr_def(symtab); end

  # source://idlc//lib/idlc/ast.rb#7632
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#7637
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/ast.rb#7595
  def idx; end

  # source://idlc//lib/idlc/ast.rb#7627
  def name(symtab); end

  # source://idlc//lib/idlc/ast.rb#7641
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#7623
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#7602
  def type_check(symtab); end
end

# source://idlc//lib/idlc/ast.rb#7585
class Idl::CsrWriteSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#7586
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#701
module Idl::Declaration
  interface!

  # source://idlc//lib/idlc/ast.rb#711
  sig { abstract.params(symtab: ::Idl::SymbolTable).void }
  def add_symbol(symtab); end
end

# source://idlc//lib/idlc/ast.rb#5028
class Idl::DontCareLvalueAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#5034
  def initialize(input, interval); end

  # source://idlc//lib/idlc/ast.rb#5032
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#5050
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#5042
  def type(_symtab); end

  # source://idlc//lib/idlc/ast.rb#5037
  def type_check(_symtab); end

  # source://idlc//lib/idlc/ast.rb#5047
  def value(_symtab); end
end

# source://idlc//lib/idlc/ast.rb#5024
class Idl::DontCareLvalueSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5025
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#4982
class Idl::DontCareReturnAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#4988
  def initialize(input, interval); end

  # source://idlc//lib/idlc/ast.rb#4986
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#60
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#5016
  def set_expected_type(t); end

  # source://idlc//lib/idlc/ast.rb#5021
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#4998
  def type(_symtab); end

  # source://idlc//lib/idlc/ast.rb#4993
  def type_check(_symtab); end

  # source://idlc//lib/idlc/ast.rb#5003
  def value(_symtab); end
end

# source://idlc//lib/idlc/ast.rb#4972
class Idl::DontCareReturnSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#4973
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#34
Idl::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# source://idlc//lib/idlc/ast.rb#6891
class Idl::ElseIfAst < ::Idl::AstNode
  include ::Idl::Returns

  # source://idlc//lib/idlc/ast.rb#6905
  def initialize(input, interval, body_interval, cond, body_stmts); end

  # source://idlc//lib/idlc/ast.rb#6903
  sig { returns(::Idl::IfBodyAst) }
  def body; end

  # source://idlc//lib/idlc/ast.rb#6900
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def cond; end

  # source://idlc//lib/idlc/ast.rb#6895
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/prune.rb#341
  def prune(symtab); end

  # source://idlc//lib/idlc/ast.rb#6926
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#6931
  def return_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#6942
  def return_values(symtab); end

  # source://idlc//lib/idlc/ast.rb#6954
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#6910
  def type_check(symtab); end
end

# source://idlc//lib/idlc/ast.rb#1282
class Idl::EnumArrayCastAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#1288
  def initialize(input, interval, enum_class_name); end

  # source://idlc//lib/idlc/ast.rb#1286
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1283
  def enum_class; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#131
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#1310
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1296
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1292
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#1305
  def value(symtab); end
end

# source://idlc//lib/idlc/ast.rb#1273
class Idl::EnumArrayCastSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1274
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#1228
class Idl::EnumCastAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#1240
  def initialize(input, interval, user_type_name, expression); end

  # source://idlc//lib/idlc/ast.rb#1232
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1235
  def enum_name; end

  # source://idlc//lib/idlc/ast.rb#1238
  def expression; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#106
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#1270
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1262
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1244
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#1267
  def value(symtab); end
end

# source://idlc//lib/idlc/ast.rb#1222
class Idl::EnumCastSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1223
  def to_ast; end
end

# source://idlc//lib/idlc/type.rb#12
class Idl::EnumDefinitionAst < ::Idl::AstNode
  include ::Idl::Declaration

  # source://idlc//lib/idlc/ast.rb#1352
  def initialize(input, interval, user_type, element_names, element_values); end

  # source://idlc//lib/idlc/ast.rb#1401
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#1350
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1376
  sig { returns(T::Array[::String]) }
  def element_names; end

  # source://idlc//lib/idlc/ast.rb#1386
  sig { returns(T::Array[::Integer]) }
  def element_values; end

  # source://idlc//lib/idlc/ast.rb#1417
  def name; end

  # source://idlc//lib/idlc/ast.rb#1421
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1409
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1389
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#1414
  def value(_symtab); end
end

# source://idlc//lib/idlc/ast.rb#1313
class Idl::EnumDefinitionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1314
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#1196
class Idl::EnumElementSizeAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#1202
  def initialize(input, interval, enum_class_name); end

  # source://idlc//lib/idlc/ast.rb#1200
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1197
  def enum_class; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#126
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#1219
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1210
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1206
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#1214
  def value(symtab); end
end

# source://idlc//lib/idlc/ast.rb#1187
class Idl::EnumElementSizeSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1188
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#4543
class Idl::EnumRefAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#4552
  def initialize(input, interval, class_name, member_name); end

  # source://idlc//lib/idlc/ast.rb#4549
  def class_name; end

  # source://idlc//lib/idlc/ast.rb#4547
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#4561
  def freeze_tree(global_symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#116
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#139
  def gen_option_adoc; end

  # source://idlc//lib/idlc/ast.rb#4550
  def member_name; end

  # source://idlc//lib/idlc/ast.rb#4608
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#4584
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#4574
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#4592
  def value(symtab); end
end

# source://idlc//lib/idlc/ast.rb#4532
class Idl::EnumRefSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#4533
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#1157
class Idl::EnumSizeAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#1163
  def initialize(input, interval, enum_class_name); end

  # source://idlc//lib/idlc/ast.rb#1161
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1158
  def enum_class; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#121
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#1184
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1171
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1167
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#1179
  def value(symtab); end
end

# source://idlc//lib/idlc/ast.rb#1148
class Idl::EnumSizeSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1149
  def to_ast; end
end

# source://idlc//lib/idlc/type.rb#598
class Idl::EnumerationType < ::Idl::Type
  # source://idlc//lib/idlc/type.rb#628
  sig do
    params(
      type_name: ::String,
      element_names: T::Array[::String],
      element_values: T::Array[::Integer],
      builtin: T::Boolean
    ).void
  end
  def initialize(type_name, element_names, element_values, builtin: T.unsafe(nil)); end

  # source://idlc//lib/idlc/type.rb#643
  sig { returns(T::Boolean) }
  def builtin?; end

  # source://idlc//lib/idlc/type.rb#646
  sig { returns(::Idl::EnumerationType) }
  def clone; end

  # source://idlc//lib/idlc/type.rb#659
  sig { params(element_value: ::Integer).returns(T.nilable(::String)) }
  def element_name(element_value); end

  # source://idlc//lib/idlc/type.rb#607
  sig { returns(T::Array[::String]) }
  def element_names; end

  # source://idlc//lib/idlc/type.rb#611
  sig { returns(T::Array[::Integer]) }
  def element_values; end

  # source://idlc//lib/idlc/type.rb#615
  sig { returns(::Idl::Type) }
  def ref_type; end

  # source://idlc//lib/idlc/type.rb#651
  sig { params(element_name: ::String).returns(T.nilable(::Integer)) }
  def value(element_name); end

  # source://idlc//lib/idlc/type.rb#603
  sig { returns(::Integer) }
  def width; end
end

# source://idlc//lib/idlc/ast.rb#474
module Idl::Executable
  interface!

  # source://idlc//lib/idlc/ast.rb#496
  sig { abstract.params(symtab: ::Idl::SymbolTable).void }
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#500
  sig { abstract.params(symtab: ::Idl::SymbolTable).void }
  def execute_unknown(symtab); end
end

# source://idlc//lib/idlc/ast.rb#6136
class Idl::FetchAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#6142
  def initialize(input, interval, body); end

  # source://idlc//lib/idlc/ast.rb#6140
  def body; end

  # source://idlc//lib/idlc/ast.rb#6138
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#6150
  def return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#6155
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#6146
  def type_check(symtab); end
end

# source://idlc//lib/idlc/ast.rb#6130
class Idl::FetchSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#6131
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#4466
class Idl::FieldAccessExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#4475
  def initialize(input, interval, bitfield, field_name); end

  # source://idlc//lib/idlc/ast.rb#4470
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#86
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#4481
  def kind(symtab); end

  # source://idlc//lib/idlc/ast.rb#4473
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def obj; end

  # source://idlc//lib/idlc/ast.rb#4529
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#4486
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#4498
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#4516
  def value(symtab); end
end

# source://idlc//lib/idlc/ast.rb#4456
class Idl::FieldAccessExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#4457
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#2363
class Idl::FieldAssignmentAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#2391
  sig do
    params(
      input: ::String,
      interval: T::Range[::Integer],
      id: ::Idl::IdAst,
      field_name: ::String,
      rhs: T.all(::Idl::AstNode, ::Idl::Rvalue)
    ).void
  end
  def initialize(input, interval, id, field_name, rhs); end

  # source://idlc//lib/idlc/ast.rb#2376
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#2436
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#2459
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/ast.rb#2373
  sig { returns(::String) }
  def field_name; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#91
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#2367
  sig { returns(::Idl::IdAst) }
  def id; end

  # source://idlc//lib/idlc/ast.rb#2370
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def rhs; end

  # source://idlc//lib/idlc/ast.rb#2466
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#2397
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#2411
  def type_check(symtab); end
end

# source://idlc//lib/idlc/ast.rb#2351
class Idl::FieldAssignmentSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#2352
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#6599
class Idl::ForLoopAst < ::Idl::AstNode
  include ::Idl::Executable
  include ::Idl::Returns

  # source://idlc//lib/idlc/ast.rb#6616
  def initialize(input, interval, init, condition, update, stmts); end

  # source://idlc//lib/idlc/ast.rb#6612
  def condition; end

  # source://idlc//lib/idlc/ast.rb#6604
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#6650
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#6733
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#191
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#6611
  def init; end

  # source://idlc//lib/idlc/passes/prune.rb#116
  def prune(symtab); end

  # source://idlc//lib/idlc/passes/reachable_exceptions.rb#197
  def reachable_exceptions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/reachable_functions.rb#167
  def reachable_functions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#6681
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#6650
  def return_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#6687
  def return_values(symtab); end

  # source://idlc//lib/idlc/ast.rb#6633
  sig { params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def satisfied?(symtab); end

  # source://idlc//lib/idlc/ast.rb#6614
  def stmts; end

  # source://idlc//lib/idlc/ast.rb#6753
  sig { override.returns(::String) }
  def to_idl; end

  # source://udb/0.1.0/lib/udb/idl/condition_to_udb.rb#72
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Hash[::String, T.untyped]) }
  def to_udb_h(symtab); end

  # source://idlc//lib/idlc/ast.rb#6621
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#6613
  def update; end
end

# source://idlc//lib/idlc/ast.rb#6587
class Idl::ForLoopSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#6588
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#6012
class Idl::FunctionBodyAst < ::Idl::AstNode
  include ::Idl::Executable
  include ::Idl::Returns

  # source://idlc//lib/idlc/ast.rb#6023
  def initialize(input, interval, stmts); end

  # source://idlc//lib/idlc/ast.rb#6017
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#6070
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#6088
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#293
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#21
  def gen_option_adoc; end

  # source://idlc//lib/idlc/passes/find_return_values.rb#67
  def pass_find_return_values(symtab); end

  # source://idlc//lib/idlc/passes/prune.rb#159
  def prune(symtab, args_already_applied: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#6055
  def return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#6070
  def return_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#6095
  def return_values(symtab); end

  # source://idlc//lib/idlc/ast.rb#6027
  def statements; end

  # source://idlc//lib/idlc/ast.rb#6029
  def stmts; end

  # source://idlc//lib/idlc/ast.rb#6125
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#6032
  def type_check(symtab); end
end

# source://idlc//lib/idlc/ast.rb#6005
class Idl::FunctionBodySyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#6007
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#5727
class Idl::FunctionCallExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#5742
  def initialize(input, interval, function_name, targs, args); end

  # source://idlc//lib/idlc/ast.rb#5784
  def arg_nodes; end

  # source://idlc//lib/idlc/ast.rb#5740
  def args; end

  # source://idlc//lib/idlc/ast.rb#5733
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#5863
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#5947
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/ast.rb#5788
  def func_type(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#278
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#27
  def gen_option_adoc; end

  # source://idlc//lib/idlc/ast.rb#5941
  def name; end

  # source://idlc//lib/idlc/passes/prune.rb#81
  def prune(symtab); end

  # source://idlc//lib/idlc/passes/reachable_exceptions.rb#25
  def reachable_exceptions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/reachable_functions.rb#20
  def reachable_functions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#5739
  def targs; end

  # source://idlc//lib/idlc/ast.rb#5755
  def template?; end

  # source://idlc//lib/idlc/ast.rb#5760
  def template_arg_nodes; end

  # source://idlc//lib/idlc/ast.rb#5764
  def template_values(symtab, unknown_ok: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#5951
  sig { override.returns(::String) }
  def to_idl; end

  # source://udb/0.1.0/lib/udb/idl/condition_to_udb.rb#108
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Hash[::String, T.untyped]) }
  def to_udb_h(symtab); end

  # source://idlc//lib/idlc/ast.rb#5854
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#5803
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#5863
  def value(symtab); end
end

# source://idlc//lib/idlc/ast.rb#5717
class Idl::FunctionCallExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5718
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#6184
class Idl::FunctionDefAst < ::Idl::AstNode
  include ::Idl::Declaration

  # source://idlc//lib/idlc/ast.rb#6198
  def initialize(input, interval, name, targs, return_types, arguments, desc, type, body); end

  # source://idlc//lib/idlc/ast.rb#6464
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#6426
  def apply_template_and_arg_syms(symtab); end

  # source://idlc//lib/idlc/ast.rb#6249
  def arguments(symtab); end

  # source://idlc//lib/idlc/ast.rb#6280
  def arguments_list_str; end

  # source://idlc//lib/idlc/ast.rb#6516
  def body; end

  # source://idlc//lib/idlc/ast.rb#6522
  def builtin?; end

  # source://idlc//lib/idlc/ast.rb#6360
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#6234
  def description; end

  # source://idlc//lib/idlc/ast.rb#6530
  def external?; end

  # source://idlc//lib/idlc/ast.rb#6222
  def freeze_tree(global_symtab); end

  # source://idlc//lib/idlc/ast.rb#6526
  def generated?; end

  # source://idlc//lib/idlc/ast.rb#6387
  def name; end

  # source://idlc//lib/idlc/ast.rb#6244
  def num_args; end

  # source://idlc//lib/idlc/passes/prune.rb#139
  def prune(symtab); end

  # source://idlc//lib/idlc/ast.rb#6219
  def reachable_functions_cache; end

  # source://idlc//lib/idlc/ast.rb#6285
  def return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#6348
  def return_type_list_str; end

  # source://idlc//lib/idlc/ast.rb#6187
  def return_type_nodes; end

  # source://idlc//lib/idlc/ast.rb#6478
  def template_names; end

  # source://idlc//lib/idlc/ast.rb#6484
  def template_types(symtab); end

  # source://idlc//lib/idlc/ast.rb#6239
  def templated?; end

  # source://idlc//lib/idlc/ast.rb#6535
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#6437
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#6506
  def type_check_args(symtab); end

  # source://idlc//lib/idlc/ast.rb#6510
  def type_check_body(symtab); end

  # source://idlc//lib/idlc/ast.rb#6410
  def type_check_from_call(symtab); end

  # source://idlc//lib/idlc/ast.rb#6502
  def type_check_return(symtab); end

  # source://idlc//lib/idlc/ast.rb#6497
  def type_check_targs(symtab); end

  # source://idlc//lib/idlc/ast.rb#6392
  def type_check_template_instance(symtab); end
end

# source://idlc//lib/idlc/ast.rb#6164
class Idl::FunctionDefSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#6165
  def to_ast; end
end

# source://idlc//lib/idlc/type.rb#720
class Idl::FunctionType < ::Idl::Type
  # source://idlc//lib/idlc/type.rb#723
  def initialize(func_name, func_def_ast, symtab); end

  # source://idlc//lib/idlc/type.rb#802
  sig do
    params(
      symtab: ::Idl::SymbolTable,
      argument_nodes: T::Array[::Idl::Rvalue],
      call_site_symtab: ::Idl::SymbolTable,
      func_call_ast: ::Idl::FunctionCallExpressionAst
    ).returns(T::Array[T.any(::Integer, ::Symbol)])
  end
  def apply_arguments(symtab, argument_nodes, call_site_symtab, func_call_ast); end

  # source://idlc//lib/idlc/type.rb#773
  def apply_template_values(template_values, func_call_ast); end

  # source://idlc//lib/idlc/type.rb#906
  def argument_name(index, template_values = T.unsafe(nil), func_call_ast); end

  # source://idlc//lib/idlc/type.rb#891
  def argument_type(index, template_values, argument_nodes, call_site_symtab, func_call_ast); end

  # source://idlc//lib/idlc/type.rb#823
  def argument_values(symtab, argument_nodes, call_site_symtab, func_call_ast); end

  # source://idlc//lib/idlc/type.rb#921
  def body; end

  # source://idlc//lib/idlc/type.rb#735
  def builtin?; end

  # source://idlc//lib/idlc/type.rb#731
  def clone; end

  # source://idlc//lib/idlc/type.rb#739
  def external?; end

  # source://idlc//lib/idlc/type.rb#721
  def func_def_ast; end

  # source://idlc//lib/idlc/type.rb#737
  def generated?; end

  # source://idlc//lib/idlc/type.rb#741
  def num_args; end

  # source://idlc//lib/idlc/type.rb#849
  sig do
    params(
      template_values: T::Array[::Integer],
      argument_nodes: T::Array[::Idl::Rvalue],
      func_call_ast: ::Idl::FunctionCallExpressionAst
    ).returns(::Idl::Type)
  end
  def return_type(template_values, argument_nodes, func_call_ast); end

  # source://idlc//lib/idlc/type.rb#878
  def return_types(template_values, argument_nodes, call_site_symtab, func_call_ast); end

  # source://idlc//lib/idlc/type.rb#862
  def return_value(template_values, argument_nodes, call_site_symtab, func_call_ast); end

  # source://idlc//lib/idlc/type.rb#767
  def template_names; end

  # source://idlc//lib/idlc/type.rb#769
  def template_types(symtab); end

  # source://idlc//lib/idlc/type.rb#771
  def templated?; end

  # source://idlc//lib/idlc/type.rb#743
  def type_check_call(template_values, argument_nodes, call_site_symtab, func_call_ast); end
end

# source://idlc//lib/idlc/ast.rb#923
class Idl::GlobalAst < ::Idl::AstNode
  include ::Idl::Declaration

  # source://idlc//lib/idlc/ast.rb#938
  def initialize(input, interval, declaration); end

  # source://idlc//lib/idlc/ast.rb#951
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#927
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#934
  def declaration; end

  # source://idlc//lib/idlc/ast.rb#929
  def id; end

  # source://idlc//lib/idlc/ast.rb#958
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#947
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#943
  def type_check(symtab); end
end

# source://idlc//lib/idlc/ast.rb#917
class Idl::GlobalSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#918
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#861
class Idl::GlobalWithInitializationAst < ::Idl::AstNode
  include ::Idl::Executable
  include ::Idl::Declaration

  # source://idlc//lib/idlc/ast.rb#876
  def initialize(input, interval, var_decl_with_init); end

  # source://idlc//lib/idlc/ast.rb#903
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#869
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#897
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#900
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/ast.rb#865
  def id; end

  # source://idlc//lib/idlc/ast.rb#866
  def rhs; end

  # source://idlc//lib/idlc/ast.rb#912
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#887
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#882
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#892
  def value(symtab); end

  # source://idlc//lib/idlc/ast.rb#872
  def var_decl_with_init; end
end

# source://idlc//lib/idlc/ast.rb#846
class Idl::GlobalWithInitializationSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#847
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#749
class Idl::IdAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#760
  sig { params(input: ::String, interval: T::Range[::Integer]).void }
  def initialize(input, interval); end

  # source://idlc//lib/idlc/ast.rb#790
  sig { returns(T::Boolean) }
  def const?; end

  # source://idlc//lib/idlc/ast.rb#753
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#147
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#88
  def gen_option_adoc; end

  # source://idlc//lib/idlc/ast.rb#806
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(::Integer, ::Symbol)) }
  def max_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#824
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(::Integer, ::Symbol)) }
  def min_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#757
  sig { returns(::String) }
  def name; end

  # source://idlc//lib/idlc/ast.rb#843
  sig { override.returns(::String) }
  def to_idl; end

  # source://udb/0.1.0/lib/udb/idl/condition_to_udb.rb#60
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Hash[::String, T.untyped]) }
  def to_udb_h(symtab); end

  # source://idlc//lib/idlc/ast.rb#772
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#766
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#793
  def value(symtab); end
end

# source://idlc//lib/idlc/ast.rb#742
class Idl::IdSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#743
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#6993
class Idl::IfAst < ::Idl::AstNode
  include ::Idl::Executable
  include ::Idl::Returns

  # source://idlc//lib/idlc/ast.rb#7017
  def initialize(input, interval, if_cond, if_body, elseifs, final_else_body); end

  # source://idlc//lib/idlc/ast.rb#6998
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#7012
  sig { returns(T::Array[::Idl::ElseIfAst]) }
  def elseifs; end

  # source://idlc//lib/idlc/ast.rb#7186
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#7232
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/ast.rb#7015
  sig { returns(::Idl::IfBodyAst) }
  def final_else_body; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#311
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#33
  def gen_option_adoc; end

  # source://idlc//lib/idlc/ast.rb#7009
  sig { returns(::Idl::IfBodyAst) }
  def if_body; end

  # source://idlc//lib/idlc/ast.rb#7006
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def if_cond; end

  # source://idlc//lib/idlc/passes/find_return_values.rb#35
  def pass_find_return_values(values, current_conditions, symtab); end

  # source://idlc//lib/idlc/passes/prune.rb#353
  def prune(symtab); end

  # source://idlc//lib/idlc/passes/reachable_exceptions.rb#101
  def reachable_exceptions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/reachable_functions.rb#77
  def reachable_functions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#7079
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#7088
  def return_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#7129
  def return_values(symtab); end

  # source://idlc//lib/idlc/ast.rb#7066
  def taken_body(symtab); end

  # source://idlc//lib/idlc/ast.rb#7239
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#7028
  def type_check(symtab); end

  private

  # source://idlc//lib/idlc/ast.rb#7147
  def execute_after_if(symtab); end

  # source://idlc//lib/idlc/ast.rb#7223
  def execute_unknown_after_if(symtab); end

  # source://idlc//lib/idlc/ast.rb#7097
  def return_values_after_if(symtab); end
end

# source://idlc//lib/idlc/ast.rb#6763
class Idl::IfBodyAst < ::Idl::AstNode
  include ::Idl::Executable
  include ::Idl::Returns

  # source://idlc//lib/idlc/ast.rb#6774
  def initialize(input, interval, body_stmts); end

  # source://idlc//lib/idlc/ast.rb#6768
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#6851
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#6877
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#34
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#70
  def gen_option_adoc; end

  # source://idlc//lib/idlc/passes/prune.rb#329
  def prune(symtab); end

  # source://idlc//lib/idlc/ast.rb#6796
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#6802
  def return_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#6823
  def return_values(symtab); end

  # source://idlc//lib/idlc/ast.rb#6772
  def stmts; end

  # source://idlc//lib/idlc/ast.rb#6885
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#6783
  def type_check(symtab); end
end

# source://idlc//lib/idlc/ast.rb#6959
class Idl::IfSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#6960
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#3062
class Idl::ImplicationExpressionAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#3071
  sig do
    params(
      input: ::String,
      interval: T::Range[::Integer],
      antecedent: T.all(::Idl::AstNode, ::Idl::Rvalue),
      consequent: T.all(::Idl::AstNode, ::Idl::Rvalue)
    ).void
  end
  def initialize(input, interval, antecedent, consequent); end

  # source://idlc//lib/idlc/ast.rb#3082
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def antecedent; end

  # source://idlc//lib/idlc/ast.rb#3085
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def consequent; end

  # source://idlc//lib/idlc/ast.rb#3077
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#3094
  sig { params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def satisfied?(symtab); end

  # source://idlc//lib/idlc/ast.rb#3100
  sig { override.returns(::String) }
  def to_idl; end

  # source://udb/0.1.0/lib/udb/idl/condition_to_udb.rb#23
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Hash[::String, T.untyped]) }
  def to_udb_h(symtab); end

  # source://idlc//lib/idlc/ast.rb#3088
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end
end

# source://idlc//lib/idlc/ast.rb#3052
class Idl::ImplicationExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#3054
  sig { override.returns(::Idl::ImplicationExpressionAst) }
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#3111
class Idl::ImplicationStatementAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#3119
  sig do
    params(
      input: ::String,
      interval: T::Range[::Integer],
      implication_expression: ::Idl::ImplicationExpressionAst
    ).void
  end
  def initialize(input, interval, implication_expression); end

  # source://idlc//lib/idlc/ast.rb#3124
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#3127
  sig { returns(::Idl::ImplicationExpressionAst) }
  def expression; end

  # source://idlc//lib/idlc/ast.rb#3135
  sig { params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def satisfied?(symtab); end

  # source://idlc//lib/idlc/ast.rb#3140
  sig { override.returns(::String) }
  def to_idl; end

  # source://udb/0.1.0/lib/udb/idl/condition_to_udb.rb#40
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Hash[::String, T.untyped]) }
  def to_udb_h(symtab); end

  # source://idlc//lib/idlc/ast.rb#3130
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end
end

# source://idlc//lib/idlc/ast.rb#3104
class Idl::ImplicationStatementSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#3106
  sig { override.returns(::Idl::ImplicationStatementAst) }
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#722
class Idl::IncludeStatementAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#731
  sig { params(input: ::String, interval: T::Range[T.untyped], filename: ::Idl::AstNode).void }
  def initialize(input, interval, filename); end

  # source://idlc//lib/idlc/ast.rb#724
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#728
  sig { returns(::String) }
  def filename; end

  # source://idlc//lib/idlc/ast.rb#736
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#739
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end
end

# source://idlc//lib/idlc/ast.rb#714
class Idl::IncludeStatementSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#716
  sig { override.returns(::Idl::IncludeStatementAst) }
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#5999
class Idl::InstructionOperationSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#6000
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#5474
class Idl::IntLiteralAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#5480
  def initialize(input, interval); end

  # source://idlc//lib/idlc/ast.rb#5478
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#5484
  def freeze_tree(global_symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#141
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#94
  def gen_option_adoc; end

  # source://idlc//lib/idlc/ast.rb#5705
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#5708
  sig { override.returns(::String) }
  def to_idl_verbose; end

  # source://idlc//lib/idlc/ast.rb#5510
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#5494
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#5624
  def unsigned_value; end

  # source://idlc//lib/idlc/ast.rb#5577
  def value(symtab); end

  # source://idlc//lib/idlc/ast.rb#5542
  def width(symtab); end
end

# source://idlc//lib/idlc/ast.rb#5459
module Idl::IntLiteralSyntaxNode
  # source://idlc//lib/idlc/ast.rb#5460
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#975
class Idl::IsaAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#1002
  def add_global_symbols(symtab); end

  # source://idlc//lib/idlc/ast.rb#988
  def bitfields; end

  # source://idlc//lib/idlc/ast.rb#979
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#976
  def definitions; end

  # source://idlc//lib/idlc/ast.rb#985
  def enums; end

  # source://idlc//lib/idlc/ast.rb#997
  def fetch; end

  # source://idlc//lib/idlc/ast.rb#994
  def functions; end

  # source://idlc//lib/idlc/ast.rb#982
  def globals; end

  # source://idlc//lib/idlc/ast.rb#1017
  def replace_include!(include_ast, isa_ast); end

  # source://idlc//lib/idlc/ast.rb#991
  def structs; end

  # source://idlc//lib/idlc/ast.rb#1036
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1027
  def type_check(symtab); end
end

# source://idlc//lib/idlc/ast.rb#962
class Idl::IsaSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#963
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#2537
class Idl::MultiVariableAssignmentAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#2559
  def initialize(input, interval, variables, function_call); end

  # source://idlc//lib/idlc/ast.rb#2541
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#2604
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#2628
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/ast.rb#2557
  def function_call; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#70
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#2568
  def rhs; end

  # source://idlc//lib/idlc/ast.rb#2636
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#2573
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#2556
  def variables; end

  # source://idlc//lib/idlc/ast.rb#2564
  def vars; end
end

# source://idlc//lib/idlc/ast.rb#2527
class Idl::MultiVariableAssignmentSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#2528
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#2650
class Idl::MultiVariableDeclarationAst < ::Idl::AstNode
  include ::Idl::Declaration

  # source://idlc//lib/idlc/ast.rb#2665
  def initialize(input, interval, type_name, var_names); end

  # source://idlc//lib/idlc/ast.rb#2698
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#2654
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#169
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#2672
  def make_global; end

  # source://idlc//lib/idlc/ast.rb#2706
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#2689
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#2682
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#2660
  def type_name; end

  # source://idlc//lib/idlc/ast.rb#2663
  def var_name_nodes; end

  # source://idlc//lib/idlc/ast.rb#2677
  def var_names; end
end

# source://idlc//lib/idlc/ast.rb#2639
class Idl::MultiVariableDeclarationSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#2640
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#4844
class Idl::NoopAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#4848
  def initialize; end

  # source://idlc//lib/idlc/ast.rb#4846
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#4856
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#4859
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#16
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#4863
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#4853
  def type_check(symtab); end
end

# source://idlc//lib/idlc/ast.rb#4099
class Idl::ParenExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#4105
  def initialize(input, interval, exp); end

  # source://idlc//lib/idlc/ast.rb#4103
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#4107
  def expression; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#136
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#4109
  def invert(symtab); end

  # source://idlc//lib/idlc/ast.rb#4122
  sig { override.returns(::String) }
  def to_idl; end

  # source://udb/0.1.0/lib/udb/idl/condition_to_udb.rb#33
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Hash[::String, T.untyped]) }
  def to_udb_h(symtab); end

  # source://idlc//lib/idlc/ast.rb#4115
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#4112
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#4118
  def value(symtab); end
end

# source://idlc//lib/idlc/ast.rb#4089
class Idl::ParenExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#4090
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#1975
class Idl::PcAssignmentAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#1986
  sig { params(input: ::String, interval: T::Range[::Integer], rval: T.all(::Idl::AstNode, ::Idl::Rvalue)).void }
  def initialize(input, interval, rval); end

  # source://idlc//lib/idlc/ast.rb#1979
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1992
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#1996
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#236
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#1983
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def rhs; end

  # source://idlc//lib/idlc/ast.rb#2006
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#2000
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end
end

# source://idlc//lib/idlc/ast.rb#1969
class Idl::PcAssignmentSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1970
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#4296
class Idl::PostDecrementExpressionAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#4304
  def initialize(input, interval, rval); end

  # source://idlc//lib/idlc/ast.rb#4300
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#4318
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#4334
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#49
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#4302
  def rval; end

  # source://idlc//lib/idlc/ast.rb#4339
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#4313
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#4308
  def type_check(symtab); end
end

# source://idlc//lib/idlc/ast.rb#4286
class Idl::PostDecrementExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#4287
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#4405
class Idl::PostIncrementExpressionAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#4413
  def initialize(input, interval, rval); end

  # source://idlc//lib/idlc/ast.rb#4409
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#4430
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#4447
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#44
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#4411
  def rval; end

  # source://idlc//lib/idlc/ast.rb#4453
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#4425
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#4418
  def type_check(symtab); end
end

# source://idlc//lib/idlc/ast.rb#4395
class Idl::PostIncrementExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#4396
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#4235
class Idl::ReplicationExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#4245
  def initialize(input, interval, n, v); end

  # source://idlc//lib/idlc/ast.rb#4239
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#266
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#4242
  def n; end

  # source://idlc//lib/idlc/ast.rb#4283
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#4271
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#4250
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#4243
  def v; end

  # source://idlc//lib/idlc/ast.rb#4262
  def value(symtab); end
end

# source://idlc//lib/idlc/ast.rb#4225
class Idl::ReplicationExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#4226
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#5134
class Idl::ReturnExpressionAst < ::Idl::AstNode
  include ::Idl::Returns

  # source://idlc//lib/idlc/ast.rb#5142
  def initialize(input, interval, return_nodes); end

  # source://idlc//lib/idlc/ast.rb#5138
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#5186
  def enclosing_function; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#29
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#106
  def gen_option_adoc; end

  # source://idlc//lib/idlc/ast.rb#5159
  def return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#5148
  def return_types(symtab); end

  # source://idlc//lib/idlc/ast.rb#5191
  def return_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#5140
  def return_value_nodes; end

  # source://idlc//lib/idlc/ast.rb#5202
  def return_values(symtab); end

  # source://idlc//lib/idlc/ast.rb#5213
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#5171
  def type_check(symtab); end
end

# source://idlc//lib/idlc/ast.rb#5121
class Idl::ReturnExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5122
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#5064
class Idl::ReturnStatementAst < ::Idl::AstNode
  include ::Idl::Returns

  # source://idlc//lib/idlc/ast.rb#5074
  def initialize(input, interval, return_expression); end

  # source://idlc//lib/idlc/ast.rb#5068
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#5103
  def enclosing_function; end

  # source://idlc//lib/idlc/ast.rb#5089
  def expected_return_type(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#260
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#76
  def gen_option_adoc; end

  # source://idlc//lib/idlc/passes/find_return_values.rb#19
  def pass_find_return_values(values, current_conditions, symtab); end

  # source://idlc//lib/idlc/ast.rb#5070
  def return_expression; end

  # source://idlc//lib/idlc/ast.rb#5084
  def return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#5079
  def return_types(symtab); end

  # source://idlc//lib/idlc/ast.rb#5108
  def return_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#5099
  def return_value_nodes; end

  # source://idlc//lib/idlc/ast.rb#5113
  def return_values(symtab); end

  # source://idlc//lib/idlc/ast.rb#5118
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#5094
  def type_check(symtab); end
end

# source://idlc//lib/idlc/ast.rb#5053
class Idl::ReturnStatementSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5054
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#504
module Idl::Returns
  abstract!

  # source://idlc//lib/idlc/ast.rb#545
  sig { params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def expected_return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#522
  sig { abstract.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#527
  sig do
    abstract
      .params(
        symtab: ::Idl::SymbolTable
      ).returns(T.nilable(T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean, T::Hash[::String, T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean)])))
  end
  def return_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#541
  sig do
    abstract
      .params(
        symtab: ::Idl::SymbolTable
      ).returns(T::Array[T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean, T::Hash[::String, T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean)])])
  end
  def return_values(symtab); end
end

# source://idlc//lib/idlc/interfaces.rb#13
module Idl::RuntimeParam
  interface!

  # source://idlc//lib/idlc/interfaces.rb#25
  sig { abstract.returns(::String) }
  def desc; end

  # source://idlc//lib/idlc/interfaces.rb#43
  sig { abstract.returns(::Idl::Type) }
  def idl_type; end

  # source://idlc//lib/idlc/interfaces.rb#22
  sig { abstract.returns(::String) }
  def name; end

  # source://idlc//lib/idlc/interfaces.rb#34
  sig { abstract.returns(T::Array[::Idl::Schema]) }
  def possible_schemas; end

  # source://idlc//lib/idlc/interfaces.rb#31
  sig { abstract.returns(::Idl::Schema) }
  def schema; end

  # source://idlc//lib/idlc/interfaces.rb#28
  sig { abstract.returns(T::Boolean) }
  def schema_known?; end

  # source://idlc//lib/idlc/interfaces.rb#40
  sig { abstract.returns(T.any(::Integer, ::String, T::Array[::Integer], T::Array[T::Boolean], T::Boolean)) }
  def value; end

  # source://idlc//lib/idlc/interfaces.rb#37
  sig { abstract.returns(T::Boolean) }
  def value_known?; end
end

# source://idlc//lib/idlc/interfaces.rb#18
Idl::RuntimeParam::ValueType = T.type_alias { T.any(::Integer, ::String, T::Array[::Integer], T::Array[T::Boolean], T::Boolean) }

# source://idlc//lib/idlc/ast.rb#596
module Idl::Rvalue
  abstract!

  # source://idlc//lib/idlc/ast.rb#646
  sig { params(symtab: ::Idl::SymbolTable).returns(T.any(::Integer, ::Symbol)) }
  def max_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#656
  sig { params(symtab: ::Idl::SymbolTable).returns(T.any(::Integer, ::Symbol)) }
  def min_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#681
  sig { params(value: ::Integer, width: ::Integer, signed: T::Boolean).returns(::Integer) }
  def truncate(value, width, signed); end

  # source://idlc//lib/idlc/ast.rb#619
  sig { abstract.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#643
  sig do
    abstract
      .params(
        symtab: ::Idl::SymbolTable
      ).returns(T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean, T::Hash[::String, T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean)]))
  end
  def value(symtab); end

  # source://idlc//lib/idlc/ast.rb#678
  sig do
    params(
      symtab: ::Idl::SymbolTable
    ).returns(T::Array[T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean, T::Hash[::String, T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean)])])
  end
  def values(symtab); end
end

# source://idlc//lib/idlc/ast.rb#698
Idl::RvalueAst = T.type_alias { T.all(::Idl::AstNode, ::Idl::Rvalue) }

# source://idlc//lib/idlc/interfaces.rb#47
module Idl::Schema
  interface!

  # source://idlc//lib/idlc/interfaces.rb#56
  sig { abstract.returns(::Integer) }
  def max_val; end

  # source://idlc//lib/idlc/interfaces.rb#53
  sig { abstract.returns(T::Boolean) }
  def max_val_known?; end

  # source://idlc//lib/idlc/interfaces.rb#62
  sig { abstract.returns(::Integer) }
  def min_val; end

  # source://idlc//lib/idlc/interfaces.rb#59
  sig { abstract.returns(T::Boolean) }
  def min_val_known?; end

  # source://idlc//lib/idlc/interfaces.rb#65
  sig { abstract.returns(::Idl::Type) }
  def to_idl_type; end
end

# source://idlc//lib/idlc/ast.rb#3246
class Idl::SignCastAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#3254
  def initialize(input, interval, exp); end

  # source://idlc//lib/idlc/ast.rb#3250
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#3252
  def expression; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#152
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#3280
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#3262
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#3257
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#3265
  def value(symtab); end
end

# source://idlc//lib/idlc/ast.rb#3240
class Idl::SignCastSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#3241
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#4872
class Idl::StatementAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#4880
  def initialize(input, interval, action); end

  # source://idlc//lib/idlc/ast.rb#4878
  def action; end

  # source://idlc//lib/idlc/ast.rb#4876
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#4890
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#4900
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#248
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#82
  def gen_option_adoc; end

  # source://idlc//lib/idlc/passes/prune.rb#220
  def prune(symtab); end

  # source://idlc//lib/idlc/passes/reachable_exceptions.rb#82
  def reachable_exceptions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/reachable_functions.rb#62
  def reachable_functions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#4911
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#4885
  def type_check(symtab); end
end

# source://idlc//lib/idlc/ast.rb#4838
class Idl::StatementSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#4839
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#5432
class Idl::StringLiteralAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#5438
  def initialize(input, interval); end

  # source://idlc//lib/idlc/ast.rb#5436
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#54
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#5456
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#5446
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#5444
  def type_check(_symtab); end

  # source://idlc//lib/idlc/ast.rb#5451
  def value(_symtab); end
end

# source://idlc//lib/idlc/ast.rb#5420
module Idl::StringLiteralSyntaxNode
  # source://idlc//lib/idlc/ast.rb#5421
  def to_ast; end
end

# source://idlc//lib/idlc/type.rb#961
Idl::StringType = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/ast.rb#1697
class Idl::StructDefinitionAst < ::Idl::AstNode
  include ::Idl::Declaration

  # source://idlc//lib/idlc/ast.rb#1712
  def initialize(input, interval, name, member_types, member_names); end

  # source://idlc//lib/idlc/ast.rb#1740
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#1710
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1707
  def member_names; end

  # source://idlc//lib/idlc/ast.rb#1751
  def member_type(name, symtab); end

  # source://idlc//lib/idlc/ast.rb#1704
  def member_types; end

  # source://idlc//lib/idlc/ast.rb#1701
  def name; end

  # source://idlc//lib/idlc/ast.rb#1758
  def num_members; end

  # source://idlc//lib/idlc/ast.rb#1761
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1729
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1721
  def type_check(symtab); end
end

# source://idlc//lib/idlc/ast.rb#1676
class Idl::StructDefinitionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1677
  def to_ast; end
end

# source://idlc//lib/idlc/type.rb#561
class Idl::StructType < ::Idl::Type
  # source://idlc//lib/idlc/type.rb#566
  sig { params(type_name: ::String, member_types: T::Array[::Idl::Type], member_names: T::Array[::String]).void }
  def initialize(type_name, member_types, member_names); end

  # source://idlc//lib/idlc/type.rb#576
  def clone; end

  # source://idlc//lib/idlc/type.rb#580
  def default; end

  # source://idlc//lib/idlc/type.rb#588
  def member?(name); end

  # source://idlc//lib/idlc/type.rb#590
  def member_type(member_name); end

  # source://idlc//lib/idlc/type.rb#574
  sig { returns(::String) }
  def name; end

  # source://idlc//lib/idlc/type.rb#563
  sig { returns(::String) }
  def type_name; end
end

# source://idlc//lib/idlc/symbol_table.rb#114
class Idl::SymbolTable
  # source://idlc//lib/idlc/symbol_table.rb#207
  sig do
    params(
      mxlen: T.nilable(::Integer),
      possible_xlens: T::Array[::Integer],
      params: T::Array[::Idl::RuntimeParam],
      builtin_enums: T::Array[::Idl::SymbolTable::EnumDef],
      builtin_funcs: T.nilable(::Idl::SymbolTable::BuiltinFunctionCallbacks),
      csrs: T::Array[::Idl::Csr],
      name: ::String
    ).void
  end
  def initialize(mxlen: T.unsafe(nil), possible_xlens: T.unsafe(nil), params: T.unsafe(nil), builtin_enums: T.unsafe(nil), builtin_funcs: T.unsafe(nil), csrs: T.unsafe(nil), name: T.unsafe(nil)); end

  # source://idlc//lib/idlc/symbol_table.rb#397
  def add(name, var); end

  # source://idlc//lib/idlc/symbol_table.rb#406
  def add!(name, var); end

  # source://idlc//lib/idlc/symbol_table.rb#423
  def add_above!(name, var); end

  # source://idlc//lib/idlc/symbol_table.rb#432
  def add_at!(level, name, var); end

  # source://idlc//lib/idlc/symbol_table.rb#456
  def at_global_scope?; end

  # source://idlc//lib/idlc/symbol_table.rb#331
  def callstack; end

  # source://idlc//lib/idlc/symbol_table.rb#188
  sig { params(csr_name: ::String).returns(T.nilable(::Idl::Csr)) }
  def csr(csr_name); end

  # source://idlc//lib/idlc/symbol_table.rb#182
  sig { params(csr_name: ::String).returns(T::Boolean) }
  def csr?(csr_name); end

  # source://idlc//lib/idlc/symbol_table.rb#185
  sig { returns(T::Hash[::String, ::Idl::Csr]) }
  def csr_hash; end

  # source://idlc//lib/idlc/symbol_table.rb#505
  def deep_clone(clone_values: T.unsafe(nil), freeze_global: T.unsafe(nil)); end

  # source://idlc//lib/idlc/symbol_table.rb#273
  def deep_freeze; end

  # source://idlc//lib/idlc/symbol_table.rb#416
  def del(name); end

  # source://idlc//lib/idlc/symbol_table.rb#377
  def find_all(single_scope: T.unsafe(nil), &block); end

  # source://idlc//lib/idlc/symbol_table.rb#347
  def get(name); end

  # source://idlc//lib/idlc/symbol_table.rb#355
  def get_from(name, level); end

  # source://idlc//lib/idlc/symbol_table.rb#367
  def get_global(name); end

  # source://idlc//lib/idlc/symbol_table.rb#461
  def global_clone; end

  # source://idlc//lib/idlc/symbol_table.rb#128
  def hash; end

  # source://idlc//lib/idlc/symbol_table.rb#502
  def in_use?; end

  # source://idlc//lib/idlc/symbol_table.rb#268
  sig { returns(::String) }
  def inspect; end

  # source://idlc//lib/idlc/symbol_table.rb#336
  def key?(name); end

  # source://idlc//lib/idlc/symbol_table.rb#340
  def keys_pretty; end

  # source://idlc//lib/idlc/symbol_table.rb#441
  def levels; end

  # source://idlc//lib/idlc/symbol_table.rb#149
  sig { returns(T::Boolean) }
  def multi_xlen?; end

  # source://idlc//lib/idlc/symbol_table.rb#120
  sig { returns(T.nilable(::Integer)) }
  def mxlen; end

  # source://idlc//lib/idlc/symbol_table.rb#123
  sig { returns(::String) }
  def name; end

  # source://idlc//lib/idlc/symbol_table.rb#191
  sig { params(param_name: ::String).returns(T.nilable(::Idl::RuntimeParam)) }
  def param(param_name); end

  # source://idlc//lib/idlc/symbol_table.rb#194
  sig { returns(T::Hash[::String, ::Idl::RuntimeParam]) }
  def params_hash; end

  # source://idlc//lib/idlc/symbol_table.rb#321
  def pop; end

  # source://idlc//lib/idlc/symbol_table.rb#152
  sig { returns(T::Array[::Integer]) }
  def possible_xlens; end

  # source://idlc//lib/idlc/symbol_table.rb#447
  sig { void }
  def print; end

  # source://idlc//lib/idlc/symbol_table.rb#309
  def push(ast); end

  # source://idlc//lib/idlc/symbol_table.rb#491
  def release; end

  class << self
    # source://idlc//lib/idlc/symbol_table.rb#159
    sig do
      params(
        blk: T.proc.params(arg0: ::String).returns(T.nilable(T::Boolean))
      ).returns(T.proc.params(arg0: ::String).returns(T.nilable(T::Boolean)))
    end
    def make_implemented_callback(&blk); end

    # source://idlc//lib/idlc/symbol_table.rb#173
    sig do
      params(
        blk: T.proc.params(arg0: ::Integer).returns(T.nilable(T::Boolean))
      ).returns(T.proc.params(arg0: ::Integer).returns(T.nilable(T::Boolean)))
    end
    def make_implemented_csr_callback(&blk); end

    # source://idlc//lib/idlc/symbol_table.rb#166
    sig do
      params(
        blk: T.proc.params(arg0: ::String, arg1: ::String).returns(T.nilable(T::Boolean))
      ).returns(T.proc.params(arg0: ::String, arg1: ::String).returns(T.nilable(T::Boolean)))
    end
    def make_implemented_version_callback(&blk); end
  end
end

# source://idlc//lib/idlc/symbol_table.rb#175
class Idl::SymbolTable::BuiltinFunctionCallbacks < ::T::Struct
  prop :implemented, T.proc.params(arg0: ::String).returns(T.nilable(T::Boolean))
  prop :implemented_version, T.proc.params(arg0: ::String, arg1: ::String).returns(T.nilable(T::Boolean))
  prop :implemented_csr, T.proc.params(arg0: ::Integer).returns(T.nilable(T::Boolean))

  class << self
    # source://sorbet-runtime/0.6.12550/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://idlc//lib/idlc/symbol_table.rb#125
class Idl::SymbolTable::DuplicateSymError < ::StandardError; end

# source://idlc//lib/idlc/symbol_table.rb#134
class Idl::SymbolTable::EnumDef < ::T::Struct
  prop :name, ::String
  prop :element_values, T::Array[::Integer]
  prop :element_names, T::Array[::String]

  # source://idlc//lib/idlc/symbol_table.rb#142
  sig { params(name: ::String, element_values: T::Array[::Integer], element_names: T::Array[::String]).void }
  def initialize(name:, element_values:, element_names:); end

  class << self
    # source://sorbet-runtime/0.6.12550/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://idlc//lib/idlc/symbol_table.rb#154
Idl::SymbolTable::ImplementedCallbackType = T.type_alias { T.proc.params(arg0: ::String).returns(T.nilable(T::Boolean)) }

# source://idlc//lib/idlc/symbol_table.rb#168
Idl::SymbolTable::ImplementedCsrCallbackType = T.type_alias { T.proc.params(arg0: ::Integer).returns(T.nilable(T::Boolean)) }

# source://idlc//lib/idlc/symbol_table.rb#161
Idl::SymbolTable::ImplementedVersionCallbackType = T.type_alias { T.proc.params(arg0: ::String, arg1: ::String).returns(T.nilable(T::Boolean)) }

# source://idlc//lib/idlc/syntax_node.rb#49
class Idl::SyntaxNode < ::Treetop::Runtime::SyntaxNode
  # source://idlc//lib/idlc/syntax_node.rb#54
  sig { overridable.returns(::Idl::AstNode) }
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#4745
class Idl::TernaryOperatorExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#4755
  def initialize(input, interval, condition, true_expression, false_expression); end

  # source://idlc//lib/idlc/ast.rb#4751
  def condition; end

  # source://idlc//lib/idlc/ast.rb#4749
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#4753
  def false_expression; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#175
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#114
  def gen_option_adoc; end

  # source://idlc//lib/idlc/passes/prune.rb#454
  def prune(symtab); end

  # source://idlc//lib/idlc/ast.rb#4835
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#4752
  def true_expression; end

  # source://idlc//lib/idlc/ast.rb#4787
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#4760
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#4819
  def value(symtab); end

  # source://idlc//lib/idlc/ast.rb#4824
  def values(symtab); end
end

# source://idlc//lib/idlc/ast.rb#4734
class Idl::TernaryOperatorExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#4735
  def to_ast; end
end

# source://idlc//lib/idlc/type.rb#15
class Idl::Type
  # source://idlc//lib/idlc/type.rb#107
  def initialize(kind, qualifiers: T.unsafe(nil), width: T.unsafe(nil), sub_type: T.unsafe(nil), name: T.unsafe(nil), tuple_types: T.unsafe(nil), enum_class: T.unsafe(nil), csr: T.unsafe(nil)); end

  # source://idlc//lib/idlc/type.rb#368
  def ary?; end

  # source://idlc//lib/idlc/type.rb#221
  def ary_type(ary); end

  # source://idlc//lib/idlc/type.rb#146
  def clone; end

  # source://idlc//lib/idlc/type.rb#161
  def comparable_to?(type); end

  # source://idlc//lib/idlc/type.rb#372
  def const?; end

  # source://idlc//lib/idlc/type.rb#231
  def convertable_to?(type); end

  # source://idlc//lib/idlc/type.rb#47
  def default; end

  # source://idlc//lib/idlc/type.rb#86
  sig { returns(::Idl::EnumerationType) }
  def enum_class; end

  # source://idlc//lib/idlc/type.rb#193
  def equal_to?(type); end

  # source://idlc//lib/idlc/type.rb#320
  def fully_qualified_name; end

  # source://idlc//lib/idlc/type.rb#384
  def global?; end

  # source://idlc//lib/idlc/type.rb#43
  sig { returns(T::Boolean) }
  def integral?; end

  # source://idlc//lib/idlc/type.rb#71
  sig { returns(::Symbol) }
  def kind; end

  # source://idlc//lib/idlc/type.rb#406
  sig { returns(::Idl::Type) }
  def make_const; end

  # source://idlc//lib/idlc/type.rb#399
  sig { returns(::Idl::Type) }
  def make_const!; end

  # source://idlc//lib/idlc/type.rb#411
  def make_global; end

  # source://idlc//lib/idlc/type.rb#392
  def make_signed; end

  # source://idlc//lib/idlc/type.rb#376
  def mutable?; end

  # source://idlc//lib/idlc/type.rb#350
  def name; end

  # source://idlc//lib/idlc/type.rb#74
  sig { returns(T::Array[::Symbol]) }
  def qualifiers; end

  # source://idlc//lib/idlc/type.rb#88
  def qualify(qualifier); end

  # source://idlc//lib/idlc/type.rb#380
  def signed?; end

  # source://idlc//lib/idlc/type.rb#80
  sig { returns(::Idl::Type) }
  def sub_type; end

  # source://idlc//lib/idlc/type.rb#388
  def template_var?; end

  # source://idlc//lib/idlc/type.rb#300
  sig { returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/type.rb#320
  def to_s; end

  # source://idlc//lib/idlc/type.rb#83
  sig { returns(T::Array[::Idl::Type]) }
  def tuple_types; end

  # source://idlc//lib/idlc/type.rb#77
  sig { returns(T.any(::Integer, ::Symbol)) }
  def width; end

  class << self
    # source://idlc//lib/idlc/type.rb#544
    sig { params(schema: T::Hash[::String, T.untyped]).returns(T.nilable(::Idl::Type)) }
    def from_json_schema(schema); end

    # source://idlc//lib/idlc/type.rb#94
    def from_typename(type_name, cfg_arch); end

    private

    # source://idlc//lib/idlc/type.rb#506
    sig { params(schema: T::Hash[::String, T.untyped]).returns(::Idl::Type) }
    def from_json_schema_array_type(schema); end

    # source://idlc//lib/idlc/type.rb#419
    sig { params(schema: T::Hash[::String, T.untyped]).returns(T.nilable(::Idl::Type)) }
    def from_json_schema_scalar_type(schema); end
  end
end

# source://idlc//lib/idlc/type.rb#18
Idl::Type::KINDS = T.let(T.unsafe(nil), Array)

# source://idlc//lib/idlc/type.rb#34
Idl::Type::QUALIFIERS = T.let(T.unsafe(nil), Array)

# source://idlc//lib/idlc/type.rb#144
Idl::Type::TYPE_FROM_KIND = T.let(T.unsafe(nil), Hash)

# source://idlc//lib/idlc/ast.rb#5997
Idl::TypeNameAst = T.type_alias { T.any(::Idl::BuiltinTypeNameAst, ::Idl::UserTypeNameAst) }

# source://idlc//lib/idlc/ast.rb#4623
class Idl::UnaryOperatorExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#4631
  def initialize(input, interval, op, expression); end

  # source://idlc//lib/idlc/ast.rb#4627
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#4720
  def exp; end

  # source://idlc//lib/idlc/ast.rb#4629
  def expression; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#254
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#4637
  def invert(symtab); end

  # source://idlc//lib/idlc/ast.rb#4725
  def op; end

  # source://idlc//lib/idlc/ast.rb#4731
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#4648
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#4664
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#4692
  def value(symtab); end
end

# source://idlc//lib/idlc/ast.rb#4611
class Idl::UnaryOperatorExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#4612
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#5466
class Idl::UnknownLiteral
  # source://idlc//lib/idlc/ast.rb#5467
  def initialize(known_value, unknown_mask); end
end

# source://idlc//lib/idlc/ast.rb#5967
class Idl::UserTypeNameAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#5971
  def initialize(input, interval); end

  # source://idlc//lib/idlc/ast.rb#5969
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#65
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#5994
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#5985
  sig { params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#5977
  def type_check(symtab); end
end

# source://idlc//lib/idlc/ast.rb#5961
class Idl::UserTypeNameSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5962
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#27
Idl::ValueRbType = T.type_alias { T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean, T::Hash[::String, T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean)]) }

# source://idlc//lib/idlc/symbol_table.rb#15
class Idl::Var
  # source://idlc//lib/idlc/symbol_table.rb#20
  def initialize(name, type, value = T.unsafe(nil), decode_var: T.unsafe(nil), template_index: T.unsafe(nil), function_name: T.unsafe(nil), param: T.unsafe(nil)); end

  # source://idlc//lib/idlc/symbol_table.rb#60
  def clone; end

  # source://idlc//lib/idlc/symbol_table.rb#72
  def const?; end

  # source://idlc//lib/idlc/symbol_table.rb#44
  sig { returns(T::Boolean) }
  def const_eval?; end

  # source://idlc//lib/idlc/symbol_table.rb#39
  sig { void }
  def const_incompatible!; end

  # source://idlc//lib/idlc/symbol_table.rb#76
  def decode_var?; end

  # source://idlc//lib/idlc/symbol_table.rb#52
  def hash; end

  # source://idlc//lib/idlc/symbol_table.rb#18
  def name; end

  # source://idlc//lib/idlc/symbol_table.rb#80
  def param?; end

  # source://idlc//lib/idlc/symbol_table.rb#94
  def template_index; end

  # source://idlc//lib/idlc/symbol_table.rb#100
  def template_val?; end

  # source://idlc//lib/idlc/symbol_table.rb#90
  def template_value?; end

  # source://idlc//lib/idlc/symbol_table.rb#86
  def template_value_for?(function_name); end

  # source://idlc//lib/idlc/symbol_table.rb#104
  def to_cxx; end

  # source://idlc//lib/idlc/symbol_table.rb#56
  def to_s; end

  # source://idlc//lib/idlc/symbol_table.rb#18
  def type; end

  # source://idlc//lib/idlc/symbol_table.rb#18
  def value; end

  # source://idlc//lib/idlc/symbol_table.rb#108
  def value=(new_value); end
end

# source://idlc//lib/idlc/ast.rb#2020
class Idl::VariableAssignmentAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#2041
  def initialize(input, interval, lhs_ast, rhs_ast); end

  # source://idlc//lib/idlc/ast.rb#2024
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#2067
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#2088
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#230
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#2038
  def lhs; end

  # source://idlc//lib/idlc/passes/prune.rb#73
  def nullify_assignments(symtab); end

  # source://idlc//lib/idlc/passes/prune.rb#68
  def prune(symtab); end

  # source://idlc//lib/idlc/ast.rb#2039
  def rhs; end

  # source://idlc//lib/idlc/ast.rb#2102
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#2047
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#2057
  def var(symtab); end
end

# source://idlc//lib/idlc/ast.rb#2009
class Idl::VariableAssignmentSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#2010
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#2720
class Idl::VariableDeclarationAst < ::Idl::AstNode
  include ::Idl::Declaration

  # source://idlc//lib/idlc/ast.rb#2750
  sig do
    params(
      input: ::String,
      interval: T::Range[::Integer],
      type_name: T.any(::Idl::BuiltinTypeNameAst, ::Idl::UserTypeNameAst),
      id: ::Idl::IdAst,
      ary_size: T.nilable(T.all(::Idl::AstNode, ::Idl::Rvalue))
    ).void
  end
  def initialize(input, interval, type_name, id, ary_size); end

  # source://idlc//lib/idlc/ast.rb#2820
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#2736
  sig { returns(T.nilable(T.all(::Idl::AstNode, ::Idl::Rvalue))) }
  def ary_size; end

  # source://idlc//lib/idlc/ast.rb#2724
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#2766
  sig { params(symtab: ::Idl::SymbolTable).returns(T.nilable(::Idl::Type)) }
  def decl_type(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#163
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#2733
  sig { returns(::Idl::IdAst) }
  def id; end

  # source://idlc//lib/idlc/ast.rb#2761
  sig { void }
  def make_global; end

  # source://idlc//lib/idlc/ast.rb#2739
  sig { returns(::String) }
  def name; end

  # source://idlc//lib/idlc/ast.rb#2832
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#2791
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#2794
  def type_check(symtab, add_sym = T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#2730
  sig { returns(T.any(::Idl::BuiltinTypeNameAst, ::Idl::UserTypeNameAst)) }
  def type_name; end
end

# source://idlc//lib/idlc/ast.rb#2709
class Idl::VariableDeclarationSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#2710
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#2856
class Idl::VariableDeclarationWithInitializationAst < ::Idl::AstNode
  include ::Idl::Executable
  include ::Idl::Declaration

  # source://idlc//lib/idlc/ast.rb#2897
  sig do
    params(
      input: ::String,
      interval: T::Range[::Integer],
      type_name_ast: T.any(::Idl::BuiltinTypeNameAst, ::Idl::UserTypeNameAst),
      var_write_ast: ::Idl::IdAst,
      ary_size: T.nilable(T.all(::Idl::AstNode, ::Idl::Rvalue)),
      rval_ast: T.all(::Idl::AstNode, ::Idl::Rvalue)
    ).void
  end
  def initialize(input, interval, type_name_ast, var_write_ast, ary_size, rval_ast); end

  # source://idlc//lib/idlc/ast.rb#2970
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#2879
  sig { returns(T.nilable(T.all(::Idl::AstNode, ::Idl::Rvalue))) }
  def ary_size; end

  # source://idlc//lib/idlc/ast.rb#2861
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#2995
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#3011
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#208
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#2885
  sig { returns(::String) }
  def id; end

  # source://idlc//lib/idlc/ast.rb#2876
  sig { returns(::Idl::IdAst) }
  def lhs; end

  # source://idlc//lib/idlc/ast.rb#2910
  def lhs_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#2906
  def make_global; end

  # source://idlc//lib/idlc/passes/prune.rb#92
  def prune(symtab); end

  # source://idlc//lib/idlc/ast.rb#2882
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def rhs; end

  # source://idlc//lib/idlc/ast.rb#3017
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#2937
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#2873
  sig { returns(T.any(::Idl::BuiltinTypeNameAst, ::Idl::UserTypeNameAst)) }
  def type_name; end
end

# source://idlc//lib/idlc/ast.rb#2841
class Idl::VariableDeclarationWithInitializationSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#2842
  def to_ast; end
end

# source://idlc//lib/idlc/type.rb#960
Idl::VoidType = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/ast.rb#3198
class Idl::WidthRevealAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#3208
  sig { params(input: ::String, interval: T::Range[::Integer], e: ::Idl::AstNode).void }
  def initialize(input, interval, e); end

  # source://idlc//lib/idlc/ast.rb#3202
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#3205
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def expression; end

  # source://idlc//lib/idlc/ast.rb#3237
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#3221
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#3213
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#3230
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Integer) }
  def value(symtab); end
end

# source://idlc//lib/idlc/ast.rb#3192
class Idl::WidthRevealSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#3193
  def to_ast; end
end

# source://idlc//lib/idlc/type.rb#938
class Idl::XregType < ::Idl::Type
  # source://idlc//lib/idlc/type.rb#939
  def initialize(xlen); end

  # source://idlc//lib/idlc/type.rb#947
  def to_cxx; end

  # source://idlc//lib/idlc/type.rb#943
  def to_s; end
end

# source://idlc//lib/idlc.rb#42
class IdlParser < ::Treetop::Runtime::CompiledParser
  include ::Idl
end

class Object < ::BasicObject
  include ::Kernel
  include ::PP::ObjectMixin

  private

  # source://idlc//lib/idlc/passes/prune.rb#18
  def create_bool_literal(value); end

  # source://idlc//lib/idlc/passes/prune.rb#13
  def create_int_literal(value); end

  # source://idlc//lib/idlc/passes/prune.rb#26
  def create_literal(symtab, value, type); end
end

# source://idlc//lib/idlc/syntax_node.rb#11
module Treetop
  class << self
    # source://treetop/1.6.12/lib/treetop/compiler/grammar_compiler.rb#35
    def load(path); end

    # source://treetop/1.6.12/lib/treetop/compiler/grammar_compiler.rb#48
    def load_from_string(s); end
  end
end

# source://idlc//lib/idlc/syntax_node.rb#12
module Treetop::Runtime; end

# source://idlc//lib/idlc.rb#17
class Treetop::Runtime::CompiledParser
  # source://treetop/1.6.12/lib/treetop/runtime/compiled_parser.rb#11
  def initialize; end

  # source://treetop/1.6.12/lib/treetop/runtime/compiled_parser.rb#8
  def consume_all_input; end

  # source://treetop/1.6.12/lib/treetop/runtime/compiled_parser.rb#8
  def consume_all_input=(_arg0); end

  # source://treetop/1.6.12/lib/treetop/runtime/compiled_parser.rb#8
  def consume_all_input?; end

  # source://treetop/1.6.12/lib/treetop/runtime/compiled_parser.rb#38
  def failure_column; end

  # source://treetop/1.6.12/lib/treetop/runtime/compiled_parser.rb#30
  def failure_index; end

  # source://treetop/1.6.12/lib/treetop/runtime/compiled_parser.rb#34
  def failure_line; end

  # source://treetop/1.6.12/lib/treetop/runtime/compiled_parser.rb#43
  def failure_reason; end

  # source://treetop/1.6.12/lib/treetop/runtime/compiled_parser.rb#6
  def index; end

  # source://treetop/1.6.12/lib/treetop/runtime/compiled_parser.rb#6
  def input; end

  # source://idlc//lib/idlc.rb#18
  def input_file; end

  # source://idlc//lib/idlc.rb#29
  def instantiate_node(node_type, *args); end

  # source://treetop/1.6.12/lib/treetop/runtime/compiled_parser.rb#6
  def max_terminal_failure_index; end

  # source://treetop/1.6.12/lib/treetop/runtime/compiled_parser.rb#15
  def parse(input, options = T.unsafe(nil)); end

  # source://treetop/1.6.12/lib/treetop/runtime/compiled_parser.rb#7
  def root=(_arg0); end

  # source://idlc//lib/idlc.rb#20
  def set_input_file(filename, starting_line = T.unsafe(nil)); end

  # source://treetop/1.6.12/lib/treetop/runtime/compiled_parser.rb#54
  def terminal_failures; end

  protected

  # source://treetop/1.6.12/lib/treetop/runtime/compiled_parser.rb#78
  def forget_failures_to_here; end

  # source://treetop/1.6.12/lib/treetop/runtime/compiled_parser.rb#106
  def has_terminal?(terminal, mode, index); end

  # source://treetop/1.6.12/lib/treetop/runtime/compiled_parser.rb#98
  def idlc_instantiate_node(node_type, *args); end

  # source://treetop/1.6.12/lib/treetop/runtime/compiled_parser.rb#66
  def index=(_arg0); end

  # source://treetop/1.6.12/lib/treetop/runtime/compiled_parser.rb#65
  def input_length; end

  # source://treetop/1.6.12/lib/treetop/runtime/compiled_parser.rb#65
  def node_cache; end

  # source://treetop/1.6.12/lib/treetop/runtime/compiled_parser.rb#87
  def parse_anything(node_class = T.unsafe(nil), inline_module = T.unsafe(nil)); end

  # source://treetop/1.6.12/lib/treetop/runtime/compiled_parser.rb#68
  def prepare_to_parse(input); end

  # source://treetop/1.6.12/lib/treetop/runtime/compiled_parser.rb#83
  def reset_index; end

  # source://treetop/1.6.12/lib/treetop/runtime/compiled_parser.rb#120
  def terminal_parse_failure(expected_string, unexpected = T.unsafe(nil)); end
end

# source://idlc//lib/idlc/syntax_node.rb#13
class Treetop::Runtime::SyntaxNode
  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#7
  def initialize(input, interval, elements = T.unsafe(nil)); end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#47
  def <=>(other); end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#98
  def dot_id; end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#15
  def elements; end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#43
  def empty?; end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#51
  def extension_modules; end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#4
  def input; end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#91
  def inspect(indent = T.unsafe(nil)); end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#78
  def inspect_children(indent = T.unsafe(nil)); end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#63
  def inspect_self(indent = T.unsafe(nil)); end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#4
  def interval; end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#35
  def nonterminal?; end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#5
  def parent; end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#5
  def parent=(_arg0); end

  # source://idlc//lib/idlc/syntax_node.rb#20
  sig { params(filename: T.nilable(::String), starting_line: ::Integer).void }
  def set_input_file(filename, starting_line = T.unsafe(nil)); end

  # source://idlc//lib/idlc/syntax_node.rb#39
  sig { params(filename: T.nilable(::String), starting_line: ::Integer).void }
  def set_input_file_unless_already_set(filename, starting_line = T.unsafe(nil)); end

  # source://idlc//lib/idlc/syntax_node.rb#30
  sig { returns(T::Boolean) }
  def space?; end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#31
  def terminal?; end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#39
  def text_value; end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#102
  def write_dot(io); end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#113
  def write_dot_file(fname); end
end
