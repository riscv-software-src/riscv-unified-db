# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `regexp_parser` gem.
# Please instead update this file by running `bin/tapioca gem regexp_parser`.


# source://regexp_parser//lib/regexp_parser/expression/shared.rb#3
module Regexp::Expression; end

# source://regexp_parser//lib/regexp_parser/expression/classes/alternation.rb#7
class Regexp::Expression::Alternation < ::Regexp::Expression::SequenceOperation
  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#7
  def alternatives; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/human_name.rb#11
  def human_name; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#133
  def match_length; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/alternation.rb#8
Regexp::Expression::Alternation::OPERAND = Regexp::Expression::Alternative

# source://regexp_parser//lib/regexp_parser/expression/classes/alternation.rb#5
class Regexp::Expression::Alternative < ::Regexp::Expression::Sequence
  # source://regexp_parser//lib/regexp_parser/expression/methods/human_name.rb#12
  def human_name; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/anchor.rb#4
module Regexp::Expression::Anchor; end

# source://regexp_parser//lib/regexp_parser/expression/classes/anchor.rb#20
Regexp::Expression::Anchor::BOL = Regexp::Expression::Anchor::BeginningOfLine

# source://regexp_parser//lib/regexp_parser/expression/classes/anchor.rb#22
Regexp::Expression::Anchor::BOS = Regexp::Expression::Anchor::BeginningOfString

# source://regexp_parser//lib/regexp_parser/expression/classes/anchor.rb#5
class Regexp::Expression::Anchor::Base < ::Regexp::Expression::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#150
  def match_length; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/anchor.rb#7
class Regexp::Expression::Anchor::BeginningOfLine < ::Regexp::Expression::Anchor::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/human_name.rb#13
  def human_name; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/anchor.rb#10
class Regexp::Expression::Anchor::BeginningOfString < ::Regexp::Expression::Anchor::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/human_name.rb#14
  def human_name; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/anchor.rb#21
Regexp::Expression::Anchor::EOL = Regexp::Expression::Anchor::EndOfLine

# source://regexp_parser//lib/regexp_parser/expression/classes/anchor.rb#23
Regexp::Expression::Anchor::EOS = Regexp::Expression::Anchor::EndOfString

# source://regexp_parser//lib/regexp_parser/expression/classes/anchor.rb#24
Regexp::Expression::Anchor::EOSobEOL = Regexp::Expression::Anchor::EndOfStringOrBeforeEndOfLine

# source://regexp_parser//lib/regexp_parser/expression/classes/anchor.rb#8
class Regexp::Expression::Anchor::EndOfLine < ::Regexp::Expression::Anchor::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/human_name.rb#15
  def human_name; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/anchor.rb#11
class Regexp::Expression::Anchor::EndOfString < ::Regexp::Expression::Anchor::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/human_name.rb#16
  def human_name; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/anchor.rb#13
class Regexp::Expression::Anchor::EndOfStringOrBeforeEndOfLine < ::Regexp::Expression::Anchor::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/human_name.rb#17
  def human_name; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/anchor.rb#18
class Regexp::Expression::Anchor::MatchStart < ::Regexp::Expression::Anchor::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/human_name.rb#18
  def human_name; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/anchor.rb#16
class Regexp::Expression::Anchor::NonWordBoundary < ::Regexp::Expression::Anchor::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/human_name.rb#19
  def human_name; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/negative.rb#15
  def negative?; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/anchor.rb#15
class Regexp::Expression::Anchor::WordBoundary < ::Regexp::Expression::Anchor::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/human_name.rb#20
  def human_name; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#66
module Regexp::Expression::Assertion; end

# source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#67
class Regexp::Expression::Assertion::Base < ::Regexp::Expression::Group::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#150
  def match_length; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#69
class Regexp::Expression::Assertion::Lookahead < ::Regexp::Expression::Assertion::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/human_name.rb#21
  def human_name; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#72
class Regexp::Expression::Assertion::Lookbehind < ::Regexp::Expression::Assertion::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/human_name.rb#22
  def human_name; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#70
class Regexp::Expression::Assertion::NegativeLookahead < ::Regexp::Expression::Assertion::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/human_name.rb#23
  def human_name; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/negative.rb#16
  def negative?; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#73
class Regexp::Expression::Assertion::NegativeLookbehind < ::Regexp::Expression::Assertion::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/human_name.rb#24
  def human_name; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/negative.rb#17
  def negative?; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#57
Regexp::Expression::Backref = Regexp::Expression::Backreference

# source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#4
module Regexp::Expression::Backreference; end

# source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#5
class Regexp::Expression::Backreference::Base < ::Regexp::Expression::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#157
  def match_length; end

  class << self
    # source://regexp_parser//lib/regexp_parser/expression/methods/tests.rb#142
    def referential?; end
  end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#17
class Regexp::Expression::Backreference::Name < ::Regexp::Expression::Backreference::Base
  # source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#21
  def initialize(token, options = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/human_name.rb#25
  def human_name; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#18
  def name; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#18
  def reference; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#33
class Regexp::Expression::Backreference::NameCall < ::Regexp::Expression::Backreference::Name
  # source://regexp_parser//lib/regexp_parser/expression/methods/human_name.rb#26
  def human_name; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#45
class Regexp::Expression::Backreference::NameRecursionLevel < ::Regexp::Expression::Backreference::Name
  # source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#48
  def initialize(token, options = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#46
  def recursion_level; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#7
class Regexp::Expression::Backreference::Number < ::Regexp::Expression::Backreference::Base
  # source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#11
  def initialize(token, options = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/human_name.rb#27
  def human_name; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#8
  def number; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#8
  def reference; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#32
class Regexp::Expression::Backreference::NumberCall < ::Regexp::Expression::Backreference::Number
  # source://regexp_parser//lib/regexp_parser/expression/methods/human_name.rb#29
  def human_name; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#34
class Regexp::Expression::Backreference::NumberCallRelative < ::Regexp::Expression::Backreference::NumberRelative
  # source://regexp_parser//lib/regexp_parser/expression/methods/human_name.rb#30
  def human_name; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#36
class Regexp::Expression::Backreference::NumberRecursionLevel < ::Regexp::Expression::Backreference::NumberRelative
  # source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#39
  def initialize(token, options = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#37
  def recursion_level; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#27
class Regexp::Expression::Backreference::NumberRelative < ::Regexp::Expression::Backreference::Number
  # source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#28
  def effective_number; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#28
  def effective_number=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/human_name.rb#28
  def human_name; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/backreference.rb#28
  def reference; end
end

# source://regexp_parser//lib/regexp_parser/expression/base.rb#4
class Regexp::Expression::Base
  include ::Regexp::Expression::Shared
  include ::Regexp::Expression::ReferencedExpressions
  extend ::Regexp::Expression::Shared::ClassMethods

  # source://regexp_parser//lib/regexp_parser/expression/base.rb#7
  def initialize(token, options = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match.rb#10
  def =~(string, offset = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/options.rb#27
  def a?; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/options.rb#27
  def ascii_classes?; end

  # source://regexp_parser//lib/regexp_parser/expression/base.rb#62
  def attributes; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/options.rb#10
  def case_insensitive?; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def conditional_level; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def conditional_level=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def custom_to_s_handling; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def custom_to_s_handling=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/options.rb#22
  def d?; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/options.rb#22
  def default_classes?; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/options.rb#16
  def extended?; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/options.rb#16
  def free_spacing?; end

  # source://regexp_parser//lib/regexp_parser/expression/base.rb#49
  def greedy?; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/options.rb#10
  def i?; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/options.rb#10
  def ignore_case?; end

  # source://regexp_parser//lib/regexp_parser/expression/base.rb#53
  def lazy?; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def level; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def level=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/options.rb#5
  def m?; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match.rb#10
  def match(string, offset = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match.rb#5
  def match?(string); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match.rb#5
  def matches?(string); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/options.rb#5
  def multiline?; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#16
  def nesting_level; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def options; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def options=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def parent; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def parent=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/base.rb#58
  def possessive?; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def pre_quantifier_decorations; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def pre_quantifier_decorations=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#16
  def quantifier; end

  # source://regexp_parser//lib/regexp_parser/expression/base.rb#19
  def quantify(*args); end

  # source://regexp_parser//lib/regexp_parser/expression/base.rb#28
  def quantity; end

  # source://regexp_parser//lib/regexp_parser/expression/base.rb#53
  def reluctant?; end

  # source://regexp_parser//lib/regexp_parser/expression/base.rb#33
  def repetitions; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def set_level; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def set_level=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/strfregexp.rb#39
  def strfre(format = T.unsafe(nil), indent_offset = T.unsafe(nil), index = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/strfregexp.rb#39
  def strfregexp(format = T.unsafe(nil), indent_offset = T.unsafe(nil), index = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def te; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def te=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def text; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def text=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/base.rb#62
  def to_h; end

  # source://regexp_parser//lib/regexp_parser/expression/base.rb#11
  def to_re(format = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def token; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def token=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def ts; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def ts=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def type; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def type=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/options.rb#32
  def u?; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/options.rb#32
  def unicode_classes?; end

  # source://regexp_parser//lib/regexp_parser/expression/base.rb#23
  def unquantified_clone; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/options.rb#16
  def x?; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/character_set.rb#4
class Regexp::Expression::CharacterSet < ::Regexp::Expression::Subexpression
  # source://regexp_parser//lib/regexp_parser/expression/classes/character_set.rb#8
  def initialize(token, options = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/classes/character_set.rb#18
  def close; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/character_set.rb#5
  def closed; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/character_set.rb#5
  def closed=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/classes/character_set.rb#5
  def closed?; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#100
  def match_length; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/character_set.rb#14
  def negate; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/character_set.rb#5
  def negative; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/character_set.rb#5
  def negative=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/negative.rb#18
  def negative?; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/parts.rb#17
  def parts; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/character_set/intersection.rb#5
class Regexp::Expression::CharacterSet::IntersectedSequence < ::Regexp::Expression::Sequence
  # source://regexp_parser//lib/regexp_parser/expression/methods/human_name.rb#31
  def human_name; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#100
  def match_length; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/character_set/intersection.rb#7
class Regexp::Expression::CharacterSet::Intersection < ::Regexp::Expression::SequenceOperation
  # source://regexp_parser//lib/regexp_parser/expression/methods/human_name.rb#32
  def human_name; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#100
  def match_length; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/character_set/intersection.rb#8
Regexp::Expression::CharacterSet::Intersection::OPERAND = Regexp::Expression::CharacterSet::IntersectedSequence

# source://regexp_parser//lib/regexp_parser/expression/classes/character_set/range.rb#5
class Regexp::Expression::CharacterSet::Range < ::Regexp::Expression::Subexpression
  # source://regexp_parser//lib/regexp_parser/expression/classes/character_set/range.rb#10
  def <<(exp); end

  # source://regexp_parser//lib/regexp_parser/expression/classes/character_set/range.rb#16
  def complete?; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/human_name.rb#33
  def human_name; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#100
  def match_length; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/parts.rb#18
  def parts; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/character_set/range.rb#6
  def ts; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/character_type.rb#4
module Regexp::Expression::CharacterType; end

# source://regexp_parser//lib/regexp_parser/expression/classes/character_type.rb#7
class Regexp::Expression::CharacterType::Any < ::Regexp::Expression::CharacterType::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/human_name.rb#34
  def human_name; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/character_type.rb#5
class Regexp::Expression::CharacterType::Base < ::Regexp::Expression::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#100
  def match_length; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/negative.rb#19
  def negative?; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/character_type.rb#8
class Regexp::Expression::CharacterType::Digit < ::Regexp::Expression::CharacterType::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/character_type.rb#17
class Regexp::Expression::CharacterType::ExtendedGrapheme < ::Regexp::Expression::CharacterType::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/character_type.rb#10
class Regexp::Expression::CharacterType::Hex < ::Regexp::Expression::CharacterType::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/character_type.rb#16
class Regexp::Expression::CharacterType::Linebreak < ::Regexp::Expression::CharacterType::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/character_type.rb#9
class Regexp::Expression::CharacterType::NonDigit < ::Regexp::Expression::CharacterType::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/character_type.rb#11
class Regexp::Expression::CharacterType::NonHex < ::Regexp::Expression::CharacterType::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/character_type.rb#15
class Regexp::Expression::CharacterType::NonSpace < ::Regexp::Expression::CharacterType::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/character_type.rb#13
class Regexp::Expression::CharacterType::NonWord < ::Regexp::Expression::CharacterType::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/character_type.rb#14
class Regexp::Expression::CharacterType::Space < ::Regexp::Expression::CharacterType::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/character_type.rb#12
class Regexp::Expression::CharacterType::Word < ::Regexp::Expression::CharacterType::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/free_space.rb#10
class Regexp::Expression::Comment < ::Regexp::Expression::FreeSpace
  # source://regexp_parser//lib/regexp_parser/expression/methods/human_name.rb#35
  def human_name; end

  class << self
    # source://regexp_parser//lib/regexp_parser/expression/methods/tests.rb#132
    def comment?; end
  end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/conditional.rb#4
module Regexp::Expression::Conditional; end

# source://regexp_parser//lib/regexp_parser/expression/classes/conditional.rb#20
class Regexp::Expression::Conditional::Branch < ::Regexp::Expression::Sequence
  # source://regexp_parser//lib/regexp_parser/expression/methods/human_name.rb#36
  def human_name; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/conditional.rb#11
class Regexp::Expression::Conditional::Condition < ::Regexp::Expression::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/human_name.rb#37
  def human_name; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#150
  def match_length; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/conditional.rb#14
  def reference; end

  class << self
    # source://regexp_parser//lib/regexp_parser/expression/methods/tests.rb#143
    def referential?; end
  end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/conditional.rb#22
class Regexp::Expression::Conditional::Expression < ::Regexp::Expression::Subexpression
  # source://regexp_parser//lib/regexp_parser/expression/classes/conditional.rb#23
  def <<(exp); end

  # source://regexp_parser//lib/regexp_parser/expression/classes/conditional.rb#27
  def add_sequence(active_opts = T.unsafe(nil), params = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/classes/conditional.rb#27
  def branch(active_opts = T.unsafe(nil), params = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/classes/conditional.rb#43
  def branches; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/conditional.rb#39
  def condition; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/conditional.rb#34
  def condition=(exp); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/human_name.rb#38
  def human_name; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#133
  def match_length; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/parts.rb#19
  def parts; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/conditional.rb#47
  def reference; end

  class << self
    # source://regexp_parser//lib/regexp_parser/expression/methods/tests.rb#144
    def referential?; end
  end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/conditional.rb#5
class Regexp::Expression::Conditional::TooManyBranches < ::Regexp::Parser::Error
  # source://regexp_parser//lib/regexp_parser/expression/classes/conditional.rb#6
  def initialize; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/escape_sequence.rb#32
Regexp::Expression::Escape = Regexp::Expression::EscapeSequence

# source://regexp_parser//lib/regexp_parser/expression/classes/escape_sequence.rb#4
module Regexp::Expression::EscapeSequence; end

# source://regexp_parser//lib/regexp_parser/expression/classes/escape_sequence.rb#25
class Regexp::Expression::EscapeSequence::AbstractMetaControlSequence < ::Regexp::Expression::EscapeSequence::Base
  private

  # source://regexp_parser//lib/regexp_parser/expression/methods/escape_sequence_codepoint.rb#48
  def control_sequence_to_s(control_sequence); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/escape_sequence_codepoint.rb#53
  def meta_char_to_codepoint(meta_char); end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/escape_sequence.rb#7
class Regexp::Expression::EscapeSequence::AsciiEscape < ::Regexp::Expression::EscapeSequence::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/escape_sequence_codepoint.rb#4
  def codepoint; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/escape_sequence.rb#8
class Regexp::Expression::EscapeSequence::Backspace < ::Regexp::Expression::EscapeSequence::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/escape_sequence_codepoint.rb#5
  def codepoint; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/escape_sequence.rb#5
class Regexp::Expression::EscapeSequence::Base < ::Regexp::Expression::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/escape_sequence_char.rb#4
  def char; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#100
  def match_length; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/escape_sequence.rb#9
class Regexp::Expression::EscapeSequence::Bell < ::Regexp::Expression::EscapeSequence::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/escape_sequence_codepoint.rb#6
  def codepoint; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/escape_sequence.rb#20
class Regexp::Expression::EscapeSequence::Codepoint < ::Regexp::Expression::EscapeSequence::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/escape_sequence_codepoint.rb#18
  def codepoint; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/escape_sequence.rb#22
class Regexp::Expression::EscapeSequence::CodepointList < ::Regexp::Expression::EscapeSequence::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/escape_sequence_codepoint.rb#28
  def char; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/escape_sequence_codepoint.rb#36
  def chars; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/escape_sequence_codepoint.rb#32
  def codepoint; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/escape_sequence_codepoint.rb#40
  def codepoints; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#166
  def match_length; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/escape_sequence.rb#26
class Regexp::Expression::EscapeSequence::Control < ::Regexp::Expression::EscapeSequence::AbstractMetaControlSequence
  # source://regexp_parser//lib/regexp_parser/expression/methods/escape_sequence_codepoint.rb#60
  def codepoint; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/escape_sequence.rb#10
class Regexp::Expression::EscapeSequence::FormFeed < ::Regexp::Expression::EscapeSequence::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/escape_sequence_codepoint.rb#7
  def codepoint; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/escape_sequence.rb#19
class Regexp::Expression::EscapeSequence::Hex < ::Regexp::Expression::EscapeSequence::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/escape_sequence_codepoint.rb#17
  def codepoint; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/escape_sequence.rb#16
class Regexp::Expression::EscapeSequence::Literal < ::Regexp::Expression::EscapeSequence::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/escape_sequence_codepoint.rb#13
  def codepoint; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/escape_sequence.rb#27
class Regexp::Expression::EscapeSequence::Meta < ::Regexp::Expression::EscapeSequence::AbstractMetaControlSequence
  # source://regexp_parser//lib/regexp_parser/expression/methods/escape_sequence_codepoint.rb#66
  def codepoint; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/escape_sequence.rb#28
class Regexp::Expression::EscapeSequence::MetaControl < ::Regexp::Expression::EscapeSequence::AbstractMetaControlSequence
  # source://regexp_parser//lib/regexp_parser/expression/methods/escape_sequence_codepoint.rb#72
  def codepoint; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/escape_sequence.rb#11
class Regexp::Expression::EscapeSequence::Newline < ::Regexp::Expression::EscapeSequence::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/escape_sequence_codepoint.rb#8
  def codepoint; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/escape_sequence.rb#18
class Regexp::Expression::EscapeSequence::Octal < ::Regexp::Expression::EscapeSequence::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/escape_sequence_codepoint.rb#15
  def codepoint; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/escape_sequence.rb#12
class Regexp::Expression::EscapeSequence::Return < ::Regexp::Expression::EscapeSequence::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/escape_sequence_codepoint.rb#9
  def codepoint; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/escape_sequence.rb#13
class Regexp::Expression::EscapeSequence::Tab < ::Regexp::Expression::EscapeSequence::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/escape_sequence_codepoint.rb#10
  def codepoint; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/escape_sequence.rb#23
class Regexp::Expression::EscapeSequence::UTF8Hex < ::Regexp::Expression::EscapeSequence::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/escape_sequence_codepoint.rb#21
  def codepoint; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/escape_sequence.rb#14
class Regexp::Expression::EscapeSequence::VerticalTab < ::Regexp::Expression::EscapeSequence::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/escape_sequence_codepoint.rb#11
  def codepoint; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/free_space.rb#4
class Regexp::Expression::FreeSpace < ::Regexp::Expression::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#150
  def match_length; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/free_space.rb#5
  def quantify(*_args); end

  class << self
    # source://regexp_parser//lib/regexp_parser/expression/methods/tests.rb#137
    def decorative?; end
  end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#4
module Regexp::Expression::Group; end

# source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#21
class Regexp::Expression::Group::Absence < ::Regexp::Expression::Group::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#174
  def match_length; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#22
class Regexp::Expression::Group::Atomic < ::Regexp::Expression::Group::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#5
class Regexp::Expression::Group::Base < ::Regexp::Expression::Subexpression
  # source://regexp_parser//lib/regexp_parser/expression/methods/parts.rb#20
  def parts; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#42
class Regexp::Expression::Group::Capture < ::Regexp::Expression::Group::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/human_name.rb#39
  def human_name; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#43
  def identifier; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#43
  def number; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#43
  def number=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#43
  def number_at_level; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#43
  def number_at_level=(_arg0); end

  class << self
    # source://regexp_parser//lib/regexp_parser/expression/methods/tests.rb#128
    def capturing?; end
  end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#62
class Regexp::Expression::Group::Comment < ::Regexp::Expression::Group::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/parts.rb#22
  def parts; end

  class << self
    # source://regexp_parser//lib/regexp_parser/expression/methods/tests.rb#133
    def comment?; end

    # source://regexp_parser//lib/regexp_parser/expression/methods/tests.rb#138
    def decorative?; end
  end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#47
class Regexp::Expression::Group::Named < ::Regexp::Expression::Group::Capture
  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#51
  def initialize(token, options = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/human_name.rb#40
  def human_name; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#48
  def identifier; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#48
  def name; end

  private

  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#56
  def initialize_copy(orig); end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#25
class Regexp::Expression::Group::Options < ::Regexp::Expression::Group::Base
  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#26
  def option_changes; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#26
  def option_changes=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#33
  def quantify(*args); end

  private

  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#28
  def initialize_copy(orig); end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#8
class Regexp::Expression::Group::Passive < ::Regexp::Expression::Group::Base
  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#11
  def initialize(*_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#9
  def implicit=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/classes/group.rb#16
  def implicit?; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/parts.rb#21
  def parts; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/keep.rb#4
module Regexp::Expression::Keep; end

# source://regexp_parser//lib/regexp_parser/expression/classes/keep.rb#7
class Regexp::Expression::Keep::Mark < ::Regexp::Expression::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/human_name.rb#41
  def human_name; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#150
  def match_length; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/literal.rb#4
class Regexp::Expression::Literal < ::Regexp::Expression::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/human_name.rb#42
  def human_name; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#107
  def match_length; end
end

# source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#87
Regexp::Expression::MatchLength = Regexp::MatchLength

# source://regexp_parser//lib/regexp_parser/expression/classes/posix_class.rb#12
Regexp::Expression::Nonposixclass = Regexp::Expression::PosixClass

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#120
Regexp::Expression::Nonproperty = Regexp::Expression::UnicodeProperty

# source://regexp_parser//lib/regexp_parser/expression/classes/posix_class.rb#4
class Regexp::Expression::PosixClass < ::Regexp::Expression::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#100
  def match_length; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/posix_class.rb#5
  def name; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/negative.rb#20
  def negative?; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/posix_class.rb#11
Regexp::Expression::Posixclass = Regexp::Expression::PosixClass

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#119
Regexp::Expression::Property = Regexp::Expression::UnicodeProperty

# source://regexp_parser//lib/regexp_parser/expression/quantifier.rb#8
class Regexp::Expression::Quantifier
  include ::Regexp::Expression::Shared
  extend ::Regexp::Expression::Shared::ClassMethods

  # source://regexp_parser//lib/regexp_parser/expression/quantifier.rb#13
  def initialize(*args); end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def conditional_level; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def conditional_level=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def custom_to_s_handling; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def custom_to_s_handling=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/quantifier.rb#33
  def greedy?; end

  # source://regexp_parser//lib/regexp_parser/expression/quantifier.rb#33
  def lazy?; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def level; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def level=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/quantifier.rb#44
  def max; end

  # source://regexp_parser//lib/regexp_parser/expression/quantifier.rb#40
  def min; end

  # source://regexp_parser//lib/regexp_parser/expression/quantifier.rb#48
  def mode; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#16
  def nesting_level; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def options; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def options=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def parent; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def parent=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/quantifier.rb#33
  def possessive?; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def pre_quantifier_decorations; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def pre_quantifier_decorations=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#16
  def quantifier; end

  # source://regexp_parser//lib/regexp_parser/expression/quantifier.rb#33
  def reluctant?; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def set_level; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def set_level=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def te; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def te=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def text; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def text=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/quantifier.rb#21
  def to_h; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def token; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def token=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def ts; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def ts=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def type; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def type=(_arg0); end

  private

  # source://regexp_parser//lib/regexp_parser/expression/quantifier.rb#54
  def deprecated_old_init(token, text, _min, _max, _mode = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/quantifier.rb#66
  def derived_data; end
end

# source://regexp_parser//lib/regexp_parser/expression/quantifier.rb#11
Regexp::Expression::Quantifier::MODES = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/expression/methods/referenced_expressions.rb#4
module Regexp::Expression::ReferencedExpressions
  # source://regexp_parser//lib/regexp_parser/expression/methods/referenced_expressions.rb#7
  def referenced_expression; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/referenced_expressions.rb#5
  def referenced_expressions; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/referenced_expressions.rb#5
  def referenced_expressions=(_arg0); end

  private

  # source://regexp_parser//lib/regexp_parser/expression/methods/referenced_expressions.rb#11
  def initialize_copy(orig); end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/root.rb#4
class Regexp::Expression::Root < ::Regexp::Expression::Subexpression
  # source://regexp_parser//lib/regexp_parser/expression/methods/human_name.rb#43
  def human_name; end

  class << self
    # source://regexp_parser//lib/regexp_parser/expression/classes/root.rb#5
    def build(options = T.unsafe(nil)); end
  end
end

# source://regexp_parser//lib/regexp_parser/expression/sequence.rb#10
class Regexp::Expression::Sequence < ::Regexp::Expression::Subexpression
  # source://regexp_parser//lib/regexp_parser/expression/sequence.rb#29
  def quantify(token, *args); end

  # source://regexp_parser//lib/regexp_parser/expression/sequence.rb#25
  def ts; end

  class << self
    # source://regexp_parser//lib/regexp_parser/expression/sequence.rb#12
    def add_to(exp, params = T.unsafe(nil), active_opts = T.unsafe(nil)); end
  end
end

# source://regexp_parser//lib/regexp_parser/expression/sequence_operation.rb#5
class Regexp::Expression::SequenceOperation < ::Regexp::Expression::Subexpression
  # source://regexp_parser//lib/regexp_parser/expression/sequence_operation.rb#14
  def <<(exp); end

  # source://regexp_parser//lib/regexp_parser/expression/sequence_operation.rb#18
  def add_sequence(active_opts = T.unsafe(nil), params = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#7
  def operands; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#11
  def operator; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/parts.rb#24
  def parts; end

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#7
  def sequences; end

  # source://regexp_parser//lib/regexp_parser/expression/sequence_operation.rb#10
  def ts; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/character_set.rb#24
Regexp::Expression::Set = Regexp::Expression::CharacterSet

# source://regexp_parser//lib/regexp_parser/expression/shared.rb#4
module Regexp::Expression::Shared
  mixes_in_class_methods ::Regexp::Expression::Shared::ClassMethods

  # source://regexp_parser//lib/regexp_parser/expression/methods/tests.rb#103
  def ==(other); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/tests.rb#103
  def ===(other); end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#53
  def base_length; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/tests.rb#126
  def capturing?; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#99
  def coded_offset; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/tests.rb#130
  def comment?; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/tests.rb#135
  def decorative?; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#49
  def ends_at(include_quantifier = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/tests.rb#103
  def eql?(other); end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#57
  def full_length; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/human_name.rb#6
  def human_name; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/printing.rb#5
  def inspect; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/tests.rb#38
  def is?(test_token, test_type = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/negative.rb#10
  def negated?; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/negative.rb#5
  def negative?; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#103
  def nesting_level=(lvl); end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#95
  def offset; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/tests.rb#77
  def one_of?(scope, top = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/tests.rb#113
  def optional?; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/parts.rb#6
  def parts; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#87
  def pre_quantifier_decoration(expression_format = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/printing.rb#14
  def pretty_print(q); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/printing.rb#19
  def pretty_print_instance_variables; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/tests.rb#117
  def quantified?; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#109
  def quantifier=(qtf); end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#91
  def quantifier_affix(expression_format = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/tests.rb#140
  def referential?; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#45
  def starts_at; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/tests.rb#122
  def terminal?; end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#74
  def to_s(format = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#74
  def to_str(format = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/construct.rb#39
  def token_class; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/tests.rb#15
  def type?(test_type); end

  private

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#20
  def init_from_token_and_options(token, options = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/shared.rb#34
  def initialize_copy(orig); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/parts.rb#12
  def intersperse(expressions, separator); end

  class << self
    # source://regexp_parser//lib/regexp_parser/expression/shared.rb#7
    def included(mod); end
  end
end

# source://regexp_parser//lib/regexp_parser/expression/shared.rb#5
module Regexp::Expression::Shared::ClassMethods
  # source://regexp_parser//lib/regexp_parser/expression/methods/tests.rb#127
  def capturing?; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/tests.rb#131
  def comment?; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/construct.rb#7
  def construct(params = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/construct.rb#17
  def construct_defaults; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/tests.rb#136
  def decorative?; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/tests.rb#141
  def referential?; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/tests.rb#123
  def terminal?; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/construct.rb#27
  def token_class; end
end

# source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#4
class Regexp::Expression::Subexpression < ::Regexp::Expression::Base
  include ::Enumerable

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#9
  def initialize(token, options = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#22
  def <<(exp); end

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#29
  def [](*args, &block); end

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#29
  def at(*args, &block); end

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#35
  def dig(*indices); end

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#29
  def each(*args, &block); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/traverse.rb#10
  def each_expression(include_self = T.unsafe(nil), &block); end

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#29
  def empty?(*args, &block); end

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#7
  def expressions; end

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#7
  def expressions=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#52
  def extract_quantifier_target(quantifier_description); end

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#29
  def fetch(*args, &block); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/traverse.rb#58
  def flat_map(include_self = T.unsafe(nil), &block); end

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#29
  def index(*args, &block); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#120
  def inner_match_length; end

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#29
  def join(*args, &block); end

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#29
  def last(*args, &block); end

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#29
  def length(*args, &block); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#113
  def match_length; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/parts.rb#23
  def parts; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/strfregexp.rb#104
  def strfre_tree(format = T.unsafe(nil), include_self = T.unsafe(nil), separator = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/strfregexp.rb#104
  def strfregexp_tree(format = T.unsafe(nil), include_self = T.unsafe(nil), separator = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#41
  def te; end

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#45
  def to_h; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/traverse.rb#34
  def traverse(include_self = T.unsafe(nil), &block); end

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#29
  def values_at(*args, &block); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/traverse.rb#34
  def walk(include_self = T.unsafe(nil), &block); end

  protected

  # source://regexp_parser//lib/regexp_parser/expression/methods/traverse.rb#68
  def each_expression_with_index(&block); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/traverse.rb#75
  def each_expression_without_index(&block); end

  private

  # source://regexp_parser//lib/regexp_parser/expression/subexpression.rb#15
  def initialize_copy(orig); end

  class << self
    # source://regexp_parser//lib/regexp_parser/expression/methods/tests.rb#124
    def terminal?; end
  end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#4
module Regexp::Expression::UnicodeProperty; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#110
class Regexp::Expression::UnicodeProperty::Age < ::Regexp::Expression::UnicodeProperty::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#15
class Regexp::Expression::UnicodeProperty::Alnum < ::Regexp::Expression::UnicodeProperty::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#16
class Regexp::Expression::UnicodeProperty::Alpha < ::Regexp::Expression::UnicodeProperty::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#33
class Regexp::Expression::UnicodeProperty::Any < ::Regexp::Expression::UnicodeProperty::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#17
class Regexp::Expression::UnicodeProperty::Ascii < ::Regexp::Expression::UnicodeProperty::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#34
class Regexp::Expression::UnicodeProperty::Assigned < ::Regexp::Expression::UnicodeProperty::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#5
class Regexp::Expression::UnicodeProperty::Base < ::Regexp::Expression::Base
  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#100
  def match_length; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#6
  def name; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/negative.rb#21
  def negative?; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#10
  def shortcut; end
end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#18
class Regexp::Expression::UnicodeProperty::Blank < ::Regexp::Expression::UnicodeProperty::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#111
class Regexp::Expression::UnicodeProperty::Block < ::Regexp::Expression::UnicodeProperty::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#19
class Regexp::Expression::UnicodeProperty::Cntrl < ::Regexp::Expression::UnicodeProperty::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#99
module Regexp::Expression::UnicodeProperty::Codepoint; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#102
class Regexp::Expression::UnicodeProperty::Codepoint::Any < ::Regexp::Expression::UnicodeProperty::Codepoint::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#100
class Regexp::Expression::UnicodeProperty::Codepoint::Base < ::Regexp::Expression::UnicodeProperty::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#103
class Regexp::Expression::UnicodeProperty::Codepoint::Control < ::Regexp::Expression::UnicodeProperty::Codepoint::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#104
class Regexp::Expression::UnicodeProperty::Codepoint::Format < ::Regexp::Expression::UnicodeProperty::Codepoint::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#106
class Regexp::Expression::UnicodeProperty::Codepoint::PrivateUse < ::Regexp::Expression::UnicodeProperty::Codepoint::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#105
class Regexp::Expression::UnicodeProperty::Codepoint::Surrogate < ::Regexp::Expression::UnicodeProperty::Codepoint::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#107
class Regexp::Expression::UnicodeProperty::Codepoint::Unassigned < ::Regexp::Expression::UnicodeProperty::Codepoint::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#112
class Regexp::Expression::UnicodeProperty::Derived < ::Regexp::Expression::UnicodeProperty::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#20
class Regexp::Expression::UnicodeProperty::Digit < ::Regexp::Expression::UnicodeProperty::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#113
class Regexp::Expression::UnicodeProperty::Emoji < ::Regexp::Expression::UnicodeProperty::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#114
class Regexp::Expression::UnicodeProperty::Enumerated < ::Regexp::Expression::UnicodeProperty::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#21
class Regexp::Expression::UnicodeProperty::Graph < ::Regexp::Expression::UnicodeProperty::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#36
module Regexp::Expression::UnicodeProperty::Letter; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#39
class Regexp::Expression::UnicodeProperty::Letter::Any < ::Regexp::Expression::UnicodeProperty::Letter::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#37
class Regexp::Expression::UnicodeProperty::Letter::Base < ::Regexp::Expression::UnicodeProperty::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#40
class Regexp::Expression::UnicodeProperty::Letter::Cased < ::Regexp::Expression::UnicodeProperty::Letter::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#42
class Regexp::Expression::UnicodeProperty::Letter::Lowercase < ::Regexp::Expression::UnicodeProperty::Letter::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#44
class Regexp::Expression::UnicodeProperty::Letter::Modifier < ::Regexp::Expression::UnicodeProperty::Letter::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#45
class Regexp::Expression::UnicodeProperty::Letter::Other < ::Regexp::Expression::UnicodeProperty::Letter::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#43
class Regexp::Expression::UnicodeProperty::Letter::Titlecase < ::Regexp::Expression::UnicodeProperty::Letter::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#41
class Regexp::Expression::UnicodeProperty::Letter::Uppercase < ::Regexp::Expression::UnicodeProperty::Letter::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#22
class Regexp::Expression::UnicodeProperty::Lower < ::Regexp::Expression::UnicodeProperty::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#48
module Regexp::Expression::UnicodeProperty::Mark; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#51
class Regexp::Expression::UnicodeProperty::Mark::Any < ::Regexp::Expression::UnicodeProperty::Mark::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#49
class Regexp::Expression::UnicodeProperty::Mark::Base < ::Regexp::Expression::UnicodeProperty::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#52
class Regexp::Expression::UnicodeProperty::Mark::Combining < ::Regexp::Expression::UnicodeProperty::Mark::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#55
class Regexp::Expression::UnicodeProperty::Mark::Enclosing < ::Regexp::Expression::UnicodeProperty::Mark::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#53
class Regexp::Expression::UnicodeProperty::Mark::Nonspacing < ::Regexp::Expression::UnicodeProperty::Mark::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#54
class Regexp::Expression::UnicodeProperty::Mark::Spacing < ::Regexp::Expression::UnicodeProperty::Mark::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#31
class Regexp::Expression::UnicodeProperty::Newline < ::Regexp::Expression::UnicodeProperty::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#58
module Regexp::Expression::UnicodeProperty::Number; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#61
class Regexp::Expression::UnicodeProperty::Number::Any < ::Regexp::Expression::UnicodeProperty::Number::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#59
class Regexp::Expression::UnicodeProperty::Number::Base < ::Regexp::Expression::UnicodeProperty::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#62
class Regexp::Expression::UnicodeProperty::Number::Decimal < ::Regexp::Expression::UnicodeProperty::Number::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#63
class Regexp::Expression::UnicodeProperty::Number::Letter < ::Regexp::Expression::UnicodeProperty::Number::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#64
class Regexp::Expression::UnicodeProperty::Number::Other < ::Regexp::Expression::UnicodeProperty::Number::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#23
class Regexp::Expression::UnicodeProperty::Print < ::Regexp::Expression::UnicodeProperty::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#24
class Regexp::Expression::UnicodeProperty::Punct < ::Regexp::Expression::UnicodeProperty::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#67
module Regexp::Expression::UnicodeProperty::Punctuation; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#70
class Regexp::Expression::UnicodeProperty::Punctuation::Any < ::Regexp::Expression::UnicodeProperty::Punctuation::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#68
class Regexp::Expression::UnicodeProperty::Punctuation::Base < ::Regexp::Expression::UnicodeProperty::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#74
class Regexp::Expression::UnicodeProperty::Punctuation::Close < ::Regexp::Expression::UnicodeProperty::Punctuation::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#71
class Regexp::Expression::UnicodeProperty::Punctuation::Connector < ::Regexp::Expression::UnicodeProperty::Punctuation::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#72
class Regexp::Expression::UnicodeProperty::Punctuation::Dash < ::Regexp::Expression::UnicodeProperty::Punctuation::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#76
class Regexp::Expression::UnicodeProperty::Punctuation::Final < ::Regexp::Expression::UnicodeProperty::Punctuation::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#75
class Regexp::Expression::UnicodeProperty::Punctuation::Initial < ::Regexp::Expression::UnicodeProperty::Punctuation::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#73
class Regexp::Expression::UnicodeProperty::Punctuation::Open < ::Regexp::Expression::UnicodeProperty::Punctuation::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#77
class Regexp::Expression::UnicodeProperty::Punctuation::Other < ::Regexp::Expression::UnicodeProperty::Punctuation::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#115
class Regexp::Expression::UnicodeProperty::Script < ::Regexp::Expression::UnicodeProperty::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#80
module Regexp::Expression::UnicodeProperty::Separator; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#83
class Regexp::Expression::UnicodeProperty::Separator::Any < ::Regexp::Expression::UnicodeProperty::Separator::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#81
class Regexp::Expression::UnicodeProperty::Separator::Base < ::Regexp::Expression::UnicodeProperty::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#85
class Regexp::Expression::UnicodeProperty::Separator::Line < ::Regexp::Expression::UnicodeProperty::Separator::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#86
class Regexp::Expression::UnicodeProperty::Separator::Paragraph < ::Regexp::Expression::UnicodeProperty::Separator::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#84
class Regexp::Expression::UnicodeProperty::Separator::Space < ::Regexp::Expression::UnicodeProperty::Separator::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#25
class Regexp::Expression::UnicodeProperty::Space < ::Regexp::Expression::UnicodeProperty::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#89
module Regexp::Expression::UnicodeProperty::Symbol; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#92
class Regexp::Expression::UnicodeProperty::Symbol::Any < ::Regexp::Expression::UnicodeProperty::Symbol::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#90
class Regexp::Expression::UnicodeProperty::Symbol::Base < ::Regexp::Expression::UnicodeProperty::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#94
class Regexp::Expression::UnicodeProperty::Symbol::Currency < ::Regexp::Expression::UnicodeProperty::Symbol::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#93
class Regexp::Expression::UnicodeProperty::Symbol::Math < ::Regexp::Expression::UnicodeProperty::Symbol::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#95
class Regexp::Expression::UnicodeProperty::Symbol::Modifier < ::Regexp::Expression::UnicodeProperty::Symbol::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#96
class Regexp::Expression::UnicodeProperty::Symbol::Other < ::Regexp::Expression::UnicodeProperty::Symbol::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#26
class Regexp::Expression::UnicodeProperty::Upper < ::Regexp::Expression::UnicodeProperty::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#27
class Regexp::Expression::UnicodeProperty::Word < ::Regexp::Expression::UnicodeProperty::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#29
class Regexp::Expression::UnicodeProperty::XPosixPunct < ::Regexp::Expression::UnicodeProperty::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/unicode_property.rb#28
class Regexp::Expression::UnicodeProperty::Xdigit < ::Regexp::Expression::UnicodeProperty::Base; end

# source://regexp_parser//lib/regexp_parser/expression/classes/free_space.rb#13
class Regexp::Expression::WhiteSpace < ::Regexp::Expression::FreeSpace
  # source://regexp_parser//lib/regexp_parser/expression/methods/human_name.rb#44
  def human_name; end

  # source://regexp_parser//lib/regexp_parser/expression/classes/free_space.rb#14
  def merge(exp); end
end

# source://regexp_parser//lib/regexp_parser/lexer.rb#7
class Regexp::Lexer
  # source://regexp_parser//lib/regexp_parser/lexer.rb#73
  def emit(token); end

  # source://regexp_parser//lib/regexp_parser/lexer.rb#22
  def lex(input, syntax = T.unsafe(nil), options: T.unsafe(nil), collect_tokens: T.unsafe(nil), &block); end

  private

  # source://regexp_parser//lib/regexp_parser/lexer.rb#93
  def ascend(type, token); end

  # source://regexp_parser//lib/regexp_parser/lexer.rb#89
  def block; end

  # source://regexp_parser//lib/regexp_parser/lexer.rb#89
  def block=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/lexer.rb#145
  def break_codepoint_list(token); end

  # source://regexp_parser//lib/regexp_parser/lexer.rb#125
  def break_literal(token); end

  # source://regexp_parser//lib/regexp_parser/lexer.rb#89
  def collect_tokens; end

  # source://regexp_parser//lib/regexp_parser/lexer.rb#89
  def collect_tokens=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/lexer.rb#89
  def conditional_nesting; end

  # source://regexp_parser//lib/regexp_parser/lexer.rb#89
  def conditional_nesting=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/lexer.rb#108
  def descend(type, token); end

  # source://regexp_parser//lib/regexp_parser/lexer.rb#164
  def merge_condition(current, last); end

  # source://regexp_parser//lib/regexp_parser/lexer.rb#89
  def nesting; end

  # source://regexp_parser//lib/regexp_parser/lexer.rb#89
  def nesting=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/lexer.rb#89
  def preprev_token; end

  # source://regexp_parser//lib/regexp_parser/lexer.rb#89
  def preprev_token=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/lexer.rb#89
  def prev_token; end

  # source://regexp_parser//lib/regexp_parser/lexer.rb#89
  def prev_token=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/lexer.rb#89
  def set_nesting; end

  # source://regexp_parser//lib/regexp_parser/lexer.rb#89
  def set_nesting=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/lexer.rb#89
  def shift; end

  # source://regexp_parser//lib/regexp_parser/lexer.rb#89
  def shift=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/lexer.rb#89
  def tokens; end

  # source://regexp_parser//lib/regexp_parser/lexer.rb#89
  def tokens=(_arg0); end

  class << self
    # source://regexp_parser//lib/regexp_parser/lexer.rb#18
    def lex(input, syntax = T.unsafe(nil), options: T.unsafe(nil), collect_tokens: T.unsafe(nil), &block); end

    # source://regexp_parser//lib/regexp_parser/lexer.rb#18
    def scan(input, syntax = T.unsafe(nil), options: T.unsafe(nil), collect_tokens: T.unsafe(nil), &block); end
  end
end

# source://regexp_parser//lib/regexp_parser/lexer.rb#14
Regexp::Lexer::CLOSING_TOKENS = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/lexer.rb#16
Regexp::Lexer::CONDITION_TOKENS = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/lexer.rb#9
Regexp::Lexer::OPENING_TOKENS = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#3
class Regexp::MatchLength
  include ::Enumerable

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#11
  def initialize(exp, opts = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#26
  def each(opts = T.unsafe(nil)); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#37
  def endless_each; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#46
  def fixed?; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#42
  def include?(length); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#62
  def inspect; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#54
  def max; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#50
  def min; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#58
  def minmax; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#67
  def to_re; end

  private

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#73
  def base_max; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#73
  def base_max=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#73
  def base_min; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#73
  def base_min=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#73
  def exp_class; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#73
  def exp_class=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#73
  def max_rep; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#73
  def max_rep=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#73
  def min_rep; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#73
  def min_rep=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#73
  def reify; end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#73
  def reify=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#76
  def test_regexp; end

  class << self
    # source://regexp_parser//lib/regexp_parser/expression/methods/match_length.rb#6
    def of(obj); end
  end
end

# source://regexp_parser//lib/regexp_parser/version.rb#4
class Regexp::Parser
  include ::Regexp::Expression

  # source://regexp_parser//lib/regexp_parser/parser.rb#27
  def parse(input, syntax = T.unsafe(nil), options: T.unsafe(nil), &block); end

  private

  # source://regexp_parser//lib/regexp_parser/parser.rb#577
  def active_opts; end

  # source://regexp_parser//lib/regexp_parser/parser.rb#101
  def anchor(token); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#264
  def assign_effective_number(exp); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#584
  def assign_referenced_expressions; end

  # source://regexp_parser//lib/regexp_parser/parser.rb#229
  def backref(token); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#204
  def captured_group_count_at_level; end

  # source://regexp_parser//lib/regexp_parser/parser.rb#58
  def captured_group_counts; end

  # source://regexp_parser//lib/regexp_parser/parser.rb#58
  def captured_group_counts=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#573
  def close_completed_character_set_range; end

  # source://regexp_parser//lib/regexp_parser/parser.rb#212
  def close_group; end

  # source://regexp_parser//lib/regexp_parser/parser.rb#541
  def close_set; end

  # source://regexp_parser//lib/regexp_parser/parser.rb#271
  def conditional(token); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#58
  def conditional_nesting; end

  # source://regexp_parser//lib/regexp_parser/parser.rb#58
  def conditional_nesting=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#208
  def count_captured_group; end

  # source://regexp_parser//lib/regexp_parser/parser.rb#218
  def decrease_nesting; end

  # source://regexp_parser//lib/regexp_parser/parser.rb#307
  def escape(token); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#62
  def extract_options(input, options); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#352
  def free_space(token); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#116
  def group(token); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#512
  def increase_group_level(exp); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#552
  def intersection(token); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#363
  def keep(token); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#367
  def literal(token); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#371
  def meta(token); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#537
  def negate_set; end

  # source://regexp_parser//lib/regexp_parser/parser.rb#301
  def nest(exp); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#296
  def nest_conditional(exp); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#58
  def nesting; end

  # source://regexp_parser//lib/regexp_parser/parser.rb#58
  def nesting=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#58
  def node; end

  # source://regexp_parser//lib/regexp_parser/parser.rb#58
  def node=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#167
  def open_group(token); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#530
  def open_set(token); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#132
  def options_group(token); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#58
  def options_stack; end

  # source://regexp_parser//lib/regexp_parser/parser.rb#58
  def options_stack=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#78
  def parse_token(token); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#393
  def posixclass(token); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#400
  def property(token); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#482
  def quantifier(token); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#545
  def range(token); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#58
  def root; end

  # source://regexp_parser//lib/regexp_parser/parser.rb#58
  def root=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#382
  def sequence_operation(klass, token); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#518
  def set(token); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#58
  def switching_options; end

  # source://regexp_parser//lib/regexp_parser/parser.rb#58
  def switching_options=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/parser.rb#200
  def total_captured_group_count; end

  # source://regexp_parser//lib/regexp_parser/parser.rb#556
  def type(token); end

  class << self
    # source://regexp_parser//lib/regexp_parser/parser.rb#23
    def parse(input, syntax = T.unsafe(nil), options: T.unsafe(nil), &block); end
  end
end

# source://regexp_parser//lib/regexp_parser/parser.rb#130
Regexp::Parser::ENC_FLAGS = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/error.rb#5
class Regexp::Parser::Error < ::StandardError; end

# source://regexp_parser//lib/regexp_parser/parser.rb#129
Regexp::Parser::MOD_FLAGS = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/parser.rb#9
class Regexp::Parser::ParserError < ::Regexp::Parser::Error; end

# source://regexp_parser//lib/regexp_parser/parser.rb#397
Regexp::Parser::UP = Regexp::Expression::UnicodeProperty

# source://regexp_parser//lib/regexp_parser/parser.rb#398
Regexp::Parser::UPTokens = Regexp::Syntax::Token::UnicodeProperty

# source://regexp_parser//lib/regexp_parser/parser.rb#17
class Regexp::Parser::UnknownTokenError < ::Regexp::Parser::ParserError
  # source://regexp_parser//lib/regexp_parser/parser.rb#18
  def initialize(type, token); end
end

# source://regexp_parser//lib/regexp_parser/parser.rb#11
class Regexp::Parser::UnknownTokenTypeError < ::Regexp::Parser::ParserError
  # source://regexp_parser//lib/regexp_parser/parser.rb#12
  def initialize(type, token); end
end

# source://regexp_parser//lib/regexp_parser/version.rb#5
Regexp::Parser::VERSION = T.let(T.unsafe(nil), String)

# source://regexp_parser//lib/regexp_parser/scanner/errors/scanner_error.rb#5
class Regexp::Scanner
  # source://regexp_parser//lib/regexp_parser/scanner.rb#2509
  def capturing_group_count; end

  # source://regexp_parser//lib/regexp_parser/scanner.rb#2509
  def capturing_group_count=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/scanner.rb#2484
  def emit(type, token, text); end

  # source://regexp_parser//lib/regexp_parser/scanner.rb#2509
  def literal_run; end

  # source://regexp_parser//lib/regexp_parser/scanner.rb#2509
  def literal_run=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/scanner.rb#24
  def scan(input_object, options: T.unsafe(nil), collect_tokens: T.unsafe(nil), &block); end

  private

  # source://regexp_parser//lib/regexp_parser/scanner.rb#2555
  def append_literal(data, ts, te); end

  # source://regexp_parser//lib/regexp_parser/scanner.rb#2513
  def block; end

  # source://regexp_parser//lib/regexp_parser/scanner.rb#2513
  def block=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/scanner.rb#2513
  def char_pos; end

  # source://regexp_parser//lib/regexp_parser/scanner.rb#2513
  def char_pos=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/scanner.rb#2513
  def collect_tokens; end

  # source://regexp_parser//lib/regexp_parser/scanner.rb#2513
  def collect_tokens=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/scanner.rb#2513
  def conditional_stack; end

  # source://regexp_parser//lib/regexp_parser/scanner.rb#2513
  def conditional_stack=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/scanner.rb#2549
  def copy(data, ts, te); end

  # source://regexp_parser//lib/regexp_parser/scanner.rb#2560
  def emit_literal; end

  # source://regexp_parser//lib/regexp_parser/scanner.rb#2595
  def emit_meta_control_sequence(data, ts, te, token); end

  # source://regexp_parser//lib/regexp_parser/scanner.rb#2566
  def emit_options(text); end

  # source://regexp_parser//lib/regexp_parser/scanner.rb#2520
  def extract_encoding(input_object, options); end

  # source://regexp_parser//lib/regexp_parser/scanner.rb#2513
  def free_spacing; end

  # source://regexp_parser//lib/regexp_parser/scanner.rb#2513
  def free_spacing=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/scanner.rb#2528
  def free_spacing?(input_object, options); end

  # source://regexp_parser//lib/regexp_parser/scanner.rb#2513
  def group_depth; end

  # source://regexp_parser//lib/regexp_parser/scanner.rb#2513
  def group_depth=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/scanner.rb#2540
  def in_group?; end

  # source://regexp_parser//lib/regexp_parser/scanner.rb#2544
  def in_set?; end

  # source://regexp_parser//lib/regexp_parser/scanner.rb#2513
  def prev_token; end

  # source://regexp_parser//lib/regexp_parser/scanner.rb#2513
  def prev_token=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/scanner.rb#2513
  def regexp_encoding; end

  # source://regexp_parser//lib/regexp_parser/scanner.rb#2513
  def regexp_encoding=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/scanner.rb#2513
  def set_depth; end

  # source://regexp_parser//lib/regexp_parser/scanner.rb#2513
  def set_depth=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/scanner.rb#2513
  def spacing_stack; end

  # source://regexp_parser//lib/regexp_parser/scanner.rb#2513
  def spacing_stack=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/scanner.rb#2513
  def tokens; end

  # source://regexp_parser//lib/regexp_parser/scanner.rb#2513
  def tokens=(_arg0); end

  class << self
    # source://regexp_parser//lib/regexp_parser/scanner.rb#2469
    def long_prop_map; end

    # source://regexp_parser//lib/regexp_parser/scanner.rb#2473
    def parse_prop_map(name); end

    # source://regexp_parser//lib/regexp_parser/scanner.rb#20
    def scan(input_object, options: T.unsafe(nil), collect_tokens: T.unsafe(nil), &block); end

    # source://regexp_parser//lib/regexp_parser/scanner.rb#2465
    def short_prop_map; end
  end
end

# source://regexp_parser//lib/regexp_parser/scanner/errors/validation_error.rb#46
class Regexp::Scanner::InvalidBackrefError < ::Regexp::Scanner::ValidationError
  # source://regexp_parser//lib/regexp_parser/scanner/errors/validation_error.rb#47
  def initialize(what, reason); end
end

# source://regexp_parser//lib/regexp_parser/scanner/errors/validation_error.rb#31
class Regexp::Scanner::InvalidGroupError < ::Regexp::Scanner::ValidationError
  # source://regexp_parser//lib/regexp_parser/scanner/errors/validation_error.rb#32
  def initialize(what, reason); end
end

# source://regexp_parser//lib/regexp_parser/scanner/errors/validation_error.rb#39
class Regexp::Scanner::InvalidGroupOption < ::Regexp::Scanner::ValidationError
  # source://regexp_parser//lib/regexp_parser/scanner/errors/validation_error.rb#40
  def initialize(option, text); end
end

# source://regexp_parser//lib/regexp_parser/scanner/errors/validation_error.rb#24
class Regexp::Scanner::InvalidSequenceError < ::Regexp::Scanner::ValidationError
  # source://regexp_parser//lib/regexp_parser/scanner/errors/validation_error.rb#25
  def initialize(what = T.unsafe(nil), where = T.unsafe(nil)); end
end

# source://regexp_parser//lib/regexp_parser/scanner.rb#2478
Regexp::Scanner::POSIX_CLASSES = T.let(T.unsafe(nil), Hash)

# source://regexp_parser//lib/regexp_parser/scanner/errors/premature_end_error.rb#5
class Regexp::Scanner::PrematureEndError < ::Regexp::Scanner::ScannerError
  # source://regexp_parser//lib/regexp_parser/scanner/errors/premature_end_error.rb#6
  def initialize(where = T.unsafe(nil)); end
end

# source://regexp_parser//lib/regexp_parser/scanner/errors/scanner_error.rb#7
class Regexp::Scanner::ScannerError < ::Regexp::Parser::Error; end

# source://regexp_parser//lib/regexp_parser/scanner/errors/validation_error.rb#60
class Regexp::Scanner::UnknownPosixClassError < ::Regexp::Scanner::ValidationError
  # source://regexp_parser//lib/regexp_parser/scanner/errors/validation_error.rb#61
  def initialize(text, _); end
end

# source://regexp_parser//lib/regexp_parser/scanner/errors/validation_error.rb#53
class Regexp::Scanner::UnknownUnicodePropertyError < ::Regexp::Scanner::ValidationError
  # source://regexp_parser//lib/regexp_parser/scanner/errors/validation_error.rb#54
  def initialize(name, _); end
end

# source://regexp_parser//lib/regexp_parser/scanner/errors/validation_error.rb#5
class Regexp::Scanner::ValidationError < ::Regexp::Scanner::ScannerError
  class << self
    # source://regexp_parser//lib/regexp_parser/scanner/errors/validation_error.rb#7
    def for(type, problem, reason = T.unsafe(nil)); end

    # source://regexp_parser//lib/regexp_parser/scanner/errors/validation_error.rb#11
    def types; end
  end
end

# source://regexp_parser//lib/regexp_parser/syntax.rb#5
module Regexp::Syntax
  private

  # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#63
  def comparable(name); end

  # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#46
  def const_missing(const_name); end

  # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#53
  def fallback_version_class(version); end

  # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#24
  def for(name); end

  # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#28
  def new(name); end

  # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#59
  def specified_versions; end

  # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#34
  def supported?(name); end

  # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#38
  def version_class(version); end

  class << self
    # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#63
    def comparable(name); end

    # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#46
    def const_missing(const_name); end

    # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#53
    def fallback_version_class(version); end

    # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#24
    def for(name); end

    # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#28
    def new(name); end

    # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#59
    def specified_versions; end

    # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#34
    def supported?(name); end

    # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#38
    def version_class(version); end
  end
end

# source://regexp_parser//lib/regexp_parser/syntax/any.rb#7
class Regexp::Syntax::Any < ::Regexp::Syntax::Base
  class << self
    # source://regexp_parser//lib/regexp_parser/syntax/any.rb#10
    def implements?(_type, _token); end
  end
end

# source://regexp_parser//lib/regexp_parser/syntax/base.rb#11
class Regexp::Syntax::Base
  include ::Regexp::Syntax::Token

  # source://regexp_parser//lib/regexp_parser/syntax/base.rb#101
  def initialize; end

  # source://regexp_parser//lib/regexp_parser/syntax/base.rb#106
  def method_missing(name, *args); end

  private

  # source://regexp_parser//lib/regexp_parser/syntax/base.rb#117
  def respond_to_missing?(name, include_private = T.unsafe(nil)); end

  class << self
    # source://regexp_parser//lib/regexp_parser/syntax/base.rb#48
    def added_features; end

    # source://regexp_parser//lib/regexp_parser/syntax/base.rb#42
    def check!(type, token); end

    # source://regexp_parser//lib/regexp_parser/syntax/base.rb#33
    def check?(type, token); end

    # source://regexp_parser//lib/regexp_parser/syntax/base.rb#28
    def excludes(type, tokens); end

    # source://regexp_parser//lib/regexp_parser/syntax/base.rb#15
    def features; end

    # source://regexp_parser//lib/regexp_parser/syntax/base.rb#15
    def features=(_arg0); end

    # source://regexp_parser//lib/regexp_parser/syntax/base.rb#38
    def implementations(type); end

    # source://regexp_parser//lib/regexp_parser/syntax/base.rb#23
    def implements(type, tokens); end

    # source://regexp_parser//lib/regexp_parser/syntax/base.rb#42
    def implements!(type, token); end

    # source://regexp_parser//lib/regexp_parser/syntax/base.rb#33
    def implements?(type, token); end

    # source://regexp_parser//lib/regexp_parser/syntax/base.rb#18
    def inherited(subclass); end

    # source://regexp_parser//lib/regexp_parser/syntax/base.rb#56
    def normalize(type, token); end

    # source://regexp_parser//lib/regexp_parser/syntax/base.rb#76
    def normalize_backref(type, token); end

    # source://regexp_parser//lib/regexp_parser/syntax/base.rb#67
    def normalize_group(type, token); end

    # source://regexp_parser//lib/regexp_parser/syntax/base.rb#52
    def removed_features; end
  end
end

# source://regexp_parser//lib/regexp_parser/syntax/versions.rb#10
Regexp::Syntax::CURRENT = Regexp::Syntax::V3_2_0

# source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#8
class Regexp::Syntax::InvalidVersionNameError < ::Regexp::Syntax::SyntaxError
  # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#9
  def initialize(name); end
end

# source://regexp_parser//lib/regexp_parser/syntax/base.rb#4
class Regexp::Syntax::NotImplementedError < ::Regexp::Syntax::SyntaxError
  # source://regexp_parser//lib/regexp_parser/syntax/base.rb#5
  def initialize(syntax, type, token); end
end

# source://regexp_parser//lib/regexp_parser/syntax.rb#6
class Regexp::Syntax::SyntaxError < ::Regexp::Parser::Error; end

# source://regexp_parser//lib/regexp_parser/syntax/token.rb#5
module Regexp::Syntax::Token; end

# source://regexp_parser//lib/regexp_parser/syntax/token.rb#44
Regexp::Syntax::Token::All = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/meta.rb#17
module Regexp::Syntax::Token::Alternation; end

# source://regexp_parser//lib/regexp_parser/syntax/token/meta.rb#18
Regexp::Syntax::Token::Alternation::All = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/meta.rb#19
Regexp::Syntax::Token::Alternation::Type = T.let(T.unsafe(nil), Symbol)

# source://regexp_parser//lib/regexp_parser/syntax/token/anchor.rb#5
module Regexp::Syntax::Token::Anchor; end

# source://regexp_parser//lib/regexp_parser/syntax/token/anchor.rb#11
Regexp::Syntax::Token::Anchor::All = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/anchor.rb#6
Regexp::Syntax::Token::Anchor::Basic = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/anchor.rb#7
Regexp::Syntax::Token::Anchor::Extended = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/anchor.rb#9
Regexp::Syntax::Token::Anchor::MatchStart = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/anchor.rb#8
Regexp::Syntax::Token::Anchor::String = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/anchor.rb#12
Regexp::Syntax::Token::Anchor::Type = T.let(T.unsafe(nil), Symbol)

# source://regexp_parser//lib/regexp_parser/syntax/token/assertion.rb#5
module Regexp::Syntax::Token::Assertion; end

# source://regexp_parser//lib/regexp_parser/syntax/token/assertion.rb#9
Regexp::Syntax::Token::Assertion::All = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/assertion.rb#6
Regexp::Syntax::Token::Assertion::Lookahead = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/assertion.rb#7
Regexp::Syntax::Token::Assertion::Lookbehind = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/assertion.rb#10
Regexp::Syntax::Token::Assertion::Type = T.let(T.unsafe(nil), Symbol)

# source://regexp_parser//lib/regexp_parser/syntax/token/backreference.rb#33
Regexp::Syntax::Token::Backref = Regexp::Syntax::Token::Backreference

# source://regexp_parser//lib/regexp_parser/syntax/token/backreference.rb#5
module Regexp::Syntax::Token::Backreference; end

# source://regexp_parser//lib/regexp_parser/syntax/token/backreference.rb#17
Regexp::Syntax::Token::Backreference::All = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/backreference.rb#9
Regexp::Syntax::Token::Backreference::Name = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/backreference.rb#8
Regexp::Syntax::Token::Backreference::Number = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/backreference.rb#7
Regexp::Syntax::Token::Backreference::NumberRef = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/backreference.rb#6
Regexp::Syntax::Token::Backreference::Plain = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/backreference.rb#11
Regexp::Syntax::Token::Backreference::RecursionLevel = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/backreference.rb#18
Regexp::Syntax::Token::Backreference::Type = T.let(T.unsafe(nil), Symbol)

# source://regexp_parser//lib/regexp_parser/syntax/token/backreference.rb#13
Regexp::Syntax::Token::Backreference::V1_8_6 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/backreference.rb#15
Regexp::Syntax::Token::Backreference::V1_9_1 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/character_set.rb#5
module Regexp::Syntax::Token::CharacterSet; end

# source://regexp_parser//lib/regexp_parser/syntax/token/character_set.rb#9
Regexp::Syntax::Token::CharacterSet::All = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/character_set.rb#6
Regexp::Syntax::Token::CharacterSet::Basic = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/character_set.rb#7
Regexp::Syntax::Token::CharacterSet::Extended = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/character_set.rb#10
Regexp::Syntax::Token::CharacterSet::Type = T.let(T.unsafe(nil), Symbol)

# source://regexp_parser//lib/regexp_parser/syntax/token/character_type.rb#5
module Regexp::Syntax::Token::CharacterType; end

# source://regexp_parser//lib/regexp_parser/syntax/token/character_type.rb#12
Regexp::Syntax::Token::CharacterType::All = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/character_type.rb#6
Regexp::Syntax::Token::CharacterType::Basic = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/character_type.rb#10
Regexp::Syntax::Token::CharacterType::Clustered = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/character_type.rb#7
Regexp::Syntax::Token::CharacterType::Extended = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/character_type.rb#8
Regexp::Syntax::Token::CharacterType::Hex = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/character_type.rb#13
Regexp::Syntax::Token::CharacterType::Type = T.let(T.unsafe(nil), Symbol)

# source://regexp_parser//lib/regexp_parser/syntax/token/conditional.rb#5
module Regexp::Syntax::Token::Conditional; end

# source://regexp_parser//lib/regexp_parser/syntax/token/conditional.rb#11
Regexp::Syntax::Token::Conditional::All = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/conditional.rb#8
Regexp::Syntax::Token::Conditional::Condition = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/conditional.rb#6
Regexp::Syntax::Token::Conditional::Delimiters = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/conditional.rb#9
Regexp::Syntax::Token::Conditional::Separator = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/conditional.rb#13
Regexp::Syntax::Token::Conditional::Type = T.let(T.unsafe(nil), Symbol)

# source://regexp_parser//lib/regexp_parser/syntax/token/escape.rb#5
module Regexp::Syntax::Token::Escape; end

# source://regexp_parser//lib/regexp_parser/syntax/token/escape.rb#10
Regexp::Syntax::Token::Escape::ASCII = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/escape.rb#26
Regexp::Syntax::Token::Escape::All = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/escape.rb#6
Regexp::Syntax::Token::Escape::Basic = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/escape.rb#8
Regexp::Syntax::Token::Escape::Control = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/escape.rb#22
Regexp::Syntax::Token::Escape::Hex = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/escape.rb#15
Regexp::Syntax::Token::Escape::Meta = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/escape.rb#24
Regexp::Syntax::Token::Escape::Octal = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/escape.rb#27
Regexp::Syntax::Token::Escape::Type = T.let(T.unsafe(nil), Symbol)

# source://regexp_parser//lib/regexp_parser/syntax/token/escape.rb#13
Regexp::Syntax::Token::Escape::Unicode = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/escape.rb#33
Regexp::Syntax::Token::EscapeSequence = Regexp::Syntax::Token::Escape

# source://regexp_parser//lib/regexp_parser/syntax/token.rb#13
module Regexp::Syntax::Token::FreeSpace; end

# source://regexp_parser//lib/regexp_parser/syntax/token.rb#14
Regexp::Syntax::Token::FreeSpace::All = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token.rb#15
Regexp::Syntax::Token::FreeSpace::Type = T.let(T.unsafe(nil), Symbol)

# source://regexp_parser//lib/regexp_parser/syntax/token/group.rb#5
module Regexp::Syntax::Token::Group; end

# source://regexp_parser//lib/regexp_parser/syntax/token/group.rb#19
Regexp::Syntax::Token::Group::All = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/group.rb#10
Regexp::Syntax::Token::Group::Atomic = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/group.rb#6
Regexp::Syntax::Token::Group::Basic = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/group.rb#12
Regexp::Syntax::Token::Group::Comment = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/group.rb#7
Regexp::Syntax::Token::Group::Extended = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/group.rb#9
Regexp::Syntax::Token::Group::Named = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/group.rb#11
Regexp::Syntax::Token::Group::Passive = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/group.rb#20
Regexp::Syntax::Token::Group::Type = T.let(T.unsafe(nil), Symbol)

# source://regexp_parser//lib/regexp_parser/syntax/token/group.rb#14
Regexp::Syntax::Token::Group::V1_8_6 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/group.rb#17
Regexp::Syntax::Token::Group::V2_4_1 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/keep.rb#5
module Regexp::Syntax::Token::Keep; end

# source://regexp_parser//lib/regexp_parser/syntax/token/keep.rb#8
Regexp::Syntax::Token::Keep::All = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/keep.rb#6
Regexp::Syntax::Token::Keep::Mark = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/keep.rb#9
Regexp::Syntax::Token::Keep::Type = T.let(T.unsafe(nil), Symbol)

# source://regexp_parser//lib/regexp_parser/syntax/token.rb#8
module Regexp::Syntax::Token::Literal; end

# source://regexp_parser//lib/regexp_parser/syntax/token.rb#9
Regexp::Syntax::Token::Literal::All = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token.rb#10
Regexp::Syntax::Token::Literal::Type = T.let(T.unsafe(nil), Symbol)

# source://regexp_parser//lib/regexp_parser/syntax/token.rb#6
Regexp::Syntax::Token::Map = T.let(T.unsafe(nil), Hash)

# source://regexp_parser//lib/regexp_parser/syntax/token/meta.rb#5
module Regexp::Syntax::Token::Meta; end

# source://regexp_parser//lib/regexp_parser/syntax/token/meta.rb#10
Regexp::Syntax::Token::Meta::All = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/meta.rb#7
Regexp::Syntax::Token::Meta::Alternation = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/meta.rb#6
Regexp::Syntax::Token::Meta::Basic = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/meta.rb#8
Regexp::Syntax::Token::Meta::Extended = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/meta.rb#11
Regexp::Syntax::Token::Meta::Type = T.let(T.unsafe(nil), Symbol)

# source://regexp_parser//lib/regexp_parser/syntax/token/posix_class.rb#5
module Regexp::Syntax::Token::PosixClass; end

# source://regexp_parser//lib/regexp_parser/syntax/token/posix_class.rb#11
Regexp::Syntax::Token::PosixClass::All = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/posix_class.rb#9
Regexp::Syntax::Token::PosixClass::Extensions = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/posix_class.rb#13
Regexp::Syntax::Token::PosixClass::NonType = T.let(T.unsafe(nil), Symbol)

# source://regexp_parser//lib/regexp_parser/syntax/token/posix_class.rb#6
Regexp::Syntax::Token::PosixClass::Standard = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/posix_class.rb#12
Regexp::Syntax::Token::PosixClass::Type = T.let(T.unsafe(nil), Symbol)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#764
Regexp::Syntax::Token::Property = Regexp::Syntax::Token::UnicodeProperty

# source://regexp_parser//lib/regexp_parser/syntax/token/quantifier.rb#5
module Regexp::Syntax::Token::Quantifier; end

# source://regexp_parser//lib/regexp_parser/syntax/token/quantifier.rb#31
Regexp::Syntax::Token::Quantifier::All = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/quantifier.rb#6
Regexp::Syntax::Token::Quantifier::Greedy = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/quantifier.rb#24
Regexp::Syntax::Token::Quantifier::Interval = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/quantifier.rb#28
Regexp::Syntax::Token::Quantifier::IntervalAll = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/quantifier.rb#26
Regexp::Syntax::Token::Quantifier::IntervalPossessive = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/quantifier.rb#25
Regexp::Syntax::Token::Quantifier::IntervalReluctant = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/quantifier.rb#18
Regexp::Syntax::Token::Quantifier::Possessive = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/quantifier.rb#12
Regexp::Syntax::Token::Quantifier::Reluctant = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/quantifier.rb#32
Regexp::Syntax::Token::Quantifier::Type = T.let(T.unsafe(nil), Symbol)

# source://regexp_parser//lib/regexp_parser/syntax/token/quantifier.rb#30
Regexp::Syntax::Token::Quantifier::V1_8_6 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/character_set.rb#16
Regexp::Syntax::Token::Set = Regexp::Syntax::Token::CharacterSet

# source://regexp_parser//lib/regexp_parser/syntax/token/backreference.rb#22
module Regexp::Syntax::Token::SubexpressionCall; end

# source://regexp_parser//lib/regexp_parser/syntax/token/backreference.rb#26
Regexp::Syntax::Token::SubexpressionCall::All = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/backreference.rb#23
Regexp::Syntax::Token::SubexpressionCall::Name = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/backreference.rb#24
Regexp::Syntax::Token::SubexpressionCall::Number = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token.rb#45
Regexp::Syntax::Token::Types = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#5
module Regexp::Syntax::Token::UnicodeProperty; end

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#68
Regexp::Syntax::Token::UnicodeProperty::Age = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#42
Regexp::Syntax::Token::UnicodeProperty::Age_V1_9_3 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#46
Regexp::Syntax::Token::UnicodeProperty::Age_V2_0_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#48
Regexp::Syntax::Token::UnicodeProperty::Age_V2_2_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#50
Regexp::Syntax::Token::UnicodeProperty::Age_V2_3_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#52
Regexp::Syntax::Token::UnicodeProperty::Age_V2_4_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#54
Regexp::Syntax::Token::UnicodeProperty::Age_V2_5_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#56
Regexp::Syntax::Token::UnicodeProperty::Age_V2_6_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#58
Regexp::Syntax::Token::UnicodeProperty::Age_V2_6_2 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#60
Regexp::Syntax::Token::UnicodeProperty::Age_V2_6_3 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#62
Regexp::Syntax::Token::UnicodeProperty::Age_V3_1_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#64
Regexp::Syntax::Token::UnicodeProperty::Age_V3_2_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#66
Regexp::Syntax::Token::UnicodeProperty::Age_V3_5_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#754
Regexp::Syntax::Token::UnicodeProperty::All = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#15
module Regexp::Syntax::Token::UnicodeProperty::Category; end

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#38
Regexp::Syntax::Token::UnicodeProperty::Category::All = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#35
Regexp::Syntax::Token::UnicodeProperty::Category::Codepoint = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#16
Regexp::Syntax::Token::UnicodeProperty::Category::Letter = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#19
Regexp::Syntax::Token::UnicodeProperty::Category::Mark = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#22
Regexp::Syntax::Token::UnicodeProperty::Category::Number = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#25
Regexp::Syntax::Token::UnicodeProperty::Category::Punctuation = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#32
Regexp::Syntax::Token::UnicodeProperty::Category::Separator = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#29
Regexp::Syntax::Token::UnicodeProperty::Category::Symbol = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#8
Regexp::Syntax::Token::UnicodeProperty::CharType_V1_9_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#11
Regexp::Syntax::Token::UnicodeProperty::CharType_V2_5_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#143
Regexp::Syntax::Token::UnicodeProperty::Derived = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#70
Regexp::Syntax::Token::UnicodeProperty::Derived_V1_9_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#124
Regexp::Syntax::Token::UnicodeProperty::Derived_V2_0_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#129
Regexp::Syntax::Token::UnicodeProperty::Derived_V2_4_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#133
Regexp::Syntax::Token::UnicodeProperty::Derived_V2_5_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#137
Regexp::Syntax::Token::UnicodeProperty::Derived_V3_5_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#738
Regexp::Syntax::Token::UnicodeProperty::Emoji = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#708
Regexp::Syntax::Token::UnicodeProperty::Emoji_V2_5_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#716
Regexp::Syntax::Token::UnicodeProperty::Emoji_V2_6_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#736
Regexp::Syntax::Token::UnicodeProperty::Enumerated = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#720
Regexp::Syntax::Token::UnicodeProperty::Enumerated_V2_4_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#757
Regexp::Syntax::Token::UnicodeProperty::NonType = T.let(T.unsafe(nil), Symbol)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#13
Regexp::Syntax::Token::UnicodeProperty::POSIX = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#342
Regexp::Syntax::Token::UnicodeProperty::Script = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#145
Regexp::Syntax::Token::UnicodeProperty::Script_V1_9_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#241
Regexp::Syntax::Token::UnicodeProperty::Script_V1_9_3 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#247
Regexp::Syntax::Token::UnicodeProperty::Script_V2_0_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#257
Regexp::Syntax::Token::UnicodeProperty::Script_V2_2_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#283
Regexp::Syntax::Token::UnicodeProperty::Script_V2_3_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#292
Regexp::Syntax::Token::UnicodeProperty::Script_V2_4_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#301
Regexp::Syntax::Token::UnicodeProperty::Script_V2_5_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#308
Regexp::Syntax::Token::UnicodeProperty::Script_V2_6_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#318
Regexp::Syntax::Token::UnicodeProperty::Script_V2_6_2 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#325
Regexp::Syntax::Token::UnicodeProperty::Script_V3_1_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#332
Regexp::Syntax::Token::UnicodeProperty::Script_V3_2_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#756
Regexp::Syntax::Token::UnicodeProperty::Type = T.let(T.unsafe(nil), Symbol)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#706
Regexp::Syntax::Token::UnicodeProperty::UnicodeBlock = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#344
Regexp::Syntax::Token::UnicodeProperty::UnicodeBlock_V1_9_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#443
Regexp::Syntax::Token::UnicodeProperty::UnicodeBlock_V2_0_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#571
Regexp::Syntax::Token::UnicodeProperty::UnicodeBlock_V2_2_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#606
Regexp::Syntax::Token::UnicodeProperty::UnicodeBlock_V2_3_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#619
Regexp::Syntax::Token::UnicodeProperty::UnicodeBlock_V2_4_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#633
Regexp::Syntax::Token::UnicodeProperty::UnicodeBlock_V2_5_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#643
Regexp::Syntax::Token::UnicodeProperty::UnicodeBlock_V2_6_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#657
Regexp::Syntax::Token::UnicodeProperty::UnicodeBlock_V2_6_2 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#669
Regexp::Syntax::Token::UnicodeProperty::UnicodeBlock_V3_1_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#680
Regexp::Syntax::Token::UnicodeProperty::UnicodeBlock_V3_2_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#702
Regexp::Syntax::Token::UnicodeProperty::UnicodeBlock_V3_5_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#740
Regexp::Syntax::Token::UnicodeProperty::V1_9_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#741
Regexp::Syntax::Token::UnicodeProperty::V1_9_3 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#742
Regexp::Syntax::Token::UnicodeProperty::V2_0_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#743
Regexp::Syntax::Token::UnicodeProperty::V2_2_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#744
Regexp::Syntax::Token::UnicodeProperty::V2_3_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#745
Regexp::Syntax::Token::UnicodeProperty::V2_4_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#746
Regexp::Syntax::Token::UnicodeProperty::V2_5_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#747
Regexp::Syntax::Token::UnicodeProperty::V2_6_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#748
Regexp::Syntax::Token::UnicodeProperty::V2_6_2 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#749
Regexp::Syntax::Token::UnicodeProperty::V2_6_3 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#750
Regexp::Syntax::Token::UnicodeProperty::V3_1_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#751
Regexp::Syntax::Token::UnicodeProperty::V3_2_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/token/unicode_property.rb#752
Regexp::Syntax::Token::UnicodeProperty::V3_5_0 = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#14
class Regexp::Syntax::UnknownSyntaxNameError < ::Regexp::Syntax::SyntaxError
  # source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#15
  def initialize(name); end
end

# source://regexp_parser//lib/regexp_parser/syntax/versions/1.8.6.rb#3
class Regexp::Syntax::V1_8_6 < ::Regexp::Syntax::Base; end

# source://regexp_parser//lib/regexp_parser/syntax/versions/1.9.1.rb#3
class Regexp::Syntax::V1_9_1 < ::Regexp::Syntax::V1_8_6; end

# source://regexp_parser//lib/regexp_parser/syntax/versions/1.9.3.rb#3
class Regexp::Syntax::V1_9_3 < ::Regexp::Syntax::V1_9_1; end

# source://regexp_parser//lib/regexp_parser/syntax/versions/2.0.0.rb#3
class Regexp::Syntax::V2_0_0 < ::Regexp::Syntax::V1_9_3; end

# source://regexp_parser//lib/regexp_parser/syntax/versions/2.2.0.rb#3
class Regexp::Syntax::V2_2_0 < ::Regexp::Syntax::V2_0_0; end

# source://regexp_parser//lib/regexp_parser/syntax/versions/2.3.0.rb#3
class Regexp::Syntax::V2_3_0 < ::Regexp::Syntax::V2_2_0; end

# source://regexp_parser//lib/regexp_parser/syntax/versions/2.4.0.rb#3
class Regexp::Syntax::V2_4_0 < ::Regexp::Syntax::V2_3_0; end

# source://regexp_parser//lib/regexp_parser/syntax/versions/2.4.1.rb#3
class Regexp::Syntax::V2_4_1 < ::Regexp::Syntax::V2_4_0; end

# source://regexp_parser//lib/regexp_parser/syntax/versions/2.5.0.rb#3
class Regexp::Syntax::V2_5_0 < ::Regexp::Syntax::V2_4_1; end

# source://regexp_parser//lib/regexp_parser/syntax/versions/2.6.0.rb#3
class Regexp::Syntax::V2_6_0 < ::Regexp::Syntax::V2_5_0; end

# source://regexp_parser//lib/regexp_parser/syntax/versions/2.6.2.rb#3
class Regexp::Syntax::V2_6_2 < ::Regexp::Syntax::V2_6_0; end

# source://regexp_parser//lib/regexp_parser/syntax/versions/2.6.3.rb#3
class Regexp::Syntax::V2_6_3 < ::Regexp::Syntax::V2_6_2; end

# source://regexp_parser//lib/regexp_parser/syntax/versions/3.1.0.rb#3
class Regexp::Syntax::V3_1_0 < ::Regexp::Syntax::V2_6_3; end

# source://regexp_parser//lib/regexp_parser/syntax/versions/3.2.0.rb#3
class Regexp::Syntax::V3_2_0 < ::Regexp::Syntax::V3_1_0; end

# source://regexp_parser//lib/regexp_parser/syntax/versions/3.5.0.rb#1
class Regexp::Syntax::V3_5_0 < ::Regexp::Syntax::V3_2_0; end

# source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#6
Regexp::Syntax::VERSION_CONST_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#4
Regexp::Syntax::VERSION_FORMAT = T.let(T.unsafe(nil), String)

# source://regexp_parser//lib/regexp_parser/syntax/version_lookup.rb#5
Regexp::Syntax::VERSION_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://regexp_parser//lib/regexp_parser/token.rb#4
Regexp::TOKEN_KEYS = T.let(T.unsafe(nil), Array)

# source://regexp_parser//lib/regexp_parser/token.rb#15
class Regexp::Token < ::Struct
  def conditional_level; end
  def conditional_level=(_); end

  # source://regexp_parser//lib/regexp_parser/token.rb#22
  def length; end

  def level; end
  def level=(_); end

  # source://regexp_parser//lib/regexp_parser/token.rb#16
  def next; end

  # source://regexp_parser//lib/regexp_parser/token.rb#16
  def next=(_arg0); end

  # source://regexp_parser//lib/regexp_parser/token.rb#18
  def offset; end

  # source://regexp_parser//lib/regexp_parser/token.rb#16
  def previous; end

  # source://regexp_parser//lib/regexp_parser/token.rb#16
  def previous=(_arg0); end

  def set_level; end
  def set_level=(_); end
  def te; end
  def te=(_); end
  def text; end
  def text=(_); end
  def token; end
  def token=(_); end
  def ts; end
  def ts=(_); end
  def type; end
  def type=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end
