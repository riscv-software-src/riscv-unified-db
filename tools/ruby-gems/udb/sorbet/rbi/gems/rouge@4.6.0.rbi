# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rouge` gem.
# Please instead update this file by running `bin/tapioca gem rouge`.


# source://rouge//lib/rouge.rb#8
module Rouge
  class << self
    # source://rouge//lib/rouge.rb#29
    def highlight(text, lexer, formatter, &b); end

    # source://rouge//lib/rouge.rb#42
    def load_file(path); end

    # source://rouge//lib/rouge.rb#49
    def load_lexers; end

    # source://rouge//lib/rouge.rb#14
    def reload!; end

    # source://rouge//lib/rouge/version.rb#5
    def version; end
  end
end

# source://rouge//lib/rouge/theme.rb#163
class Rouge::CSSTheme < ::Rouge::Theme
  # source://rouge//lib/rouge/theme.rb#164
  def initialize(opts = T.unsafe(nil)); end

  # source://rouge//lib/rouge/theme.rb#168
  def render(&b); end

  # source://rouge//lib/rouge/theme.rb#180
  def render_base(selector, &b); end

  # source://rouge//lib/rouge/theme.rb#184
  def style_for(tok); end

  private

  # source://rouge//lib/rouge/theme.rb#189
  def css_selector(token); end

  # source://rouge//lib/rouge/theme.rb#207
  def inflate_token(tok, &b); end

  # source://rouge//lib/rouge/theme.rb#197
  def single_css_selector(token); end
end

# source://rouge//lib/rouge/formatter.rb#6
class Rouge::Formatter
  # source://rouge//lib/rouge/formatter.rb#49
  def initialize(opts = T.unsafe(nil)); end

  # source://rouge//lib/rouge/formatter.rb#53
  def escape?(tok); end

  # source://rouge//lib/rouge/formatter.rb#57
  def filter_escapes(tokens); end

  # source://rouge//lib/rouge/formatter.rb#68
  def format(tokens, &b); end

  # source://rouge//lib/rouge/formatter.rb#80
  def render(tokens); end

  # source://rouge//lib/rouge/formatter.rb#87
  def stream(tokens, &b); end

  protected

  # source://rouge//lib/rouge/formatter.rb#92
  def token_lines(tokens, &b); end

  class << self
    # source://rouge//lib/rouge/formatter.rb#39
    def disable_escape!; end

    # source://rouge//lib/rouge/formatter.rb#35
    def enable_escape!; end

    # source://rouge//lib/rouge/formatter.rb#31
    def escape_enabled?; end

    # source://rouge//lib/rouge/formatter.rb#20
    def find(tag); end

    # source://rouge//lib/rouge/formatter.rb#45
    def format(tokens, *args, **kwargs, &b); end

    # source://rouge//lib/rouge/formatter.rb#12
    def tag(tag = T.unsafe(nil)); end

    # source://rouge//lib/rouge/formatter.rb#24
    def with_escape; end
  end
end

# source://rouge//lib/rouge/formatter.rb#8
Rouge::Formatter::REGISTRY = T.let(T.unsafe(nil), Hash)

# source://rouge//lib/rouge/formatters/html.rb#5
module Rouge::Formatters; end

# source://rouge//lib/rouge/formatters/html.rb#7
class Rouge::Formatters::HTML < ::Rouge::Formatter
  # source://rouge//lib/rouge/formatters/html.rb#29
  def safe_span(tok, safe_val); end

  # source://rouge//lib/rouge/formatters/html.rb#23
  def span(tok, val); end

  # source://rouge//lib/rouge/formatters/html.rb#19
  def stream(tokens, &b); end

  private

  # source://rouge//lib/rouge/formatters/html.rb#50
  def escape_special_html_chars(value); end
end

# source://rouge//lib/rouge/formatters/html.rb#14
Rouge::Formatters::HTML::ESCAPE_REGEX = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/formatters/html.rb#8
Rouge::Formatters::HTML::TABLE_FOR_ESCAPE_HTML = T.let(T.unsafe(nil), Hash)

# source://rouge//lib/rouge/formatters/html_inline.rb#6
class Rouge::Formatters::HTMLInline < ::Rouge::Formatters::HTML
  # source://rouge//lib/rouge/formatters/html_inline.rb#9
  def initialize(theme); end

  # source://rouge//lib/rouge/formatters/html_inline.rb#21
  def safe_span(tok, safe_val); end
end

# source://rouge//lib/rouge/formatters/html_legacy.rb#10
class Rouge::Formatters::HTMLLegacy < ::Rouge::Formatter
  # source://rouge//lib/rouge/formatters/html_legacy.rb#27
  def initialize(opts = T.unsafe(nil)); end

  # source://rouge//lib/rouge/formatters/html_legacy.rb#40
  def stream(tokens, &b); end
end

# source://rouge//lib/rouge/formatters/html_line_highlighter.rb#6
class Rouge::Formatters::HTMLLineHighlighter < ::Rouge::Formatter
  # source://rouge//lib/rouge/formatters/html_line_highlighter.rb#9
  def initialize(delegate, opts = T.unsafe(nil)); end

  # source://rouge//lib/rouge/formatters/html_line_highlighter.rb#15
  def stream(tokens); end
end

# source://rouge//lib/rouge/formatters/html_line_table.rb#6
class Rouge::Formatters::HTMLLineTable < ::Rouge::Formatter
  # source://rouge//lib/rouge/formatters/html_line_table.rb#24
  def initialize(formatter, opts = T.unsafe(nil)); end

  # source://rouge//lib/rouge/formatters/html_line_table.rb#34
  def stream(tokens, &b); end
end

# source://rouge//lib/rouge/formatters/html_linewise.rb#6
class Rouge::Formatters::HTMLLinewise < ::Rouge::Formatter
  # source://rouge//lib/rouge/formatters/html_linewise.rb#7
  def initialize(formatter, opts = T.unsafe(nil)); end

  # source://rouge//lib/rouge/formatters/html_linewise.rb#13
  def stream(tokens, &b); end
end

# source://rouge//lib/rouge/formatters/html_pygments.rb#5
class Rouge::Formatters::HTMLPygments < ::Rouge::Formatter
  # source://rouge//lib/rouge/formatters/html_pygments.rb#6
  def initialize(inner, css_class = T.unsafe(nil)); end

  # source://rouge//lib/rouge/formatters/html_pygments.rb#11
  def stream(tokens, &b); end
end

# source://rouge//lib/rouge/formatters/html_table.rb#6
class Rouge::Formatters::HTMLTable < ::Rouge::Formatter
  # source://rouge//lib/rouge/formatters/html_table.rb#9
  def initialize(inner, opts = T.unsafe(nil)); end

  # source://rouge//lib/rouge/formatters/html_table.rb#23
  def stream(tokens, &b); end

  # source://rouge//lib/rouge/formatters/html_table.rb#18
  def style(scope); end
end

# source://rouge//lib/rouge/formatters/null.rb#7
class Rouge::Formatters::Null < ::Rouge::Formatter
  # source://rouge//lib/rouge/formatters/null.rb#10
  def initialize(*_arg0); end

  # source://rouge//lib/rouge/formatters/null.rb#13
  def stream(tokens, &b); end
end

# source://rouge//lib/rouge/formatters/terminal256.rb#7
class Rouge::Formatters::Terminal256 < ::Rouge::Formatter
  # source://rouge//lib/rouge/formatters/terminal256.rb#15
  def initialize(theme = T.unsafe(nil)); end

  # source://rouge//lib/rouge/formatters/terminal256.rb#173
  def escape_sequence(token); end

  # source://rouge//lib/rouge/formatters/terminal256.rb#184
  def get_style(token); end

  # source://rouge//lib/rouge/formatters/terminal256.rb#180
  def make_escape_sequence(style); end

  # source://rouge//lib/rouge/formatters/terminal256.rb#25
  def stream(tokens, &b); end

  # source://rouge//lib/rouge/formatters/terminal256.rb#190
  def text_style; end

  # source://rouge//lib/rouge/formatters/terminal256.rb#11
  def theme; end
end

# source://rouge//lib/rouge/formatters/terminal256.rb#31
class Rouge::Formatters::Terminal256::EscapeSequence
  # source://rouge//lib/rouge/formatters/terminal256.rb#33
  def initialize(style); end

  # source://rouge//lib/rouge/formatters/terminal256.rb#80
  def bg; end

  # source://rouge//lib/rouge/formatters/terminal256.rb#75
  def fg; end

  # source://rouge//lib/rouge/formatters/terminal256.rb#105
  def reset_string; end

  # source://rouge//lib/rouge/formatters/terminal256.rb#86
  def stream_value(val, &b); end

  # source://rouge//lib/rouge/formatters/terminal256.rb#32
  def style; end

  # source://rouge//lib/rouge/formatters/terminal256.rb#93
  def style_string; end

  private

  # source://rouge//lib/rouge/formatters/terminal256.rb#117
  def escape(attrs); end

  class << self
    # source://rouge//lib/rouge/formatters/terminal256.rb#144
    def closest_color(r, g, b); end

    # source://rouge//lib/rouge/formatters/terminal256.rb#122
    def color_index(color); end

    # source://rouge//lib/rouge/formatters/terminal256.rb#127
    def get_rgb(color); end

    # source://rouge//lib/rouge/formatters/terminal256.rb#37
    def xterm_colors; end
  end
end

# source://rouge//lib/rouge/formatters/terminal256.rb#142
Rouge::Formatters::Terminal256::EscapeSequence::MAX_DISTANCE = T.let(T.unsafe(nil), Integer)

# source://rouge//lib/rouge/formatters/terminal256.rb#165
class Rouge::Formatters::Terminal256::Unescape < ::Rouge::Formatters::Terminal256::EscapeSequence
  # source://rouge//lib/rouge/formatters/terminal256.rb#166
  def initialize(*_arg0); end

  # source://rouge//lib/rouge/formatters/terminal256.rb#168
  def reset_string(*_arg0); end

  # source://rouge//lib/rouge/formatters/terminal256.rb#169
  def stream_value(val); end

  # source://rouge//lib/rouge/formatters/terminal256.rb#167
  def style_string(*_arg0); end
end

# source://rouge//lib/rouge/formatters/terminal_truecolor.rb#5
class Rouge::Formatters::TerminalTruecolor < ::Rouge::Formatters::Terminal256
  # source://rouge//lib/rouge/formatters/terminal_truecolor.rb#32
  def make_escape_sequence(style); end
end

# source://rouge//lib/rouge/formatters/terminal_truecolor.rb#8
class Rouge::Formatters::TerminalTruecolor::TruecolorEscapeSequence < ::Rouge::Formatters::Terminal256::EscapeSequence
  # source://rouge//lib/rouge/formatters/terminal_truecolor.rb#19
  def get_rgb(color); end

  # source://rouge//lib/rouge/formatters/terminal_truecolor.rb#9
  def style_string; end
end

# source://rouge//lib/rouge/formatters/tex.rb#6
class Rouge::Formatters::Tex < ::Rouge::Formatter
  # source://rouge//lib/rouge/formatters/tex.rb#33
  def initialize(opts = T.unsafe(nil)); end

  # source://rouge//lib/rouge/formatters/tex.rb#37
  def escape_tex(str); end

  # source://rouge//lib/rouge/formatters/tex.rb#74
  def hphantom_tag(tok, val); end

  # source://rouge//lib/rouge/formatters/tex.rb#64
  def render_line(line, &b); end

  # source://rouge//lib/rouge/formatters/tex.rb#41
  def stream(tokens, &b); end

  # source://rouge//lib/rouge/formatters/tex.rb#81
  def tag(tok, val); end
end

# source://rouge//lib/rouge/formatters/tex.rb#13
Rouge::Formatters::Tex::ESCAPE = T.let(T.unsafe(nil), Hash)

# source://rouge//lib/rouge/formatters/tex.rb#31
Rouge::Formatters::Tex::ESCAPE_REGEX = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/guesser.rb#4
class Rouge::Guesser
  # source://rouge//lib/rouge/guesser.rb#33
  def collect_best(lexers, opts = T.unsafe(nil), &scorer); end

  # source://rouge//lib/rouge/guesser.rb#53
  def filter(lexers); end

  class << self
    # source://rouge//lib/rouge/guesser.rb#14
    def guess(guessers, lexers); end
  end
end

# source://rouge//lib/rouge/guesser.rb#5
class Rouge::Guesser::Ambiguous < ::StandardError
  # source://rouge//lib/rouge/guesser.rb#7
  def initialize(alternatives); end

  # source://rouge//lib/rouge/guesser.rb#6
  def alternatives; end

  # source://rouge//lib/rouge/guesser.rb#9
  def message; end
end

# source://rouge//lib/rouge/guessers/util.rb#4
module Rouge::Guessers; end

# source://rouge//lib/rouge/guessers/disambiguation.rb#5
class Rouge::Guessers::Disambiguation < ::Rouge::Guesser
  include ::Rouge::Guessers::Util
  include ::Rouge::Lexers

  # source://rouge//lib/rouge/guessers/disambiguation.rb#9
  def initialize(filename, source); end

  # source://rouge//lib/rouge/guessers/disambiguation.rb#30
  def contains?(text); end

  # source://rouge//lib/rouge/guessers/disambiguation.rb#14
  def filter(lexers); end

  # source://rouge//lib/rouge/guessers/disambiguation.rb#34
  def matches?(re); end

  class << self
    # source://rouge//lib/rouge/guessers/disambiguation.rb#39
    def disambiguate(*patterns, &decider); end

    # source://rouge//lib/rouge/guessers/disambiguation.rb#43
    def disambiguators; end
  end
end

# source://rouge//lib/rouge/guessers/disambiguation.rb#47
class Rouge::Guessers::Disambiguation::Disambiguator
  include ::Rouge::Guessers::Util

  # source://rouge//lib/rouge/guessers/disambiguation.rb#50
  def initialize(patterns, &decider); end

  # source://rouge//lib/rouge/guessers/disambiguation.rb#55
  def decide!(guesser); end

  # source://rouge//lib/rouge/guessers/disambiguation.rb#64
  def match?(filename); end
end

# source://rouge//lib/rouge/guessers/filename.rb#5
class Rouge::Guessers::Filename < ::Rouge::Guesser
  # source://rouge//lib/rouge/guessers/filename.rb#7
  def initialize(filename); end

  # source://rouge//lib/rouge/guessers/filename.rb#17
  def filter(lexers); end

  # source://rouge//lib/rouge/guessers/filename.rb#6
  def fname; end
end

# source://rouge//lib/rouge/guessers/glob_mapping.rb#7
class Rouge::Guessers::GlobMapping < ::Rouge::Guesser
  include ::Rouge::Guessers::Util

  # source://rouge//lib/rouge/guessers/glob_mapping.rb#26
  def initialize(glob_map, filename); end

  # source://rouge//lib/rouge/guessers/glob_mapping.rb#25
  def filename; end

  # source://rouge//lib/rouge/guessers/glob_mapping.rb#31
  def filter(lexers); end

  # source://rouge//lib/rouge/guessers/glob_mapping.rb#25
  def glob_map; end

  class << self
    # source://rouge//lib/rouge/guessers/glob_mapping.rb#10
    def by_pairs(mapping, filename); end
  end
end

# source://rouge//lib/rouge/guessers/mimetype.rb#5
class Rouge::Guessers::Mimetype < ::Rouge::Guesser
  # source://rouge//lib/rouge/guessers/mimetype.rb#7
  def initialize(mimetype); end

  # source://rouge//lib/rouge/guessers/mimetype.rb#11
  def filter(lexers); end

  # source://rouge//lib/rouge/guessers/mimetype.rb#6
  def mimetype; end
end

# source://rouge//lib/rouge/guessers/modeline.rb#5
class Rouge::Guessers::Modeline < ::Rouge::Guesser
  include ::Rouge::Guessers::Util

  # source://rouge//lib/rouge/guessers/modeline.rb#23
  def initialize(source, opts = T.unsafe(nil)); end

  # source://rouge//lib/rouge/guessers/modeline.rb#28
  def filter(lexers); end
end

# source://rouge//lib/rouge/guessers/modeline.rb#9
Rouge::Guessers::Modeline::EMACS_MODELINE = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/guessers/modeline.rb#21
Rouge::Guessers::Modeline::MODELINES = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/guessers/modeline.rb#14
Rouge::Guessers::Modeline::VIM_MODELINE_1 = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/guessers/modeline.rb#19
Rouge::Guessers::Modeline::VIM_MODELINE_2 = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/guessers/source.rb#5
class Rouge::Guessers::Source < ::Rouge::Guesser
  include ::Rouge::Guessers::Util

  # source://rouge//lib/rouge/guessers/source.rb#9
  def initialize(source); end

  # source://rouge//lib/rouge/guessers/source.rb#13
  def filter(lexers); end

  # source://rouge//lib/rouge/guessers/source.rb#8
  def source; end
end

# source://rouge//lib/rouge/guessers/util.rb#5
module Rouge::Guessers::Util
  # source://rouge//lib/rouge/guessers/util.rb#23
  def get_source(source); end

  # source://rouge//lib/rouge/guessers/util.rb#17
  def test_glob(pattern, path); end
end

# source://rouge//lib/rouge/guessers/util.rb#6
module Rouge::Guessers::Util::SourceNormalizer
  class << self
    # source://rouge//lib/rouge/guessers/util.rb#12
    def normalize(source); end
  end
end

# source://rouge//lib/rouge/guessers/util.rb#7
Rouge::Guessers::Util::SourceNormalizer::UTF8_BOM = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/guessers/util.rb#8
Rouge::Guessers::Util::SourceNormalizer::UTF8_BOM_RE = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/theme.rb#136
module Rouge::HasModes
  # source://rouge//lib/rouge/theme.rb#144
  def get_mode(mode); end

  # source://rouge//lib/rouge/theme.rb#137
  def mode(arg = T.unsafe(nil)); end

  # source://rouge//lib/rouge/theme.rb#156
  def mode!(arg); end

  # source://rouge//lib/rouge/theme.rb#151
  def set_mode!(mode); end
end

# source://rouge//lib/rouge/util.rb#68
module Rouge::Indentation
  # source://rouge//lib/rouge/util.rb#83
  def indentation(indent_str); end

  # source://rouge//lib/rouge/util.rb#69
  def reset!; end

  # source://rouge//lib/rouge/util.rb#75
  def starts_block(block_state); end
end

# source://rouge//lib/rouge/util.rb#5
class Rouge::InheritableHash < ::Hash
  # source://rouge//lib/rouge/util.rb#6
  def initialize(parent = T.unsafe(nil)); end

  # source://rouge//lib/rouge/util.rb#10
  def [](k); end

  # source://rouge//lib/rouge/util.rb#25
  def each(&b); end

  # source://rouge//lib/rouge/util.rb#21
  def include?(k); end

  # source://rouge//lib/rouge/util.rb#32
  def keys; end

  def own_keys; end

  # source://rouge//lib/rouge/util.rb#17
  def parent; end
end

# source://rouge//lib/rouge/util.rb#39
class Rouge::InheritableList
  include ::Enumerable

  # source://rouge//lib/rouge/util.rb#42
  def initialize(parent = T.unsafe(nil)); end

  # source://rouge//lib/rouge/util.rb#61
  def <<(o); end

  # source://rouge//lib/rouge/util.rb#50
  def each(&b); end

  # source://rouge//lib/rouge/util.rb#57
  def own_entries; end

  # source://rouge//lib/rouge/util.rb#46
  def parent; end

  # source://rouge//lib/rouge/util.rb#61
  def push(o); end
end

# source://rouge//lib/rouge.rb#11
Rouge::LIB_DIR = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/lexer.rb#12
class Rouge::Lexer
  include ::Rouge::Token::Tokens

  # source://rouge//lib/rouge/lexer.rb#323
  def initialize(opts = T.unsafe(nil)); end

  # source://rouge//lib/rouge/lexer.rb#338
  def as_bool(val); end

  # source://rouge//lib/rouge/lexer.rb#366
  def as_lexer(val); end

  # source://rouge//lib/rouge/lexer.rb#355
  def as_list(val); end

  # source://rouge//lib/rouge/lexer.rb#349
  def as_string(val); end

  # source://rouge//lib/rouge/lexer.rb#379
  def as_token(val); end

  # source://rouge//lib/rouge/lexer.rb#389
  def bool_option(name, &default); end

  # source://rouge//lib/rouge/lexer.rb#474
  def continue_lex(string, &b); end

  # source://rouge//lib/rouge/lexer.rb#415
  def hash_option(name, defaults, &val_cast); end

  # source://rouge//lib/rouge/lexer.rb#451
  def lex(string, opts = T.unsafe(nil), &b); end

  # source://rouge//lib/rouge/lexer.rb#403
  def lexer_option(name, &default); end

  # source://rouge//lib/rouge/lexer.rb#407
  def list_option(name, &default); end

  # source://rouge//lib/rouge/lexer.rb#313
  def options; end

  # source://rouge//lib/rouge/lexer.rb#437
  def reset!; end

  # source://rouge//lib/rouge/lexer.rb#508
  def stream_tokens(stream, &b); end

  # source://rouge//lib/rouge/lexer.rb#399
  def string_option(name, &default); end

  # source://rouge//lib/rouge/lexer.rb#497
  def tag; end

  # source://rouge//lib/rouge/lexer.rb#411
  def token_option(name, &default); end

  # source://rouge//lib/rouge/lexer.rb#332
  def with(opts = T.unsafe(nil)); end

  class << self
    # source://rouge//lib/rouge/lexer.rb#261
    def aliases(*args); end

    # source://rouge//lib/rouge/lexer.rb#141
    def all; end

    # source://rouge//lib/rouge/lexer.rb#295
    def assert_utf8!(str); end

    # source://rouge//lib/rouge/lexer.rb#30
    def continue_lex(*a, &b); end

    # source://rouge//lib/rouge/lexer.rb#215
    def debug_enabled?; end

    # source://rouge//lib/rouge/lexer.rb#134
    def demo(arg = T.unsafe(nil)); end

    # source://rouge//lib/rouge/lexer.rb#127
    def demo_file(arg = T.unsafe(nil)); end

    # source://rouge//lib/rouge/lexer.rb#109
    def desc(arg = T.unsafe(nil)); end

    # source://rouge//lib/rouge/lexer.rb#520
    def detect?(text); end

    # source://rouge//lib/rouge/lexer.rb#221
    def detectable?; end

    # source://rouge//lib/rouge/lexer.rb#211
    def disable_debug!; end

    # source://rouge//lib/rouge/lexer.rb#207
    def enable_debug!; end

    # source://rouge//lib/rouge/lexer.rb#280
    def filenames(*fnames); end

    # source://rouge//lib/rouge/lexer.rb#37
    def find(name); end

    # source://rouge//lib/rouge/lexer.rb#94
    def find_fancy(str, code = T.unsafe(nil), default_options = T.unsafe(nil)); end

    # source://rouge//lib/rouge/lexer.rb#182
    def guess(info = T.unsafe(nil), &fallback); end

    # source://rouge//lib/rouge/lexer.rb#199
    def guess_by_filename(fname); end

    # source://rouge//lib/rouge/lexer.rb#195
    def guess_by_mimetype(mt); end

    # source://rouge//lib/rouge/lexer.rb#203
    def guess_by_source(source); end

    # source://rouge//lib/rouge/lexer.rb#150
    def guesses(info = T.unsafe(nil)); end

    # source://rouge//lib/rouge/lexer.rb#22
    def lex(stream, opts = T.unsafe(nil), &b); end

    # source://rouge//lib/rouge/lexer.rb#46
    def lookup_fancy(str, code = T.unsafe(nil), default_options = T.unsafe(nil)); end

    # source://rouge//lib/rouge/lexer.rb#290
    def mimetypes(*mts); end

    # source://rouge//lib/rouge/lexer.rb#121
    def option(name, desc); end

    # source://rouge//lib/rouge/lexer.rb#117
    def option_docs; end

    # source://rouge//lib/rouge/lexer.rb#245
    def tag(t = T.unsafe(nil)); end

    # source://rouge//lib/rouge/lexer.rb#101
    def title(t = T.unsafe(nil)); end

    protected

    # source://rouge//lib/rouge/lexer.rb#228
    def register(name, lexer); end

    private

    # source://rouge//lib/rouge/lexer.rb#306
    def registry; end
  end
end

# source://rouge//lib/rouge/lexer.rb#525
module Rouge::Lexers
  class << self
    # source://rouge//lib/rouge/lexer.rb#529
    def load_lexer(relpath); end
  end
end

# source://rouge//lib/rouge/lexers/abap.rb#8
class Rouge::Lexers::ABAP < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/abap.rb#148
    def builtins; end

    # source://rouge//lib/rouge/lexers/abap.rb#15
    def keywords; end

    # source://rouge//lib/rouge/lexers/abap.rb#178
    def new_keywords; end

    # source://rouge//lib/rouge/lexers/abap.rb#171
    def types; end
  end
end

# source://rouge//lib/rouge/lexers/apiblueprint.rb#7
class Rouge::Lexers::APIBlueprint < ::Rouge::Lexers::Markdown; end

# source://rouge//lib/rouge/lexers/actionscript.rb#6
class Rouge::Lexers::Actionscript < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/actionscript.rb#100
    def builtins; end

    # source://rouge//lib/rouge/lexers/actionscript.rb#96
    def constants; end

    # source://rouge//lib/rouge/lexers/actionscript.rb#84
    def declarations; end

    # source://rouge//lib/rouge/lexers/actionscript.rb#76
    def keywords; end

    # source://rouge//lib/rouge/lexers/actionscript.rb#88
    def reserved; end
  end
end

# source://rouge//lib/rouge/lexers/ada.rb#6
class Rouge::Lexers::Ada < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/ada.rb#23
    def idents; end
  end
end

# source://rouge//lib/rouge/lexers/ada.rb#20
Rouge::Lexers::Ada::EXP = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/ada.rb#15
Rouge::Lexers::Ada::ID = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/ada.rb#18
Rouge::Lexers::Ada::NUM = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/ada.rb#19
Rouge::Lexers::Ada::XNUM = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/apache.rb#7
class Rouge::Lexers::Apache < ::Rouge::RegexLexer
  # source://rouge//lib/rouge/lexers/apache.rb#30
  def name_for_token(token, tktype); end

  class << self
    # source://rouge//lib/rouge/lexers/apache.rb#15
    def directives; end

    # source://rouge//lib/rouge/lexers/apache.rb#20
    def sections; end

    # source://rouge//lib/rouge/lexers/apache.rb#25
    def values; end
  end
end

# source://rouge//lib/rouge/lexers/apex.rb#6
class Rouge::Lexers::Apex < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/apex.rb#44
    def constants; end

    # source://rouge//lib/rouge/lexers/apex.rb#22
    def declarations; end

    # source://rouge//lib/rouge/lexers/apex.rb#14
    def keywords; end

    # source://rouge//lib/rouge/lexers/apex.rb#30
    def soql; end

    # source://rouge//lib/rouge/lexers/apex.rb#38
    def types; end
  end
end

# source://rouge//lib/rouge/lexers/apple_script.rb#6
class Rouge::Lexers::AppleScript < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/apple_script.rb#30
    def builtins; end

    # source://rouge//lib/rouge/lexers/apple_script.rb#23
    def classes; end

    # source://rouge//lib/rouge/lexers/apple_script.rb#42
    def commands; end

    # source://rouge//lib/rouge/lexers/apple_script.rb#87
    def controls; end

    # source://rouge//lib/rouge/lexers/apple_script.rb#95
    def declarations; end

    # source://rouge//lib/rouge/lexers/apple_script.rb#35
    def handler_params; end

    # source://rouge//lib/rouge/lexers/apple_script.rb#17
    def literals; end

    # source://rouge//lib/rouge/lexers/apple_script.rb#68
    def operators; end

    # source://rouge//lib/rouge/lexers/apple_script.rb#60
    def references; end

    # source://rouge//lib/rouge/lexers/apple_script.rb#99
    def reserved; end

    # source://rouge//lib/rouge/lexers/apple_script.rb#103
    def studio_classes; end

    # source://rouge//lib/rouge/lexers/apple_script.rb#169
    def studio_commands; end

    # source://rouge//lib/rouge/lexers/apple_script.rb#122
    def studio_events; end

    # source://rouge//lib/rouge/lexers/apple_script.rb#183
    def studio_properties; end
  end
end

# source://rouge//lib/rouge/lexers/armasm.rb#6
class Rouge::Lexers::ArmAsm < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/armasm.rb#44
    def builtin; end

    # source://rouge//lib/rouge/lexers/armasm.rb#18
    def file_directive; end

    # source://rouge//lib/rouge/lexers/armasm.rb#24
    def general_directive; end

    # source://rouge//lib/rouge/lexers/armasm.rb#52
    def operator; end

    # source://rouge//lib/rouge/lexers/armasm.rb#12
    def preproc_keyword; end

    # source://rouge//lib/rouge/lexers/armasm.rb#37
    def shift_or_condition; end
  end
end

# source://rouge//lib/rouge/lexers/augeas.rb#6
class Rouge::Lexers::Augeas < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/augeas.rb#15
    def reserved; end
  end
end

# source://rouge//lib/rouge/lexers/awk.rb#6
class Rouge::Lexers::Awk < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/awk.rb#42
    def builtins; end

    # source://rouge//lib/rouge/lexers/awk.rb#35
    def constants; end

    # source://rouge//lib/rouge/lexers/awk.rb#27
    def declarations; end

    # source://rouge//lib/rouge/lexers/awk.rb#14
    def detect?(text); end

    # source://rouge//lib/rouge/lexers/awk.rb#20
    def keywords; end

    # source://rouge//lib/rouge/lexers/awk.rb#31
    def reserved; end
  end
end

# source://rouge//lib/rouge/lexer.rb#526
Rouge::Lexers::BASE_DIR = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/lexers/bbcbasic.rb#6
class Rouge::Lexers::BBCBASIC < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/bbcbasic.rb#45
    def constant; end

    # source://rouge//lib/rouge/lexers/bbcbasic.rb#18
    def function; end

    # source://rouge//lib/rouge/lexers/bbcbasic.rb#39
    def operator; end

    # source://rouge//lib/rouge/lexers/bbcbasic.rb#12
    def punctuation; end

    # source://rouge//lib/rouge/lexers/bbcbasic.rb#28
    def statement; end
  end
end

# source://rouge//lib/rouge/lexers/biml.rb#7
class Rouge::Lexers::BIML < ::Rouge::Lexers::XML
  class << self
    # source://rouge//lib/rouge/lexers/biml.rb#13
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/bpf.rb#6
class Rouge::Lexers::BPF < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/bpf.rb#15
Rouge::Lexers::BPF::MISC_KEYWORDS = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/lexers/bpf.rb#11
Rouge::Lexers::BPF::TYPE_KEYWORDS = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/lexers/batchfile.rb#6
class Rouge::Lexers::Batchfile < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/batchfile.rb#73
    def attributes; end

    # source://rouge//lib/rouge/lexers/batchfile.rb#35
    def builtin_commands; end

    # source://rouge//lib/rouge/lexers/batchfile.rb#28
    def devices; end

    # source://rouge//lib/rouge/lexers/batchfile.rb#16
    def keywords; end

    # source://rouge//lib/rouge/lexers/batchfile.rb#22
    def operator_words; end

    # source://rouge//lib/rouge/lexers/batchfile.rb#48
    def other_commands; end
  end
end

# source://rouge//lib/rouge/lexers/bibtex.rb#9
class Rouge::Lexers::BibTeX < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/bicep.rb#3
class Rouge::Lexers::Bicep < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/bicep.rb#17
    def datatypes; end

    # source://rouge//lib/rouge/lexers/bicep.rb#21
    def functions; end

    # source://rouge//lib/rouge/lexers/bicep.rb#10
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/brainfuck.rb#6
class Rouge::Lexers::Brainfuck < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/brightscript.rb#6
class Rouge::Lexers::Brightscript < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/brightscript.rb#63
    def builtins; end

    # source://rouge//lib/rouge/lexers/brightscript.rb#29
    def keyword_reserved; end

    # source://rouge//lib/rouge/lexers/brightscript.rb#40
    def keyword_reserved_unsupported; end

    # source://rouge//lib/rouge/lexers/brightscript.rb#47
    def keyword_type; end

    # source://rouge//lib/rouge/lexers/brightscript.rb#16
    def name_builtin; end

    # source://rouge//lib/rouge/lexers/brightscript.rb#55
    def operator_word; end
  end
end

# source://rouge//lib/rouge/lexers/bsl.rb#6
class Rouge::Lexers::Bsl < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/bsl.rb#30
Rouge::Lexers::Bsl::BUILTINS = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/bsl.rb#12
Rouge::Lexers::Bsl::KEYWORDS = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/c.rb#6
class Rouge::Lexers::C < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/c.rb#59
    def builtins; end

    # source://rouge//lib/rouge/lexers/c.rb#18
    def keywords; end

    # source://rouge//lib/rouge/lexers/c.rb#29
    def keywords_type; end

    # source://rouge//lib/rouge/lexers/c.rb#50
    def reserved; end
  end
end

# source://rouge//lib/rouge/lexers/cmhg.rb#6
class Rouge::Lexers::CMHG < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/cmhg.rb#12
    def preproc_keyword; end
  end
end

# source://rouge//lib/rouge/lexers/cmake.rb#6
class Rouge::Lexers::CMake < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/cmake.rb#14
Rouge::Lexers::CMake::BRACKET_OPEN = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/lexers/cmake.rb#24
Rouge::Lexers::CMake::BUILTIN_COMMANDS = T.let(T.unsafe(nil), Set)

# source://rouge//lib/rouge/lexers/cmake.rb#13
Rouge::Lexers::CMake::SPACE = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/lexers/cmake.rb#16
Rouge::Lexers::CMake::STATES_MAP = T.let(T.unsafe(nil), Hash)

# source://rouge//lib/rouge/lexers/cobol.rb#6
class Rouge::Lexers::COBOL < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/cobol.rb#15
    def divisions; end

    # source://rouge//lib/rouge/lexers/cobol.rb#29
    def keywords; end

    # source://rouge//lib/rouge/lexers/cobol.rb#21
    def sections; end
  end
end

# source://rouge//lib/rouge/lexers/css.rb#6
class Rouge::Lexers::CSS < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/css.rb#124
    def builtins; end

    # source://rouge//lib/rouge/lexers/css.rb#170
    def colors; end

    # source://rouge//lib/rouge/lexers/css.rb#198
    def functions; end

    # source://rouge//lib/rouge/lexers/css.rb#19
    def properties; end

    # source://rouge//lib/rouge/lexers/css.rb#217
    def vendor_prefixes; end
  end
end

# source://rouge//lib/rouge/lexers/csvs.rb#6
class Rouge::Lexers::CSVS < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/csharp.rb#6
class Rouge::Lexers::CSharp < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/csharp.rb#43
    def cpp_keywords; end

    # source://rouge//lib/rouge/lexers/csharp.rb#20
    def keywords; end

    # source://rouge//lib/rouge/lexers/csharp.rb#36
    def keywords_type; end
  end
end

# source://rouge//lib/rouge/lexers/cuda.rb#7
class Rouge::Lexers::CUDA < ::Rouge::Lexers::Cpp
  class << self
    # source://rouge//lib/rouge/lexers/cuda.rb#14
    def keywords; end

    # source://rouge//lib/rouge/lexers/cuda.rb#21
    def keywords_type; end
  end
end

# source://rouge//lib/rouge/lexers/ceylon.rb#6
class Rouge::Lexers::Ceylon < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/cfscript.rb#7
class Rouge::Lexers::Cfscript < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/cfscript.rb#20
    def declarations; end

    # source://rouge//lib/rouge/lexers/cfscript.rb#14
    def keywords; end

    # source://rouge//lib/rouge/lexers/cfscript.rb#26
    def types; end
  end
end

# source://rouge//lib/rouge/lexers/cisco_ios.rb#9
class Rouge::Lexers::CiscoIos < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/clean.rb#6
class Rouge::Lexers::Clean < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/clean.rb#13
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/clojure.rb#6
class Rouge::Lexers::Clojure < ::Rouge::RegexLexer
  # source://rouge//lib/rouge/lexers/clojure.rb#70
  def name_token(name); end

  class << self
    # source://rouge//lib/rouge/lexers/clojure.rb#24
    def builtins; end

    # source://rouge//lib/rouge/lexers/clojure.rb#17
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/codeowners.rb#6
class Rouge::Lexers::Codeowners < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/coffeescript.rb#6
class Rouge::Lexers::Coffeescript < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/coffeescript.rb#41
    def builtins; end

    # source://rouge//lib/rouge/lexers/coffeescript.rb#35
    def constants; end

    # source://rouge//lib/rouge/lexers/coffeescript.rb#15
    def detect?(text); end

    # source://rouge//lib/rouge/lexers/coffeescript.rb#19
    def keywords; end

    # source://rouge//lib/rouge/lexers/coffeescript.rb#28
    def reserved; end
  end
end

# source://rouge//lib/rouge/lexers/common_lisp.rb#6
class Rouge::Lexers::CommonLisp < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/common_lisp.rb#201
Rouge::Lexers::CommonLisp::BUILTIN_CLASSES = T.let(T.unsafe(nil), Set)

# source://rouge//lib/rouge/lexers/common_lisp.rb#16
Rouge::Lexers::CommonLisp::BUILTIN_FUNCTIONS = T.let(T.unsafe(nil), Set)

# source://rouge//lib/rouge/lexers/common_lisp.rb#183
Rouge::Lexers::CommonLisp::BUILTIN_TYPES = T.let(T.unsafe(nil), Set)

# source://rouge//lib/rouge/lexers/common_lisp.rb#178
Rouge::Lexers::CommonLisp::DECLARATIONS = T.let(T.unsafe(nil), Set)

# source://rouge//lib/rouge/lexers/common_lisp.rb#173
Rouge::Lexers::CommonLisp::LAMBDA_LIST_KEYWORDS = T.let(T.unsafe(nil), Set)

# source://rouge//lib/rouge/lexers/common_lisp.rb#152
Rouge::Lexers::CommonLisp::MACROS = T.let(T.unsafe(nil), Set)

# source://rouge//lib/rouge/lexers/common_lisp.rb#145
Rouge::Lexers::CommonLisp::SPECIAL_FORMS = T.let(T.unsafe(nil), Set)

# source://rouge//lib/rouge/lexers/conf.rb#6
class Rouge::Lexers::Conf < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/console.rb#40
class Rouge::Lexers::ConsoleLexer < ::Rouge::Lexer
  # source://rouge//lib/rouge/lexers/console.rb#52
  def initialize(*_arg0); end

  # source://rouge//lib/rouge/lexers/console.rb#63
  def allow_comments?; end

  # source://rouge//lib/rouge/lexers/console.rb#72
  def comment_regex; end

  # source://rouge//lib/rouge/lexers/console.rb#76
  def end_chars; end

  # source://rouge//lib/rouge/lexers/console.rb#86
  def error_regex; end

  # source://rouge//lib/rouge/lexers/console.rb#92
  def lang_lexer; end

  # source://rouge//lib/rouge/lexers/console.rb#105
  def line_regex; end

  # source://rouge//lib/rouge/lexers/console.rb#109
  def output_lexer; end

  # source://rouge//lib/rouge/lexers/console.rb#122
  def process_line(input, &output); end

  # source://rouge//lib/rouge/lexers/console.rb#167
  def prompt_prefix_regex; end

  # source://rouge//lib/rouge/lexers/console.rb#175
  def prompt_regex; end

  # source://rouge//lib/rouge/lexers/console.rb#181
  def stream_tokens(input, &output); end
end

# source://rouge//lib/rouge/lexers/coq.rb#6
class Rouge::Lexers::Coq < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/coq.rb#59
    def classify(x); end

    # source://rouge//lib/rouge/lexers/coq.rb#19
    def coq; end

    # source://rouge//lib/rouge/lexers/coq.rb#12
    def gallina; end

    # source://rouge//lib/rouge/lexers/coq.rb#32
    def ltac; end

    # source://rouge//lib/rouge/lexers/coq.rb#46
    def tacticals; end

    # source://rouge//lib/rouge/lexers/coq.rb#52
    def terminators; end
  end
end

# source://rouge//lib/rouge/lexers/cpp.rb#8
class Rouge::Lexers::Cpp < ::Rouge::Lexers::C
  class << self
    # source://rouge//lib/rouge/lexers/cpp.rb#23
    def keywords; end

    # source://rouge//lib/rouge/lexers/cpp.rb#37
    def keywords_type; end

    # source://rouge//lib/rouge/lexers/cpp.rb#43
    def reserved; end
  end
end

# source://rouge//lib/rouge/lexers/crystal.rb#6
class Rouge::Lexers::Crystal < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/crystal.rb#15
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/cypher.rb#6
class Rouge::Lexers::Cypher < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/cypher.rb#15
    def functions; end

    # source://rouge//lib/rouge/lexers/cypher.rb#34
    def keywords; end

    # source://rouge//lib/rouge/lexers/cypher.rb#28
    def predicates; end
  end
end

# source://rouge//lib/rouge/lexers/cython.rb#8
class Rouge::Lexers::Cython < ::Rouge::Lexers::Python
  # source://rouge//lib/rouge/lexers/cython.rb#16
  def initialize(opts = T.unsafe(nil)); end

  class << self
    # source://rouge//lib/rouge/lexers/cython.rb#27
    def c_keywords; end

    # source://rouge//lib/rouge/lexers/cython.rb#21
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/d.rb#6
class Rouge::Lexers::D < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/dafny.rb#6
class Rouge::Lexers::Dafny < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/dart.rb#6
class Rouge::Lexers::Dart < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/datastudio.rb#6
class Rouge::Lexers::Datastudio < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/datastudio.rb#16
    def sql_keywords; end
  end
end

# source://rouge//lib/rouge/lexers/diff.rb#5
class Rouge::Lexers::Diff < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/diff.rb#14
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/digdag.rb#8
class Rouge::Lexers::Digdag < ::Rouge::Lexers::YAML; end

# source://rouge//lib/rouge/lexers/digdag.rb#18
Rouge::Lexers::Digdag::KEYWORD_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/docker.rb#6
class Rouge::Lexers::Docker < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/docker.rb#14
Rouge::Lexers::Docker::KEYWORDS = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/lexers/dot.rb#6
class Rouge::Lexers::Dot < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/ecl.rb#6
class Rouge::Lexers::ECL < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/ecl.rb#16
    def class_first; end

    # source://rouge//lib/rouge/lexers/ecl.rb#22
    def class_second; end

    # source://rouge//lib/rouge/lexers/ecl.rb#28
    def functions; end

    # source://rouge//lib/rouge/lexers/ecl.rb#51
    def keywords; end

    # source://rouge//lib/rouge/lexers/ecl.rb#71
    def template; end

    # source://rouge//lib/rouge/lexers/ecl.rb#81
    def type; end

    # source://rouge//lib/rouge/lexers/ecl.rb#89
    def typed; end
  end
end

# source://rouge//lib/rouge/lexers/eex.rb#5
class Rouge::Lexers::EEX < ::Rouge::TemplateLexer
  # source://rouge//lib/rouge/lexers/eex.rb#14
  def initialize(opts = T.unsafe(nil)); end
end

# source://rouge//lib/rouge/lexers/epp.rb#5
class Rouge::Lexers::EPP < ::Rouge::TemplateLexer
  # source://rouge//lib/rouge/lexers/epp.rb#13
  def initialize(opts = T.unsafe(nil)); end
end

# source://rouge//lib/rouge/lexers/erb.rb#6
class Rouge::Lexers::ERB < ::Rouge::TemplateLexer
  # source://rouge//lib/rouge/lexers/erb.rb#15
  def initialize(opts = T.unsafe(nil)); end
end

# source://rouge//lib/rouge/lexers/eiffel.rb#6
class Rouge::Lexers::Eiffel < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/eiffel.rb#23
Rouge::Lexers::Eiffel::BooleanConstants = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/eiffel.rb#14
Rouge::Lexers::Eiffel::LanguageKeywords = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/eiffel.rb#25
Rouge::Lexers::Eiffel::LanguageVariables = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/eiffel.rb#27
Rouge::Lexers::Eiffel::SimpleString = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/elixir.rb#8
class Rouge::Lexers::Elixir < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/elixir.rb#17
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/elm.rb#6
class Rouge::Lexers::Elm < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/email.rb#6
class Rouge::Lexers::Email < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/erlang.rb#6
class Rouge::Lexers::Erlang < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/escape.rb#6
class Rouge::Lexers::Escape < ::Rouge::Lexer
  # source://rouge//lib/rouge/lexers/escape.rb#20
  def initialize(*_arg0); end

  # source://rouge//lib/rouge/lexers/escape.rb#17
  def end; end

  # source://rouge//lib/rouge/lexers/escape.rb#18
  def lang; end

  # source://rouge//lib/rouge/lexers/escape.rb#16
  def start; end

  # source://rouge//lib/rouge/lexers/escape.rb#35
  def stream_tokens(str, &b); end

  # source://rouge//lib/rouge/lexers/escape.rb#31
  def to_end_regex; end

  # source://rouge//lib/rouge/lexers/escape.rb#27
  def to_start_regex; end
end

# source://rouge//lib/rouge/lexers/fsharp.rb#6
class Rouge::Lexers::FSharp < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/fsharp.rb#29
    def keyopts; end

    # source://rouge//lib/rouge/lexers/fsharp.rb#13
    def keywords; end

    # source://rouge//lib/rouge/lexers/fsharp.rb#40
    def primitives; end

    # source://rouge//lib/rouge/lexers/fsharp.rb#36
    def word_operators; end
  end
end

# source://rouge//lib/rouge/lexers/factor.rb#6
class Rouge::Lexers::Factor < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/factor.rb#17
    def builtins; end

    # source://rouge//lib/rouge/lexers/factor.rb#13
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/fluent.rb#6
class Rouge::Lexers::Fluent < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/fortran.rb#10
class Rouge::Lexers::Fortran < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/fortran.rb#53
    def intrinsics; end

    # source://rouge//lib/rouge/lexers/fortran.rb#23
    def keywords; end

    # source://rouge//lib/rouge/lexers/fortran.rb#45
    def types; end
  end
end

# source://rouge//lib/rouge/lexers/freefem.rb#8
class Rouge::Lexers::FreeFEM < ::Rouge::Lexers::Cpp
  class << self
    # source://rouge//lib/rouge/lexers/freefem.rb#170
    def attributes; end

    # source://rouge//lib/rouge/lexers/freefem.rb#56
    def builtins; end

    # source://rouge//lib/rouge/lexers/freefem.rb#18
    def keywords; end

    # source://rouge//lib/rouge/lexers/freefem.rb#25
    def keywords_type; end

    # source://rouge//lib/rouge/lexers/freefem.rb#34
    def reserved; end
  end
end

# source://rouge//lib/rouge/lexers/gdscript.rb#6
class Rouge::Lexers::GDScript < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/gdscript.rb#30
    def builtins; end

    # source://rouge//lib/rouge/lexers/gdscript.rb#43
    def builtins_type; end

    # source://rouge//lib/rouge/lexers/gdscript.rb#14
    def keywords; end

    # source://rouge//lib/rouge/lexers/gdscript.rb#24
    def keywords_reserved; end
  end
end

# source://rouge//lib/rouge/lexers/ghc_cmm.rb#15
class Rouge::Lexers::GHCCmm < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/ghc_core.rb#8
class Rouge::Lexers::GHCCore < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/gherkin.rb#6
class Rouge::Lexers::Gherkin < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/gherkin.rb#16
    def detect?(text); end

    # source://rouge//lib/rouge/lexers/gherkin.rb#21
    def keywords; end

    # source://rouge//lib/rouge/lexers/gherkin.rb#26
    def step_regex; end
  end
end

# source://rouge//lib/rouge/lexers/glsl.rb#12
class Rouge::Lexers::Glsl < ::Rouge::Lexers::C
  class << self
    # source://rouge//lib/rouge/lexers/glsl.rb#87
    def builtins; end

    # source://rouge//lib/rouge/lexers/glsl.rb#20
    def keywords; end

    # source://rouge//lib/rouge/lexers/glsl.rb#35
    def keywords_type; end

    # source://rouge//lib/rouge/lexers/glsl.rb#61
    def reserved; end
  end
end

# source://rouge//lib/rouge/lexers/go.rb#6
class Rouge::Lexers::Go < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/go.rb#96
Rouge::Lexers::Go::BIG_U_VALUE = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#102
Rouge::Lexers::Go::BYTE_VALUE = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#103
Rouge::Lexers::Go::CHAR_LIT = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#35
Rouge::Lexers::Go::COMMENT = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#81
Rouge::Lexers::Go::DECIMALS = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#27
Rouge::Lexers::Go::DECIMAL_DIGIT = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#74
Rouge::Lexers::Go::DECIMAL_LIT = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#94
Rouge::Lexers::Go::ESCAPED_CHAR = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#104
Rouge::Lexers::Go::ESCAPE_SEQUENCE = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#82
Rouge::Lexers::Go::EXPONENT = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#83
Rouge::Lexers::Go::FLOAT_LIT = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#34
Rouge::Lexers::Go::GENERAL_COMMENT = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#101
Rouge::Lexers::Go::HEX_BYTE_VALUE = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#29
Rouge::Lexers::Go::HEX_DIGIT = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#76
Rouge::Lexers::Go::HEX_LIT = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#53
Rouge::Lexers::Go::IDENTIFIER = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#90
Rouge::Lexers::Go::IMAGINARY_LIT = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#113
Rouge::Lexers::Go::INTERPRETED_STRING_LIT = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#77
Rouge::Lexers::Go::INT_LIT = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#39
Rouge::Lexers::Go::KEYWORD = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#26
Rouge::Lexers::Go::LETTER = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#33
Rouge::Lexers::Go::LINE_COMMENT = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#95
Rouge::Lexers::Go::LITTLE_U_VALUE = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#19
Rouge::Lexers::Go::NEWLINE = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#100
Rouge::Lexers::Go::OCTAL_BYTE_VALUE = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#28
Rouge::Lexers::Go::OCTAL_DIGIT = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#75
Rouge::Lexers::Go::OCTAL_LIT = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#58
Rouge::Lexers::Go::OPERATOR = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#130
Rouge::Lexers::Go::PREDECLARED_CONSTANTS = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#132
Rouge::Lexers::Go::PREDECLARED_FUNCTIONS = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#120
Rouge::Lexers::Go::PREDECLARED_TYPES = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#112
Rouge::Lexers::Go::RAW_STRING_LIT = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#68
Rouge::Lexers::Go::SEPARATOR = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#116
Rouge::Lexers::Go::STRING_LIT = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#20
Rouge::Lexers::Go::UNICODE_CHAR = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#22
Rouge::Lexers::Go::UNICODE_DIGIT = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#21
Rouge::Lexers::Go::UNICODE_LETTER = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#97
Rouge::Lexers::Go::UNICODE_VALUE = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#17
Rouge::Lexers::Go::WHITE_SPACE = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/gradle.rb#8
class Rouge::Lexers::Gradle < ::Rouge::Lexers::Groovy
  class << self
    # source://rouge//lib/rouge/lexers/gradle.rb#16
    def keywords; end

    # source://rouge//lib/rouge/lexers/gradle.rb#23
    def types; end
  end
end

# source://rouge//lib/rouge/lexers/graphql.rb#6
class Rouge::Lexers::GraphQL < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/groovy.rb#6
class Rouge::Lexers::Groovy < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/groovy.rb#40
    def constants; end

    # source://rouge//lib/rouge/lexers/groovy.rb#26
    def declarations; end

    # source://rouge//lib/rouge/lexers/groovy.rb#14
    def detect?(text); end

    # source://rouge//lib/rouge/lexers/groovy.rb#19
    def keywords; end

    # source://rouge//lib/rouge/lexers/groovy.rb#34
    def types; end
  end
end

# source://rouge//lib/rouge/lexers/hlsl.rb#8
class Rouge::Lexers::HLSL < ::Rouge::Lexers::C
  class << self
    # source://rouge//lib/rouge/lexers/hlsl.rb#74
    def builtins; end

    # source://rouge//lib/rouge/lexers/hlsl.rb#15
    def keywords; end

    # source://rouge//lib/rouge/lexers/hlsl.rb#28
    def keywords_type; end

    # source://rouge//lib/rouge/lexers/hlsl.rb#65
    def reserved; end
  end
end

# source://rouge//lib/rouge/lexers/hocon.rb#8
class Rouge::Lexers::HOCON < ::Rouge::Lexers::JSON; end

# source://rouge//lib/rouge/lexers/hql.rb#7
class Rouge::Lexers::HQL < ::Rouge::Lexers::SQL
  class << self
    # source://rouge//lib/rouge/lexers/hql.rb#13
    def keywords; end

    # source://rouge//lib/rouge/lexers/hql.rb#101
    def keywords_type; end
  end
end

# source://rouge//lib/rouge/lexers/html.rb#6
class Rouge::Lexers::HTML < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/html.rb#13
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/http.rb#6
class Rouge::Lexers::HTTP < ::Rouge::RegexLexer
  # source://rouge//lib/rouge/lexers/http.rb#17
  def content_lexer; end

  # source://rouge//lib/rouge/lexers/http.rb#21
  def guess_content_lexer; end

  class << self
    # source://rouge//lib/rouge/lexers/http.rb#13
    def http_methods; end
  end
end

# source://rouge//lib/rouge/lexers/hack.rb#8
class Rouge::Lexers::Hack < ::Rouge::Lexers::PHP
  class << self
    # source://rouge//lib/rouge/lexers/hack.rb#15
    def detect?(text); end

    # source://rouge//lib/rouge/lexers/hack.rb#24
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/haml.rb#8
class Rouge::Lexers::Haml < ::Rouge::RegexLexer
  include ::Rouge::Indentation

  # source://rouge//lib/rouge/lexers/haml.rb#26
  def initialize(opts = T.unsafe(nil)); end

  # source://rouge//lib/rouge/lexers/haml.rb#21
  def filters; end

  # source://rouge//lib/rouge/lexers/haml.rb#50
  def html; end

  # source://rouge//lib/rouge/lexers/haml.rb#46
  def ruby; end

  # source://rouge//lib/rouge/lexers/haml.rb#54
  def ruby!(state); end
end

# source://rouge//lib/rouge/lexers/handlebars.rb#6
class Rouge::Lexers::Handlebars < ::Rouge::TemplateLexer; end

# source://rouge//lib/rouge/lexers/haskell.rb#6
class Rouge::Lexers::Haskell < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/haskell.rb#15
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/haxe.rb#5
class Rouge::Lexers::Haxe < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/haxe.rb#49
    def builtins; end

    # source://rouge//lib/rouge/lexers/haxe.rb#45
    def constants; end

    # source://rouge//lib/rouge/lexers/haxe.rb#32
    def declarations; end

    # source://rouge//lib/rouge/lexers/haxe.rb#14
    def detect?(text); end

    # source://rouge//lib/rouge/lexers/haxe.rb#26
    def imports; end

    # source://rouge//lib/rouge/lexers/haxe.rb#18
    def keywords; end

    # source://rouge//lib/rouge/lexers/haxe.rb#39
    def reserved; end
  end
end

# source://rouge//lib/rouge/lexers/hcl.rb#6
class Rouge::Lexers::Hcl < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/hcl.rb#56
    def builtins; end

    # source://rouge//lib/rouge/lexers/hcl.rb#52
    def constants; end

    # source://rouge//lib/rouge/lexers/hcl.rb#44
    def declarations; end

    # source://rouge//lib/rouge/lexers/hcl.rb#40
    def keywords; end

    # source://rouge//lib/rouge/lexers/hcl.rb#48
    def reserved; end
  end
end

# source://rouge//lib/rouge/lexers/hylang.rb#6
class Rouge::Lexers::HyLang < ::Rouge::RegexLexer
  # source://rouge//lib/rouge/lexers/hylang.rb#50
  def name_token(name); end

  class << self
    # source://rouge//lib/rouge/lexers/hylang.rb#25
    def builtins; end

    # source://rouge//lib/rouge/lexers/hylang.rb#17
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/idlang.rb#8
class Rouge::Lexers::IDLang < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/idlang.rb#52
    def conditionals; end

    # source://rouge//lib/rouge/lexers/idlang.rb#39
    def decorators; end

    # source://rouge//lib/rouge/lexers/idlang.rb#19
    def exec_unit; end

    # source://rouge//lib/rouge/lexers/idlang.rb#25
    def keywords; end

    # source://rouge//lib/rouge/lexers/idlang.rb#46
    def operators; end

    # source://rouge//lib/rouge/lexers/idlang.rb#60
    def routines; end

    # source://rouge//lib/rouge/lexers/idlang.rb#32
    def standalone_statements; end
  end
end

# source://rouge//lib/rouge/lexers/ini.rb#6
class Rouge::Lexers::INI < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/io.rb#6
class Rouge::Lexers::IO < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/io.rb#21
    def builtins; end

    # source://rouge//lib/rouge/lexers/io.rb#17
    def constants; end

    # source://rouge//lib/rouge/lexers/io.rb#13
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/irb.rb#8
class Rouge::Lexers::IRBLexer < ::Rouge::Lexers::ConsoleLexer
  # source://rouge//lib/rouge/lexers/irb.rb#35
  def allow_comments?; end

  # source://rouge//lib/rouge/lexers/irb.rb#21
  def lang_lexer; end

  # source://rouge//lib/rouge/lexers/irb.rb#17
  def output_lexer; end

  # source://rouge//lib/rouge/lexers/irb.rb#25
  def prompt_regex; end
end

# source://rouge//lib/rouge/lexers/irb.rb#41
class Rouge::Lexers::IRBOutputLexer < ::Rouge::Lexers::Ruby; end

# source://rouge//lib/rouge/lexers/isbl.rb#6
class Rouge::Lexers::ISBL < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/isbl.rb#12
    def builtins; end

    # source://rouge//lib/rouge/lexers/isbl.rb#17
    def constants; end

    # source://rouge//lib/rouge/lexers/isbl.rb#25
    def globals; end

    # source://rouge//lib/rouge/lexers/isbl.rb#21
    def interfaces; end

    # source://rouge//lib/rouge/lexers/isbl.rb#29
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/idris.rb#6
class Rouge::Lexers::Idris < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/idris.rb#23
    def ascii; end

    # source://rouge//lib/rouge/lexers/idris.rb#30
    def prelude_functions; end

    # source://rouge//lib/rouge/lexers/idris.rb#15
    def reserved_keywords; end
  end
end

# source://rouge//lib/rouge/lexers/iecst.rb#6
class Rouge::Lexers::IecST < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/iecst.rb#14
    def keywords; end

    # source://rouge//lib/rouge/lexers/iecst.rb#39
    def literals; end

    # source://rouge//lib/rouge/lexers/iecst.rb#43
    def operators; end

    # source://rouge//lib/rouge/lexers/iecst.rb#29
    def types; end
  end
end

# source://rouge//lib/rouge/lexers/igorpro.rb#6
class Rouge::Lexers::IgorPro < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/igorpro.rb#44
    def igorConstants; end

    # source://rouge//lib/rouge/lexers/igorpro.rb#36
    def igorDeclarations; end

    # source://rouge//lib/rouge/lexers/igorpro.rb#50
    def igorFunction; end

    # source://rouge//lib/rouge/lexers/igorpro.rb#322
    def igorOperation; end

    # source://rouge//lib/rouge/lexers/igorpro.rb#14
    def keywords; end

    # source://rouge//lib/rouge/lexers/igorpro.rb#509
    def object_name; end

    # source://rouge//lib/rouge/lexers/igorpro.rb#28
    def preprocessor; end
  end
end

# source://rouge//lib/rouge/lexers/isabelle.rb#7
class Rouge::Lexers::Isabelle < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/isabelle.rb#127
    def keyword_abandon_proof; end

    # source://rouge//lib/rouge/lexers/isabelle.rb#29
    def keyword_diag; end

    # source://rouge//lib/rouge/lexers/isabelle.rb#15
    def keyword_minor; end

    # source://rouge//lib/rouge/lexers/isabelle.rb#150
    def keyword_proof_asm; end

    # source://rouge//lib/rouge/lexers/isabelle.rb#154
    def keyword_proof_asm_goal; end

    # source://rouge//lib/rouge/lexers/isabelle.rb#135
    def keyword_proof_block; end

    # source://rouge//lib/rouge/lexers/isabelle.rb#139
    def keyword_proof_chain; end

    # source://rouge//lib/rouge/lexers/isabelle.rb#143
    def keyword_proof_decl; end

    # source://rouge//lib/rouge/lexers/isabelle.rb#131
    def keyword_proof_goal; end

    # source://rouge//lib/rouge/lexers/isabelle.rb#158
    def keyword_proof_script; end

    # source://rouge//lib/rouge/lexers/isabelle.rb#123
    def keyword_qed; end

    # source://rouge//lib/rouge/lexers/isabelle.rb#57
    def keyword_section; end

    # source://rouge//lib/rouge/lexers/isabelle.rb#61
    def keyword_subsection; end

    # source://rouge//lib/rouge/lexers/isabelle.rb#65
    def keyword_theory_decl; end

    # source://rouge//lib/rouge/lexers/isabelle.rb#109
    def keyword_theory_goal; end

    # source://rouge//lib/rouge/lexers/isabelle.rb#105
    def keyword_theory_script; end

    # source://rouge//lib/rouge/lexers/isabelle.rb#53
    def keyword_thy; end
  end
end

# source://rouge//lib/rouge/lexers/j.rb#6
class Rouge::Lexers::J < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/j.rb#77
    def control_words; end

    # source://rouge//lib/rouge/lexers/j.rb#84
    def control_words_id; end

    # source://rouge//lib/rouge/lexers/j.rb#30
    def inflection_list; end

    # source://rouge//lib/rouge/lexers/j.rb#72
    def primitive(char, inflection); end

    # source://rouge//lib/rouge/lexers/j.rb#34
    def primitive_table; end

    # source://rouge//lib/rouge/lexers/j.rb#17
    def token_map; end
  end
end

# source://rouge//lib/rouge/lexers/jsl.rb#6
class Rouge::Lexers::JSL < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/json.rb#6
class Rouge::Lexers::JSON < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/json5.rb#8
class Rouge::Lexers::JSON5 < ::Rouge::Lexers::JSON; end

# source://rouge//lib/rouge/lexers/json_doc.rb#8
class Rouge::Lexers::JSONDOC < ::Rouge::Lexers::JSON; end

# source://rouge//lib/rouge/lexers/jsp.rb#6
class Rouge::Lexers::JSP < ::Rouge::TemplateLexer
  # source://rouge//lib/rouge/lexers/jsp.rb#12
  def initialize(*_arg0); end
end

# source://rouge//lib/rouge/lexers/jsx.rb#7
class Rouge::Lexers::JSX < ::Rouge::Lexers::Javascript; end

# source://rouge//lib/rouge/lexers/janet.rb#6
class Rouge::Lexers::Janet < ::Rouge::RegexLexer
  # source://rouge//lib/rouge/lexers/janet.rb#107
  def name_token(name); end

  class << self
    # source://rouge//lib/rouge/lexers/janet.rb#23
    def bundled; end

    # source://rouge//lib/rouge/lexers/janet.rb#17
    def specials; end
  end
end

# source://rouge//lib/rouge/lexers/java.rb#6
class Rouge::Lexers::Java < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/javascript.rb#12
class Rouge::Lexers::Javascript < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/javascript.rb#127
    def builtins; end

    # source://rouge//lib/rouge/lexers/javascript.rb#123
    def constants; end

    # source://rouge//lib/rouge/lexers/javascript.rb#109
    def declarations; end

    # source://rouge//lib/rouge/lexers/javascript.rb#24
    def detect?(text); end

    # source://rouge//lib/rouge/lexers/javascript.rb#142
    def id_regex; end

    # source://rouge//lib/rouge/lexers/javascript.rb#101
    def keywords; end

    # source://rouge//lib/rouge/lexers/javascript.rb#116
    def reserved; end
  end
end

# source://rouge//lib/rouge/lexers/jinja.rb#6
class Rouge::Lexers::Jinja < ::Rouge::TemplateLexer
  class << self
    # source://rouge//lib/rouge/lexers/jinja.rb#16
    def keywords; end

    # source://rouge//lib/rouge/lexers/jinja.rb#30
    def pseudo_keywords; end

    # source://rouge//lib/rouge/lexers/jinja.rb#24
    def tests; end

    # source://rouge//lib/rouge/lexers/jinja.rb#34
    def word_operators; end
  end
end

# source://rouge//lib/rouge/lexers/jsonnet.rb#6
class Rouge::Lexers::Jsonnet < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/jsonnet.rb#32
    def builtins; end

    # source://rouge//lib/rouge/lexers/jsonnet.rb#26
    def constants; end

    # source://rouge//lib/rouge/lexers/jsonnet.rb#20
    def declarations; end

    # source://rouge//lib/rouge/lexers/jsonnet.rb#13
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/julia.rb#6
class Rouge::Lexers::Julia < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/julia.rb#16
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/julia.rb#20
Rouge::Lexers::Julia::BUILTINS = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/julia.rb#30
Rouge::Lexers::Julia::KEYWORDS = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/julia.rb#255
Rouge::Lexers::Julia::NAME_RE = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/julia.rb#170
Rouge::Lexers::Julia::OPERATORS = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/julia.rb#184
Rouge::Lexers::Julia::PUNCTUATION = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/julia.rb#65
Rouge::Lexers::Julia::TYPES = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/kotlin.rb#6
class Rouge::Lexers::Kotlin < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/llvm.rb#6
class Rouge::Lexers::LLVM < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/llvm.rb#22
    def instructions; end

    # source://rouge//lib/rouge/lexers/llvm.rb#17
    def keywords; end

    # source://rouge//lib/rouge/lexers/llvm.rb#27
    def types; end
  end
end

# source://rouge//lib/rouge/lexers/lasso.rb#8
class Rouge::Lexers::Lasso < ::Rouge::TemplateLexer
  # source://rouge//lib/rouge/lexers/lasso.rb#23
  def initialize(*_arg0); end

  # source://rouge//lib/rouge/lexers/lasso.rb#29
  def start_inline?; end

  class << self
    # source://rouge//lib/rouge/lexers/lasso.rb#18
    def detect?(text); end

    # source://rouge//lib/rouge/lexers/lasso.rb#38
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/lean.rb#7
class Rouge::Lexers::Lean < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/lean.rb#14
    def keywords; end

    # source://rouge//lib/rouge/lexers/lean.rb#103
    def operators; end

    # source://rouge//lib/rouge/lexers/lean.rb#95
    def types; end
  end
end

# source://rouge//lib/rouge/lexers/liquid.rb#6
class Rouge::Lexers::Liquid < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/literate_coffeescript.rb#6
class Rouge::Lexers::LiterateCoffeescript < ::Rouge::RegexLexer
  # source://rouge//lib/rouge/lexers/literate_coffeescript.rb#17
  def coffee; end

  # source://rouge//lib/rouge/lexers/literate_coffeescript.rb#13
  def markdown; end
end

# source://rouge//lib/rouge/lexers/literate_haskell.rb#6
class Rouge::Lexers::LiterateHaskell < ::Rouge::RegexLexer
  # source://rouge//lib/rouge/lexers/literate_haskell.rb#14
  def haskell; end
end

# source://rouge//lib/rouge/lexers/livescript.rb#6
class Rouge::Lexers::Livescript < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/livescript.rb#36
    def builtins; end

    # source://rouge//lib/rouge/lexers/livescript.rb#32
    def constants; end

    # source://rouge//lib/rouge/lexers/livescript.rb#19
    def declarations; end

    # source://rouge//lib/rouge/lexers/livescript.rb#15
    def detect?(text); end

    # source://rouge//lib/rouge/lexers/livescript.rb#23
    def keywords; end

    # source://rouge//lib/rouge/lexers/livescript.rb#40
    def loop_control_keywords; end
  end
end

# source://rouge//lib/rouge/lexers/lua.rb#6
class Rouge::Lexers::Lua < ::Rouge::RegexLexer
  # source://rouge//lib/rouge/lexers/lua.rb#17
  def initialize(opts = T.unsafe(nil)); end

  # source://rouge//lib/rouge/lexers/lua.rb#32
  def builtins; end

  class << self
    # source://rouge//lib/rouge/lexers/lua.rb#27
    def builtins; end

    # source://rouge//lib/rouge/lexers/lua.rb#23
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/lustre.rb#6
class Rouge::Lexers::Lustre < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/lustre.rb#13
    def keywords; end

    # source://rouge//lib/rouge/lexers/lustre.rb#27
    def primitives; end

    # source://rouge//lib/rouge/lexers/lustre.rb#21
    def word_operators; end
  end
end

# source://rouge//lib/rouge/lexers/lutin.rb#9
class Rouge::Lexers::Lutin < ::Rouge::Lexers::Lustre
  class << self
    # source://rouge//lib/rouge/lexers/lutin.rb#16
    def keywords; end

    # source://rouge//lib/rouge/lexers/lutin.rb#28
    def primitives; end

    # source://rouge//lib/rouge/lexers/lutin.rb#23
    def word_operators; end
  end
end

# source://rouge//lib/rouge/lexers/m68k.rb#6
class Rouge::Lexers::M68k < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/m68k.rb#69
    def builtins; end

    # source://rouge//lib/rouge/lexers/m68k.rb#14
    def keywords; end

    # source://rouge//lib/rouge/lexers/m68k.rb#47
    def keywords_type; end

    # source://rouge//lib/rouge/lexers/m68k.rb#53
    def reserved; end
  end
end

# source://rouge//lib/rouge/lexers/mxml.rb#6
class Rouge::Lexers::MXML < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/magik.rb#6
class Rouge::Lexers::Magik < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/magik.rb#63
    def character; end

    # source://rouge//lib/rouge/lexers/magik.rb#56
    def decimal; end

    # source://rouge//lib/rouge/lexers/magik.rb#47
    def digits; end

    # source://rouge//lib/rouge/lexers/magik.rb#53
    def exponent; end

    # source://rouge//lib/rouge/lexers/magik.rb#82
    def global_ref; end

    # source://rouge//lib/rouge/lexers/magik.rb#73
    def identifier; end

    # source://rouge//lib/rouge/lexers/magik.rb#13
    def keywords; end

    # source://rouge//lib/rouge/lexers/magik.rb#85
    def label; end

    # source://rouge//lib/rouge/lexers/magik.rb#59
    def number; end

    # source://rouge//lib/rouge/lexers/magik.rb#76
    def package_identifier; end

    # source://rouge//lib/rouge/lexers/magik.rb#70
    def piped_identifier; end

    # source://rouge//lib/rouge/lexers/magik.rb#50
    def radix; end

    # source://rouge//lib/rouge/lexers/magik.rb#67
    def simple_identifier; end

    # source://rouge//lib/rouge/lexers/magik.rb#40
    def string_double; end

    # source://rouge//lib/rouge/lexers/magik.rb#43
    def string_single; end

    # source://rouge//lib/rouge/lexers/magik.rb#79
    def symbol; end
  end
end

# source://rouge//lib/rouge/lexers/make.rb#6
class Rouge::Lexers::Make < ::Rouge::RegexLexer
  # source://rouge//lib/rouge/lexers/make.rb#23
  def initialize(opts = T.unsafe(nil)); end

  class << self
    # source://rouge//lib/rouge/lexers/make.rb#14
    def functions; end
  end
end

# source://rouge//lib/rouge/lexers/markdown.rb#6
class Rouge::Lexers::Markdown < ::Rouge::RegexLexer
  # source://rouge//lib/rouge/lexers/markdown.rb#15
  def html; end
end

# source://rouge//lib/rouge/lexers/mason.rb#6
class Rouge::Lexers::Mason < ::Rouge::TemplateLexer
  # source://rouge//lib/rouge/lexers/mason.rb#13
  def initialize(*_arg0); end
end

# source://rouge//lib/rouge/lexers/mason.rb#21
Rouge::Lexers::Mason::COMPONENTS = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/mason.rb#20
Rouge::Lexers::Mason::PERL_BLOCKS = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/mason.rb#19
Rouge::Lexers::Mason::TEXT_BLOCKS = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/mathematica.rb#6
class Rouge::Lexers::Mathematica < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/mathematica.rb#58
    def builtins; end

    # source://rouge//lib/rouge/lexers/mathematica.rb#51
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/matlab.rb#6
class Rouge::Lexers::Matlab < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/matlab.rb#23
    def builtins; end

    # source://rouge//lib/rouge/lexers/matlab.rb#14
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/meson.rb#6
class Rouge::Lexers::Meson < ::Rouge::RegexLexer
  # source://rouge//lib/rouge/lexers/meson.rb#42
  def current_string; end

  class << self
    # source://rouge//lib/rouge/lexers/meson.rb#26
    def builtin_functions; end

    # source://rouge//lib/rouge/lexers/meson.rb#20
    def builtin_variables; end

    # source://rouge//lib/rouge/lexers/meson.rb#13
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/meson.rb#137
class Rouge::Lexers::Meson::StringRegister < ::Array
  # source://rouge//lib/rouge/lexers/meson.rb#138
  def delim?(delim); end

  # source://rouge//lib/rouge/lexers/meson.rb#142
  def register(type: T.unsafe(nil), delim: T.unsafe(nil)); end

  # source://rouge//lib/rouge/lexers/meson.rb#146
  def remove; end

  # source://rouge//lib/rouge/lexers/meson.rb#150
  def type?(type); end
end

# source://rouge//lib/rouge/lexers/minizinc.rb#9
class Rouge::Lexers::MiniZinc < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/minizinc.rb#16
    def builtins; end

    # source://rouge//lib/rouge/lexers/minizinc.rb#28
    def keywords; end

    # source://rouge//lib/rouge/lexers/minizinc.rb#36
    def keywords_type; end

    # source://rouge//lib/rouge/lexers/minizinc.rb#42
    def operators; end
  end
end

# source://rouge//lib/rouge/lexers/mojo.rb#8
class Rouge::Lexers::Mojo < ::Rouge::Lexers::Python
  class << self
    # source://rouge//lib/rouge/lexers/mojo.rb#27
    def builtins; end

    # source://rouge//lib/rouge/lexers/mojo.rb#16
    def detect?(text); end

    # source://rouge//lib/rouge/lexers/mojo.rb#20
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/moonscript.rb#8
class Rouge::Lexers::Moonscript < ::Rouge::RegexLexer
  # source://rouge//lib/rouge/lexers/moonscript.rb#19
  def initialize(*_arg0); end

  # source://rouge//lib/rouge/lexers/moonscript.rb#30
  def builtins; end

  class << self
    # source://rouge//lib/rouge/lexers/moonscript.rb#26
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/mosel.rb#6
class Rouge::Lexers::Mosel < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/msgtrans.rb#6
class Rouge::Lexers::MsgTrans < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/nasm.rb#8
class Rouge::Lexers::Nasm < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/nesasm.rb#6
class Rouge::Lexers::NesAsm < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/nesasm.rb#13
    def keywords; end

    # source://rouge//lib/rouge/lexers/nesasm.rb#28
    def keywords_reserved; end

    # source://rouge//lib/rouge/lexers/nesasm.rb#22
    def keywords_type; end
  end
end

# source://rouge//lib/rouge/lexers/nginx.rb#6
class Rouge::Lexers::Nginx < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/nial.rb#6
class Rouge::Lexers::Nial < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/nial.rb#110
    def consts; end

    # source://rouge//lib/rouge/lexers/nial.rb#44
    def funcs; end

    # source://rouge//lib/rouge/lexers/nial.rb#12
    def keywords; end

    # source://rouge//lib/rouge/lexers/nial.rb#21
    def operators; end

    # source://rouge//lib/rouge/lexers/nial.rb#26
    def punctuations; end

    # source://rouge//lib/rouge/lexers/nial.rb#30
    def transformers; end
  end
end

# source://rouge//lib/rouge/lexers/nim.rb#6
class Rouge::Lexers::Nim < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/nim.rb#40
    def underscorize(words); end
  end
end

# source://rouge//lib/rouge/lexers/nim.rb#15
Rouge::Lexers::Nim::KEYWORDS = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/nim.rb#36
Rouge::Lexers::Nim::NAMESPACE = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/nim.rb#23
Rouge::Lexers::Nim::OPWORDS = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/nim.rb#27
Rouge::Lexers::Nim::PSEUDOKEYWORDS = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/nim.rb#31
Rouge::Lexers::Nim::TYPES = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/nix.rb#6
class Rouge::Lexers::Nix < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/ocl.rb#3
class Rouge::Lexers::OCL < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/ocl.rb#25
    def builtins; end

    # source://rouge//lib/rouge/lexers/ocl.rb#37
    def functions; end

    # source://rouge//lib/rouge/lexers/ocl.rb#11
    def keywords; end

    # source://rouge//lib/rouge/lexers/ocl.rb#18
    def keywords_type; end

    # source://rouge//lib/rouge/lexers/ocl.rb#31
    def operators; end
  end
end

# source://rouge//lib/rouge/lexers/ocaml.rb#8
class Rouge::Lexers::OCaml < ::Rouge::Lexers::OCamlCommon
  class << self
    # source://rouge//lib/rouge/lexers/ocaml.rb#15
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/ocaml/common.rb#7
class Rouge::Lexers::OCamlCommon < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/ocaml/common.rb#8
    def keywords; end

    # source://rouge//lib/rouge/lexers/ocaml/common.rb#22
    def primitives; end

    # source://rouge//lib/rouge/lexers/ocaml/common.rb#18
    def word_operators; end
  end
end

# source://rouge//lib/rouge/lexers/objective_c.rb#9
class Rouge::Lexers::ObjectiveC < ::Rouge::Lexers::C
  extend ::Rouge::Lexers::ObjectiveCCommon
end

# source://rouge//lib/rouge/lexers/objective_c/common.rb#6
module Rouge::Lexers::ObjectiveCCommon
  # source://rouge//lib/rouge/lexers/objective_c/common.rb#15
  def at_builtins; end

  # source://rouge//lib/rouge/lexers/objective_c/common.rb#7
  def at_keywords; end

  # source://rouge//lib/rouge/lexers/objective_c/common.rb#19
  def builtins; end

  class << self
    # source://rouge//lib/rouge/lexers/objective_c/common.rb#23
    def extended(base); end
  end
end

# source://rouge//lib/rouge/lexers/objective_cpp.rb#9
class Rouge::Lexers::ObjectiveCpp < ::Rouge::Lexers::Cpp
  extend ::Rouge::Lexers::ObjectiveCCommon
end

# source://rouge//lib/rouge/lexers/openedge.rb#6
class Rouge::Lexers::OpenEdge < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/openedge.rb#17
    def keywords; end

    # source://rouge//lib/rouge/lexers/openedge.rb#493
    def keywords_prepro; end

    # source://rouge//lib/rouge/lexers/openedge.rb#502
    def keywords_type; end
  end
end

# source://rouge//lib/rouge/lexers/opentype_feature_file.rb#6
class Rouge::Lexers::OpenTypeFeatureFile < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/opentype_feature_file.rb#13
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/p4.rb#6
class Rouge::Lexers::P4 < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/p4.rb#36
    def builtins; end

    # source://rouge//lib/rouge/lexers/p4.rb#29
    def decls; end

    # source://rouge//lib/rouge/lexers/p4.rb#13
    def keywords; end

    # source://rouge//lib/rouge/lexers/p4.rb#22
    def operators; end
  end
end

# source://rouge//lib/rouge/lexers/php.rb#6
class Rouge::Lexers::PHP < ::Rouge::TemplateLexer
  # source://rouge//lib/rouge/lexers/php.rb#21
  def initialize(*_arg0); end

  # source://rouge//lib/rouge/lexers/php.rb#56
  def builtins; end

  class << self
    # source://rouge//lib/rouge/lexers/php.rb#51
    def builtins; end

    # source://rouge//lib/rouge/lexers/php.rb#31
    def detect?(text); end

    # source://rouge//lib/rouge/lexers/php.rb#37
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/plsql.rb#6
class Rouge::Lexers::PLSQL < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/plsql.rb#33
    def keywords; end

    # source://rouge//lib/rouge/lexers/plsql.rb#392
    def keywords_func; end

    # source://rouge//lib/rouge/lexers/plsql.rb#13
    def keywords_reserved; end

    # source://rouge//lib/rouge/lexers/plsql.rb#434
    def keywords_type; end
  end
end

# source://rouge//lib/rouge/lexers/pascal.rb#6
class Rouge::Lexers::Pascal < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/perl.rb#6
class Rouge::Lexers::Perl < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/perl.rb#16
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/plain_text.rb#6
class Rouge::Lexers::PlainText < ::Rouge::Lexer
  # source://rouge//lib/rouge/lexers/plain_text.rb#16
  def initialize(*_arg0); end

  # source://rouge//lib/rouge/lexers/plain_text.rb#22
  def stream_tokens(string, &b); end

  # source://rouge//lib/rouge/lexers/plain_text.rb#15
  def token; end
end

# source://rouge//lib/rouge/lexers/plist.rb#5
class Rouge::Lexers::Plist < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/pony.rb#6
class Rouge::Lexers::Pony < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/postscript.rb#7
class Rouge::Lexers::PostScript < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/postscript.rb#15
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/powershell.rb#7
class Rouge::Lexers::Powershell < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/powershell.rb#16
Rouge::Lexers::Powershell::ATTRIBUTES = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/powershell.rb#22
Rouge::Lexers::Powershell::AUTO_VARS = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/lexers/powershell.rb#36
Rouge::Lexers::Powershell::KEYWORDS = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/lexers/powershell.rb#46
Rouge::Lexers::Powershell::KEYWORDS_TYPE = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/lexers/powershell.rb#74
Rouge::Lexers::Powershell::MULTILINE_KEYWORDS = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/lexers/powershell.rb#65
Rouge::Lexers::Powershell::OPERATORS = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/lexers/praat.rb#6
class Rouge::Lexers::Praat < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/praat.rb#14
    def detect?(text); end

    # source://rouge//lib/rouge/lexers/praat.rb#63
    def functions_array; end

    # source://rouge//lib/rouge/lexers/praat.rb#83
    def functions_builtin; end

    # source://rouge//lib/rouge/lexers/praat.rb#69
    def functions_matrix; end

    # source://rouge//lib/rouge/lexers/praat.rb#35
    def functions_numeric; end

    # source://rouge//lib/rouge/lexers/praat.rb#26
    def functions_string; end

    # source://rouge//lib/rouge/lexers/praat.rb#77
    def functions_string_vector; end

    # source://rouge//lib/rouge/lexers/praat.rb#18
    def keywords; end

    # source://rouge//lib/rouge/lexers/praat.rb#136
    def object_attributes; end

    # source://rouge//lib/rouge/lexers/praat.rb#92
    def objects; end

    # source://rouge//lib/rouge/lexers/praat.rb#121
    def variables_numeric; end

    # source://rouge//lib/rouge/lexers/praat.rb#128
    def variables_string; end
  end
end

# source://rouge//lib/rouge/lexers/prolog.rb#6
class Rouge::Lexers::Prolog < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/prometheus.rb#5
class Rouge::Lexers::Prometheus < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/prometheus.rb#13
    def functions; end
  end
end

# source://rouge//lib/rouge/lexers/properties.rb#6
class Rouge::Lexers::Properties < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/protobuf.rb#6
class Rouge::Lexers::Protobuf < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/puppet.rb#6
class Rouge::Lexers::Puppet < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/puppet.rb#25
    def constants; end

    # source://rouge//lib/rouge/lexers/puppet.rb#13
    def detect?(text); end

    # source://rouge//lib/rouge/lexers/puppet.rb#18
    def keywords; end

    # source://rouge//lib/rouge/lexers/puppet.rb#31
    def metaparameters; end
  end
end

# source://rouge//lib/rouge/lexers/python.rb#6
class Rouge::Lexers::Python < ::Rouge::RegexLexer
  # source://rouge//lib/rouge/lexers/python.rb#76
  def current_string; end

  class << self
    # source://rouge//lib/rouge/lexers/python.rb#28
    def builtins; end

    # source://rouge//lib/rouge/lexers/python.rb#44
    def builtins_pseudo; end

    # source://rouge//lib/rouge/lexers/python.rb#15
    def detect?(text); end

    # source://rouge//lib/rouge/lexers/python.rb#48
    def exceptions; end

    # source://rouge//lib/rouge/lexers/python.rb#19
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/python.rb#274
class Rouge::Lexers::Python::StringRegister < ::Array
  # source://rouge//lib/rouge/lexers/python.rb#275
  def delim?(delim); end

  # source://rouge//lib/rouge/lexers/python.rb#279
  def register(type: T.unsafe(nil), delim: T.unsafe(nil)); end

  # source://rouge//lib/rouge/lexers/python.rb#283
  def remove; end

  # source://rouge//lib/rouge/lexers/python.rb#287
  def type?(type); end
end

# source://rouge//lib/rouge/lexers/q.rb#5
class Rouge::Lexers::Q < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/q.rb#27
    def builtins; end

    # source://rouge//lib/rouge/lexers/q.rb#15
    def keywords; end

    # source://rouge//lib/rouge/lexers/q.rb#19
    def word_operators; end
  end
end

# source://rouge//lib/rouge/lexers/qml.rb#8
class Rouge::Lexers::Qml < ::Rouge::Lexers::Javascript; end

# source://rouge//lib/rouge/lexers/r.rb#6
class Rouge::Lexers::R < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/r.rb#47
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/r.rb#23
Rouge::Lexers::R::BUILTIN_CONSTANTS = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/r.rb#16
Rouge::Lexers::R::KEYWORDS = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/r.rb#18
Rouge::Lexers::R::KEYWORD_CONSTANTS = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/r.rb#27
Rouge::Lexers::R::PRIMITIVE_FUNCTIONS = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/rml.rb#6
class Rouge::Lexers::RML < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/rml.rb#19
    def arithmetic_keywords; end

    # source://rouge//lib/rouge/lexers/rml.rb#12
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/racket.rb#6
class Rouge::Lexers::Racket < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/racket.rb#65
    def builtins; end

    # source://rouge//lib/rouge/lexers/racket.rb#14
    def detect?(text); end

    # source://rouge//lib/rouge/lexers/racket.rb#21
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/rescript.rb#8
class Rouge::Lexers::ReScript < ::Rouge::Lexers::OCamlCommon
  class << self
    # source://rouge//lib/rouge/lexers/rescript.rb#15
    def keywords; end

    # source://rouge//lib/rouge/lexers/rescript.rb#23
    def types; end

    # source://rouge//lib/rouge/lexers/rescript.rb#30
    def word_operators; end
  end
end

# source://rouge//lib/rouge/lexers/reasonml.rb#8
class Rouge::Lexers::ReasonML < ::Rouge::Lexers::OCamlCommon
  class << self
    # source://rouge//lib/rouge/lexers/reasonml.rb#15
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/rego.rb#6
class Rouge::Lexers::Rego < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/rego.rb#12
    def constants; end

    # source://rouge//lib/rouge/lexers/rego.rb#18
    def operators; end
  end
end

# source://rouge//lib/rouge/lexers/robot_framework.rb#6
class Rouge::Lexers::RobotFramework < ::Rouge::RegexLexer
  # source://rouge//lib/rouge/lexers/robot_framework.rb#16
  def initialize(opts = T.unsafe(nil)); end

  class << self
    # source://rouge//lib/rouge/lexers/robot_framework.rb#31
    def settings_with_args; end

    # source://rouge//lib/rouge/lexers/robot_framework.rb#23
    def settings_with_keywords; end
  end
end

# source://rouge//lib/rouge/lexers/ruby.rb#6
class Rouge::Lexers::Ruby < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/ruby.rb#18
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/rust.rb#6
class Rouge::Lexers::Rust < ::Rouge::RegexLexer
  # source://rouge//lib/rouge/lexers/rust.rb#53
  def macro_closed?; end

  class << self
    # source://rouge//lib/rouge/lexers/rust.rb#35
    def builtins; end

    # source://rouge//lib/rouge/lexers/rust.rb#19
    def detect?(text); end

    # source://rouge//lib/rouge/lexers/rust.rb#23
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/sas.rb#5
class Rouge::Lexers::SAS < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/sas.rb#12
    def data_step_statements; end

    # source://rouge//lib/rouge/lexers/sas.rb#140
    def proc_keywords; end

    # source://rouge//lib/rouge/lexers/sas.rb#122
    def sas_auto_macro_vars; end

    # source://rouge//lib/rouge/lexers/sas.rb#29
    def sas_functions; end

    # source://rouge//lib/rouge/lexers/sas.rb#109
    def sas_macro_functions; end

    # source://rouge//lib/rouge/lexers/sas.rb#94
    def sas_macro_statements; end

    # source://rouge//lib/rouge/lexers/sas.rb#330
    def sas_proc_names; end
  end
end

# source://rouge//lib/rouge/lexers/sml.rb#6
class Rouge::Lexers::SML < ::Rouge::RegexLexer
  # source://rouge//lib/rouge/lexers/sml.rb#62
  def token_for_final_id(id); end

  # source://rouge//lib/rouge/lexers/sml.rb#70
  def token_for_id(id); end

  # source://rouge//lib/rouge/lexers/sml.rb#54
  def token_for_id_with_dot(id); end

  class << self
    # source://rouge//lib/rouge/lexers/sml.rb#15
    def keywords; end

    # source://rouge//lib/rouge/lexers/sml.rb#25
    def symbolic_reserved; end
  end
end

# source://rouge//lib/rouge/lexers/sparql.rb#6
class Rouge::Lexers::SPARQL < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/sparql.rb#13
    def builtins; end

    # source://rouge//lib/rouge/lexers/sparql.rb#25
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/sqf.rb#6
class Rouge::Lexers::SQF < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/sqf.rb#57
    def commands; end

    # source://rouge//lib/rouge/lexers/sqf.rb#32
    def constants; end

    # source://rouge//lib/rouge/lexers/sqf.rb#25
    def controlflow; end

    # source://rouge//lib/rouge/lexers/sqf.rb#46
    def diag_commands; end

    # source://rouge//lib/rouge/lexers/sqf.rb#19
    def initializers; end

    # source://rouge//lib/rouge/lexers/sqf.rb#39
    def namespaces; end

    # source://rouge//lib/rouge/lexers/sqf.rb#13
    def wordoperators; end
  end
end

# source://rouge//lib/rouge/lexers/sql.rb#6
class Rouge::Lexers::SQL < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/sql.rb#13
    def keywords; end

    # source://rouge//lib/rouge/lexers/sql.rb#91
    def keywords_type; end
  end
end

# source://rouge//lib/rouge/lexers/ssh.rb#6
class Rouge::Lexers::SSH < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/sass.rb#8
class Rouge::Lexers::Sass < ::Rouge::Lexers::SassCommon
  include ::Rouge::Indentation
end

# source://rouge//lib/rouge/lexers/sass/common.rb#7
class Rouge::Lexers::SassCommon < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/scala.rb#6
class Rouge::Lexers::Scala < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/scheme.rb#6
class Rouge::Lexers::Scheme < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/scheme.rb#22
    def builtins; end

    # source://rouge//lib/rouge/lexers/scheme.rb#14
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/scss.rb#8
class Rouge::Lexers::Scss < ::Rouge::Lexers::SassCommon; end

# source://rouge//lib/rouge/lexers/sed.rb#6
class Rouge::Lexers::Sed < ::Rouge::RegexLexer
  # source://rouge//lib/rouge/lexers/sed.rb#52
  def regex; end

  # source://rouge//lib/rouge/lexers/sed.rb#56
  def replacement; end

  class << self
    # source://rouge//lib/rouge/lexers/sed.rb#14
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/sed.rb#18
class Rouge::Lexers::Sed::Regex < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/sed.rb#44
class Rouge::Lexers::Sed::Replacement < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/shell.rb#6
class Rouge::Lexers::Shell < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/shell.rb#22
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/shell.rb#32
Rouge::Lexers::Shell::BUILTINS = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/lexers/shell.rb#27
Rouge::Lexers::Shell::KEYWORDS = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/lexers/sieve.rb#6
class Rouge::Lexers::Sieve < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/sieve.rb#20
    def actions; end

    # source://rouge//lib/rouge/lexers/sieve.rb#16
    def controls; end

    # source://rouge//lib/rouge/lexers/sieve.rb#39
    def tests; end
  end
end

# source://rouge//lib/rouge/lexers/slice.rb#8
class Rouge::Lexers::Slice < ::Rouge::Lexers::C
  class << self
    # source://rouge//lib/rouge/lexers/slice.rb#16
    def keywords; end

    # source://rouge//lib/rouge/lexers/slice.rb#25
    def keywords_type; end
  end
end

# source://rouge//lib/rouge/lexers/slim.rb#8
class Rouge::Lexers::Slim < ::Rouge::RegexLexer
  include ::Rouge::Indentation

  # source://rouge//lib/rouge/lexers/slim.rb#32
  def filters; end

  # source://rouge//lib/rouge/lexers/slim.rb#28
  def html; end

  # source://rouge//lib/rouge/lexers/slim.rb#24
  def ruby; end
end

# source://rouge//lib/rouge/lexers/smalltalk.rb#6
class Rouge::Lexers::Smalltalk < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/smarty.rb#6
class Rouge::Lexers::Smarty < ::Rouge::TemplateLexer
  class << self
    # source://rouge//lib/rouge/lexers/smarty.rb#14
    def builtins; end
  end
end

# source://rouge//lib/rouge/lexers/stan.rb#6
class Rouge::Lexers::Stan < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/stan.rb#90
    def builtin_functions; end

    # source://rouge//lib/rouge/lexers/stan.rb#333
    def constants; end

    # source://rouge//lib/rouge/lexers/stan.rb#268
    def distributions; end

    # source://rouge//lib/rouge/lexers/stan.rb#48
    def keywords; end

    # source://rouge//lib/rouge/lexers/stan.rb#62
    def reserved; end

    # source://rouge//lib/rouge/lexers/stan.rb#54
    def types; end
  end
end

# source://rouge//lib/rouge/lexers/stan.rb#14
Rouge::Lexers::Stan::ID = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/stan.rb#16
Rouge::Lexers::Stan::OP = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/stan.rb#15
Rouge::Lexers::Stan::RT = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/stan.rb#13
Rouge::Lexers::Stan::WS = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/stata.rb#6
class Rouge::Lexers::Stata < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/stata.rb#90
    def reserved_keywords; end

    # source://rouge//lib/rouge/lexers/stata.rb#85
    def type_keywords; end
  end
end

# source://rouge//lib/rouge/lexers/stata.rb#19
Rouge::Lexers::Stata::KEYWORDS = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/stata.rb#48
Rouge::Lexers::Stata::PRIMITIVE_FUNCTIONS = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/supercollider.rb#6
class Rouge::Lexers::SuperCollider < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/supercollider.rb#28
    def constants; end

    # source://rouge//lib/rouge/lexers/supercollider.rb#13
    def keywords; end

    # source://rouge//lib/rouge/lexers/supercollider.rb#22
    def reserved; end
  end
end

# source://rouge//lib/rouge/lexers/svelte.rb#8
class Rouge::Lexers::Svelte < ::Rouge::Lexers::HTML
  # source://rouge//lib/rouge/lexers/svelte.rb#14
  def initialize(*_arg0); end
end

# source://rouge//lib/rouge/lexers/swift.rb#6
class Rouge::Lexers::Swift < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/systemd.rb#6
class Rouge::Lexers::SystemD < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/syzlang.rb#6
class Rouge::Lexers::Syzlang < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/syzlang.rb#11
    def keywords; end

    # source://rouge//lib/rouge/lexers/syzlang.rb#19
    def keywords_type; end
  end
end

# source://rouge//lib/rouge/lexers/syzprog.rb#6
class Rouge::Lexers::Syzprog < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/syzprog.rb#11
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/tcl.rb#6
class Rouge::Lexers::TCL < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/tcl.rb#13
    def detect?(text); end

    # source://rouge//lib/rouge/lexers/tcl.rb#58
    def gen_command_state(name = T.unsafe(nil)); end

    # source://rouge//lib/rouge/lexers/tcl.rb#82
    def gen_delimiter_states(name, close, opts = T.unsafe(nil)); end
  end
end

# source://rouge//lib/rouge/lexers/tcl.rb#40
Rouge::Lexers::TCL::ALL = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/tcl.rb#26
Rouge::Lexers::TCL::BUILTINS = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/tcl.rb#44
Rouge::Lexers::TCL::CHARS = T.let(T.unsafe(nil), Proc)

# source://rouge//lib/rouge/lexers/tcl.rb#39
Rouge::Lexers::TCL::CLOSE = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/tcl.rb#41
Rouge::Lexers::TCL::END_LINE = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/tcl.rb#42
Rouge::Lexers::TCL::END_WORD = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/tcl.rb#19
Rouge::Lexers::TCL::KEYWORDS = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/tcl.rb#45
Rouge::Lexers::TCL::NOT_CHARS = T.let(T.unsafe(nil), Proc)

# source://rouge//lib/rouge/lexers/tcl.rb#38
Rouge::Lexers::TCL::OPEN = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/toml.rb#6
class Rouge::Lexers::TOML < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/tsx.rb#9
class Rouge::Lexers::TSX < ::Rouge::Lexers::JSX
  extend ::Rouge::Lexers::TypescriptCommon
end

# source://rouge//lib/rouge/lexers/ttcn3.rb#6
class Rouge::Lexers::TTCN3 < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/ttcn3.rb#14
    def keywords; end

    # source://rouge//lib/rouge/lexers/ttcn3.rb#32
    def reserved; end

    # source://rouge//lib/rouge/lexers/ttcn3.rb#42
    def types; end
  end
end

# source://rouge//lib/rouge/lexers/tap.rb#5
class Rouge::Lexers::Tap < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/tex.rb#6
class Rouge::Lexers::TeX < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/tex.rb#15
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/terraform.rb#8
class Rouge::Lexers::Terraform < ::Rouge::Lexers::Hcl
  class << self
    # source://rouge//lib/rouge/lexers/terraform.rb#36
    def builtins; end

    # source://rouge//lib/rouge/lexers/terraform.rb#32
    def constants; end

    # source://rouge//lib/rouge/lexers/terraform.rb#22
    def declarations; end

    # source://rouge//lib/rouge/lexers/terraform.rb#16
    def keywords; end

    # source://rouge//lib/rouge/lexers/terraform.rb#28
    def reserved; end
  end
end

# source://rouge//lib/rouge/lexers/tulip.rb#5
class Rouge::Lexers::Tulip < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/tulip.rb#14
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/turtle.rb#6
class Rouge::Lexers::Turtle < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/twig.rb#8
class Rouge::Lexers::Twig < ::Rouge::Lexers::Jinja
  class << self
    # source://rouge//lib/rouge/lexers/twig.rb#18
    def keywords; end

    # source://rouge//lib/rouge/lexers/twig.rb#31
    def pseudo_keywords; end

    # source://rouge//lib/rouge/lexers/twig.rb#26
    def tests; end

    # source://rouge//lib/rouge/lexers/twig.rb#35
    def word_operators; end
  end
end

# source://rouge//lib/rouge/lexers/typescript.rb#9
class Rouge::Lexers::Typescript < ::Rouge::Lexers::Javascript
  extend ::Rouge::Lexers::TypescriptCommon
end

# source://rouge//lib/rouge/lexers/typescript/common.rb#6
module Rouge::Lexers::TypescriptCommon
  # source://rouge//lib/rouge/lexers/typescript/common.rb#27
  def builtins; end

  # source://rouge//lib/rouge/lexers/typescript/common.rb#14
  def declarations; end

  # source://rouge//lib/rouge/lexers/typescript/common.rb#7
  def keywords; end

  # source://rouge//lib/rouge/lexers/typescript/common.rb#20
  def reserved; end

  class << self
    # source://rouge//lib/rouge/lexers/typescript/common.rb#36
    def extended(base); end
  end
end

# source://rouge//lib/rouge/lexers/vhdl.rb#6
class Rouge::Lexers::VHDL < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/vhdl.rb#14
    def keywords; end

    # source://rouge//lib/rouge/lexers/vhdl.rb#27
    def keywords_type; end

    # source://rouge//lib/rouge/lexers/vhdl.rb#35
    def operator_words; end
  end
end

# source://rouge//lib/rouge/lexers/vala.rb#6
class Rouge::Lexers::Vala < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/varnish.rb#6
class Rouge::Lexers::Varnish < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/varnish.rb#28
    def functions; end

    # source://rouge//lib/rouge/lexers/varnish.rb#18
    def keywords; end

    # source://rouge//lib/rouge/lexers/varnish.rb#39
    def variables; end
  end
end

# source://rouge//lib/rouge/lexers/varnish.rb#15
Rouge::Lexers::Varnish::SPACE = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/lexers/velocity.rb#5
class Rouge::Lexers::Velocity < ::Rouge::TemplateLexer; end

# source://rouge//lib/rouge/lexers/verilog.rb#6
class Rouge::Lexers::Verilog < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/verilog.rb#15
    def keywords; end

    # source://rouge//lib/rouge/lexers/verilog.rb#52
    def keywords_system_task; end

    # source://rouge//lib/rouge/lexers/verilog.rb#37
    def keywords_type; end
  end
end

# source://rouge//lib/rouge/lexers/viml.rb#6
class Rouge::Lexers::VimL < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/viml.rb#16
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/vb.rb#6
class Rouge::Lexers::VisualBasic < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/vb.rb#47
    def builtins; end

    # source://rouge//lib/rouge/lexers/vb.rb#14
    def keywords; end

    # source://rouge//lib/rouge/lexers/vb.rb#33
    def keywords_type; end

    # source://rouge//lib/rouge/lexers/vb.rb#40
    def operator_words; end
  end
end

# source://rouge//lib/rouge/lexers/vue.rb#7
class Rouge::Lexers::Vue < ::Rouge::Lexers::HTML
  # source://rouge//lib/rouge/lexers/vue.rb#15
  def initialize(*_arg0); end

  # source://rouge//lib/rouge/lexers/vue.rb#20
  def lookup_lang(lang); end
end

# source://rouge//lib/rouge/lexers/wollok.rb#6
class Rouge::Lexers::Wollok < ::Rouge::RegexLexer
  private

  # source://rouge//lib/rouge/lexers/wollok.rb#102
  def entities; end
end

# source://rouge//lib/rouge/lexers/xml.rb#6
class Rouge::Lexers::XML < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/xml.rb#17
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/xpath.rb#6
class Rouge::Lexers::XPath < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/xpath.rb#67
    def axes; end

    # source://rouge//lib/rouge/lexers/xpath.rb#46
    def commentStart; end

    # source://rouge//lib/rouge/lexers/xpath.rb#92
    def constructorTypes; end

    # source://rouge//lib/rouge/lexers/xpath.rb#18
    def decimalLiteral; end

    # source://rouge//lib/rouge/lexers/xpath.rb#14
    def digits; end

    # source://rouge//lib/rouge/lexers/xpath.rb#22
    def doubleLiteral; end

    # source://rouge//lib/rouge/lexers/xpath.rb#42
    def eqName; end

    # source://rouge//lib/rouge/lexers/xpath.rb#79
    def keywords; end

    # source://rouge//lib/rouge/lexers/xpath.rb#56
    def kindTest; end

    # source://rouge//lib/rouge/lexers/xpath.rb#63
    def kindTestForPI; end

    # source://rouge//lib/rouge/lexers/xpath.rb#30
    def ncName; end

    # source://rouge//lib/rouge/lexers/xpath.rb#50
    def openParen; end

    # source://rouge//lib/rouge/lexers/xpath.rb#75
    def operators; end

    # source://rouge//lib/rouge/lexers/xpath.rb#34
    def qName; end

    # source://rouge//lib/rouge/lexers/xpath.rb#26
    def stringLiteral; end

    # source://rouge//lib/rouge/lexers/xpath.rb#38
    def uriQName; end

    # source://rouge//lib/rouge/lexers/xpath.rb#83
    def word_operators; end
  end
end

# source://rouge//lib/rouge/lexers/xquery.rb#7
class Rouge::Lexers::XQuery < ::Rouge::Lexers::XPath
  class << self
    # source://rouge//lib/rouge/lexers/xquery.rb#14
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/xojo.rb#6
class Rouge::Lexers::Xojo < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/yaml.rb#6
class Rouge::Lexers::YAML < ::Rouge::RegexLexer
  # source://rouge//lib/rouge/lexers/yaml.rb#62
  def continue_indent(match); end

  # source://rouge//lib/rouge/lexers/yaml.rb#37
  def dedent?(level); end

  # source://rouge//lib/rouge/lexers/yaml.rb#32
  def indent; end

  # source://rouge//lib/rouge/lexers/yaml.rb#41
  def indent?(level); end

  # source://rouge//lib/rouge/lexers/yaml.rb#25
  def reset_indent; end

  # source://rouge//lib/rouge/lexers/yaml.rb#46
  def save_indent(match); end

  # source://rouge//lib/rouge/lexers/yaml.rb#67
  def set_indent(match, opts = T.unsafe(nil)); end

  class << self
    # source://rouge//lib/rouge/lexers/yaml.rb#16
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/yang.rb#6
class Rouge::Lexers::YANG < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/yang.rb#40
    def body_stmts_keywords; end

    # source://rouge//lib/rouge/lexers/yang.rb#69
    def constants_keywords; end

    # source://rouge//lib/rouge/lexers/yang.rb#47
    def data_def_stmts_keywords; end

    # source://rouge//lib/rouge/lexers/yang.rb#34
    def linkage_stmts_keywords; end

    # source://rouge//lib/rouge/lexers/yang.rb#62
    def list_stmts_keywords; end

    # source://rouge//lib/rouge/lexers/yang.rb#28
    def meta_stmts_keywords; end

    # source://rouge//lib/rouge/lexers/yang.rb#22
    def module_header_stmts_keywords; end

    # source://rouge//lib/rouge/lexers/yang.rb#16
    def top_stmts_keywords; end

    # source://rouge//lib/rouge/lexers/yang.rb#54
    def type_stmts_keywords; end

    # source://rouge//lib/rouge/lexers/yang.rb#77
    def types; end
  end
end

# source://rouge//lib/rouge/lexers/zig.rb#6
class Rouge::Lexers::Zig < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/zig.rb#28
    def builtins; end

    # source://rouge//lib/rouge/lexers/zig.rb#15
    def keywords; end
  end
end

# source://rouge//lib/rouge/regex_lexer.rb#8
class Rouge::RegexLexer < ::Rouge::Lexer
  # source://rouge//lib/rouge/regex_lexer.rb#433
  def delegate(lexer, text = T.unsafe(nil)); end

  # source://rouge//lib/rouge/regex_lexer.rb#281
  def get_state(state_name); end

  # source://rouge//lib/rouge/regex_lexer.rb#477
  def goto(state_name); end

  # source://rouge//lib/rouge/regex_lexer.rb#412
  def group(tok); end

  # source://rouge//lib/rouge/regex_lexer.rb#418
  def groups(*tokens); end

  # source://rouge//lib/rouge/regex_lexer.rb#492
  def in_state?(state_name); end

  # source://rouge//lib/rouge/regex_lexer.rb#466
  def pop!(times = T.unsafe(nil)); end

  # source://rouge//lib/rouge/regex_lexer.rb#450
  def push(state_name = T.unsafe(nil), &b); end

  # source://rouge//lib/rouge/regex_lexer.rb#443
  def recurse(text = T.unsafe(nil)); end

  # source://rouge//lib/rouge/regex_lexer.rb#302
  def reset!; end

  # source://rouge//lib/rouge/regex_lexer.rb#485
  def reset_stack; end

  # source://rouge//lib/rouge/regex_lexer.rb#288
  def stack; end

  # source://rouge//lib/rouge/regex_lexer.rb#296
  def state; end

  # source://rouge//lib/rouge/regex_lexer.rb#500
  def state?(state_name); end

  # source://rouge//lib/rouge/regex_lexer.rb#358
  def step(state, stream); end

  # source://rouge//lib/rouge/regex_lexer.rb#324
  def stream_tokens(str, &b); end

  # source://rouge//lib/rouge/regex_lexer.rb#404
  def token(tok, val = T.unsafe(nil)); end

  private

  # source://rouge//lib/rouge/regex_lexer.rb#505
  def yield_token(tok, val); end

  class << self
    # source://rouge//lib/rouge/regex_lexer.rb#264
    def append(name, &b); end

    # source://rouge//lib/rouge/regex_lexer.rb#271
    def get_state(name); end

    # source://rouge//lib/rouge/regex_lexer.rb#258
    def prepend(name, &b); end

    # source://rouge//lib/rouge/regex_lexer.rb#231
    def replace_state(name, new_defn); end

    # source://rouge//lib/rouge/regex_lexer.rb#247
    def start(&b); end

    # source://rouge//lib/rouge/regex_lexer.rb#238
    def start_procs; end

    # source://rouge//lib/rouge/regex_lexer.rb#253
    def state(name, &b); end

    # source://rouge//lib/rouge/regex_lexer.rb#226
    def state_definitions; end

    # source://rouge//lib/rouge/regex_lexer.rb#222
    def states; end
  end
end

# source://rouge//lib/rouge/regex_lexer.rb#19
class Rouge::RegexLexer::ClosedState < ::StandardError
  # source://rouge//lib/rouge/regex_lexer.rb#21
  def initialize(state); end

  # source://rouge//lib/rouge/regex_lexer.rb#25
  def rule; end

  # source://rouge//lib/rouge/regex_lexer.rb#20
  def state; end

  # source://rouge//lib/rouge/regex_lexer.rb#29
  def to_s; end
end

# source://rouge//lib/rouge/regex_lexer.rb#9
class Rouge::RegexLexer::InvalidRegex < ::StandardError
  # source://rouge//lib/rouge/regex_lexer.rb#10
  def initialize(re); end

  # source://rouge//lib/rouge/regex_lexer.rb#14
  def to_s; end
end

# source://rouge//lib/rouge/regex_lexer.rb#351
Rouge::RegexLexer::MAX_NULL_SCANS = T.let(T.unsafe(nil), Integer)

# source://rouge//lib/rouge/regex_lexer.rb#44
class Rouge::RegexLexer::Rule
  # source://rouge//lib/rouge/regex_lexer.rb#48
  def initialize(re, callback); end

  # source://rouge//lib/rouge/regex_lexer.rb#47
  def beginning_of_line; end

  # source://rouge//lib/rouge/regex_lexer.rb#45
  def callback; end

  # source://rouge//lib/rouge/regex_lexer.rb#54
  def inspect; end

  # source://rouge//lib/rouge/regex_lexer.rb#46
  def re; end
end

# source://rouge//lib/rouge/regex_lexer.rb#63
class Rouge::RegexLexer::State
  # source://rouge//lib/rouge/regex_lexer.rb#65
  def initialize(name, rules); end

  # source://rouge//lib/rouge/regex_lexer.rb#70
  def inspect; end

  # source://rouge//lib/rouge/regex_lexer.rb#64
  def name; end

  # source://rouge//lib/rouge/regex_lexer.rb#64
  def rules; end
end

# source://rouge//lib/rouge/regex_lexer.rb#75
class Rouge::RegexLexer::StateDSL
  # source://rouge//lib/rouge/regex_lexer.rb#77
  def initialize(name, &defn); end

  # source://rouge//lib/rouge/regex_lexer.rb#101
  def appended(&defn); end

  # source://rouge//lib/rouge/regex_lexer.rb#76
  def name; end

  # source://rouge//lib/rouge/regex_lexer.rb#93
  def prepended(&defn); end

  # source://rouge//lib/rouge/regex_lexer.rb#76
  def rules; end

  # source://rouge//lib/rouge/regex_lexer.rb#85
  def to_state(lexer_class); end

  protected

  # source://rouge//lib/rouge/regex_lexer.rb#201
  def close!; end

  # source://rouge//lib/rouge/regex_lexer.rb#191
  def context_sensitive?(re); end

  # source://rouge//lib/rouge/regex_lexer.rb#208
  def mixin(state); end

  # source://rouge//lib/rouge/regex_lexer.rb#129
  def rule(re, tok = T.unsafe(nil), next_state = T.unsafe(nil), &callback); end

  private

  # source://rouge//lib/rouge/regex_lexer.rb#213
  def load!; end
end

# source://rouge//lib/rouge/template_lexer.rb#10
class Rouge::TemplateLexer < ::Rouge::RegexLexer
  # source://rouge//lib/rouge/template_lexer.rb#12
  def parent; end
end

# source://rouge//lib/rouge/tex_theme_renderer.rb#5
class Rouge::TexThemeRenderer
  # source://rouge//lib/rouge/tex_theme_renderer.rb#6
  def initialize(theme, opts = T.unsafe(nil)); end

  # source://rouge//lib/rouge/tex_theme_renderer.rb#97
  def camelize(name); end

  # source://rouge//lib/rouge/tex_theme_renderer.rb#86
  def gen_inline(name, &b); end

  # source://rouge//lib/rouge/tex_theme_renderer.rb#70
  def inline_name(color); end

  # source://rouge//lib/rouge/tex_theme_renderer.rb#101
  def palette_name(name); end

  # source://rouge//lib/rouge/tex_theme_renderer.rb#33
  def render(&b); end

  # source://rouge//lib/rouge/tex_theme_renderer.rb#111
  def render_blank(tok, &b); end

  # source://rouge//lib/rouge/tex_theme_renderer.rb#65
  def render_inline_pallete(style, &b); end

  # source://rouge//lib/rouge/tex_theme_renderer.rb#57
  def render_palette(palette, &b); end

  # source://rouge//lib/rouge/tex_theme_renderer.rb#115
  def render_style(tok, style, &b); end

  # source://rouge//lib/rouge/tex_theme_renderer.rb#107
  def token_name(tok); end
end

# source://rouge//lib/rouge/text_analyzer.rb#5
class Rouge::TextAnalyzer < ::String
  # source://rouge//lib/rouge/text_analyzer.rb#25
  def doctype; end

  # source://rouge//lib/rouge/text_analyzer.rb#36
  def doctype?(type = T.unsafe(nil)); end

  # source://rouge//lib/rouge/text_analyzer.rb#42
  def lexes_cleanly?(lexer); end

  # source://rouge//lib/rouge/text_analyzer.rb#7
  def shebang; end

  # source://rouge//lib/rouge/text_analyzer.rb#18
  def shebang?(match); end
end

# source://rouge//lib/rouge/theme.rb#5
class Rouge::Theme
  include ::Rouge::Token::Tokens

  # source://rouge//lib/rouge/theme.rb#78
  def get_own_style(token); end

  # source://rouge//lib/rouge/theme.rb#82
  def get_style(token); end

  # source://rouge//lib/rouge/theme.rb#86
  def name; end

  # source://rouge//lib/rouge/theme.rb#67
  def palette(*a); end

  # source://rouge//lib/rouge/theme.rb#46
  def styles; end

  class << self
    # source://rouge//lib/rouge/theme.rb#111
    def base_style; end

    # source://rouge//lib/rouge/theme.rb#126
    def find(n); end

    # source://rouge//lib/rouge/theme.rb#99
    def get_own_style(token); end

    # source://rouge//lib/rouge/theme.rb#107
    def get_style(token); end

    # source://rouge//lib/rouge/theme.rb#115
    def name(n = T.unsafe(nil)); end

    # source://rouge//lib/rouge/theme.rb#51
    def palette(arg = T.unsafe(nil)); end

    # source://rouge//lib/rouge/theme.rb#122
    def register(name); end

    # source://rouge//lib/rouge/theme.rb#130
    def registry; end

    # source://rouge//lib/rouge/theme.rb#74
    def render(opts = T.unsafe(nil), &b); end

    # source://rouge//lib/rouge/theme.rb#91
    def style(*tokens); end

    # source://rouge//lib/rouge/theme.rb#70
    def styles; end
  end
end

# source://rouge//lib/rouge/theme.rb#8
class Rouge::Theme::Style < ::Hash
  # source://rouge//lib/rouge/theme.rb#9
  def initialize(theme, hsh = T.unsafe(nil)); end

  # source://rouge//lib/rouge/theme.rb#16
  def bg; end

  # source://rouge//lib/rouge/theme.rb#16
  def fg; end

  # source://rouge//lib/rouge/theme.rb#22
  def render(selector, &b); end

  # source://rouge//lib/rouge/theme.rb#34
  def rendered_rules(&b); end
end

# source://rouge//lib/rouge/themes/thankful_eyes.rb#5
module Rouge::Themes; end

# source://rouge//lib/rouge/themes/base16.rb#9
class Rouge::Themes::Base16 < ::Rouge::CSSTheme
  extend ::Rouge::HasModes

  class << self
    # source://rouge//lib/rouge/themes/base16.rb#36
    def dark!; end

    # source://rouge//lib/rouge/themes/base16.rb#31
    def light!; end

    # source://rouge//lib/rouge/themes/base16.rb#41
    def make_dark!; end

    # source://rouge//lib/rouge/themes/base16.rb#45
    def make_light!; end
  end
end

# source://rouge//lib/rouge/themes/base16.rb#113
class Rouge::Themes::Base16::Monokai < ::Rouge::Themes::Base16; end

# source://rouge//lib/rouge/themes/base16.rb#90
class Rouge::Themes::Base16::Solarized < ::Rouge::Themes::Base16; end

# source://rouge//lib/rouge/themes/bw.rb#8
class Rouge::Themes::BlackWhiteTheme < ::Rouge::CSSTheme; end

# source://rouge//lib/rouge/themes/colorful.rb#7
class Rouge::Themes::Colorful < ::Rouge::CSSTheme; end

# source://rouge//lib/rouge/themes/github.rb#6
class Rouge::Themes::Github < ::Rouge::CSSTheme
  extend ::Rouge::HasModes

  class << self
    # source://rouge//lib/rouge/themes/github.rb#43
    def dark!; end

    # source://rouge//lib/rouge/themes/github.rb#38
    def light!; end

    # source://rouge//lib/rouge/themes/github.rb#48
    def make_dark!; end

    # source://rouge//lib/rouge/themes/github.rb#71
    def make_light!; end
  end
end

# source://rouge//lib/rouge/themes/github.rb#22
Rouge::Themes::Github::P_BLUE_1 = T.let(T.unsafe(nil), Hash)

# source://rouge//lib/rouge/themes/github.rb#23
Rouge::Themes::Github::P_BLUE_2 = T.let(T.unsafe(nil), Hash)

# source://rouge//lib/rouge/themes/github.rb#24
Rouge::Themes::Github::P_BLUE_5 = T.let(T.unsafe(nil), Hash)

# source://rouge//lib/rouge/themes/github.rb#25
Rouge::Themes::Github::P_BLUE_6 = T.let(T.unsafe(nil), Hash)

# source://rouge//lib/rouge/themes/github.rb#26
Rouge::Themes::Github::P_BLUE_8 = T.let(T.unsafe(nil), Hash)

# source://rouge//lib/rouge/themes/github.rb#29
Rouge::Themes::Github::P_GRAY_0 = T.let(T.unsafe(nil), Hash)

# source://rouge//lib/rouge/themes/github.rb#30
Rouge::Themes::Github::P_GRAY_1 = T.let(T.unsafe(nil), Hash)

# source://rouge//lib/rouge/themes/github.rb#31
Rouge::Themes::Github::P_GRAY_3 = T.let(T.unsafe(nil), Hash)

# source://rouge//lib/rouge/themes/github.rb#32
Rouge::Themes::Github::P_GRAY_5 = T.let(T.unsafe(nil), Hash)

# source://rouge//lib/rouge/themes/github.rb#33
Rouge::Themes::Github::P_GRAY_8 = T.let(T.unsafe(nil), Hash)

# source://rouge//lib/rouge/themes/github.rb#34
Rouge::Themes::Github::P_GRAY_9 = T.let(T.unsafe(nil), Hash)

# source://rouge//lib/rouge/themes/github.rb#18
Rouge::Themes::Github::P_GREEN_0 = T.let(T.unsafe(nil), Hash)

# source://rouge//lib/rouge/themes/github.rb#19
Rouge::Themes::Github::P_GREEN_1 = T.let(T.unsafe(nil), Hash)

# source://rouge//lib/rouge/themes/github.rb#20
Rouge::Themes::Github::P_GREEN_6 = T.let(T.unsafe(nil), Hash)

# source://rouge//lib/rouge/themes/github.rb#21
Rouge::Themes::Github::P_GREEN_8 = T.let(T.unsafe(nil), Hash)

# source://rouge//lib/rouge/themes/github.rb#16
Rouge::Themes::Github::P_ORANGE_2 = T.let(T.unsafe(nil), Hash)

# source://rouge//lib/rouge/themes/github.rb#17
Rouge::Themes::Github::P_ORANGE_6 = T.let(T.unsafe(nil), Hash)

# source://rouge//lib/rouge/themes/github.rb#27
Rouge::Themes::Github::P_PURPLE_2 = T.let(T.unsafe(nil), Hash)

# source://rouge//lib/rouge/themes/github.rb#28
Rouge::Themes::Github::P_PURPLE_5 = T.let(T.unsafe(nil), Hash)

# source://rouge//lib/rouge/themes/github.rb#11
Rouge::Themes::Github::P_RED_0 = T.let(T.unsafe(nil), Hash)

# source://rouge//lib/rouge/themes/github.rb#12
Rouge::Themes::Github::P_RED_3 = T.let(T.unsafe(nil), Hash)

# source://rouge//lib/rouge/themes/github.rb#13
Rouge::Themes::Github::P_RED_5 = T.let(T.unsafe(nil), Hash)

# source://rouge//lib/rouge/themes/github.rb#14
Rouge::Themes::Github::P_RED_7 = T.let(T.unsafe(nil), Hash)

# source://rouge//lib/rouge/themes/github.rb#15
Rouge::Themes::Github::P_RED_8 = T.let(T.unsafe(nil), Hash)

# source://rouge//lib/rouge/themes/gruvbox.rb#10
class Rouge::Themes::Gruvbox < ::Rouge::CSSTheme
  extend ::Rouge::HasModes

  class << self
    # source://rouge//lib/rouge/themes/gruvbox.rb#67
    def dark!; end

    # source://rouge//lib/rouge/themes/gruvbox.rb#62
    def light!; end

    # source://rouge//lib/rouge/themes/gruvbox.rb#72
    def make_dark!; end

    # source://rouge//lib/rouge/themes/gruvbox.rb#99
    def make_light!; end
  end
end

# source://rouge//lib/rouge/themes/gruvbox.rb#40
Rouge::Themes::Gruvbox::C_bright_aqua = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#38
Rouge::Themes::Gruvbox::C_bright_blue = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#36
Rouge::Themes::Gruvbox::C_bright_green = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#41
Rouge::Themes::Gruvbox::C_bright_orange = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#39
Rouge::Themes::Gruvbox::C_bright_purple = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#35
Rouge::Themes::Gruvbox::C_bright_red = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#37
Rouge::Themes::Gruvbox::C_bright_yellow = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#15
Rouge::Themes::Gruvbox::C_dark0 = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#14
Rouge::Themes::Gruvbox::C_dark0_hard = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#16
Rouge::Themes::Gruvbox::C_dark0_soft = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#17
Rouge::Themes::Gruvbox::C_dark1 = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#18
Rouge::Themes::Gruvbox::C_dark2 = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#19
Rouge::Themes::Gruvbox::C_dark3 = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#20
Rouge::Themes::Gruvbox::C_dark4 = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#21
Rouge::Themes::Gruvbox::C_dark4_256 = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#56
Rouge::Themes::Gruvbox::C_faded_aqua = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#54
Rouge::Themes::Gruvbox::C_faded_blue = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#52
Rouge::Themes::Gruvbox::C_faded_green = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#57
Rouge::Themes::Gruvbox::C_faded_orange = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#55
Rouge::Themes::Gruvbox::C_faded_purple = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#51
Rouge::Themes::Gruvbox::C_faded_red = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#53
Rouge::Themes::Gruvbox::C_faded_yellow = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#24
Rouge::Themes::Gruvbox::C_gray_244 = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#23
Rouge::Themes::Gruvbox::C_gray_245 = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#27
Rouge::Themes::Gruvbox::C_light0 = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#26
Rouge::Themes::Gruvbox::C_light0_hard = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#28
Rouge::Themes::Gruvbox::C_light0_soft = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#29
Rouge::Themes::Gruvbox::C_light1 = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#30
Rouge::Themes::Gruvbox::C_light2 = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#31
Rouge::Themes::Gruvbox::C_light3 = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#32
Rouge::Themes::Gruvbox::C_light4 = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#33
Rouge::Themes::Gruvbox::C_light4_256 = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#48
Rouge::Themes::Gruvbox::C_neutral_aqua = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#46
Rouge::Themes::Gruvbox::C_neutral_blue = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#44
Rouge::Themes::Gruvbox::C_neutral_green = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#49
Rouge::Themes::Gruvbox::C_neutral_orange = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#47
Rouge::Themes::Gruvbox::C_neutral_purple = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#43
Rouge::Themes::Gruvbox::C_neutral_red = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#45
Rouge::Themes::Gruvbox::C_neutral_yellow = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/igor_pro.rb#6
class Rouge::Themes::IgorPro < ::Rouge::CSSTheme; end

# source://rouge//lib/rouge/themes/magritte.rb#6
class Rouge::Themes::Magritte < ::Rouge::CSSTheme; end

# source://rouge//lib/rouge/themes/molokai.rb#6
class Rouge::Themes::Molokai < ::Rouge::CSSTheme; end

# source://rouge//lib/rouge/themes/monokai.rb#6
class Rouge::Themes::Monokai < ::Rouge::CSSTheme; end

# source://rouge//lib/rouge/themes/monokai_sublime.rb#6
class Rouge::Themes::MonokaiSublime < ::Rouge::CSSTheme; end

# source://rouge//lib/rouge/themes/pastie.rb#8
class Rouge::Themes::Pastie < ::Rouge::CSSTheme; end

# source://rouge//lib/rouge/themes/thankful_eyes.rb#6
class Rouge::Themes::ThankfulEyes < ::Rouge::CSSTheme; end

# source://rouge//lib/rouge/themes/tulip.rb#6
class Rouge::Themes::Tulip < ::Rouge::CSSTheme; end

# source://rouge//lib/rouge/token.rb#5
class Rouge::Token
  class << self
    # source://rouge//lib/rouge/token.rb#19
    def [](qualname); end

    # source://rouge//lib/rouge/token.rb#11
    def cache; end

    # source://rouge//lib/rouge/token.rb#62
    def each_token(&b); end

    # source://rouge//lib/rouge/token.rb#25
    def inspect; end

    # source://rouge//lib/rouge/token.rb#46
    def make_token(name, shortname, &b); end

    # source://rouge//lib/rouge/token.rb#29
    def matches?(other); end

    # source://rouge//lib/rouge/token.rb#7
    def name; end

    # source://rouge//lib/rouge/token.rb#8
    def parent; end

    # source://rouge//lib/rouge/token.rb#37
    def qualname; end

    # source://rouge//lib/rouge/token.rb#41
    def register!; end

    # source://rouge//lib/rouge/token.rb#9
    def shortname; end

    # source://rouge//lib/rouge/token.rb#15
    def sub_tokens; end

    # source://rouge//lib/rouge/token.rb#57
    def token(name, shortname, &b); end

    # source://rouge//lib/rouge/token.rb#33
    def token_chain; end
  end
end

# source://rouge//lib/rouge/token.rb#69
module Rouge::Token::Tokens
  class << self
    # source://rouge//lib/rouge/token.rb#70
    def token(name, shortname, &b); end
  end
end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Comment < ::Rouge::Token; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Comment::Doc < ::Rouge::Token::Tokens::Comment; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Comment::Hashbang < ::Rouge::Token::Tokens::Comment; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Comment::Multiline < ::Rouge::Token::Tokens::Comment; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Comment::Preproc < ::Rouge::Token::Tokens::Comment; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Comment::PreprocFile < ::Rouge::Token::Tokens::Comment; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Comment::Single < ::Rouge::Token::Tokens::Comment; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Comment::Special < ::Rouge::Token::Tokens::Comment; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Error < ::Rouge::Token; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Escape < ::Rouge::Token; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Generic < ::Rouge::Token; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Generic::Deleted < ::Rouge::Token::Tokens::Generic; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Generic::Emph < ::Rouge::Token::Tokens::Generic; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Generic::EmphStrong < ::Rouge::Token::Tokens::Generic; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Generic::Error < ::Rouge::Token::Tokens::Generic; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Generic::Heading < ::Rouge::Token::Tokens::Generic; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Generic::Inserted < ::Rouge::Token::Tokens::Generic; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Generic::Lineno < ::Rouge::Token::Tokens::Generic; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Generic::Output < ::Rouge::Token::Tokens::Generic; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Generic::Prompt < ::Rouge::Token::Tokens::Generic; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Generic::Strong < ::Rouge::Token::Tokens::Generic; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Generic::Subheading < ::Rouge::Token::Tokens::Generic; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Generic::Traceback < ::Rouge::Token::Tokens::Generic; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Keyword < ::Rouge::Token; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Keyword::Constant < ::Rouge::Token::Tokens::Keyword; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Keyword::Declaration < ::Rouge::Token::Tokens::Keyword; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Keyword::Namespace < ::Rouge::Token::Tokens::Keyword; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Keyword::Pseudo < ::Rouge::Token::Tokens::Keyword; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Keyword::Reserved < ::Rouge::Token::Tokens::Keyword; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Keyword::Type < ::Rouge::Token::Tokens::Keyword; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Keyword::Variable < ::Rouge::Token::Tokens::Keyword; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal < ::Rouge::Token; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::Date < ::Rouge::Token::Tokens::Literal; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::Number < ::Rouge::Token::Tokens::Literal; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::Number::Bin < ::Rouge::Token::Tokens::Literal::Number; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::Number::Float < ::Rouge::Token::Tokens::Literal::Number; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::Number::Hex < ::Rouge::Token::Tokens::Literal::Number; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::Number::Integer < ::Rouge::Token::Tokens::Literal::Number; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::Number::Integer::Long < ::Rouge::Token::Tokens::Literal::Number::Integer; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::Number::Oct < ::Rouge::Token::Tokens::Literal::Number; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::Number::Other < ::Rouge::Token::Tokens::Literal::Number; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::String < ::Rouge::Token::Tokens::Literal; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::String::Affix < ::Rouge::Token::Tokens::Literal::String; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::String::Backtick < ::Rouge::Token::Tokens::Literal::String; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::String::Char < ::Rouge::Token::Tokens::Literal::String; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::String::Delimiter < ::Rouge::Token::Tokens::Literal::String; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::String::Doc < ::Rouge::Token::Tokens::Literal::String; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::String::Double < ::Rouge::Token::Tokens::Literal::String; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::String::Escape < ::Rouge::Token::Tokens::Literal::String; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::String::Heredoc < ::Rouge::Token::Tokens::Literal::String; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::String::Interpol < ::Rouge::Token::Tokens::Literal::String; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::String::Other < ::Rouge::Token::Tokens::Literal::String; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::String::Regex < ::Rouge::Token::Tokens::Literal::String; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::String::Single < ::Rouge::Token::Tokens::Literal::String; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::String::Symbol < ::Rouge::Token::Tokens::Literal::String; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name < ::Rouge::Token; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Attribute < ::Rouge::Token::Tokens::Name; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Builtin < ::Rouge::Token::Tokens::Name; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Builtin::Pseudo < ::Rouge::Token::Tokens::Name::Builtin; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Class < ::Rouge::Token::Tokens::Name; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Constant < ::Rouge::Token::Tokens::Name; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Decorator < ::Rouge::Token::Tokens::Name; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Entity < ::Rouge::Token::Tokens::Name; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Exception < ::Rouge::Token::Tokens::Name; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Function < ::Rouge::Token::Tokens::Name; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Function::Magic < ::Rouge::Token::Tokens::Name::Function; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Label < ::Rouge::Token::Tokens::Name; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Namespace < ::Rouge::Token::Tokens::Name; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Other < ::Rouge::Token::Tokens::Name; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Property < ::Rouge::Token::Tokens::Name; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Tag < ::Rouge::Token::Tokens::Name; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Variable < ::Rouge::Token::Tokens::Name; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Variable::Class < ::Rouge::Token::Tokens::Name::Variable; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Variable::Global < ::Rouge::Token::Tokens::Name::Variable; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Variable::Instance < ::Rouge::Token::Tokens::Name::Variable; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Variable::Magic < ::Rouge::Token::Tokens::Name::Variable; end

# source://rouge//lib/rouge/token.rb#188
Rouge::Token::Tokens::Num = Rouge::Token::Tokens::Literal::Number

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Operator < ::Rouge::Token; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Operator::Word < ::Rouge::Token::Tokens::Operator; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Other < ::Rouge::Token; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Punctuation < ::Rouge::Token; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Punctuation::Indicator < ::Rouge::Token::Tokens::Punctuation; end

# source://rouge//lib/rouge/token.rb#189
Rouge::Token::Tokens::Str = Rouge::Token::Tokens::Literal::String

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Text < ::Rouge::Token; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Text::Whitespace < ::Rouge::Token::Tokens::Text; end
