# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `activesupport` gem.
# Please instead update this file by running `bin/tapioca gem activesupport`.


# :include: ../README.rdoc
#
# source://activesupport//lib/active_support/array_inquirer.rb#3
module ActiveSupport
  extend ::ActiveSupport::LazyLoadHooks

  # source://activesupport//lib/active_support/json/decoding.rb#9
  def parse_json_times; end

  # source://activesupport//lib/active_support/json/decoding.rb#9
  def parse_json_times=(val); end

  class << self
    # source://activesupport//lib/active_support/json/encoding.rb#8
    def escape_html_entities_in_json(*_arg0, **_arg1, &_arg2); end

    # source://activesupport//lib/active_support/json/encoding.rb#8
    def escape_html_entities_in_json=(arg); end

    # source://activesupport//lib/active_support/json/encoding.rb#8
    def json_encoder(*_arg0, **_arg1, &_arg2); end

    # source://activesupport//lib/active_support/json/encoding.rb#8
    def json_encoder=(arg); end

    # source://activesupport//lib/active_support/json/decoding.rb#9
    def parse_json_times; end

    # source://activesupport//lib/active_support/json/decoding.rb#9
    def parse_json_times=(val); end

    # source://activesupport//lib/active_support/json/encoding.rb#8
    def time_precision(*_arg0, **_arg1, &_arg2); end

    # source://activesupport//lib/active_support/json/encoding.rb#8
    def time_precision=(arg); end

    # source://activesupport//lib/active_support/json/encoding.rb#8
    def use_standard_json_time_format(*_arg0, **_arg1, &_arg2); end

    # source://activesupport//lib/active_support/json/encoding.rb#8
    def use_standard_json_time_format=(arg); end
  end
end

# = \Array Inquirer
#
# Wrapping an array in an +ArrayInquirer+ gives a friendlier way to check
# its string-like contents:
#
#   variants = ActiveSupport::ArrayInquirer.new([:phone, :tablet])
#
#   variants.phone?    # => true
#   variants.tablet?   # => true
#   variants.desktop?  # => false
#
# source://activesupport//lib/active_support/array_inquirer.rb#14
class ActiveSupport::ArrayInquirer < ::Array
  # Passes each element of +candidates+ collection to ArrayInquirer collection.
  # The method returns true if any element from the ArrayInquirer collection
  # is equal to the stringified or symbolized form of any element in the +candidates+ collection.
  #
  # If +candidates+ collection is not given, method returns true.
  #
  #   variants = ActiveSupport::ArrayInquirer.new([:phone, :tablet])
  #
  #   variants.any?                      # => true
  #   variants.any?(:phone, :tablet)     # => true
  #   variants.any?('phone', 'desktop')  # => true
  #   variants.any?(:desktop, :watch)    # => false
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/array_inquirer.rb#27
  def any?(*candidates); end

  private

  # source://activesupport//lib/active_support/array_inquirer.rb#42
  def method_missing(name, *_arg1, **_arg2, &_arg3); end

  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/array_inquirer.rb#38
  def respond_to_missing?(name, include_private = T.unsafe(nil)); end
end

# source://activesupport//lib/active_support/core_ext/big_decimal/conversions.rb#7
module ActiveSupport::BigDecimalWithDefaultFormat
  # source://activesupport//lib/active_support/core_ext/big_decimal/conversions.rb#8
  def to_s(format = T.unsafe(nil)); end
end

# source://activesupport//lib/active_support/core_ext/erb/util.rb#6
module ActiveSupport::CoreExt; end

# source://activesupport//lib/active_support/core_ext/erb/util.rb#7
module ActiveSupport::CoreExt::ERBUtil
  # A utility method for escaping HTML tag characters.
  # This method is also aliased as <tt>h</tt>.
  #
  #   puts html_escape('is a > 0 & a < 10?')
  #   # => is a &gt; 0 &amp; a &lt; 10?
  #
  # source://activesupport//lib/active_support/core_ext/erb/util.rb#25
  def h(s); end

  # A utility method for escaping HTML tag characters.
  # This method is also aliased as <tt>h</tt>.
  #
  #   puts html_escape('is a > 0 & a < 10?')
  #   # => is a &gt; 0 &amp; a &lt; 10?
  #
  # source://activesupport//lib/active_support/core_ext/erb/util.rb#25
  def html_escape(s); end

  # HTML escapes strings but doesn't wrap them with an ActiveSupport::SafeBuffer.
  # This method is not for public consumption! Seriously!
  #
  # source://activesupport//lib/active_support/core_ext/erb/util.rb#10
  def unwrapped_html_escape(s); end
end

# source://activesupport//lib/active_support/core_ext/erb/util.rb#31
module ActiveSupport::CoreExt::ERBUtilPrivate
  include ::ActiveSupport::CoreExt::ERBUtil

  private

  # source://activesupport//lib/active_support/core_ext/erb/util.rb#25
  def h(s); end

  # source://activesupport//lib/active_support/core_ext/erb/util.rb#25
  def html_escape(s); end

  # source://activesupport//lib/active_support/core_ext/erb/util.rb#10
  def unwrapped_html_escape(s); end
end

# Provides +deep_merge+ and +deep_merge!+ methods. Expects the including class
# to provide a <tt>merge!(other, &block)</tt> method.
#
# source://activesupport//lib/active_support/deep_mergeable.rb#6
module ActiveSupport::DeepMergeable
  # Returns a new instance with the values from +other+ merged recursively.
  #
  #   class Hash
  #     include ActiveSupport::DeepMergeable
  #   end
  #
  #   hash_1 = { a: true, b: { c: [1, 2, 3] } }
  #   hash_2 = { a: false, b: { x: [3, 4, 5] } }
  #
  #   hash_1.deep_merge(hash_2)
  #   # => { a: false, b: { c: [1, 2, 3], x: [3, 4, 5] } }
  #
  # A block can be provided to merge non-<tt>DeepMergeable</tt> values:
  #
  #   hash_1 = { a: 100, b: 200, c: { c1: 100 } }
  #   hash_2 = { b: 250, c: { c1: 200 } }
  #
  #   hash_1.deep_merge(hash_2) do |key, this_val, other_val|
  #     this_val + other_val
  #   end
  #   # => { a: 100, b: 450, c: { c1: 300 } }
  #
  # source://activesupport//lib/active_support/deep_mergeable.rb#29
  def deep_merge(other, &block); end

  # Same as #deep_merge, but modifies +self+.
  #
  # source://activesupport//lib/active_support/deep_mergeable.rb#34
  def deep_merge!(other, &block); end

  # Returns true if +other+ can be deep merged into +self+. Classes may
  # override this method to restrict or expand the domain of deep mergeable
  # values. Defaults to checking that +other+ is of type +self.class+.
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/deep_mergeable.rb#49
  def deep_merge?(other); end
end

# source://activesupport//lib/active_support/delegation.rb#14
module ActiveSupport::Delegation
  class << self
    # source://activesupport//lib/active_support/delegation.rb#21
    def generate(owner, methods, location: T.unsafe(nil), to: T.unsafe(nil), prefix: T.unsafe(nil), allow_nil: T.unsafe(nil), nilable: T.unsafe(nil), private: T.unsafe(nil), as: T.unsafe(nil), signature: T.unsafe(nil)); end

    # source://activesupport//lib/active_support/delegation.rb#150
    def generate_method_missing(owner, target, allow_nil: T.unsafe(nil)); end
  end
end

# source://activesupport//lib/active_support/delegation.rb#18
ActiveSupport::Delegation::RESERVED_METHOD_NAMES = T.let(T.unsafe(nil), Set)

# source://activesupport//lib/active_support/delegation.rb#15
ActiveSupport::Delegation::RUBY_RESERVED_KEYWORDS = T.let(T.unsafe(nil), Array)

# Error generated by +delegate+ when a method is called on +nil+ and +allow_nil+
# option is not used.
#
# source://activesupport//lib/active_support/delegation.rb#6
class ActiveSupport::DelegationError < ::NoMethodError
  class << self
    # source://activesupport//lib/active_support/delegation.rb#8
    def nil_target(method_name, target); end
  end
end

# = Active Support \Duration
#
# Provides accurate date and time measurements using Date#advance and
# Time#advance, respectively. It mainly supports the methods on Numeric.
#
#   1.month.ago       # equivalent to Time.now.advance(months: -1)
#
# source://activesupport//lib/active_support/duration.rb#14
class ActiveSupport::Duration
  # @return [Duration] a new instance of Duration
  #
  # source://activesupport//lib/active_support/duration.rb#226
  def initialize(value, parts, variable = T.unsafe(nil)); end

  # Returns the modulo of this Duration by another Duration or Numeric.
  # Numeric values are treated as seconds.
  #
  # source://activesupport//lib/active_support/duration.rb#312
  def %(other); end

  # Multiplies this Duration by a Numeric and returns a new Duration.
  #
  # source://activesupport//lib/active_support/duration.rb#287
  def *(other); end

  # Adds another Duration or a Numeric to this Duration. Numeric values
  # are treated as seconds.
  #
  # source://activesupport//lib/active_support/duration.rb#268
  def +(other); end

  # source://activesupport//lib/active_support/duration.rb#326
  def +@; end

  # Subtracts another Duration or a Numeric from this Duration. Numeric
  # values are treated as seconds.
  #
  # source://activesupport//lib/active_support/duration.rb#282
  def -(other); end

  # source://activesupport//lib/active_support/duration.rb#322
  def -@; end

  # Divides this Duration by a Numeric and returns a new Duration.
  #
  # source://activesupport//lib/active_support/duration.rb#298
  def /(other); end

  # Compares one Duration with another or a Numeric to this Duration.
  # Numeric values are treated as seconds.
  #
  # source://activesupport//lib/active_support/duration.rb#258
  def <=>(other); end

  # Returns +true+ if +other+ is also a Duration instance with the
  # same +value+, or if <tt>other == value</tt>.
  #
  # source://activesupport//lib/active_support/duration.rb#341
  def ==(other); end

  # source://activesupport//lib/active_support/duration.rb#481
  def _parts; end

  # source://activesupport//lib/active_support/duration.rb#224
  def abs(&_arg0); end

  # Calculates a new Time or Date that is as far in the future
  # as this Duration represents.
  #
  # source://activesupport//lib/active_support/duration.rb#436
  def after(time = T.unsafe(nil)); end

  # Calculates a new Time or Date that is as far in the past
  # as this Duration represents.
  #
  # source://activesupport//lib/active_support/duration.rb#444
  def ago(time = T.unsafe(nil)); end

  # source://activesupport//lib/active_support/duration.rb#459
  def as_json(options = T.unsafe(nil)); end

  # Calculates a new Time or Date that is as far in the past
  # as this Duration represents.
  #
  # source://activesupport//lib/active_support/duration.rb#444
  def before(time = T.unsafe(nil)); end

  # source://activesupport//lib/active_support/duration.rb#245
  def coerce(other); end

  # source://activesupport//lib/active_support/duration.rb#467
  def encode_with(coder); end

  # Returns +true+ if +other+ is also a Duration instance, which has the
  # same parts as this one.
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/duration.rb#426
  def eql?(other); end

  # Calculates a new Time or Date that is as far in the future
  # as this Duration represents.
  #
  # source://activesupport//lib/active_support/duration.rb#436
  def from_now(time = T.unsafe(nil)); end

  # source://activesupport//lib/active_support/duration.rb#430
  def hash; end

  # Returns the amount of days a duration covers as a float
  #
  #   12.hours.in_days # => 0.5
  #
  # source://activesupport//lib/active_support/duration.rb#399
  def in_days; end

  # Returns the amount of hours a duration covers as a float
  #
  #   1.day.in_hours # => 24.0
  #
  # source://activesupport//lib/active_support/duration.rb#392
  def in_hours; end

  # Returns the amount of minutes a duration covers as a float
  #
  #   1.day.in_minutes # => 1440.0
  #
  # source://activesupport//lib/active_support/duration.rb#385
  def in_minutes; end

  # Returns the amount of months a duration covers as a float
  #
  #   9.weeks.in_months # => 2.07
  #
  # source://activesupport//lib/active_support/duration.rb#413
  def in_months; end

  # Returns the number of seconds that this Duration represents.
  #
  #   1.minute.to_i   # => 60
  #   1.hour.to_i     # => 3600
  #   1.day.to_i      # => 86400
  #
  # Note that this conversion makes some assumptions about the
  # duration of some periods, e.g. months are always 1/12 of year
  # and years are 365.2425 days:
  #
  #   # equivalent to (1.year / 12).to_i
  #   1.month.to_i    # => 2629746
  #
  #   # equivalent to 365.2425.days.to_i
  #   1.year.to_i     # => 31556952
  #
  # In such cases, Ruby's core
  # Date[https://docs.ruby-lang.org/en/master/Date.html] and
  # Time[https://docs.ruby-lang.org/en/master/Time.html] should be used for precision
  # date and time arithmetic.
  #
  # source://activesupport//lib/active_support/duration.rb#377
  def in_seconds; end

  # Returns the amount of weeks a duration covers as a float
  #
  #   2.months.in_weeks # => 8.696
  #
  # source://activesupport//lib/active_support/duration.rb#406
  def in_weeks; end

  # Returns the amount of years a duration covers as a float
  #
  #   30.days.in_years # => 0.082
  #
  # source://activesupport//lib/active_support/duration.rb#420
  def in_years; end

  # source://activesupport//lib/active_support/duration.rb#463
  def init_with(coder); end

  # source://activesupport//lib/active_support/duration.rb#450
  def inspect; end

  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/duration.rb#335
  def instance_of?(klass); end

  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/duration.rb#330
  def is_a?(klass); end

  # Build ISO 8601 Duration string for this duration.
  # The +precision+ parameter can be used to limit seconds' precision of duration.
  #
  # source://activesupport//lib/active_support/duration.rb#473
  def iso8601(precision: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/duration.rb#330
  def kind_of?(klass); end

  # source://activesupport//lib/active_support/duration.rb#224
  def negative?(&_arg0); end

  # Returns a copy of the parts hash that defines the duration.
  #
  #   5.minutes.parts # => {:minutes=>5}
  #   3.years.parts # => {:years=>3}
  #
  # source://activesupport//lib/active_support/duration.rb#241
  def parts; end

  # source://activesupport//lib/active_support/duration.rb#224
  def positive?(&_arg0); end

  # Calculates a new Time or Date that is as far in the future
  # as this Duration represents.
  #
  # source://activesupport//lib/active_support/duration.rb#436
  def since(time = T.unsafe(nil)); end

  # source://activesupport//lib/active_support/duration.rb#224
  def to_f(&_arg0); end

  # Returns the number of seconds that this Duration represents.
  #
  #   1.minute.to_i   # => 60
  #   1.hour.to_i     # => 3600
  #   1.day.to_i      # => 86400
  #
  # Note that this conversion makes some assumptions about the
  # duration of some periods, e.g. months are always 1/12 of year
  # and years are 365.2425 days:
  #
  #   # equivalent to (1.year / 12).to_i
  #   1.month.to_i    # => 2629746
  #
  #   # equivalent to 365.2425.days.to_i
  #   1.year.to_i     # => 31556952
  #
  # In such cases, Ruby's core
  # Date[https://docs.ruby-lang.org/en/master/Date.html] and
  # Time[https://docs.ruby-lang.org/en/master/Time.html] should be used for precision
  # date and time arithmetic.
  #
  # source://activesupport//lib/active_support/duration.rb#377
  def to_i; end

  # Returns the amount of seconds a duration covers as a string.
  # For more information check to_i method.
  #
  #   1.day.to_s # => "86400"
  #
  # source://activesupport//lib/active_support/duration.rb#353
  def to_s; end

  # Calculates a new Time or Date that is as far in the past
  # as this Duration represents.
  #
  # source://activesupport//lib/active_support/duration.rb#444
  def until(time = T.unsafe(nil)); end

  # Returns the value of attribute value.
  #
  # source://activesupport//lib/active_support/duration.rb#133
  def value; end

  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/duration.rb#477
  def variable?; end

  # source://activesupport//lib/active_support/duration.rb#224
  def zero?(&_arg0); end

  private

  # source://activesupport//lib/active_support/duration.rb#516
  def method_missing(*_arg0, **_arg1, &_arg2); end

  # @raise [TypeError]
  #
  # source://activesupport//lib/active_support/duration.rb#520
  def raise_type_error(other); end

  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/duration.rb#512
  def respond_to_missing?(method, _); end

  # source://activesupport//lib/active_support/duration.rb#486
  def sum(sign, time = T.unsafe(nil)); end

  class << self
    # source://activesupport//lib/active_support/duration.rb#149
    def ===(other); end

    # Creates a new Duration from a seconds value that is converted
    # to the individual parts:
    #
    #   ActiveSupport::Duration.build(31556952).parts # => {:years=>1}
    #   ActiveSupport::Duration.build(2716146).parts  # => {:months=>1, :days=>1}
    #
    # source://activesupport//lib/active_support/duration.rb#189
    def build(value); end

    # source://activesupport//lib/active_support/duration.rb#167
    def days(value); end

    # source://activesupport//lib/active_support/duration.rb#163
    def hours(value); end

    # source://activesupport//lib/active_support/duration.rb#159
    def minutes(value); end

    # source://activesupport//lib/active_support/duration.rb#175
    def months(value); end

    # Creates a new Duration from string formatted according to ISO 8601 Duration.
    #
    # See {ISO 8601}[https://en.wikipedia.org/wiki/ISO_8601#Durations] for more information.
    # This method allows negative parts to be present in pattern.
    # If invalid string is provided, it will raise +ActiveSupport::Duration::ISO8601Parser::ParsingError+.
    #
    # source://activesupport//lib/active_support/duration.rb#144
    def parse(iso8601duration); end

    # source://activesupport//lib/active_support/duration.rb#155
    def seconds(value); end

    # source://activesupport//lib/active_support/duration.rb#171
    def weeks(value); end

    # source://activesupport//lib/active_support/duration.rb#179
    def years(value); end

    private

    # source://activesupport//lib/active_support/duration.rb#217
    def calculate_total_seconds(parts); end
  end
end

# Parses a string formatted according to ISO 8601 Duration into the hash.
#
# See {ISO 8601}[https://en.wikipedia.org/wiki/ISO_8601#Durations] for more information.
#
# This parser allows negative parts to be present in pattern.
#
# source://activesupport//lib/active_support/duration/iso8601_parser.rb#12
class ActiveSupport::Duration::ISO8601Parser
  # @return [ISO8601Parser] a new instance of ISO8601Parser
  #
  # source://activesupport//lib/active_support/duration/iso8601_parser.rb#34
  def initialize(string); end

  # Returns the value of attribute mode.
  #
  # source://activesupport//lib/active_support/duration/iso8601_parser.rb#32
  def mode; end

  # Sets the attribute mode
  #
  # @param value the value to set the attribute mode to.
  #
  # source://activesupport//lib/active_support/duration/iso8601_parser.rb#32
  def mode=(_arg0); end

  # source://activesupport//lib/active_support/duration/iso8601_parser.rb#41
  def parse!; end

  # Returns the value of attribute parts.
  #
  # source://activesupport//lib/active_support/duration/iso8601_parser.rb#31
  def parts; end

  # Returns the value of attribute scanner.
  #
  # source://activesupport//lib/active_support/duration/iso8601_parser.rb#31
  def scanner; end

  # Returns the value of attribute sign.
  #
  # source://activesupport//lib/active_support/duration/iso8601_parser.rb#32
  def sign; end

  # Sets the attribute sign
  #
  # @param value the value to set the attribute sign to.
  #
  # source://activesupport//lib/active_support/duration/iso8601_parser.rb#32
  def sign=(_arg0); end

  private

  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/duration/iso8601_parser.rb#83
  def finished?; end

  # Parses number which can be a float with either comma or period.
  #
  # source://activesupport//lib/active_support/duration/iso8601_parser.rb#88
  def number; end

  # @raise [ParsingError]
  #
  # source://activesupport//lib/active_support/duration/iso8601_parser.rb#96
  def raise_parsing_error(reason = T.unsafe(nil)); end

  # source://activesupport//lib/active_support/duration/iso8601_parser.rb#92
  def scan(pattern); end

  # Checks for various semantic errors as stated in ISO 8601 standard.
  #
  # source://activesupport//lib/active_support/duration/iso8601_parser.rb#101
  def validate!; end
end

# source://activesupport//lib/active_support/duration/iso8601_parser.rb#17
ActiveSupport::Duration::ISO8601Parser::COMMA = T.let(T.unsafe(nil), String)

# source://activesupport//lib/active_support/duration/iso8601_parser.rb#22
ActiveSupport::Duration::ISO8601Parser::DATE_COMPONENT = T.let(T.unsafe(nil), Regexp)

# source://activesupport//lib/active_support/duration/iso8601_parser.rb#28
ActiveSupport::Duration::ISO8601Parser::DATE_COMPONENTS = T.let(T.unsafe(nil), Array)

# source://activesupport//lib/active_support/duration/iso8601_parser.rb#20
ActiveSupport::Duration::ISO8601Parser::DATE_MARKER = T.let(T.unsafe(nil), Regexp)

# source://activesupport//lib/active_support/duration/iso8601_parser.rb#25
ActiveSupport::Duration::ISO8601Parser::DATE_TO_PART = T.let(T.unsafe(nil), Hash)

# source://activesupport//lib/active_support/duration/iso8601_parser.rb#16
ActiveSupport::Duration::ISO8601Parser::PERIOD = T.let(T.unsafe(nil), String)

# source://activesupport//lib/active_support/duration/iso8601_parser.rb#15
ActiveSupport::Duration::ISO8601Parser::PERIOD_OR_COMMA = T.let(T.unsafe(nil), Regexp)

# source://activesupport//lib/active_support/duration/iso8601_parser.rb#13
class ActiveSupport::Duration::ISO8601Parser::ParsingError < ::ArgumentError; end

# source://activesupport//lib/active_support/duration/iso8601_parser.rb#19
ActiveSupport::Duration::ISO8601Parser::SIGN_MARKER = T.let(T.unsafe(nil), Regexp)

# source://activesupport//lib/active_support/duration/iso8601_parser.rb#23
ActiveSupport::Duration::ISO8601Parser::TIME_COMPONENT = T.let(T.unsafe(nil), Regexp)

# source://activesupport//lib/active_support/duration/iso8601_parser.rb#29
ActiveSupport::Duration::ISO8601Parser::TIME_COMPONENTS = T.let(T.unsafe(nil), Array)

# source://activesupport//lib/active_support/duration/iso8601_parser.rb#21
ActiveSupport::Duration::ISO8601Parser::TIME_MARKER = T.let(T.unsafe(nil), Regexp)

# source://activesupport//lib/active_support/duration/iso8601_parser.rb#26
ActiveSupport::Duration::ISO8601Parser::TIME_TO_PART = T.let(T.unsafe(nil), Hash)

# Serializes duration to string according to ISO 8601 Duration format.
#
# source://activesupport//lib/active_support/duration/iso8601_serializer.rb#6
class ActiveSupport::Duration::ISO8601Serializer
  # @return [ISO8601Serializer] a new instance of ISO8601Serializer
  #
  # source://activesupport//lib/active_support/duration/iso8601_serializer.rb#9
  def initialize(duration, precision: T.unsafe(nil)); end

  # Builds and returns output string.
  #
  # source://activesupport//lib/active_support/duration/iso8601_serializer.rb#15
  def serialize; end

  private

  # source://activesupport//lib/active_support/duration/iso8601_serializer.rb#55
  def format_seconds(seconds); end

  # Return pair of duration's parts and whole duration sign.
  # Parts are summarized (as they can become repetitive due to addition, etc).
  # Zero parts are removed as not significant.
  #
  # source://activesupport//lib/active_support/duration/iso8601_serializer.rb#38
  def normalize; end

  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/duration/iso8601_serializer.rb#51
  def week_mixed_with_date?(parts); end
end

# source://activesupport//lib/active_support/duration/iso8601_serializer.rb#7
ActiveSupport::Duration::ISO8601Serializer::DATE_COMPONENTS = T.let(T.unsafe(nil), Array)

# source://activesupport//lib/active_support/duration.rb#130
ActiveSupport::Duration::PARTS = T.let(T.unsafe(nil), Array)

# source://activesupport//lib/active_support/duration.rb#120
ActiveSupport::Duration::PARTS_IN_SECONDS = T.let(T.unsafe(nil), Hash)

# source://activesupport//lib/active_support/duration.rb#115
ActiveSupport::Duration::SECONDS_PER_DAY = T.let(T.unsafe(nil), Integer)

# source://activesupport//lib/active_support/duration.rb#114
ActiveSupport::Duration::SECONDS_PER_HOUR = T.let(T.unsafe(nil), Integer)

# source://activesupport//lib/active_support/duration.rb#113
ActiveSupport::Duration::SECONDS_PER_MINUTE = T.let(T.unsafe(nil), Integer)

# 1/12 of a gregorian year
#
# source://activesupport//lib/active_support/duration.rb#117
ActiveSupport::Duration::SECONDS_PER_MONTH = T.let(T.unsafe(nil), Integer)

# source://activesupport//lib/active_support/duration.rb#116
ActiveSupport::Duration::SECONDS_PER_WEEK = T.let(T.unsafe(nil), Integer)

# length of a gregorian year (365.2425 days)
#
# source://activesupport//lib/active_support/duration.rb#118
ActiveSupport::Duration::SECONDS_PER_YEAR = T.let(T.unsafe(nil), Integer)

# source://activesupport//lib/active_support/duration.rb#15
class ActiveSupport::Duration::Scalar < ::Numeric
  # @return [Scalar] a new instance of Scalar
  #
  # source://activesupport//lib/active_support/duration.rb#19
  def initialize(value); end

  # source://activesupport//lib/active_support/duration.rb#85
  def %(other); end

  # source://activesupport//lib/active_support/duration.rb#66
  def *(other); end

  # source://activesupport//lib/active_support/duration.rb#41
  def +(other); end

  # source://activesupport//lib/active_support/duration.rb#53
  def -(other); end

  # source://activesupport//lib/active_support/duration.rb#27
  def -@; end

  # source://activesupport//lib/active_support/duration.rb#77
  def /(other); end

  # source://activesupport//lib/active_support/duration.rb#31
  def <=>(other); end

  # source://activesupport//lib/active_support/duration.rb#23
  def coerce(other); end

  # source://activesupport//lib/active_support/duration.rb#17
  def to_f(*_arg0, **_arg1, &_arg2); end

  # source://activesupport//lib/active_support/duration.rb#17
  def to_i(*_arg0, **_arg1, &_arg2); end

  # source://activesupport//lib/active_support/duration.rb#17
  def to_s(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute value.
  #
  # source://activesupport//lib/active_support/duration.rb#16
  def value; end

  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/duration.rb#93
  def variable?; end

  private

  # source://activesupport//lib/active_support/duration.rb#98
  def calculate(op, other); end

  # @raise [TypeError]
  #
  # source://activesupport//lib/active_support/duration.rb#108
  def raise_type_error(other); end
end

# source://activesupport//lib/active_support/duration.rb#131
ActiveSupport::Duration::VARIABLE_PARTS = T.let(T.unsafe(nil), Array)

# = Active Support \Inflector
#
# The Inflector transforms words from singular to plural, class names to table
# names, modularized class names to ones without, and class names to foreign
# keys. The default inflections for pluralization, singularization, and
# uncountable words are kept in inflections.rb.
#
# The \Rails core team has stated patches for the inflections library will not
# be accepted in order to avoid breaking legacy applications which may be
# relying on errant inflections. If you discover an incorrect inflection and
# require it for your application or wish to define rules for languages other
# than English, please correct or add them yourself (explained below).
#
# source://activesupport//lib/active_support/inflector/inflections.rb#7
module ActiveSupport::Inflector
  extend ::ActiveSupport::Inflector

  # Converts strings to UpperCamelCase.
  # If the +uppercase_first_letter+ parameter is set to false, then produces
  # lowerCamelCase.
  #
  # Also converts '/' to '::' which is useful for converting
  # paths to namespaces.
  #
  #   camelize('active_model')                # => "ActiveModel"
  #   camelize('active_model', false)         # => "activeModel"
  #   camelize('active_model/errors')         # => "ActiveModel::Errors"
  #   camelize('active_model/errors', false)  # => "activeModel::Errors"
  #
  # As a rule of thumb you can think of +camelize+ as the inverse of
  # #underscore, though there are cases where that does not hold:
  #
  #   camelize(underscore('SSLError'))        # => "SslError"
  #
  # source://activesupport//lib/active_support/inflector/methods.rb#70
  def camelize(term, uppercase_first_letter = T.unsafe(nil)); end

  # Creates a class name from a plural table name like \Rails does for table
  # names to models. Note that this returns a string and not a Class. (To
  # convert to an actual class follow +classify+ with #constantize.)
  #
  #   classify('ham_and_eggs') # => "HamAndEgg"
  #   classify('posts')        # => "Post"
  #
  # Singular names are not handled correctly:
  #
  #   classify('calculus')     # => "Calculu"
  #
  # source://activesupport//lib/active_support/inflector/methods.rb#218
  def classify(table_name); end

  # Tries to find a constant with the name specified in the argument string.
  #
  #   constantize('Module')   # => Module
  #   constantize('Foo::Bar') # => Foo::Bar
  #
  # The name is assumed to be the one of a top-level constant, no matter
  # whether it starts with "::" or not. No lexical context is taken into
  # account:
  #
  #   C = 'outside'
  #   module M
  #     C = 'inside'
  #     C                # => 'inside'
  #     constantize('C') # => 'outside', same as ::C
  #   end
  #
  # NameError is raised when the name is not in CamelCase or the constant is
  # unknown.
  #
  # source://activesupport//lib/active_support/inflector/methods.rb#289
  def constantize(camel_cased_word); end

  # Replaces underscores with dashes in the string.
  #
  #   dasherize('puni_puni') # => "puni-puni"
  #
  # source://activesupport//lib/active_support/inflector/methods.rb#226
  def dasherize(underscored_word); end

  # Removes the rightmost segment from the constant expression in the string.
  #
  #   deconstantize('Net::HTTP')   # => "Net"
  #   deconstantize('::Net::HTTP') # => "::Net"
  #   deconstantize('String')      # => ""
  #   deconstantize('::String')    # => ""
  #   deconstantize('')            # => ""
  #
  # See also #demodulize.
  #
  # source://activesupport//lib/active_support/inflector/methods.rb#256
  def deconstantize(path); end

  # Removes the module part from the expression in the string.
  #
  #   demodulize('ActiveSupport::Inflector::Inflections') # => "Inflections"
  #   demodulize('Inflections')                           # => "Inflections"
  #   demodulize('::Inflections')                         # => "Inflections"
  #   demodulize('')                                      # => ""
  #
  # See also #deconstantize.
  #
  # source://activesupport//lib/active_support/inflector/methods.rb#238
  def demodulize(path); end

  # Converts the first character in the string to lowercase.
  #
  #   downcase_first('If they enjoyed The Matrix') # => "if they enjoyed The Matrix"
  #   downcase_first('I')                          # => "i"
  #   downcase_first('')                           # => ""
  #
  # source://activesupport//lib/active_support/inflector/methods.rb#175
  def downcase_first(string); end

  # Creates a foreign key name from a class name.
  # +separate_class_name_and_id_with_underscore+ sets whether
  # the method should put '_' between the name and 'id'.
  #
  #   foreign_key('Message')        # => "message_id"
  #   foreign_key('Message', false) # => "messageid"
  #   foreign_key('Admin::Post')    # => "post_id"
  #
  # source://activesupport//lib/active_support/inflector/methods.rb#267
  def foreign_key(class_name, separate_class_name_and_id_with_underscore = T.unsafe(nil)); end

  # Tweaks an attribute name for display to end users.
  #
  # Specifically, performs these transformations:
  #
  # * Applies human inflection rules to the argument.
  # * Deletes leading underscores, if any.
  # * Removes an "_id" suffix if present.
  # * Replaces underscores with spaces, if any.
  # * Downcases all words except acronyms.
  # * Capitalizes the first word.
  # The capitalization of the first word can be turned off by setting the
  # +:capitalize+ option to false (default is true).
  #
  # The trailing '_id' can be kept and capitalized by setting the
  # optional parameter +keep_id_suffix+ to true (default is false).
  #
  #   humanize('employee_salary')                  # => "Employee salary"
  #   humanize('author_id')                        # => "Author"
  #   humanize('author_id', capitalize: false)     # => "author"
  #   humanize('_id')                              # => "Id"
  #   humanize('author_id', keep_id_suffix: true)  # => "Author id"
  #
  # If "SSL" was defined to be an acronym:
  #
  #   humanize('ssl_error') # => "SSL error"
  #
  # source://activesupport//lib/active_support/inflector/methods.rb#135
  def humanize(lower_case_and_underscored_word, capitalize: T.unsafe(nil), keep_id_suffix: T.unsafe(nil)); end

  # Yields a singleton instance of Inflector::Inflections so you can specify
  # additional inflector rules. If passed an optional locale, rules for other
  # languages can be specified. If not specified, defaults to <tt>:en</tt>.
  # Only rules for English are provided.
  #
  #   ActiveSupport::Inflector.inflections(:en) do |inflect|
  #     inflect.uncountable 'rails'
  #   end
  #
  # source://activesupport//lib/active_support/inflector/inflections.rb#265
  def inflections(locale = T.unsafe(nil)); end

  # Returns the suffix that should be added to a number to denote the position
  # in an ordered sequence such as 1st, 2nd, 3rd, 4th.
  #
  #   ordinal(1)     # => "st"
  #   ordinal(2)     # => "nd"
  #   ordinal(1002)  # => "nd"
  #   ordinal(1003)  # => "rd"
  #   ordinal(-11)   # => "th"
  #   ordinal(-1021) # => "st"
  #
  # source://activesupport//lib/active_support/inflector/methods.rb#334
  def ordinal(number); end

  # Turns a number into an ordinal string used to denote the position in an
  # ordered sequence such as 1st, 2nd, 3rd, 4th.
  #
  #   ordinalize(1)     # => "1st"
  #   ordinalize(2)     # => "2nd"
  #   ordinalize(1002)  # => "1002nd"
  #   ordinalize(1003)  # => "1003rd"
  #   ordinalize(-11)   # => "-11th"
  #   ordinalize(-1021) # => "-1021st"
  #
  # source://activesupport//lib/active_support/inflector/methods.rb#347
  def ordinalize(number); end

  # Replaces special characters in a string so that it may be used as part of
  # a 'pretty' URL.
  #
  #   parameterize("Donald E. Knuth") # => "donald-e-knuth"
  #   parameterize("^très|Jolie-- ")  # => "tres-jolie"
  #
  # To use a custom separator, override the +separator+ argument.
  #
  #   parameterize("Donald E. Knuth", separator: '_') # => "donald_e_knuth"
  #   parameterize("^très|Jolie__ ", separator: '_')  # => "tres_jolie"
  #
  # To preserve the case of the characters in a string, use the +preserve_case+ argument.
  #
  #   parameterize("Donald E. Knuth", preserve_case: true) # => "Donald-E-Knuth"
  #   parameterize("^très|Jolie-- ", preserve_case: true) # => "tres-Jolie"
  #
  # It preserves dashes and underscores unless they are used as separators:
  #
  #   parameterize("^très|Jolie__ ")                 # => "tres-jolie__"
  #   parameterize("^très|Jolie-- ", separator: "_") # => "tres_jolie--"
  #   parameterize("^très_Jolie-- ", separator: ".") # => "tres_jolie--"
  #
  # If the optional parameter +locale+ is specified,
  # the word will be parameterized as a word of that language.
  # By default, this parameter is set to <tt>nil</tt> and it will use
  # the configured <tt>I18n.locale</tt>.
  #
  # source://activesupport//lib/active_support/inflector/transliterate.rb#123
  def parameterize(string, separator: T.unsafe(nil), preserve_case: T.unsafe(nil), locale: T.unsafe(nil)); end

  # Returns the plural form of the word in the string.
  #
  # If passed an optional +locale+ parameter, the word will be
  # pluralized using rules defined for that language. By default,
  # this parameter is set to <tt>:en</tt>.
  #
  #   pluralize('post')             # => "posts"
  #   pluralize('octopus')          # => "octopi"
  #   pluralize('sheep')            # => "sheep"
  #   pluralize('words')            # => "words"
  #   pluralize('CamelOctopus')     # => "CamelOctopi"
  #   pluralize('ley', :es)         # => "leyes"
  #
  # source://activesupport//lib/active_support/inflector/methods.rb#33
  def pluralize(word, locale = T.unsafe(nil)); end

  # Tries to find a constant with the name specified in the argument string.
  #
  #   safe_constantize('Module')   # => Module
  #   safe_constantize('Foo::Bar') # => Foo::Bar
  #
  # The name is assumed to be the one of a top-level constant, no matter
  # whether it starts with "::" or not. No lexical context is taken into
  # account:
  #
  #   C = 'outside'
  #   module M
  #     C = 'inside'
  #     C                     # => 'inside'
  #     safe_constantize('C') # => 'outside', same as ::C
  #   end
  #
  # +nil+ is returned when the name is not in CamelCase or the constant (or
  # part of it) is unknown.
  #
  #   safe_constantize('blargle')                  # => nil
  #   safe_constantize('UnknownModule')            # => nil
  #   safe_constantize('UnknownModule::Foo::Bar')  # => nil
  #
  # source://activesupport//lib/active_support/inflector/methods.rb#315
  def safe_constantize(camel_cased_word); end

  # The reverse of #pluralize, returns the singular form of a word in a
  # string.
  #
  # If passed an optional +locale+ parameter, the word will be
  # singularized using rules defined for that language. By default,
  # this parameter is set to <tt>:en</tt>.
  #
  #   singularize('posts')            # => "post"
  #   singularize('octopi')           # => "octopus"
  #   singularize('sheep')            # => "sheep"
  #   singularize('word')             # => "word"
  #   singularize('CamelOctopi')      # => "CamelOctopus"
  #   singularize('leyes', :es)       # => "ley"
  #
  # source://activesupport//lib/active_support/inflector/methods.rb#50
  def singularize(word, locale = T.unsafe(nil)); end

  # Creates the name of a table like \Rails does for models to table names.
  # This method uses the #pluralize method on the last word in the string.
  #
  #   tableize('RawScaledScorer') # => "raw_scaled_scorers"
  #   tableize('ham_and_egg')     # => "ham_and_eggs"
  #   tableize('fancyCategory')   # => "fancy_categories"
  #
  # source://activesupport//lib/active_support/inflector/methods.rb#204
  def tableize(class_name); end

  # Capitalizes all the words and replaces some characters in the string to
  # create a nicer looking title. +titleize+ is meant for creating pretty
  # output. It is not used in the \Rails internals.
  #
  # The trailing '_id','Id'.. can be kept and capitalized by setting the
  # optional parameter +keep_id_suffix+ to true.
  # By default, this parameter is false.
  #
  #   titleize('man from the boondocks')                       # => "Man From The Boondocks"
  #   titleize('x-men: the last stand')                        # => "X Men: The Last Stand"
  #   titleize('TheManWithoutAPast')                           # => "The Man Without A Past"
  #   titleize('raiders_of_the_lost_ark')                      # => "Raiders Of The Lost Ark"
  #   titleize('string_ending_with_id', keep_id_suffix: true)  # => "String Ending With Id"
  #
  # source://activesupport//lib/active_support/inflector/methods.rb#192
  def titleize(word, keep_id_suffix: T.unsafe(nil)); end

  # Replaces non-ASCII characters with an ASCII approximation, or if none
  # exists, a replacement character which defaults to "?".
  #
  #    transliterate('Ærøskøbing')
  #    # => "AEroskobing"
  #
  # Default approximations are provided for Western/Latin characters,
  # e.g, "ø", "ñ", "é", "ß", etc.
  #
  # This method is I18n aware, so you can set up custom approximations for a
  # locale. This can be useful, for example, to transliterate German's "ü"
  # and "ö" to "ue" and "oe", or to add support for transliterating Russian
  # to ASCII.
  #
  # In order to make your custom transliterations available, you must set
  # them as the <tt>i18n.transliterate.rule</tt> i18n key:
  #
  #   # Store the transliterations in locales/de.yml
  #   i18n:
  #     transliterate:
  #       rule:
  #         ü: "ue"
  #         ö: "oe"
  #
  #   # Or set them using Ruby
  #   I18n.backend.store_translations(:de, i18n: {
  #     transliterate: {
  #       rule: {
  #         'ü' => 'ue',
  #         'ö' => 'oe'
  #       }
  #     }
  #   })
  #
  # The value for <tt>i18n.transliterate.rule</tt> can be a simple Hash that
  # maps characters to ASCII approximations as shown above, or, for more
  # complex requirements, a Proc:
  #
  #   I18n.backend.store_translations(:de, i18n: {
  #     transliterate: {
  #       rule: ->(string) { MyTransliterator.transliterate(string) }
  #     }
  #   })
  #
  # Now you can have different transliterations for each locale:
  #
  #   transliterate('Jürgen', locale: :en)
  #   # => "Jurgen"
  #
  #   transliterate('Jürgen', locale: :de)
  #   # => "Juergen"
  #
  # Transliteration is restricted to UTF-8, US-ASCII, and GB18030 strings.
  # Other encodings will raise an ArgumentError.
  #
  # @raise [ArgumentError]
  #
  # source://activesupport//lib/active_support/inflector/transliterate.rb#64
  def transliterate(string, replacement = T.unsafe(nil), locale: T.unsafe(nil)); end

  # Makes an underscored, lowercase form from the expression in the string.
  #
  # Changes '::' to '/' to convert namespaces to paths.
  #
  #   underscore('ActiveModel')         # => "active_model"
  #   underscore('ActiveModel::Errors') # => "active_model/errors"
  #
  # As a rule of thumb you can think of +underscore+ as the inverse of
  # #camelize, though there are cases where that does not hold:
  #
  #   camelize(underscore('SSLError'))  # => "SslError"
  #
  # source://activesupport//lib/active_support/inflector/methods.rb#99
  def underscore(camel_cased_word); end

  # Converts the first character in the string to uppercase.
  #
  #   upcase_first('what a Lovely Day') # => "What a Lovely Day"
  #   upcase_first('w')                 # => "W"
  #   upcase_first('')                  # => ""
  #
  # source://activesupport//lib/active_support/inflector/methods.rb#166
  def upcase_first(string); end

  private

  # Applies inflection rules for +singularize+ and +pluralize+.
  #
  # If passed an optional +locale+ parameter, the uncountables will be
  # found for that locale.
  #
  #   apply_inflections('post', inflections.plurals, :en)    # => "posts"
  #   apply_inflections('posts', inflections.singulars, :en) # => "post"
  #
  # source://activesupport//lib/active_support/inflector/methods.rb#376
  def apply_inflections(word, rules, locale = T.unsafe(nil)); end

  # Mounts a regular expression, returned as a string to ease interpolation,
  # that will match part by part the given constant.
  #
  #   const_regexp("Foo::Bar::Baz") # => "Foo(::Bar(::Baz)?)?"
  #   const_regexp("::")            # => "::"
  #
  # source://activesupport//lib/active_support/inflector/methods.rb#357
  def const_regexp(camel_cased_word); end
end

# source://activesupport//lib/active_support/inflector/transliterate.rb#8
ActiveSupport::Inflector::ALLOWED_ENCODINGS_FOR_TRANSLITERATE = T.let(T.unsafe(nil), Array)

# = Active Support \Inflections
#
# A singleton instance of this class is yielded by Inflector.inflections,
# which can then be used to specify additional inflection rules. If passed
# an optional locale, rules for other languages can be specified. The
# default locale is <tt>:en</tt>. Only rules for English are provided.
#
#   ActiveSupport::Inflector.inflections(:en) do |inflect|
#     inflect.plural /^(ox)$/i, '\1\2en'
#     inflect.singular /^(ox)en/i, '\1'
#
#     inflect.irregular 'cactus', 'cacti'
#
#     inflect.uncountable 'equipment'
#   end
#
# New rules are added at the top. So in the example above, the irregular
# rule for cactus will now be the first of the pluralization and
# singularization rules that is runs. This guarantees that your rules run
# before any of the rules that may already have been loaded.
#
# source://activesupport//lib/active_support/inflector/inflections.rb#30
class ActiveSupport::Inflector::Inflections
  # @return [Inflections] a new instance of Inflections
  #
  # source://activesupport//lib/active_support/inflector/inflections.rb#80
  def initialize; end

  # Specifies a new acronym. An acronym must be specified as it will appear
  # in a camelized string. An underscore string that contains the acronym
  # will retain the acronym when passed to +camelize+, +humanize+, or
  # +titleize+. A camelized string that contains the acronym will maintain
  # the acronym when titleized or humanized, and will convert the acronym
  # into a non-delimited single lowercase word when passed to +underscore+.
  #
  #   acronym 'HTML'
  #   titleize 'html'     # => 'HTML'
  #   camelize 'html'     # => 'HTML'
  #   underscore 'MyHTML' # => 'my_html'
  #
  # The acronym, however, must occur as a delimited unit and not be part of
  # another word for conversions to recognize it:
  #
  #   acronym 'HTTP'
  #   camelize 'my_http_delimited' # => 'MyHTTPDelimited'
  #   camelize 'https'             # => 'Https', not 'HTTPs'
  #   underscore 'HTTPS'           # => 'http_s', not 'https'
  #
  #   acronym 'HTTPS'
  #   camelize 'https'   # => 'HTTPS'
  #   underscore 'HTTPS' # => 'https'
  #
  # Note: Acronyms that are passed to +pluralize+ will no longer be
  # recognized, since the acronym will not occur as a delimited unit in the
  # pluralized result. To work around this, you must specify the pluralized
  # form as an acronym as well:
  #
  #    acronym 'API'
  #    camelize(pluralize('api')) # => 'Apis'
  #
  #    acronym 'APIs'
  #    camelize(pluralize('api')) # => 'APIs'
  #
  # +acronym+ may be used to specify any word that contains an acronym or
  # otherwise needs to maintain a non-standard capitalization. The only
  # restriction is that the word must begin with a capital letter.
  #
  #   acronym 'RESTful'
  #   underscore 'RESTful'           # => 'restful'
  #   underscore 'RESTfulController' # => 'restful_controller'
  #   titleize 'RESTfulController'   # => 'RESTful Controller'
  #   camelize 'restful'             # => 'RESTful'
  #   camelize 'restful_controller'  # => 'RESTfulController'
  #
  #   acronym 'McDonald'
  #   underscore 'McDonald' # => 'mcdonald'
  #   camelize 'mcdonald'   # => 'McDonald'
  #
  # source://activesupport//lib/active_support/inflector/inflections.rb#142
  def acronym(word); end

  # Returns the value of attribute acronyms.
  #
  # source://activesupport//lib/active_support/inflector/inflections.rb#76
  def acronyms; end

  # source://activesupport//lib/active_support/inflector/inflections.rb#78
  def acronyms_camelize_regex; end

  # source://activesupport//lib/active_support/inflector/inflections.rb#78
  def acronyms_underscore_regex; end

  # Clears the loaded inflections within a given scope (default is
  # <tt>:all</tt>). Give the scope as a symbol of the inflection type, the
  # options are: <tt>:plurals</tt>, <tt>:singulars</tt>, <tt>:uncountables</tt>,
  # <tt>:humans</tt>, <tt>:acronyms</tt>.
  #
  #   clear :all
  #   clear :plurals
  #
  # source://activesupport//lib/active_support/inflector/inflections.rb#231
  def clear(scope = T.unsafe(nil)); end

  # Specifies a humanized form of a string by a regular expression rule or
  # by a string mapping. When using a regular expression based replacement,
  # the normal humanize formatting is called after the replacement. When a
  # string is used, the human form should be specified as desired (example:
  # 'The name', not 'the_name').
  #
  #   human /_cnt$/i, '\1_count'
  #   human 'legacy_col_person_name', 'Name'
  #
  # source://activesupport//lib/active_support/inflector/inflections.rb#220
  def human(rule, replacement); end

  # Returns the value of attribute humans.
  #
  # source://activesupport//lib/active_support/inflector/inflections.rb#76
  def humans; end

  # Specifies a new irregular that applies to both pluralization and
  # singularization at the same time. This can only be used for strings, not
  # regular expressions. You simply pass the irregular in singular and
  # plural form.
  #
  #   irregular 'cactus', 'cacti'
  #   irregular 'person', 'people'
  #
  # source://activesupport//lib/active_support/inflector/inflections.rb#174
  def irregular(singular, plural); end

  # Specifies a new pluralization rule and its replacement. The rule can
  # either be a string or a regular expression. The replacement should
  # always be a string that may include references to the matched data from
  # the rule.
  #
  # source://activesupport//lib/active_support/inflector/inflections.rb#151
  def plural(rule, replacement); end

  # Returns the value of attribute plurals.
  #
  # source://activesupport//lib/active_support/inflector/inflections.rb#76
  def plurals; end

  # Specifies a new singularization rule and its replacement. The rule can
  # either be a string or a regular expression. The replacement should
  # always be a string that may include references to the matched data from
  # the rule.
  #
  # source://activesupport//lib/active_support/inflector/inflections.rb#161
  def singular(rule, replacement); end

  # Returns the value of attribute singulars.
  #
  # source://activesupport//lib/active_support/inflector/inflections.rb#76
  def singulars; end

  # Specifies words that are uncountable and should not be inflected.
  #
  #   uncountable 'money'
  #   uncountable 'money', 'information'
  #   uncountable %w( money information rice )
  #
  # source://activesupport//lib/active_support/inflector/inflections.rb#208
  def uncountable(*words); end

  # Returns the value of attribute uncountables.
  #
  # source://activesupport//lib/active_support/inflector/inflections.rb#76
  def uncountables; end

  private

  # source://activesupport//lib/active_support/inflector/inflections.rb#250
  def define_acronym_regex_patterns; end

  # Private, for the test suite.
  #
  # source://activesupport//lib/active_support/inflector/inflections.rb#86
  def initialize_dup(orig); end

  class << self
    # source://activesupport//lib/active_support/inflector/inflections.rb#65
    def instance(locale = T.unsafe(nil)); end

    # source://activesupport//lib/active_support/inflector/inflections.rb#69
    def instance_or_fallback(locale); end
  end
end

# source://activesupport//lib/active_support/inflector/inflections.rb#33
class ActiveSupport::Inflector::Inflections::Uncountables < ::Array
  # @return [Uncountables] a new instance of Uncountables
  #
  # source://activesupport//lib/active_support/inflector/inflections.rb#34
  def initialize; end

  # source://activesupport//lib/active_support/inflector/inflections.rb#44
  def <<(*word); end

  # source://activesupport//lib/active_support/inflector/inflections.rb#48
  def add(words); end

  # source://activesupport//lib/active_support/inflector/inflections.rb#39
  def delete(entry); end

  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/inflector/inflections.rb#55
  def uncountable?(str); end

  private

  # source://activesupport//lib/active_support/inflector/inflections.rb#60
  def to_regex(string); end
end

# source://activesupport//lib/active_support/json/decoding.rb#11
module ActiveSupport::JSON
  class << self
    # Parses a JSON string (JavaScript Object Notation) into a hash.
    # See http://www.json.org for more info.
    #
    #   ActiveSupport::JSON.decode("{\"team\":\"rails\",\"players\":\"36\"}")
    #   => {"team" => "rails", "players" => "36"}
    #
    # source://activesupport//lib/active_support/json/decoding.rb#22
    def decode(json); end

    # Dumps objects in JSON (JavaScript Object Notation).
    # See http://www.json.org for more info.
    #
    #   ActiveSupport::JSON.encode({ team: 'rails', players: '36' })
    #   # => "{\"team\":\"rails\",\"players\":\"36\"}"
    #
    # Generates JSON that is safe to include in JavaScript as it escapes
    # U+2028 (Line Separator) and U+2029 (Paragraph Separator):
    #
    #   ActiveSupport::JSON.encode({ key: "\u2028" })
    #   # => "{\"key\":\"\\u2028\"}"
    #
    # By default, it also generates JSON that is safe to include in HTML, as
    # it escapes <tt><</tt>, <tt>></tt>, and <tt>&</tt>:
    #
    #   ActiveSupport::JSON.encode({ key: "<>&" })
    #   # => "{\"key\":\"\\u003c\\u003e\\u0026\"}"
    #
    # This can be changed with the +escape_html_entities+ option, or the
    # global escape_html_entities_in_json configuration option.
    #
    #   ActiveSupport::JSON.encode({ key: "<>&" }, escape_html_entities: false)
    #   # => "{\"key\":\"<>&\"}"
    #
    # source://activesupport//lib/active_support/json/encoding.rb#40
    def dump(value, options = T.unsafe(nil)); end

    # Dumps objects in JSON (JavaScript Object Notation).
    # See http://www.json.org for more info.
    #
    #   ActiveSupport::JSON.encode({ team: 'rails', players: '36' })
    #   # => "{\"team\":\"rails\",\"players\":\"36\"}"
    #
    # Generates JSON that is safe to include in JavaScript as it escapes
    # U+2028 (Line Separator) and U+2029 (Paragraph Separator):
    #
    #   ActiveSupport::JSON.encode({ key: "\u2028" })
    #   # => "{\"key\":\"\\u2028\"}"
    #
    # By default, it also generates JSON that is safe to include in HTML, as
    # it escapes <tt><</tt>, <tt>></tt>, and <tt>&</tt>:
    #
    #   ActiveSupport::JSON.encode({ key: "<>&" })
    #   # => "{\"key\":\"\\u003c\\u003e\\u0026\"}"
    #
    # This can be changed with the +escape_html_entities+ option, or the
    # global escape_html_entities_in_json configuration option.
    #
    #   ActiveSupport::JSON.encode({ key: "<>&" }, escape_html_entities: false)
    #   # => "{\"key\":\"<>&\"}"
    #
    # source://activesupport//lib/active_support/json/encoding.rb#40
    def encode(value, options = T.unsafe(nil)); end

    # Parses a JSON string (JavaScript Object Notation) into a hash.
    # See http://www.json.org for more info.
    #
    #   ActiveSupport::JSON.decode("{\"team\":\"rails\",\"players\":\"36\"}")
    #   => {"team" => "rails", "players" => "36"}
    #
    # source://activesupport//lib/active_support/json/decoding.rb#22
    def load(json); end

    # Returns the class of the error that will be raised when there is an
    # error in decoding JSON. Using this method means you won't directly
    # depend on the ActiveSupport's JSON implementation, in case it changes
    # in the future.
    #
    #   begin
    #     obj = ActiveSupport::JSON.decode(some_string)
    #   rescue ActiveSupport::JSON.parse_error
    #     Rails.logger.warn("Attempted to decode invalid JSON: #{some_string}")
    #   end
    #
    # source://activesupport//lib/active_support/json/decoding.rb#43
    def parse_error; end

    private

    # source://activesupport//lib/active_support/json/decoding.rb#48
    def convert_dates_from(data); end
  end
end

# source://activesupport//lib/active_support/json/decoding.rb#14
ActiveSupport::JSON::DATETIME_REGEX = T.let(T.unsafe(nil), Regexp)

# matches YAML-formatted dates
#
# source://activesupport//lib/active_support/json/decoding.rb#13
ActiveSupport::JSON::DATE_REGEX = T.let(T.unsafe(nil), Regexp)

# source://activesupport//lib/active_support/json/encoding.rb#46
module ActiveSupport::JSON::Encoding
  class << self
    # If true, encode >, <, & as escaped unicode sequences (e.g. > as \u003e)
    # as a safety measure.
    #
    # source://activesupport//lib/active_support/json/encoding.rb#121
    def escape_html_entities_in_json; end

    # If true, encode >, <, & as escaped unicode sequences (e.g. > as \u003e)
    # as a safety measure.
    #
    # source://activesupport//lib/active_support/json/encoding.rb#121
    def escape_html_entities_in_json=(_arg0); end

    # Sets the encoder used by \Rails to encode Ruby objects into JSON strings
    # in +Object#to_json+ and +ActiveSupport::JSON.encode+.
    #
    # source://activesupport//lib/active_support/json/encoding.rb#129
    def json_encoder; end

    # Sets the encoder used by \Rails to encode Ruby objects into JSON strings
    # in +Object#to_json+ and +ActiveSupport::JSON.encode+.
    #
    # source://activesupport//lib/active_support/json/encoding.rb#129
    def json_encoder=(_arg0); end

    # Sets the precision of encoded time values.
    # Defaults to 3 (equivalent to millisecond precision)
    #
    # source://activesupport//lib/active_support/json/encoding.rb#125
    def time_precision; end

    # Sets the precision of encoded time values.
    # Defaults to 3 (equivalent to millisecond precision)
    #
    # source://activesupport//lib/active_support/json/encoding.rb#125
    def time_precision=(_arg0); end

    # If true, use ISO 8601 format for dates and times. Otherwise, fall back
    # to the Active Support legacy format.
    #
    # source://activesupport//lib/active_support/json/encoding.rb#117
    def use_standard_json_time_format; end

    # If true, use ISO 8601 format for dates and times. Otherwise, fall back
    # to the Active Support legacy format.
    #
    # source://activesupport//lib/active_support/json/encoding.rb#117
    def use_standard_json_time_format=(_arg0); end
  end
end

# source://activesupport//lib/active_support/json/encoding.rb#47
class ActiveSupport::JSON::Encoding::JSONGemEncoder
  # @return [JSONGemEncoder] a new instance of JSONGemEncoder
  #
  # source://activesupport//lib/active_support/json/encoding.rb#50
  def initialize(options = T.unsafe(nil)); end

  # Encode the given object into a JSON string
  #
  # source://activesupport//lib/active_support/json/encoding.rb#55
  def encode(value); end

  # Returns the value of attribute options.
  #
  # source://activesupport//lib/active_support/json/encoding.rb#48
  def options; end

  private

  # Convert an object into a "JSON-ready" representation composed of
  # primitives like Hash, Array, String, Symbol, Numeric,
  # and +true+/+false+/+nil+.
  # Recursively calls #as_json to the object to recursively build a
  # fully JSON-ready object.
  #
  # This allows developers to implement #as_json without having to
  # worry about what base types of objects they are allowed to return
  # or having to remember to call #as_json recursively.
  #
  # Note: the +options+ hash passed to +object.to_json+ is only passed
  # to +object.as_json+, not any of this method's recursive +#as_json+
  # calls.
  #
  # source://activesupport//lib/active_support/json/encoding.rb#88
  def jsonify(value); end

  # Encode a "jsonified" Ruby data structure using the JSON gem
  #
  # source://activesupport//lib/active_support/json/encoding.rb#109
  def stringify(jsonified); end
end

# = Lazy Load Hooks
#
# LazyLoadHooks allows \Rails to lazily load a lot of components and thus
# making the app boot faster. Because of this feature now there is no need to
# require +ActiveRecord::Base+ at boot time purely to apply
# configuration. Instead a hook is registered that applies configuration once
# +ActiveRecord::Base+ is loaded. Here +ActiveRecord::Base+ is
# used as example but this feature can be applied elsewhere too.
#
# Here is an example where on_load method is called to register a hook.
#
#   initializer 'active_record.initialize_timezone' do
#     ActiveSupport.on_load(:active_record) do
#       self.time_zone_aware_attributes = true
#       self.default_timezone = :utc
#     end
#   end
#
# When the entirety of +ActiveRecord::Base+ has been
# evaluated then run_load_hooks is invoked. The very last line of
# +ActiveRecord::Base+ is:
#
#   ActiveSupport.run_load_hooks(:active_record, ActiveRecord::Base)
#
# run_load_hooks will then execute all the hooks that were registered
# with the on_load method. In the case of the above example, it will
# execute the block of code that is in the +initializer+.
#
# Registering a hook that has already run results in that hook executing
# immediately. This allows hooks to be nested for code that relies on
# multiple lazily loaded components:
#
#   initializer "action_text.renderer" do
#     ActiveSupport.on_load(:action_controller_base) do
#       ActiveSupport.on_load(:action_text_content) do
#         self.default_renderer = Class.new(ActionController::Base).renderer
#       end
#     end
#   end
#
# source://activesupport//lib/active_support/lazy_load_hooks.rb#43
module ActiveSupport::LazyLoadHooks
  # Declares a block that will be executed when a \Rails component is fully
  # loaded. If the component has already loaded, the block is executed
  # immediately.
  #
  # Options:
  #
  # * <tt>:yield</tt> - Yields the object that run_load_hooks to +block+.
  # * <tt>:run_once</tt> - Given +block+ will run only once.
  #
  # source://activesupport//lib/active_support/lazy_load_hooks.rb#60
  def on_load(name, options = T.unsafe(nil), &block); end

  # Executes all blocks registered to +name+ via on_load, using +base+ as the
  # evaluation context.
  #
  #   ActiveSupport.run_load_hooks(:active_record, ActiveRecord::Base)
  #
  # In the case of the above example, it will execute all hooks registered
  # for +:active_record+ within the class +ActiveRecord::Base+.
  #
  # source://activesupport//lib/active_support/lazy_load_hooks.rb#75
  def run_load_hooks(name, base = T.unsafe(nil)); end

  private

  # source://activesupport//lib/active_support/lazy_load_hooks.rb#91
  def execute_hook(name, base, options, block); end

  # source://activesupport//lib/active_support/lazy_load_hooks.rb#83
  def with_execution_control(name, block, once); end

  class << self
    # source://activesupport//lib/active_support/lazy_load_hooks.rb#44
    def extended(base); end
  end
end

# source://activesupport//lib/active_support/multibyte.rb#4
module ActiveSupport::Multibyte
  class << self
    # Returns the current proxy class.
    #
    # source://activesupport//lib/active_support/multibyte.rb#19
    def proxy_class; end

    # The proxy class returned when calling mb_chars. You can use this accessor
    # to configure your own proxy class so you can support other encodings. See
    # the ActiveSupport::Multibyte::Chars implementation for an example how to
    # do this.
    #
    #   ActiveSupport::Multibyte.proxy_class = CharsForUTF32
    #
    # source://activesupport//lib/active_support/multibyte.rb#14
    def proxy_class=(klass); end
  end
end

# = Active Support \Multibyte \Chars
#
# Chars enables you to work transparently with UTF-8 encoding in the Ruby
# String class without having extensive knowledge about the encoding. A
# Chars object accepts a string upon initialization and proxies String
# methods in an encoding safe manner. All the normal String methods are also
# implemented on the proxy.
#
# String methods are proxied through the Chars object, and can be accessed
# through the +mb_chars+ method. Methods which would normally return a
# String object now return a Chars object so methods can be chained.
#
#   'The Perfect String  '.mb_chars.downcase.strip
#   # => #<ActiveSupport::Multibyte::Chars:0x007fdc434ccc10 @wrapped_string="the perfect string">
#
# Chars objects are perfectly interchangeable with String objects as long as
# no explicit class checks are made. If certain methods do explicitly check
# the class, call +to_s+ before you pass chars objects to them.
#
#   bad.explicit_checking_method 'T'.mb_chars.downcase.to_s
#
# The default Chars implementation assumes that the encoding of the string
# is UTF-8, if you want to handle different encodings you can write your own
# multibyte string handler and configure it through
# ActiveSupport::Multibyte.proxy_class.
#
#   class CharsForUTF32
#     def size
#       @wrapped_string.size / 4
#     end
#
#     def self.accepts?(string)
#       string.length % 4 == 0
#     end
#   end
#
#   ActiveSupport::Multibyte.proxy_class = CharsForUTF32
#
# source://activesupport//lib/active_support/multibyte/chars.rb#47
class ActiveSupport::Multibyte::Chars
  include ::Comparable

  # Creates a new Chars instance by wrapping _string_.
  #
  # @return [Chars] a new instance of Chars
  #
  # source://activesupport//lib/active_support/multibyte/chars.rb#56
  def initialize(string); end

  # source://activesupport//lib/active_support/multibyte/chars.rb#53
  def <=>(*_arg0, **_arg1, &_arg2); end

  # source://activesupport//lib/active_support/multibyte/chars.rb#53
  def =~(*_arg0, **_arg1, &_arg2); end

  # source://activesupport//lib/active_support/multibyte/chars.rb#53
  def acts_like_string?(*_arg0, **_arg1, &_arg2); end

  # source://activesupport//lib/active_support/multibyte/chars.rb#164
  def as_json(options = T.unsafe(nil)); end

  # Performs composition on all the characters.
  #
  #   'é'.length                       # => 1
  #   'é'.mb_chars.compose.to_s.length # => 1
  #
  # source://activesupport//lib/active_support/multibyte/chars.rb#143
  def compose; end

  # Performs canonical decomposition on all the characters.
  #
  #   'é'.length                         # => 1
  #   'é'.mb_chars.decompose.to_s.length # => 2
  #
  # source://activesupport//lib/active_support/multibyte/chars.rb#135
  def decompose; end

  # Returns the number of grapheme clusters in the string.
  #
  #   'क्षि'.mb_chars.length   # => 4
  #   'क्षि'.mb_chars.grapheme_length # => 2
  #
  # source://activesupport//lib/active_support/multibyte/chars.rb#151
  def grapheme_length; end

  # Limits the byte size of the string to a number of bytes without breaking
  # characters. Usable when the storage for a string is limited for some
  # reason.
  #
  #   'こんにちは'.mb_chars.limit(7).to_s # => "こん"
  #
  # source://activesupport//lib/active_support/multibyte/chars.rb#118
  def limit(limit); end

  # source://activesupport//lib/active_support/multibyte/chars.rb#53
  def match?(*_arg0, **_arg1, &_arg2); end

  # Forward all undefined methods to the wrapped string.
  #
  # source://activesupport//lib/active_support/multibyte/chars.rb#65
  def method_missing(method, *_arg1, **_arg2, &_arg3); end

  # Reverses all characters in the string.
  #
  #   'Café'.mb_chars.reverse.to_s # => 'éfaC'
  #
  # source://activesupport//lib/active_support/multibyte/chars.rb#109
  def reverse; end

  # source://activesupport//lib/active_support/multibyte/chars.rb#169
  def reverse!(*args); end

  # Works like <tt>String#slice!</tt>, but returns an instance of
  # Chars, or +nil+ if the string was not modified. The string will not be
  # modified if the range given is out of bounds
  #
  #   string = 'Welcome'
  #   string.mb_chars.slice!(3)    # => #<ActiveSupport::Multibyte::Chars:0x000000038109b8 @wrapped_string="c">
  #   string # => 'Welome'
  #   string.mb_chars.slice!(0..3) # => #<ActiveSupport::Multibyte::Chars:0x00000002eb80a0 @wrapped_string="Welo">
  #   string # => 'me'
  #
  # source://activesupport//lib/active_support/multibyte/chars.rb#99
  def slice!(*args); end

  # Works just like <tt>String#split</tt>, with the exception that the items
  # in the resulting list are Chars instances instead of String. This makes
  # chaining methods easier.
  #
  #   'Café périferôl'.mb_chars.split(/é/).map { |part| part.upcase.to_s } # => ["CAF", " P", "RIFERÔL"]
  #
  # source://activesupport//lib/active_support/multibyte/chars.rb#86
  def split(*args); end

  # Replaces all ISO-8859-1 or CP1252 characters by their UTF-8 equivalent
  # resulting in a valid UTF-8 string.
  #
  # Passing +true+ will forcibly tidy all bytes, assuming that the string's
  # encoding is entirely CP1252 or ISO-8859-1.
  #
  # source://activesupport//lib/active_support/multibyte/chars.rb#160
  def tidy_bytes(force = T.unsafe(nil)); end

  # source://activesupport//lib/active_support/multibyte/chars.rb#169
  def tidy_bytes!(*args); end

  # Capitalizes the first letter of every word, when possible.
  #
  #   "ÉL QUE SE ENTERÓ".mb_chars.titleize.to_s    # => "Él Que Se Enteró"
  #   "日本語".mb_chars.titleize.to_s               # => "日本語"
  #
  # source://activesupport//lib/active_support/multibyte/chars.rb#126
  def titlecase; end

  # Capitalizes the first letter of every word, when possible.
  #
  #   "ÉL QUE SE ENTERÓ".mb_chars.titleize.to_s    # => "Él Que Se Enteró"
  #   "日本語".mb_chars.titleize.to_s               # => "日本語"
  #
  # source://activesupport//lib/active_support/multibyte/chars.rb#126
  def titleize; end

  # Returns the value of attribute wrapped_string.
  #
  # source://activesupport//lib/active_support/multibyte/chars.rb#49
  def to_s; end

  # Returns the value of attribute wrapped_string.
  #
  # source://activesupport//lib/active_support/multibyte/chars.rb#49
  def to_str; end

  # Returns the value of attribute wrapped_string.
  #
  # source://activesupport//lib/active_support/multibyte/chars.rb#49
  def wrapped_string; end

  private

  # source://activesupport//lib/active_support/multibyte/chars.rb#176
  def chars(string); end

  # Returns +true+ if _obj_ responds to the given method. Private methods
  # are included in the search only if the optional second parameter
  # evaluates to +true+.
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/multibyte/chars.rb#77
  def respond_to_missing?(method, include_private); end
end

# source://activesupport//lib/active_support/multibyte/unicode.rb#5
module ActiveSupport::Multibyte::Unicode
  extend ::ActiveSupport::Multibyte::Unicode

  # Compose decomposed characters to the composed form.
  #
  # source://activesupport//lib/active_support/multibyte/unicode.rb#21
  def compose(codepoints); end

  # Decompose composed characters to the decomposed form.
  #
  # source://activesupport//lib/active_support/multibyte/unicode.rb#12
  def decompose(type, codepoints); end

  # Replaces all ISO-8859-1 or CP1252 characters by their UTF-8 equivalent
  # resulting in a valid UTF-8 string.
  #
  # Passing +true+ will forcibly tidy all bytes, assuming that the string's
  # encoding is entirely CP1252 or ISO-8859-1.
  #
  # source://activesupport//lib/active_support/multibyte/unicode.rb#30
  def tidy_bytes(string, force = T.unsafe(nil)); end

  private

  # source://activesupport//lib/active_support/multibyte/unicode.rb#37
  def recode_windows1252_chars(string); end
end

# The Unicode version that is supported by the implementation
#
# source://activesupport//lib/active_support/multibyte/unicode.rb#9
ActiveSupport::Multibyte::Unicode::UNICODE_VERSION = T.let(T.unsafe(nil), String)

# source://activesupport//lib/active_support/core_ext/string/output_safety.rb#19
class ActiveSupport::SafeBuffer < ::String
  # @return [SafeBuffer] a new instance of SafeBuffer
  #
  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#70
  def initialize(str = T.unsafe(nil)); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#123
  def %(args); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#116
  def *(_); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#112
  def +(other); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#80
  def <<(value); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#38
  def [](*args); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#104
  def []=(arg1, arg2, arg3 = T.unsafe(nil)); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#88
  def bytesplice(*args, value); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#153
  def capitalize(*args, &block); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#157
  def capitalize!(*args); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#153
  def chomp(*args, &block); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#157
  def chomp!(*args); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#153
  def chop(*args, &block); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#157
  def chop!(*args); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#59
  def chr; end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#80
  def concat(value); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#153
  def delete(*args, &block); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#157
  def delete!(*args); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#153
  def delete_prefix(*args, &block); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#157
  def delete_prefix!(*args); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#153
  def delete_suffix(*args, &block); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#157
  def delete_suffix!(*args); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#153
  def downcase(*args, &block); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#157
  def downcase!(*args); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#146
  def encode_with(coder); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#167
  def gsub(*args, &block); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#178
  def gsub!(*args, &block); end

  # Returns the value of attribute html_safe.
  #
  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#134
  def html_safe?; end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#92
  def insert(index, value); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#153
  def lstrip(*args, &block); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#157
  def lstrip!(*args); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#153
  def next(*args, &block); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#157
  def next!(*args); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#96
  def prepend(value); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#100
  def replace(value); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#153
  def reverse(*args, &block); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#157
  def reverse!(*args); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#153
  def rstrip(*args, &block); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#157
  def rstrip!(*args); end

  # @raise [SafeConcatError]
  #
  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#65
  def safe_concat(value); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#153
  def scrub(*args, &block); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#157
  def scrub!(*args); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#38
  def slice(*args); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#51
  def slice!(*args); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#153
  def squeeze(*args, &block); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#157
  def squeeze!(*args); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#153
  def strip(*args, &block); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#157
  def strip!(*args); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#167
  def sub(*args, &block); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#178
  def sub!(*args, &block); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#153
  def succ(*args, &block); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#157
  def succ!(*args); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#153
  def swapcase(*args, &block); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#157
  def swapcase!(*args); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#142
  def to_param; end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#138
  def to_s; end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#153
  def tr(*args, &block); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#157
  def tr!(*args); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#153
  def tr_s(*args, &block); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#157
  def tr_s!(*args); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#153
  def unicode_normalize(*args, &block); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#157
  def unicode_normalize!(*args); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#153
  def upcase(*args, &block); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#157
  def upcase!(*args); end

  private

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#193
  def explicit_html_escape_interpolated_argument(arg); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#197
  def implicit_html_escape_interpolated_argument(arg); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#75
  def initialize_copy(other); end

  def original_concat(*_arg0); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#205
  def set_block_back_references(block, match_data); end

  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#211
  def string_into_safe_buffer(new_string, is_html_safe); end
end

# Raised when ActiveSupport::SafeBuffer#safe_concat is called on unsafe buffers.
#
# source://activesupport//lib/active_support/core_ext/string/output_safety.rb#32
class ActiveSupport::SafeBuffer::SafeConcatError < ::StandardError
  # @return [SafeConcatError] a new instance of SafeConcatError
  #
  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#33
  def initialize; end
end

# source://activesupport//lib/active_support/core_ext/string/output_safety.rb#20
ActiveSupport::SafeBuffer::UNSAFE_STRING_METHODS = T.let(T.unsafe(nil), Array)

# source://activesupport//lib/active_support/core_ext/string/output_safety.rb#26
ActiveSupport::SafeBuffer::UNSAFE_STRING_METHODS_WITH_BACKREF = T.let(T.unsafe(nil), Array)

# = \String Inquirer
#
# Wrapping a string in this class gives you a prettier way to test
# for equality. The value returned by <tt>Rails.env</tt> is wrapped
# in a StringInquirer object, so instead of calling this:
#
#   Rails.env == 'production'
#
# you can call this:
#
#   Rails.env.production?
#
# == Instantiating a new \StringInquirer
#
#   vehicle = ActiveSupport::StringInquirer.new('car')
#   vehicle.car?   # => true
#   vehicle.bike?  # => false
#
# source://activesupport//lib/active_support/string_inquirer.rb#21
class ActiveSupport::StringInquirer < ::String
  private

  # source://activesupport//lib/active_support/string_inquirer.rb#27
  def method_missing(method_name, *_arg1, **_arg2, &_arg3); end

  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/string_inquirer.rb#23
  def respond_to_missing?(method_name, include_private = T.unsafe(nil)); end
end

# = Active Support \Time With Zone
#
# A Time-like class that can represent a time in any time zone. Necessary
# because standard Ruby Time instances are limited to UTC and the
# system's <tt>ENV['TZ']</tt> zone.
#
# You shouldn't ever need to create a TimeWithZone instance directly via +new+.
# Instead use methods +local+, +parse+, +at+, and +now+ on TimeZone instances,
# and +in_time_zone+ on Time and DateTime instances.
#
#   Time.zone = 'Eastern Time (US & Canada)'        # => 'Eastern Time (US & Canada)'
#   Time.zone.local(2007, 2, 10, 15, 30, 45)        # => Sat, 10 Feb 2007 15:30:45.000000000 EST -05:00
#   Time.zone.parse('2007-02-10 15:30:45')          # => Sat, 10 Feb 2007 15:30:45.000000000 EST -05:00
#   Time.zone.at(1171139445)                        # => Sat, 10 Feb 2007 15:30:45.000000000 EST -05:00
#   Time.zone.now                                   # => Sun, 18 May 2008 13:07:55.754107581 EDT -04:00
#   Time.utc(2007, 2, 10, 20, 30, 45).in_time_zone  # => Sat, 10 Feb 2007 15:30:45.000000000 EST -05:00
#
# See Time and TimeZone for further documentation of these methods.
#
# TimeWithZone instances implement the same API as Ruby Time instances, so
# that Time and TimeWithZone instances are interchangeable.
#
#   t = Time.zone.now                     # => Sun, 18 May 2008 13:27:25.031505668 EDT -04:00
#   t.hour                                # => 13
#   t.dst?                                # => true
#   t.utc_offset                          # => -14400
#   t.zone                                # => "EDT"
#   t.to_fs(:rfc822)                      # => "Sun, 18 May 2008 13:27:25 -0400"
#   t + 1.day                             # => Mon, 19 May 2008 13:27:25.031505668 EDT -04:00
#   t.beginning_of_year                   # => Tue, 01 Jan 2008 00:00:00.000000000 EST -05:00
#   t > Time.utc(1999)                    # => true
#   t.is_a?(Time)                         # => true
#   t.is_a?(ActiveSupport::TimeWithZone)  # => true
#
# source://activesupport//lib/active_support/time_with_zone.rb#44
class ActiveSupport::TimeWithZone
  include ::DateAndTime::Compatibility
  include ::Comparable

  # @return [TimeWithZone] a new instance of TimeWithZone
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#51
  def initialize(utc_time, time_zone, local_time = T.unsafe(nil), period = T.unsafe(nil)); end

  # Adds an interval of time to the current object's time and returns that
  # value as a new TimeWithZone object.
  #
  #   Time.zone = 'Eastern Time (US & Canada)' # => 'Eastern Time (US & Canada)'
  #   now = Time.zone.now # => Sun, 02 Nov 2014 01:26:28.725182881 EDT -04:00
  #   now + 1000          # => Sun, 02 Nov 2014 01:43:08.725182881 EDT -04:00
  #
  # If we're adding a Duration of variable length (i.e., years, months, days),
  # move forward from #time, otherwise move forward from #utc, for accuracy
  # when moving across DST boundaries.
  #
  # For instance, a time + 24.hours will advance exactly 24 hours, while a
  # time + 1.day will advance 23-25 hours, depending on the day.
  #
  #   now + 24.hours      # => Mon, 03 Nov 2014 00:26:28.725182881 EST -05:00
  #   now + 1.day         # => Mon, 03 Nov 2014 01:26:28.725182881 EST -05:00
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#298
  def +(other); end

  # Subtracts an interval of time and returns a new TimeWithZone object unless
  # the other value +acts_like?+ time. In which case, it will subtract the
  # other time and return the difference in seconds as a Float.
  #
  #   Time.zone = 'Eastern Time (US & Canada)' # => 'Eastern Time (US & Canada)'
  #   now = Time.zone.now # => Mon, 03 Nov 2014 00:26:28.725182881 EST -05:00
  #   now - 1000          # => Mon, 03 Nov 2014 00:09:48.725182881 EST -05:00
  #
  # If subtracting a Duration of variable length (i.e., years, months, days),
  # move backward from #time, otherwise move backward from #utc, for accuracy
  # when moving across DST boundaries.
  #
  # For instance, a time - 24.hours will go subtract exactly 24 hours, while a
  # time - 1.day will subtract 23-25 hours, depending on the day.
  #
  #   now - 24.hours      # => Sun, 02 Nov 2014 01:26:28.725182881 EDT -04:00
  #   now - 1.day         # => Sun, 02 Nov 2014 00:26:28.725182881 EDT -04:00
  #
  # If both the TimeWithZone object and the other value act like Time, a Float
  # will be returned.
  #
  #   Time.zone.now - 1.day.ago # => 86399.999967
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#341
  def -(other); end

  # Use the time in UTC for comparisons.
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#231
  def <=>(other); end

  # So that +self+ <tt>acts_like?(:time)</tt>.
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#504
  def acts_like_time?; end

  # Uses Date to provide precise Time calculations for years, months, and days
  # according to the proleptic Gregorian calendar. The result is returned as a
  # new TimeWithZone object.
  #
  # The +options+ parameter takes a hash with any of these keys:
  # <tt>:years</tt>, <tt>:months</tt>, <tt>:weeks</tt>, <tt>:days</tt>,
  # <tt>:hours</tt>, <tt>:minutes</tt>, <tt>:seconds</tt>.
  #
  # If advancing by a value of variable length (i.e., years, weeks, months,
  # days), move forward from #time, otherwise move forward from #utc, for
  # accuracy when moving across DST boundaries.
  #
  #   Time.zone = 'Eastern Time (US & Canada)' # => 'Eastern Time (US & Canada)'
  #   now = Time.zone.now # => Sun, 02 Nov 2014 01:26:28.558049687 EDT -04:00
  #   now.advance(seconds: 1) # => Sun, 02 Nov 2014 01:26:29.558049687 EDT -04:00
  #   now.advance(minutes: 1) # => Sun, 02 Nov 2014 01:27:28.558049687 EDT -04:00
  #   now.advance(hours: 1)   # => Sun, 02 Nov 2014 01:26:28.558049687 EST -05:00
  #   now.advance(days: 1)    # => Mon, 03 Nov 2014 01:26:28.558049687 EST -05:00
  #   now.advance(weeks: 1)   # => Sun, 09 Nov 2014 01:26:28.558049687 EST -05:00
  #   now.advance(months: 1)  # => Tue, 02 Dec 2014 01:26:28.558049687 EST -05:00
  #   now.advance(years: 1)   # => Mon, 02 Nov 2015 01:26:28.558049687 EST -05:00
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#430
  def advance(options); end

  def after?(_arg0); end

  # Subtracts an interval of time from the current object's time and returns
  # the result as a new TimeWithZone object.
  #
  #   Time.zone = 'Eastern Time (US & Canada)' # => 'Eastern Time (US & Canada)'
  #   now = Time.zone.now # => Mon, 03 Nov 2014 00:26:28.725182881 EST -05:00
  #   now.ago(1000)       # => Mon, 03 Nov 2014 00:09:48.725182881 EST -05:00
  #
  # If we're subtracting a Duration of variable length (i.e., years, months,
  # days), move backward from #time, otherwise move backward from #utc, for
  # accuracy when moving across DST boundaries.
  #
  # For instance, <tt>time.ago(24.hours)</tt> will move back exactly 24 hours,
  # while <tt>time.ago(1.day)</tt> will move back 23-25 hours, depending on
  # the day.
  #
  #   now.ago(24.hours)   # => Sun, 02 Nov 2014 01:26:28.725182881 EDT -04:00
  #   now.ago(1.day)      # => Sun, 02 Nov 2014 00:26:28.725182881 EDT -04:00
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#369
  def ago(other); end

  # Coerces time to a string for JSON encoding. The default format is ISO 8601.
  # You can get %Y/%m/%d %H:%M:%S +offset style by setting
  # <tt>ActiveSupport::JSON::Encoding.use_standard_json_time_format</tt>
  # to +false+.
  #
  #   # With ActiveSupport::JSON::Encoding.use_standard_json_time_format = true
  #   Time.utc(2005,2,1,15,15,10).in_time_zone("Hawaii").as_json
  #   # => "2005-02-01T05:15:10.000-10:00"
  #
  #   # With ActiveSupport::JSON::Encoding.use_standard_json_time_format = false
  #   Time.utc(2005,2,1,15,15,10).in_time_zone("Hawaii").as_json
  #   # => "2005/02/01 05:15:10 -1000"
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#166
  def as_json(options = T.unsafe(nil)); end

  def before?(_arg0); end

  # Returns true if the current object's time is within the specified
  # +min+ and +max+ time.
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#239
  def between?(min, max); end

  # An instance of ActiveSupport::TimeWithZone is never blank
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#515
  def blank?; end

  # Returns a new +ActiveSupport::TimeWithZone+ where one or more of the elements have
  # been changed according to the +options+ parameter. The time options (<tt>:hour</tt>,
  # <tt>:min</tt>, <tt>:sec</tt>, <tt>:usec</tt>, <tt>:nsec</tt>) reset cascadingly,
  # so if only the hour is passed, then minute, sec, usec, and nsec is set to 0. If the
  # hour and minute is passed, then sec, usec, and nsec is set to 0. The +options+
  # parameter takes a hash with any of these keys: <tt>:year</tt>, <tt>:month</tt>,
  # <tt>:day</tt>, <tt>:hour</tt>, <tt>:min</tt>, <tt>:sec</tt>, <tt>:usec</tt>,
  # <tt>:nsec</tt>, <tt>:offset</tt>, <tt>:zone</tt>. Pass either <tt>:usec</tt>
  # or <tt>:nsec</tt>, not both. Similarly, pass either <tt>:zone</tt> or
  # <tt>:offset</tt>, not both.
  #
  #   t = Time.zone.now          # => Fri, 14 Apr 2017 11:45:15.116992711 EST -05:00
  #   t.change(year: 2020)       # => Tue, 14 Apr 2020 11:45:15.116992711 EST -05:00
  #   t.change(hour: 12)         # => Fri, 14 Apr 2017 12:00:00.000000000 EST -05:00
  #   t.change(min: 30)          # => Fri, 14 Apr 2017 11:30:00.000000000 EST -05:00
  #   t.change(offset: "-10:00") # => Fri, 14 Apr 2017 11:45:15.116992711 HST -10:00
  #   t.change(zone: "Hawaii")   # => Fri, 14 Apr 2017 11:45:15.116992711 HST -10:00
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#390
  def change(options); end

  # Returns a <tt>Time</tt> instance of the simultaneous time in the UTC timezone.
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#63
  def comparable_time; end

  # source://activesupport//lib/active_support/time_with_zone.rb#442
  def day; end

  # Returns true if the current time is within Daylight Savings \Time for the
  # specified time zone.
  #
  #   Time.zone = 'Eastern Time (US & Canada)'    # => 'Eastern Time (US & Canada)'
  #   Time.zone.parse("2012-5-30").dst?           # => true
  #   Time.zone.parse("2012-11-30").dst?          # => false
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#94
  def dst?; end

  # source://activesupport//lib/active_support/time_with_zone.rb#178
  def encode_with(coder); end

  # Returns +true+ if +other+ is equal to current object.
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#274
  def eql?(other); end

  # Returns a formatted string of the offset from UTC, or an alternative
  # string if the time zone is already UTC.
  #
  #   Time.zone = 'Eastern Time (US & Canada)'   # => "Eastern Time (US & Canada)"
  #   Time.zone.now.formatted_offset(true)       # => "-05:00"
  #   Time.zone.now.formatted_offset(false)      # => "-0500"
  #   Time.zone = 'UTC'                          # => "UTC"
  #   Time.zone.now.formatted_offset(true, "0")  # => "0"
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#125
  def formatted_offset(colon = T.unsafe(nil), alternate_utc_string = T.unsafe(nil)); end

  # source://activesupport//lib/active_support/time_with_zone.rb#523
  def freeze; end

  # Returns true if the current object's time is in the future.
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#269
  def future?; end

  # Returns a <tt>Time</tt> instance of the simultaneous time in the UTC timezone.
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#63
  def getgm; end

  # Returns a <tt>Time</tt> instance of the simultaneous time in the system timezone.
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#83
  def getlocal(utc_offset = T.unsafe(nil)); end

  # Returns a <tt>Time</tt> instance of the simultaneous time in the UTC timezone.
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#63
  def getutc; end

  # Returns true if the current time zone is set to UTC.
  #
  #   Time.zone = 'UTC'                           # => 'UTC'
  #   Time.zone.now.utc?                          # => true
  #   Time.zone = 'Eastern Time (US & Canada)'    # => 'Eastern Time (US & Canada)'
  #   Time.zone.now.utc?                          # => false
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#105
  def gmt?; end

  # Returns the offset from current time to UTC time in seconds.
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#111
  def gmt_offset; end

  # Returns a <tt>Time</tt> instance of the simultaneous time in the UTC timezone.
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#63
  def gmtime; end

  # Returns the offset from current time to UTC time in seconds.
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#111
  def gmtoff; end

  # source://activesupport//lib/active_support/time_with_zone.rb#278
  def hash; end

  # source://activesupport//lib/active_support/time_with_zone.rb#442
  def hour; end

  # Returns a string of the object's date and time in the format used by
  # HTTP requests.
  #
  #   Time.zone.now.httpdate  # => "Tue, 01 Jan 2013 04:39:43 GMT"
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#186
  def httpdate; end

  # Adds an interval of time to the current object's time and returns that
  # value as a new TimeWithZone object.
  #
  #   Time.zone = 'Eastern Time (US & Canada)' # => 'Eastern Time (US & Canada)'
  #   now = Time.zone.now # => Sun, 02 Nov 2014 01:26:28.725182881 EDT -04:00
  #   now + 1000          # => Sun, 02 Nov 2014 01:43:08.725182881 EDT -04:00
  #
  # If we're adding a Duration of variable length (i.e., years, months, days),
  # move forward from #time, otherwise move forward from #utc, for accuracy
  # when moving across DST boundaries.
  #
  # For instance, a time + 24.hours will advance exactly 24 hours, while a
  # time + 1.day will advance 23-25 hours, depending on the day.
  #
  #   now + 24.hours      # => Mon, 03 Nov 2014 00:26:28.725182881 EST -05:00
  #   now + 1.day         # => Mon, 03 Nov 2014 01:26:28.725182881 EST -05:00
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#298
  def in(other); end

  # Returns the simultaneous time in <tt>Time.zone</tt>, or the specified zone.
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#77
  def in_time_zone(new_zone = T.unsafe(nil)); end

  # source://activesupport//lib/active_support/time_with_zone.rb#174
  def init_with(coder); end

  # Returns a string of the object's date, time, zone, and offset from UTC.
  #
  #   Time.zone.now.inspect # => "2024-11-13 07:00:10.528054960 UTC +00:00"
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#140
  def inspect; end

  # Say we're a Time to thwart type checking.
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#509
  def is_a?(klass); end

  # Returns true if the current time is within Daylight Savings \Time for the
  # specified time zone.
  #
  #   Time.zone = 'Eastern Time (US & Canada)'    # => 'Eastern Time (US & Canada)'
  #   Time.zone.parse("2012-5-30").dst?           # => true
  #   Time.zone.parse("2012-11-30").dst?          # => false
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#94
  def isdst; end

  # Returns a string of the object's date and time in the ISO 8601 standard
  # format.
  #
  #   Time.zone.now.xmlschema  # => "2014-12-04T11:02:37-05:00"
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#148
  def iso8601(fraction_digits = T.unsafe(nil)); end

  # Say we're a Time to thwart type checking.
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#509
  def kind_of?(klass); end

  # Returns a <tt>Time</tt> instance of the simultaneous time in the system timezone.
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#83
  def localtime(utc_offset = T.unsafe(nil)); end

  # source://activesupport//lib/active_support/time_with_zone.rb#529
  def marshal_dump; end

  # source://activesupport//lib/active_support/time_with_zone.rb#533
  def marshal_load(variables); end

  # source://activesupport//lib/active_support/time_with_zone.rb#442
  def mday; end

  # Send the missing method to +time+ instance, and wrap result in a new
  # TimeWithZone with the existing +time_zone+.
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#553
  def method_missing(*_arg0, **_arg1, &_arg2); end

  # source://activesupport//lib/active_support/time_with_zone.rb#442
  def min; end

  # source://activesupport//lib/active_support/time_with_zone.rb#442
  def mon; end

  # source://activesupport//lib/active_support/time_with_zone.rb#442
  def month; end

  # Returns true if the current object's time falls within
  # the next day (tomorrow).
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#256
  def next_day?; end

  # source://activesupport//lib/active_support/time_with_zone.rb#442
  def nsec; end

  # Returns true if the current object's time is in the past.
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#244
  def past?; end

  # Returns the underlying +TZInfo::TimezonePeriod+.
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#72
  def period; end

  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#519
  def present?; end

  # Returns true if the current object's time falls within
  # the previous day (yesterday).
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#263
  def prev_day?; end

  # respond_to_missing? is not called in some cases, such as when type conversion is
  # performed with Kernel#String
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#539
  def respond_to?(sym, include_priv = T.unsafe(nil)); end

  # Returns a string of the object's date and time in the RFC 2822 standard
  # format.
  #
  #   Time.zone.now.rfc2822  # => "Tue, 01 Jan 2013 04:51:39 +0000"
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#194
  def rfc2822; end

  # Returns a string of the object's date and time in the ISO 8601 standard
  # format.
  #
  #   Time.zone.now.xmlschema  # => "2014-12-04T11:02:37-05:00"
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#148
  def rfc3339(fraction_digits = T.unsafe(nil)); end

  # Returns a string of the object's date and time in the RFC 2822 standard
  # format.
  #
  #   Time.zone.now.rfc2822  # => "Tue, 01 Jan 2013 04:51:39 +0000"
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#194
  def rfc822; end

  # source://activesupport//lib/active_support/time_with_zone.rb#442
  def sec; end

  # Adds an interval of time to the current object's time and returns that
  # value as a new TimeWithZone object.
  #
  #   Time.zone = 'Eastern Time (US & Canada)' # => 'Eastern Time (US & Canada)'
  #   now = Time.zone.now # => Sun, 02 Nov 2014 01:26:28.725182881 EDT -04:00
  #   now + 1000          # => Sun, 02 Nov 2014 01:43:08.725182881 EDT -04:00
  #
  # If we're adding a Duration of variable length (i.e., years, months, days),
  # move forward from #time, otherwise move forward from #utc, for accuracy
  # when moving across DST boundaries.
  #
  # For instance, a time + 24.hours will advance exactly 24 hours, while a
  # time + 1.day will advance 23-25 hours, depending on the day.
  #
  #   now + 24.hours      # => Mon, 03 Nov 2014 00:26:28.725182881 EST -05:00
  #   now + 1.day         # => Mon, 03 Nov 2014 01:26:28.725182881 EST -05:00
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#298
  def since(other); end

  # Replaces <tt>%Z</tt> directive with +zone before passing to Time#strftime,
  # so that zone information is correct.
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#225
  def strftime(format); end

  # Returns a <tt>Time</tt> instance that represents the time in +time_zone+.
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#58
  def time; end

  # Returns the value of attribute time_zone.
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#49
  def time_zone; end

  # Returns Array of parts of Time in sequence of
  # [seconds, minutes, hours, day, month, year, weekday, yearday, dst?, zone].
  #
  #   now = Time.zone.now     # => Tue, 18 Aug 2015 02:29:27.485278555 UTC +00:00
  #   now.to_a                # => [27, 29, 2, 18, 8, 2015, 2, 230, false, "UTC"]
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#453
  def to_a; end

  # source://activesupport//lib/active_support/time_with_zone.rb#442
  def to_date; end

  # Returns an instance of DateTime with the timezone's UTC offset
  #
  #   Time.zone.now.to_datetime                         # => Tue, 18 Aug 2015 02:32:20 +0000
  #   Time.current.in_time_zone('Hawaii').to_datetime   # => Mon, 17 Aug 2015 16:32:20 -1000
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#486
  def to_datetime; end

  # Returns the object's date and time as a floating-point number of seconds
  # since the Epoch (January 1, 1970 00:00 UTC).
  #
  #   Time.zone.now.to_f # => 1417709320.285418
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#461
  def to_f; end

  # Returns a string of the object's date and time.
  #
  # This method is aliased to <tt>to_formatted_s</tt>.
  #
  # Accepts an optional <tt>format</tt>:
  # * <tt>:default</tt> - default value, mimics Ruby Time#to_s format.
  # * <tt>:db</tt> - format outputs time in UTC :db time. See Time#to_fs(:db).
  # * Any key in +Time::DATE_FORMATS+ can be used. See active_support/core_ext/time/conversions.rb.
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#212
  def to_formatted_s(format = T.unsafe(nil)); end

  # Returns a string of the object's date and time.
  #
  # This method is aliased to <tt>to_formatted_s</tt>.
  #
  # Accepts an optional <tt>format</tt>:
  # * <tt>:default</tt> - default value, mimics Ruby Time#to_s format.
  # * <tt>:db</tt> - format outputs time in UTC :db time. See Time#to_fs(:db).
  # * Any key in +Time::DATE_FORMATS+ can be used. See active_support/core_ext/time/conversions.rb.
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#212
  def to_fs(format = T.unsafe(nil)); end

  # Returns the object's date and time as an integer number of seconds
  # since the Epoch (January 1, 1970 00:00 UTC).
  #
  #   Time.zone.now.to_i # => 1417709320
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#469
  def to_i; end

  # Returns the object's date and time as a rational number of seconds
  # since the Epoch (January 1, 1970 00:00 UTC).
  #
  #   Time.zone.now.to_r # => (708854548642709/500000)
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#478
  def to_r; end

  # Returns a string of the object's date and time.
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#200
  def to_s; end

  # Returns an instance of +Time+, either with the same timezone as +self+,
  # with the same UTC offset as +self+ or in the local system timezone
  # depending on the setting of +ActiveSupport.to_time_preserves_timezone+.
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#493
  def to_time; end

  # Returns true if the current object's time falls within
  # the current day.
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#250
  def today?; end

  # Returns true if the current object's time falls within
  # the next day (tomorrow).
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#256
  def tomorrow?; end

  # Returns the object's date and time as an integer number of seconds
  # since the Epoch (January 1, 1970 00:00 UTC).
  #
  #   Time.zone.now.to_i # => 1417709320
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#469
  def tv_sec; end

  # source://activesupport//lib/active_support/time_with_zone.rb#442
  def usec; end

  # Returns a <tt>Time</tt> instance of the simultaneous time in the UTC timezone.
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#63
  def utc; end

  # Returns true if the current time zone is set to UTC.
  #
  #   Time.zone = 'UTC'                           # => 'UTC'
  #   Time.zone.now.utc?                          # => true
  #   Time.zone = 'Eastern Time (US & Canada)'    # => 'Eastern Time (US & Canada)'
  #   Time.zone.now.utc?                          # => false
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#105
  def utc?; end

  # Returns the offset from current time to UTC time in seconds.
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#111
  def utc_offset; end

  # source://activesupport//lib/active_support/time_with_zone.rb#442
  def wday; end

  # Returns a string of the object's date and time in the ISO 8601 standard
  # format.
  #
  #   Time.zone.now.xmlschema  # => "2014-12-04T11:02:37-05:00"
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#148
  def xmlschema(fraction_digits = T.unsafe(nil)); end

  # source://activesupport//lib/active_support/time_with_zone.rb#442
  def yday; end

  # source://activesupport//lib/active_support/time_with_zone.rb#442
  def year; end

  # Returns true if the current object's time falls within
  # the previous day (yesterday).
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#263
  def yesterday?; end

  # Returns the time zone abbreviation.
  #
  #   Time.zone = 'Eastern Time (US & Canada)'   # => "Eastern Time (US & Canada)"
  #   Time.zone.now.zone # => "EST"
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#133
  def zone; end

  private

  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#589
  def duration_of_variable_length?(obj); end

  # source://activesupport//lib/active_support/time_with_zone.rb#570
  def get_period_and_ensure_valid_local_time(period); end

  # source://activesupport//lib/active_support/time_with_zone.rb#562
  def incorporate_utc_offset(time, offset); end

  # Ensure proxy class responds to all methods that underlying time instance
  # responds to.
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/time_with_zone.rb#547
  def respond_to_missing?(sym, include_priv); end

  # source://activesupport//lib/active_support/time_with_zone.rb#583
  def transfer_time_values_to_utc_constructor(time); end

  # source://activesupport//lib/active_support/time_with_zone.rb#593
  def wrap_with_time_zone(time); end
end

# source://activesupport//lib/active_support/time_with_zone.rb#45
ActiveSupport::TimeWithZone::PRECISIONS = T.let(T.unsafe(nil), Hash)

# source://activesupport//lib/active_support/time_with_zone.rb#560
ActiveSupport::TimeWithZone::SECONDS_PER_DAY = T.let(T.unsafe(nil), Integer)

# = Active Support \Time Zone
#
# The TimeZone class serves as a wrapper around +TZInfo::Timezone+ instances.
# It allows us to do the following:
#
# * Limit the set of zones provided by TZInfo to a meaningful subset of 134
#   zones.
# * Retrieve and display zones with a friendlier name
#   (e.g., "Eastern \Time (US & Canada)" instead of "America/New_York").
# * Lazily load +TZInfo::Timezone+ instances only when they're needed.
# * Create ActiveSupport::TimeWithZone instances via TimeZone's +local+,
#   +parse+, +at+, and +now+ methods.
#
# If you set <tt>config.time_zone</tt> in the \Rails Application, you can
# access this TimeZone object via <tt>Time.zone</tt>:
#
#   # application.rb:
#   class Application < Rails::Application
#     config.time_zone = 'Eastern Time (US & Canada)'
#   end
#
#   Time.zone      # => #<ActiveSupport::TimeZone:0x514834...>
#   Time.zone.name # => "Eastern Time (US & Canada)"
#   Time.zone.now  # => Sun, 18 May 2008 14:30:44 EDT -04:00
#
# source://activesupport//lib/active_support/values/time_zone.rb#31
class ActiveSupport::TimeZone
  include ::Comparable

  # :stopdoc:
  #
  # @return [TimeZone] a new instance of TimeZone
  #
  # source://activesupport//lib/active_support/values/time_zone.rb#309
  def initialize(name, utc_offset = T.unsafe(nil), tzinfo = T.unsafe(nil)); end

  # Compare this time zone to the parameter. The two are compared first on
  # their offsets, and then by name.
  #
  # source://activesupport//lib/active_support/values/time_zone.rb#333
  def <=>(zone); end

  # Compare #name and TZInfo identifier to a supplied regexp, returning +true+
  # if a match is found.
  #
  # source://activesupport//lib/active_support/values/time_zone.rb#342
  def =~(re); end

  # source://activesupport//lib/active_support/values/time_zone.rb#567
  def abbr(time); end

  # \Method for creating new ActiveSupport::TimeWithZone instance in time zone
  # of +self+ from number of seconds since the Unix epoch.
  #
  #   Time.zone = 'Hawaii'        # => "Hawaii"
  #   Time.utc(2000).to_f         # => 946684800.0
  #   Time.zone.at(946684800.0)   # => Fri, 31 Dec 1999 14:00:00 HST -10:00
  #
  # A second argument can be supplied to specify sub-second precision.
  #
  #   Time.zone = 'Hawaii'                # => "Hawaii"
  #   Time.at(946684800, 123456.789).nsec # => 123456789
  #
  # source://activesupport//lib/active_support/values/time_zone.rb#379
  def at(*args); end

  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/values/time_zone.rb#571
  def dst?(time); end

  # source://activesupport//lib/active_support/values/time_zone.rb#579
  def encode_with(coder); end

  # Returns a formatted string of the offset from UTC, or an alternative
  # string if the time zone is already UTC.
  #
  #   zone = ActiveSupport::TimeZone['Central Time (US & Canada)']
  #   zone.formatted_offset        # => "-06:00"
  #   zone.formatted_offset(false) # => "-0600"
  #
  # source://activesupport//lib/active_support/values/time_zone.rb#327
  def formatted_offset(colon = T.unsafe(nil), alternate_utc_string = T.unsafe(nil)); end

  # source://activesupport//lib/active_support/values/time_zone.rb#575
  def init_with(coder); end

  # \Method for creating new ActiveSupport::TimeWithZone instance in time zone
  # of +self+ from an ISO 8601 string.
  #
  #   Time.zone = 'Hawaii'                     # => "Hawaii"
  #   Time.zone.iso8601('1999-12-31T14:00:00') # => Fri, 31 Dec 1999 14:00:00 HST -10:00
  #
  # If the time components are missing then they will be set to zero.
  #
  #   Time.zone = 'Hawaii'            # => "Hawaii"
  #   Time.zone.iso8601('1999-12-31') # => Fri, 31 Dec 1999 00:00:00 HST -10:00
  #
  # If the string is invalid then an +ArgumentError+ will be raised unlike +parse+
  # which usually returns +nil+ when given an invalid date string.
  #
  # source://activesupport//lib/active_support/values/time_zone.rb#396
  def iso8601(str); end

  # \Method for creating new ActiveSupport::TimeWithZone instance in time zone
  # of +self+ from given values.
  #
  #   Time.zone = 'Hawaii'                    # => "Hawaii"
  #   Time.zone.local(2007, 2, 1, 15, 30, 45) # => Thu, 01 Feb 2007 15:30:45 HST -10:00
  #
  # source://activesupport//lib/active_support/values/time_zone.rb#363
  def local(*args); end

  # Adjust the given time to the simultaneous time in UTC. Returns a
  # Time.utc() instance.
  #
  # source://activesupport//lib/active_support/values/time_zone.rb#551
  def local_to_utc(time, dst = T.unsafe(nil)); end

  # Compare #name and TZInfo identifier to a supplied regexp, returning +true+
  # if a match is found.
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/values/time_zone.rb#348
  def match?(re); end

  # Returns the value of attribute name.
  #
  # source://activesupport//lib/active_support/values/time_zone.rb#296
  def name; end

  # Returns an ActiveSupport::TimeWithZone instance representing the current
  # time in the time zone represented by +self+.
  #
  #   Time.zone = 'Hawaii'  # => "Hawaii"
  #   Time.zone.now         # => Wed, 23 Jan 2008 20:24:27 HST -10:00
  #
  # source://activesupport//lib/active_support/values/time_zone.rb#516
  def now; end

  # \Method for creating new ActiveSupport::TimeWithZone instance in time zone
  # of +self+ from parsed string.
  #
  #   Time.zone = 'Hawaii'                   # => "Hawaii"
  #   Time.zone.parse('1999-12-31 14:00:00') # => Fri, 31 Dec 1999 14:00:00 HST -10:00
  #
  # If upper components are missing from the string, they are supplied from
  # TimeZone#now:
  #
  #   Time.zone.now               # => Fri, 31 Dec 1999 14:00:00 HST -10:00
  #   Time.zone.parse('22:30:00') # => Fri, 31 Dec 1999 22:30:00 HST -10:00
  #
  # However, if the date component is not provided, but any other upper
  # components are supplied, then the day of the month defaults to 1:
  #
  #   Time.zone.parse('Mar 2000') # => Wed, 01 Mar 2000 00:00:00 HST -10:00
  #
  # If the string is invalid then an +ArgumentError+ could be raised.
  #
  # source://activesupport//lib/active_support/values/time_zone.rb#453
  def parse(str, now = T.unsafe(nil)); end

  # source://activesupport//lib/active_support/values/time_zone.rb#559
  def period_for_local(time, dst = T.unsafe(nil)); end

  # source://activesupport//lib/active_support/values/time_zone.rb#555
  def period_for_utc(time); end

  # source://activesupport//lib/active_support/values/time_zone.rb#563
  def periods_for_local(time); end

  # \Method for creating new ActiveSupport::TimeWithZone instance in time zone
  # of +self+ from an RFC 3339 string.
  #
  #   Time.zone = 'Hawaii'                     # => "Hawaii"
  #   Time.zone.rfc3339('2000-01-01T00:00:00Z') # => Fri, 31 Dec 1999 14:00:00 HST -10:00
  #
  # If the time or zone components are missing then an +ArgumentError+ will
  # be raised. This is much stricter than either +parse+ or +iso8601+ which
  # allow for missing components.
  #
  #   Time.zone = 'Hawaii'            # => "Hawaii"
  #   Time.zone.rfc3339('1999-12-31') # => ArgumentError: invalid date
  #
  # @raise [ArgumentError]
  #
  # source://activesupport//lib/active_support/values/time_zone.rb#469
  def rfc3339(str); end

  # Parses +str+ according to +format+ and returns an ActiveSupport::TimeWithZone.
  #
  # Assumes that +str+ is a time in the time zone +self+,
  # unless +format+ includes an explicit time zone.
  # (This is the same behavior as +parse+.)
  # In either case, the returned TimeWithZone has the timezone of +self+.
  #
  #   Time.zone = 'Hawaii'                   # => "Hawaii"
  #   Time.zone.strptime('1999-12-31 14:00:00', '%Y-%m-%d %H:%M:%S') # => Fri, 31 Dec 1999 14:00:00 HST -10:00
  #
  # If upper components are missing from the string, they are supplied from
  # TimeZone#now:
  #
  #   Time.zone.now                              # => Fri, 31 Dec 1999 14:00:00 HST -10:00
  #   Time.zone.strptime('22:30:00', '%H:%M:%S') # => Fri, 31 Dec 1999 22:30:00 HST -10:00
  #
  # However, if the date component is not provided, but any other upper
  # components are supplied, then the day of the month defaults to 1:
  #
  #   Time.zone.strptime('Mar 2000', '%b %Y') # => Wed, 01 Mar 2000 00:00:00 HST -10:00
  #
  # source://activesupport//lib/active_support/values/time_zone.rb#507
  def strptime(str, format, now = T.unsafe(nil)); end

  # Returns a textual representation of this time zone.
  #
  # source://activesupport//lib/active_support/values/time_zone.rb#354
  def to_s; end

  # Returns the current date in this time zone.
  #
  # source://activesupport//lib/active_support/values/time_zone.rb#521
  def today; end

  # Returns the next date in this time zone.
  #
  # source://activesupport//lib/active_support/values/time_zone.rb#526
  def tomorrow; end

  # Returns the value of attribute tzinfo.
  #
  # source://activesupport//lib/active_support/values/time_zone.rb#297
  def tzinfo; end

  # Returns the offset of this time zone from UTC in seconds.
  #
  # source://activesupport//lib/active_support/values/time_zone.rb#317
  def utc_offset; end

  # Adjust the given time to the simultaneous time in the time zone
  # represented by +self+. Returns a local time with the appropriate offset
  # -- if you want an ActiveSupport::TimeWithZone instance, use
  # Time#in_time_zone() instead.
  #
  # As of tzinfo 2, utc_to_local returns a Time with a non-zero utc_offset.
  # See the +utc_to_local_returns_utc_offset_times+ config for more info.
  #
  # source://activesupport//lib/active_support/values/time_zone.rb#542
  def utc_to_local(time); end

  # Returns the previous date in this time zone.
  #
  # source://activesupport//lib/active_support/values/time_zone.rb#531
  def yesterday; end

  private

  # @raise [ArgumentError]
  #
  # source://activesupport//lib/active_support/values/time_zone.rb#585
  def parts_to_time(parts, now); end

  # source://activesupport//lib/active_support/values/time_zone.rb#610
  def time_now; end

  class << self
    # Locate a specific time zone object. If the argument is a string, it
    # is interpreted to mean the name of the timezone to locate. If it is a
    # numeric value it is either the hour offset, or the second offset, of the
    # timezone to find. (The first one with that offset will be returned.)
    # Returns +nil+ if no such time zone is known to the system.
    #
    # source://activesupport//lib/active_support/values/time_zone.rb#232
    def [](arg); end

    # Returns an array of all TimeZone objects. There are multiple
    # TimeZone objects per time zone, in many cases, to make it easier
    # for users to find their own time zone.
    #
    # source://activesupport//lib/active_support/values/time_zone.rb#223
    def all; end

    # source://activesupport//lib/active_support/values/time_zone.rb#265
    def clear; end

    # A convenience method for returning a collection of TimeZone objects
    # for time zones in the country specified by its ISO 3166-1 Alpha2 code.
    #
    # source://activesupport//lib/active_support/values/time_zone.rb#260
    def country_zones(country_code); end

    def create(*_arg0); end

    # source://activesupport//lib/active_support/values/time_zone.rb#207
    def find_tzinfo(name); end

    # Returns a TimeZone instance with the given name, or +nil+ if no
    # such TimeZone instance exists. (This exists to support the use of
    # this class with the +composed_of+ macro.)
    #
    # source://activesupport//lib/active_support/values/time_zone.rb#216
    def new(name); end

    # Assumes self represents an offset from UTC in seconds (as returned from
    # Time#utc_offset) and turns this into an +HH:MM formatted string.
    #
    #   ActiveSupport::TimeZone.seconds_to_utc_offset(-21_600) # => "-06:00"
    #
    # source://activesupport//lib/active_support/values/time_zone.rb#199
    def seconds_to_utc_offset(seconds, colon = T.unsafe(nil)); end

    # A convenience method for returning a collection of TimeZone objects
    # for time zones in the USA.
    #
    # source://activesupport//lib/active_support/values/time_zone.rb#254
    def us_zones; end

    private

    # source://activesupport//lib/active_support/values/time_zone.rb#273
    def load_country_zones(code); end

    # source://activesupport//lib/active_support/values/time_zone.rb#287
    def zones_map; end
  end
end

# Keys are \Rails TimeZone names, values are TZInfo identifiers.
#
# source://activesupport//lib/active_support/values/time_zone.rb#33
ActiveSupport::TimeZone::MAPPING = T.let(T.unsafe(nil), Hash)

# source://activesupport//lib/active_support/values/time_zone.rb#188
ActiveSupport::TimeZone::UTC_OFFSET_WITHOUT_COLON = T.let(T.unsafe(nil), String)

# source://activesupport//lib/active_support/values/time_zone.rb#187
ActiveSupport::TimeZone::UTC_OFFSET_WITH_COLON = T.let(T.unsafe(nil), String)

# source://activesupport//lib/active_support/core_ext/object/json.rb#35
module ActiveSupport::ToJsonWithActiveSupportEncoder
  # source://activesupport//lib/active_support/core_ext/object/json.rb#36
  def to_json(options = T.unsafe(nil)); end
end

# source://activesupport//lib/active_support/core_ext/object/try.rb#6
module ActiveSupport::Tryable
  # source://activesupport//lib/active_support/core_ext/object/try.rb#7
  def try(*args, **_arg1, &block); end

  # source://activesupport//lib/active_support/core_ext/object/try.rb#20
  def try!(*args, **_arg1, &block); end
end

# source://activesupport//lib/active_support/core_ext/object/to_query.rb#39
class Array
  include ::Enumerable

  # source://activesupport//lib/active_support/core_ext/object/json.rb#164
  def as_json(options = T.unsafe(nil)); end

  # Extends <tt>Array#to_s</tt> to convert a collection of elements into a
  # comma separated id list if <tt>:db</tt> argument is given as the format.
  #
  # This method is aliased to <tt>to_formatted_s</tt>.
  #
  #   Blog.all.to_fs(:db)  # => "1,2,3"
  #   Blog.none.to_fs(:db) # => "null"
  #   [1,2].to_fs          # => "[1, 2]"
  #
  # source://activesupport//lib/active_support/core_ext/array/conversions.rb#94
  def to_formatted_s(format = T.unsafe(nil)); end

  # Extends <tt>Array#to_s</tt> to convert a collection of elements into a
  # comma separated id list if <tt>:db</tt> argument is given as the format.
  #
  # This method is aliased to <tt>to_formatted_s</tt>.
  #
  #   Blog.all.to_fs(:db)  # => "1,2,3"
  #   Blog.none.to_fs(:db) # => "null"
  #   [1,2].to_fs          # => "[1, 2]"
  #
  # source://activesupport//lib/active_support/core_ext/array/conversions.rb#94
  def to_fs(format = T.unsafe(nil)); end

  # Calls <tt>to_param</tt> on all its elements and joins the result with
  # slashes. This is used by <tt>url_for</tt> in Action Pack.
  #
  # source://activesupport//lib/active_support/core_ext/object/to_query.rb#42
  def to_param; end

  # Converts an array into a string suitable for use as a URL query string,
  # using the given +key+ as the param name.
  #
  #   ['Rails', 'coding'].to_query('hobbies') # => "hobbies%5B%5D=Rails&hobbies%5B%5D=coding"
  #
  # source://activesupport//lib/active_support/core_ext/object/to_query.rb#50
  def to_query(key); end

  # Converts the array to a comma-separated sentence where the last element is
  # joined by the connector word.
  #
  # You can pass the following options to change the default behavior. If you
  # pass an option key that doesn't exist in the list below, it will raise an
  # <tt>ArgumentError</tt>.
  #
  # ==== Options
  #
  # * <tt>:words_connector</tt> - The sign or word used to join all but the last
  #   element in arrays with three or more elements (default: <tt>", "</tt>).
  # * <tt>:last_word_connector</tt> - The sign or word used to join the last element
  #   in arrays with three or more elements (default: <tt>", and "</tt>).
  # * <tt>:two_words_connector</tt> - The sign or word used to join the elements
  #   in arrays with two elements (default: <tt>" and "</tt>).
  # * <tt>:locale</tt> - If +i18n+ is available, you can set a locale and use
  #   the connector options defined on the 'support.array' namespace in the
  #   corresponding dictionary file.
  #
  # ==== Examples
  #
  #   [].to_sentence                      # => ""
  #   ['one'].to_sentence                 # => "one"
  #   ['one', 'two'].to_sentence          # => "one and two"
  #   ['one', 'two', 'three'].to_sentence # => "one, two, and three"
  #
  #   ['one', 'two'].to_sentence(passing: 'invalid option')
  #   # => ArgumentError: Unknown key: :passing. Valid keys are: :words_connector, :two_words_connector, :last_word_connector, :locale
  #
  #   ['one', 'two'].to_sentence(two_words_connector: '-')
  #   # => "one-two"
  #
  #   ['one', 'two', 'three'].to_sentence(words_connector: ' or ', last_word_connector: ' or at least ')
  #   # => "one or two or at least three"
  #
  # Using <tt>:locale</tt> option:
  #
  #   # Given this locale dictionary:
  #   #
  #   #   es:
  #   #     support:
  #   #       array:
  #   #         words_connector: " o "
  #   #         two_words_connector: " y "
  #   #         last_word_connector: " o al menos "
  #
  #   ['uno', 'dos'].to_sentence(locale: :es)
  #   # => "uno y dos"
  #
  #   ['uno', 'dos', 'tres'].to_sentence(locale: :es)
  #   # => "uno o dos o al menos tres"
  #
  # source://activesupport//lib/active_support/core_ext/array/conversions.rb#60
  def to_sentence(options = T.unsafe(nil)); end

  # Returns a string that represents the array in XML by invoking +to_xml+
  # on each element. Active Record collections delegate their representation
  # in XML to this method.
  #
  # All elements are expected to respond to +to_xml+, if any of them does
  # not then an exception is raised.
  #
  # The root node reflects the class name of the first element in plural
  # if all elements belong to the same type and that's not Hash:
  #
  #   customer.projects.to_xml
  #
  #   <?xml version="1.0" encoding="UTF-8"?>
  #   <projects type="array">
  #     <project>
  #       <amount type="decimal">20000.0</amount>
  #       <customer-id type="integer">1567</customer-id>
  #       <deal-date type="date">2008-04-09</deal-date>
  #       ...
  #     </project>
  #     <project>
  #       <amount type="decimal">57230.0</amount>
  #       <customer-id type="integer">1567</customer-id>
  #       <deal-date type="date">2008-04-15</deal-date>
  #       ...
  #     </project>
  #   </projects>
  #
  # Otherwise the root element is "objects":
  #
  #   [{ foo: 1, bar: 2}, { baz: 3}].to_xml
  #
  #   <?xml version="1.0" encoding="UTF-8"?>
  #   <objects type="array">
  #     <object>
  #       <bar type="integer">2</bar>
  #       <foo type="integer">1</foo>
  #     </object>
  #     <object>
  #       <baz type="integer">3</baz>
  #     </object>
  #   </objects>
  #
  # If the collection is empty the root element is "nil-classes" by default:
  #
  #   [].to_xml
  #
  #   <?xml version="1.0" encoding="UTF-8"?>
  #   <nil-classes type="array"/>
  #
  # To ensure a meaningful root element use the <tt>:root</tt> option:
  #
  #   customer_with_no_projects.projects.to_xml(root: 'projects')
  #
  #   <?xml version="1.0" encoding="UTF-8"?>
  #   <projects type="array"/>
  #
  # By default name of the node for the children of root is <tt>root.singularize</tt>.
  # You can change it with the <tt>:children</tt> option.
  #
  # The +options+ hash is passed downwards:
  #
  #   Message.all.to_xml(skip_types: true)
  #
  #   <?xml version="1.0" encoding="UTF-8"?>
  #   <messages>
  #     <message>
  #       <created-at>2008-03-07T09:58:18+01:00</created-at>
  #       <id>1</id>
  #       <name>1</name>
  #       <updated-at>2008-03-07T09:58:18+01:00</updated-at>
  #       <user-id>1</user-id>
  #     </message>
  #   </messages>
  #
  # source://activesupport//lib/active_support/core_ext/array/conversions.rb#183
  def to_xml(options = T.unsafe(nil)); end
end

# source://activesupport//lib/active_support/core_ext/object/json.rb#124
class BigDecimal < ::Numeric
  include ::ActiveSupport::BigDecimalWithDefaultFormat

  # A BigDecimal would be naturally represented as a JSON number. Most libraries,
  # however, parse non-integer JSON numbers directly as floats. Clients using
  # those libraries would get in general a wrong number and no way to recover
  # other than manually inspecting the string with the JSON code itself.
  #
  # That's why a JSON string is returned. The JSON literal is not numeric, but
  # if the other end knows by contract that the data is supposed to be a
  # BigDecimal, it still has the chance to post-process the string and get the
  # real value.
  #
  # source://activesupport//lib/active_support/core_ext/object/json.rb#134
  def as_json(options = T.unsafe(nil)); end

  # source://activesupport//lib/active_support/core_ext/big_decimal/conversions.rb#8
  def to_s(format = T.unsafe(nil)); end
end

# source://activesupport//lib/active_support/core_ext/object/json.rb#68
class Data
  # source://activesupport//lib/active_support/core_ext/object/json.rb#69
  def as_json(options = T.unsafe(nil)); end
end

# source://activesupport//lib/active_support/core_ext/date/zones.rb#6
class Date
  include ::Comparable
  include ::DateAndTime::Zones
  include ::DateAndTime::Calculations

  # source://activesupport//lib/active_support/core_ext/date/calculations.rb#90
  def +(other); end

  # source://activesupport//lib/active_support/core_ext/date/calculations.rb#100
  def -(other); end

  # Allow Date to be compared with Time by converting to DateTime and relying on the <=> from there.
  #
  # source://activesupport//lib/active_support/core_ext/date/calculations.rb#152
  def <=>(other); end

  # Provides precise Date calculations for years, months, and days. The +options+ parameter takes a hash with
  # any of these keys: <tt>:years</tt>, <tt>:months</tt>, <tt>:weeks</tt>, <tt>:days</tt>.
  #
  # The increments are applied in order of time units from largest to smallest.
  # In other words, the date is incremented first by +:years+, then by
  # +:months+, then by +:weeks+, then by +:days+. This order can affect the
  # result around the end of a month. For example, incrementing first by months
  # then by days:
  #
  #   Date.new(2004, 9, 30).advance(months: 1, days: 1)
  #   # => Sun, 31 Oct 2004
  #
  # Whereas incrementing first by days then by months yields a different result:
  #
  #   Date.new(2004, 9, 30).advance(days: 1).advance(months: 1)
  #   # => Mon, 01 Nov 2004
  #
  # source://activesupport//lib/active_support/core_ext/date/calculations.rb#127
  def advance(options); end

  # Converts Date to a Time (or DateTime if necessary) with the time portion set to the beginning of the day (0:00)
  # and then subtracts the specified number of seconds.
  #
  # source://activesupport//lib/active_support/core_ext/date/calculations.rb#55
  def ago(seconds); end

  # source://activesupport//lib/active_support/core_ext/object/json.rb#211
  def as_json(options = T.unsafe(nil)); end

  # Converts Date to a Time (or DateTime if necessary) with the time portion set to the beginning of the day (0:00)
  #
  # source://activesupport//lib/active_support/core_ext/date/calculations.rb#67
  def at_beginning_of_day; end

  # Converts Date to a Time (or DateTime if necessary) with the time portion set to the end of the day (23:59:59)
  #
  # source://activesupport//lib/active_support/core_ext/date/calculations.rb#85
  def at_end_of_day; end

  # Converts Date to a Time (or DateTime if necessary) with the time portion set to the middle of the day (12:00)
  #
  # source://activesupport//lib/active_support/core_ext/date/calculations.rb#75
  def at_midday; end

  # Converts Date to a Time (or DateTime if necessary) with the time portion set to the middle of the day (12:00)
  #
  # source://activesupport//lib/active_support/core_ext/date/calculations.rb#75
  def at_middle_of_day; end

  # Converts Date to a Time (or DateTime if necessary) with the time portion set to the beginning of the day (0:00)
  #
  # source://activesupport//lib/active_support/core_ext/date/calculations.rb#67
  def at_midnight; end

  # Converts Date to a Time (or DateTime if necessary) with the time portion set to the middle of the day (12:00)
  #
  # source://activesupport//lib/active_support/core_ext/date/calculations.rb#75
  def at_noon; end

  # Converts Date to a Time (or DateTime if necessary) with the time portion set to the beginning of the day (0:00)
  #
  # source://activesupport//lib/active_support/core_ext/date/calculations.rb#67
  def beginning_of_day; end

  # Returns a new Date where one or more of the elements have been changed according to the +options+ parameter.
  # The +options+ parameter is a hash with a combination of these keys: <tt>:year</tt>, <tt>:month</tt>, <tt>:day</tt>.
  #
  #   Date.new(2007, 5, 12).change(day: 1)               # => Date.new(2007, 5, 1)
  #   Date.new(2007, 5, 12).change(year: 2005, month: 1) # => Date.new(2005, 1, 12)
  #
  # source://activesupport//lib/active_support/core_ext/date/calculations.rb#143
  def change(options); end

  # Allow Date to be compared with Time by converting to DateTime and relying on the <=> from there.
  #
  # source://activesupport//lib/active_support/core_ext/date/calculations.rb#152
  def compare_with_coercion(other); end

  # Converts Date to a Time (or DateTime if necessary) with the time portion set to the end of the day (23:59:59)
  #
  # source://activesupport//lib/active_support/core_ext/date/calculations.rb#85
  def end_of_day; end

  # Converts Date to a Time (or DateTime if necessary) with the time portion set to the beginning of the day (0:00)
  # and then adds the specified number of seconds
  #
  # source://activesupport//lib/active_support/core_ext/date/calculations.rb#61
  def in(seconds); end

  # Overrides the default inspect method with a human readable one, e.g., "Mon, 21 Feb 2005"
  #
  # source://activesupport//lib/active_support/core_ext/date/conversions.rb#63
  def inspect; end

  # Converts Date to a Time (or DateTime if necessary) with the time portion set to the middle of the day (12:00)
  #
  # source://activesupport//lib/active_support/core_ext/date/calculations.rb#75
  def midday; end

  # Converts Date to a Time (or DateTime if necessary) with the time portion set to the middle of the day (12:00)
  #
  # source://activesupport//lib/active_support/core_ext/date/calculations.rb#75
  def middle_of_day; end

  # Converts Date to a Time (or DateTime if necessary) with the time portion set to the beginning of the day (0:00)
  #
  # source://activesupport//lib/active_support/core_ext/date/calculations.rb#67
  def midnight; end

  # source://activesupport//lib/active_support/core_ext/date/calculations.rb#100
  def minus_with_duration(other); end

  # Converts Date to a Time (or DateTime if necessary) with the time portion set to the middle of the day (12:00)
  #
  # source://activesupport//lib/active_support/core_ext/date/calculations.rb#75
  def noon; end

  # source://activesupport//lib/active_support/core_ext/date/calculations.rb#90
  def plus_with_duration(other); end

  # Overrides the default inspect method with a human readable one, e.g., "Mon, 21 Feb 2005"
  #
  # source://activesupport//lib/active_support/core_ext/date/conversions.rb#63
  def readable_inspect; end

  # Converts Date to a Time (or DateTime if necessary) with the time portion set to the beginning of the day (0:00)
  # and then adds the specified number of seconds
  #
  # source://activesupport//lib/active_support/core_ext/date/calculations.rb#61
  def since(seconds); end

  # Convert to a formatted string. See DATE_FORMATS for predefined formats.
  #
  # This method is aliased to <tt>to_formatted_s</tt>.
  #
  #   date = Date.new(2007, 11, 10)       # => Sat, 10 Nov 2007
  #
  #   date.to_fs(:db)                     # => "2007-11-10"
  #   date.to_formatted_s(:db)            # => "2007-11-10"
  #
  #   date.to_fs(:short)         # => "10 Nov"
  #   date.to_fs(:number)        # => "20071110"
  #   date.to_fs(:long)          # => "November 10, 2007"
  #   date.to_fs(:long_ordinal)  # => "November 10th, 2007"
  #   date.to_fs(:rfc822)        # => "10 Nov 2007"
  #   date.to_fs(:rfc2822)       # => "10 Nov 2007"
  #   date.to_fs(:iso8601)       # => "2007-11-10"
  #
  # == Adding your own date formats to to_fs
  # You can add your own formats to the Date::DATE_FORMATS hash.
  # Use the format name as the hash key and either a strftime string
  # or Proc instance that takes a date argument as the value.
  #
  #   # config/initializers/date_formats.rb
  #   Date::DATE_FORMATS[:month_and_year] = '%B %Y'
  #   Date::DATE_FORMATS[:short_ordinal] = ->(date) { date.strftime("%B #{date.day.ordinalize}") }
  #
  # source://activesupport//lib/active_support/core_ext/date/conversions.rb#49
  def to_formatted_s(format = T.unsafe(nil)); end

  # Convert to a formatted string. See DATE_FORMATS for predefined formats.
  #
  # This method is aliased to <tt>to_formatted_s</tt>.
  #
  #   date = Date.new(2007, 11, 10)       # => Sat, 10 Nov 2007
  #
  #   date.to_fs(:db)                     # => "2007-11-10"
  #   date.to_formatted_s(:db)            # => "2007-11-10"
  #
  #   date.to_fs(:short)         # => "10 Nov"
  #   date.to_fs(:number)        # => "20071110"
  #   date.to_fs(:long)          # => "November 10, 2007"
  #   date.to_fs(:long_ordinal)  # => "November 10th, 2007"
  #   date.to_fs(:rfc822)        # => "10 Nov 2007"
  #   date.to_fs(:rfc2822)       # => "10 Nov 2007"
  #   date.to_fs(:iso8601)       # => "2007-11-10"
  #
  # == Adding your own date formats to to_fs
  # You can add your own formats to the Date::DATE_FORMATS hash.
  # Use the format name as the hash key and either a strftime string
  # or Proc instance that takes a date argument as the value.
  #
  #   # config/initializers/date_formats.rb
  #   Date::DATE_FORMATS[:month_and_year] = '%B %Y'
  #   Date::DATE_FORMATS[:short_ordinal] = ->(date) { date.strftime("%B #{date.day.ordinalize}") }
  #
  # source://activesupport//lib/active_support/core_ext/date/conversions.rb#49
  def to_fs(format = T.unsafe(nil)); end

  # Converts a Date instance to a Time, where the time is set to the beginning of the day.
  # The timezone can be either +:local+ or +:utc+ (default +:local+).
  #
  #   date = Date.new(2007, 11, 10)  # => Sat, 10 Nov 2007
  #
  #   date.to_time                   # => 2007-11-10 00:00:00 0800
  #   date.to_time(:local)           # => 2007-11-10 00:00:00 0800
  #
  #   date.to_time(:utc)             # => 2007-11-10 00:00:00 UTC
  #
  # NOTE: The +:local+ timezone is Ruby's *process* timezone, i.e. <tt>ENV['TZ']</tt>.
  # If the <b>application's</b> timezone is needed, then use +in_time_zone+ instead.
  #
  # @raise [ArgumentError]
  #
  # source://activesupport//lib/active_support/core_ext/date/conversions.rb#83
  def to_time(form = T.unsafe(nil)); end

  # Returns a string which represents the time in used time zone as DateTime
  # defined by XML Schema:
  #
  #   date = Date.new(2015, 05, 23)  # => Sat, 23 May 2015
  #   date.xmlschema                 # => "2015-05-23T00:00:00+04:00"
  #
  # source://activesupport//lib/active_support/core_ext/date/conversions.rb#95
  def xmlschema; end

  class << self
    # Returns the week start (e.g. +:monday+) for the current request, if this has been set (via Date.beginning_of_week=).
    # If <tt>Date.beginning_of_week</tt> has not been set for the current request, returns the week start specified in <tt>config.beginning_of_week</tt>.
    # If no +config.beginning_of_week+ was specified, returns +:monday+.
    #
    # source://activesupport//lib/active_support/core_ext/date/calculations.rb#19
    def beginning_of_week; end

    # Sets <tt>Date.beginning_of_week</tt> to a week start (e.g. +:monday+) for current request/thread.
    #
    # This method accepts any of the following day symbols:
    # +:monday+, +:tuesday+, +:wednesday+, +:thursday+, +:friday+, +:saturday+, +:sunday+
    #
    # source://activesupport//lib/active_support/core_ext/date/calculations.rb#27
    def beginning_of_week=(week_start); end

    # Returns the value of attribute beginning_of_week_default.
    #
    # source://activesupport//lib/active_support/core_ext/date/calculations.rb#14
    def beginning_of_week_default; end

    # Sets the attribute beginning_of_week_default
    #
    # @param value the value to set the attribute beginning_of_week_default to.
    #
    # source://activesupport//lib/active_support/core_ext/date/calculations.rb#14
    def beginning_of_week_default=(_arg0); end

    # Returns Time.zone.today when <tt>Time.zone</tt> or <tt>config.time_zone</tt> are set, otherwise just returns Date.today.
    #
    # source://activesupport//lib/active_support/core_ext/date/calculations.rb#48
    def current; end

    # Returns week start day symbol (e.g. +:monday+), or raises an +ArgumentError+ for invalid day symbol.
    #
    # @raise [ArgumentError]
    #
    # source://activesupport//lib/active_support/core_ext/date/calculations.rb#32
    def find_beginning_of_week!(week_start); end

    # Returns a new Date representing the date 1 day after today (i.e. tomorrow's date).
    #
    # source://activesupport//lib/active_support/core_ext/date/calculations.rb#43
    def tomorrow; end

    # Returns a new Date representing the date 1 day ago (i.e. yesterday's date).
    #
    # source://activesupport//lib/active_support/core_ext/date/calculations.rb#38
    def yesterday; end
  end
end

# source://activesupport//lib/active_support/core_ext/date/conversions.rb#9
Date::DATE_FORMATS = T.let(T.unsafe(nil), Hash)

# source://activesupport//lib/active_support/core_ext/date_and_time/zones.rb#3
module DateAndTime; end

# source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#7
module DateAndTime::Calculations
  # Returns true if the date/time falls after <tt>date_or_time</tt>.
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#72
  def after?(date_or_time); end

  # Returns a Range representing the whole day of the current date/time.
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#310
  def all_day; end

  # Returns a Range representing the whole month of the current date/time.
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#321
  def all_month; end

  # Returns a Range representing the whole quarter of the current date/time.
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#326
  def all_quarter; end

  # Returns a Range representing the whole week of the current date/time.
  # Week starts on start_day, default is <tt>Date.beginning_of_week</tt> or <tt>config.beginning_of_week</tt> when set.
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#316
  def all_week(start_day = T.unsafe(nil)); end

  # Returns a Range representing the whole year of the current date/time.
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#331
  def all_year; end

  # Returns a new date/time at the start of the month.
  #
  #   today = Date.today # => Thu, 18 Jun 2015
  #   today.beginning_of_month # => Mon, 01 Jun 2015
  #
  # +DateTime+ objects will have a time set to 0:00.
  #
  #   now = DateTime.current # => Thu, 18 Jun 2015 15:23:13 +0000
  #   now.beginning_of_month # => Mon, 01 Jun 2015 00:00:00 +0000
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#125
  def at_beginning_of_month; end

  # Returns a new date/time at the start of the quarter.
  #
  #   today = Date.today # => Fri, 10 Jul 2015
  #   today.beginning_of_quarter # => Wed, 01 Jul 2015
  #
  # +DateTime+ objects will have a time set to 0:00.
  #
  #   now = DateTime.current # => Fri, 10 Jul 2015 18:41:29 +0000
  #   now.beginning_of_quarter # => Wed, 01 Jul 2015 00:00:00 +0000
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#139
  def at_beginning_of_quarter; end

  # Returns a new date/time representing the start of this week on the given day.
  # Week is assumed to start on +start_day+, default is
  # +Date.beginning_of_week+ or +config.beginning_of_week+ when set.
  # +DateTime+ objects have their time set to 0:00.
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#267
  def at_beginning_of_week(start_day = T.unsafe(nil)); end

  # Returns a new date/time at the beginning of the year.
  #
  #   today = Date.today # => Fri, 10 Jul 2015
  #   today.beginning_of_year # => Thu, 01 Jan 2015
  #
  # +DateTime+ objects will have a time set to 0:00.
  #
  #   now = DateTime.current # => Fri, 10 Jul 2015 18:41:29 +0000
  #   now.beginning_of_year # => Thu, 01 Jan 2015 00:00:00 +0000
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#179
  def at_beginning_of_year; end

  # Returns a new date/time representing the end of the month.
  # DateTime objects will have a time set to 23:59:59.
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#296
  def at_end_of_month; end

  # Returns a new date/time at the end of the quarter.
  #
  #   today = Date.today # => Fri, 10 Jul 2015
  #   today.end_of_quarter # => Wed, 30 Sep 2015
  #
  # +DateTime+ objects will have a time set to 23:59:59.
  #
  #   now = DateTime.current # => Fri, 10 Jul 2015 18:41:29 +0000
  #   now.end_of_quarter # => Wed, 30 Sep 2015 23:59:59 +0000
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#154
  def at_end_of_quarter; end

  # Returns a new date/time representing the end of this week on the given day.
  # Week is assumed to start on +start_day+, default is
  # +Date.beginning_of_week+ or +config.beginning_of_week+ when set.
  # DateTime objects have their time set to 23:59:59.
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#283
  def at_end_of_week(start_day = T.unsafe(nil)); end

  # Returns a new date/time representing the end of the year.
  # DateTime objects will have a time set to 23:59:59.
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#304
  def at_end_of_year; end

  # Returns true if the date/time falls before <tt>date_or_time</tt>.
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#67
  def before?(date_or_time); end

  # Returns a new date/time at the start of the month.
  #
  #   today = Date.today # => Thu, 18 Jun 2015
  #   today.beginning_of_month # => Mon, 01 Jun 2015
  #
  # +DateTime+ objects will have a time set to 0:00.
  #
  #   now = DateTime.current # => Thu, 18 Jun 2015 15:23:13 +0000
  #   now.beginning_of_month # => Mon, 01 Jun 2015 00:00:00 +0000
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#125
  def beginning_of_month; end

  # Returns a new date/time at the start of the quarter.
  #
  #   today = Date.today # => Fri, 10 Jul 2015
  #   today.beginning_of_quarter # => Wed, 01 Jul 2015
  #
  # +DateTime+ objects will have a time set to 0:00.
  #
  #   now = DateTime.current # => Fri, 10 Jul 2015 18:41:29 +0000
  #   now.beginning_of_quarter # => Wed, 01 Jul 2015 00:00:00 +0000
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#139
  def beginning_of_quarter; end

  # Returns a new date/time representing the start of this week on the given day.
  # Week is assumed to start on +start_day+, default is
  # +Date.beginning_of_week+ or +config.beginning_of_week+ when set.
  # +DateTime+ objects have their time set to 0:00.
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#267
  def beginning_of_week(start_day = T.unsafe(nil)); end

  # Returns a new date/time at the beginning of the year.
  #
  #   today = Date.today # => Fri, 10 Jul 2015
  #   today.beginning_of_year # => Thu, 01 Jan 2015
  #
  # +DateTime+ objects will have a time set to 0:00.
  #
  #   now = DateTime.current # => Fri, 10 Jul 2015 18:41:29 +0000
  #   now.beginning_of_year # => Thu, 01 Jan 2015 00:00:00 +0000
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#179
  def beginning_of_year; end

  # Returns a new date/time the specified number of days ago.
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#77
  def days_ago(days); end

  # Returns a new date/time the specified number of days in the future.
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#82
  def days_since(days); end

  # Returns the number of days to the start of the week on the given day.
  # Week is assumed to start on +start_day+, default is
  # +Date.beginning_of_week+ or +config.beginning_of_week+ when set.
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#258
  def days_to_week_start(start_day = T.unsafe(nil)); end

  # Returns a new date/time representing the end of the month.
  # DateTime objects will have a time set to 23:59:59.
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#296
  def end_of_month; end

  # Returns a new date/time at the end of the quarter.
  #
  #   today = Date.today # => Fri, 10 Jul 2015
  #   today.end_of_quarter # => Wed, 30 Sep 2015
  #
  # +DateTime+ objects will have a time set to 23:59:59.
  #
  #   now = DateTime.current # => Fri, 10 Jul 2015 18:41:29 +0000
  #   now.end_of_quarter # => Wed, 30 Sep 2015 23:59:59 +0000
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#154
  def end_of_quarter; end

  # Returns a new date/time representing the end of this week on the given day.
  # Week is assumed to start on +start_day+, default is
  # +Date.beginning_of_week+ or +config.beginning_of_week+ when set.
  # DateTime objects have their time set to 23:59:59.
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#283
  def end_of_week(start_day = T.unsafe(nil)); end

  # Returns a new date/time representing the end of the year.
  # DateTime objects will have a time set to 23:59:59.
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#304
  def end_of_year; end

  # Returns true if the date/time is in the future.
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#52
  def future?; end

  # Short-hand for <tt>months_ago(1)</tt>.
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#240
  def last_month; end

  # Short-hand for <tt>months_ago(3)</tt>.
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#245
  def last_quarter; end

  # Returns a new date/time representing the given day in the previous week.
  # Week is assumed to start on +start_day+, default is
  # +Date.beginning_of_week+ or +config.beginning_of_week+ when set.
  # DateTime objects have their time set to 0:00 unless +same_time+ is true.
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#223
  def last_week(start_day = T.unsafe(nil), same_time: T.unsafe(nil)); end

  # Returns a new date/time representing the previous weekday.
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#230
  def last_weekday; end

  # Short-hand for <tt>years_ago(1)</tt>.
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#251
  def last_year; end

  # Returns Monday of this week assuming that week starts on Monday.
  # +DateTime+ objects have their time set to 0:00.
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#275
  def monday; end

  # Returns a new date/time the specified number of months ago.
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#97
  def months_ago(months); end

  # Returns a new date/time the specified number of months in the future.
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#102
  def months_since(months); end

  # Returns true if the date/time is tomorrow.
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#35
  def next_day?; end

  # Returns a new date/time representing the next occurrence of the specified day of week.
  #
  #   today = Date.today               # => Thu, 14 Dec 2017
  #   today.next_occurring(:monday)    # => Mon, 18 Dec 2017
  #   today.next_occurring(:thursday)  # => Thu, 21 Dec 2017
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#340
  def next_occurring(day_of_week); end

  # Short-hand for <tt>months_since(3)</tt>.
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#215
  def next_quarter; end

  # Returns a new date/time representing the given day in the next week.
  #
  #   today = Date.today # => Thu, 07 May 2015
  #   today.next_week    # => Mon, 11 May 2015
  #
  # The +given_day_in_next_week+ defaults to the beginning of the week
  # which is determined by +Date.beginning_of_week+ or +config.beginning_of_week+
  # when set.
  #
  #   today = Date.today       # => Thu, 07 May 2015
  #   today.next_week(:friday) # => Fri, 15 May 2015
  #
  # +DateTime+ objects have their time set to 0:00 unless +same_time+ is true.
  #
  #   now = DateTime.current # => Thu, 07 May 2015 13:31:16 +0000
  #   now.next_week      # => Mon, 11 May 2015 00:00:00 +0000
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#200
  def next_week(given_day_in_next_week = T.unsafe(nil), same_time: T.unsafe(nil)); end

  # Returns a new date/time representing the next weekday.
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#206
  def next_weekday; end

  # Returns true if the date/time does not fall on a Saturday or Sunday.
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#62
  def on_weekday?; end

  # Returns true if the date/time falls on a Saturday or Sunday.
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#57
  def on_weekend?; end

  # Returns true if the date/time is in the past.
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#47
  def past?; end

  # Returns true if the date/time is yesterday.
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#41
  def prev_day?; end

  # Returns a new date/time representing the previous occurrence of the specified day of week.
  #
  #   today = Date.today               # => Thu, 14 Dec 2017
  #   today.prev_occurring(:monday)    # => Mon, 11 Dec 2017
  #   today.prev_occurring(:thursday)  # => Thu, 07 Dec 2017
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#351
  def prev_occurring(day_of_week); end

  # Short-hand for <tt>months_ago(3)</tt>.
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#245
  def prev_quarter; end

  # Returns a new date/time representing the given day in the previous week.
  # Week is assumed to start on +start_day+, default is
  # +Date.beginning_of_week+ or +config.beginning_of_week+ when set.
  # DateTime objects have their time set to 0:00 unless +same_time+ is true.
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#223
  def prev_week(start_day = T.unsafe(nil), same_time: T.unsafe(nil)); end

  # Returns a new date/time representing the previous weekday.
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#230
  def prev_weekday; end

  # Returns the quarter for a date/time.
  #
  #   Date.new(2010, 1, 31).quarter  # => 1
  #   Date.new(2010, 4, 12).quarter  # => 2
  #   Date.new(2010, 9, 15).quarter  # => 3
  #   Date.new(2010, 12, 25).quarter # => 4
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#166
  def quarter; end

  # Returns Sunday of this week assuming that week starts on Monday.
  # +DateTime+ objects have their time set to 23:59:59.
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#290
  def sunday; end

  # Returns true if the date/time is today.
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#30
  def today?; end

  # Returns a new date/time representing tomorrow.
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#25
  def tomorrow; end

  # Returns true if the date/time is tomorrow.
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#35
  def tomorrow?; end

  # Returns a new date/time the specified number of weeks ago.
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#87
  def weeks_ago(weeks); end

  # Returns a new date/time the specified number of weeks in the future.
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#92
  def weeks_since(weeks); end

  # Returns a new date/time the specified number of years ago.
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#107
  def years_ago(years); end

  # Returns a new date/time the specified number of years in the future.
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#112
  def years_since(years); end

  # Returns a new date/time representing yesterday.
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#20
  def yesterday; end

  # Returns true if the date/time is yesterday.
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#41
  def yesterday?; end

  private

  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#370
  def copy_time_to(other); end

  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#366
  def days_span(day); end

  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#358
  def first_hour(date_or_time); end

  # source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#362
  def last_hour(date_or_time); end
end

# source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#8
DateAndTime::Calculations::DAYS_INTO_WEEK = T.let(T.unsafe(nil), Hash)

# source://activesupport//lib/active_support/core_ext/date_and_time/calculations.rb#17
DateAndTime::Calculations::WEEKEND_DAYS = T.let(T.unsafe(nil), Array)

# source://activesupport//lib/active_support/core_ext/date_and_time/compatibility.rb#7
module DateAndTime::Compatibility
  # source://activesupport//lib/active_support/core_ext/date_and_time/compatibility.rb#39
  def preserve_timezone; end

  # source://activesupport//lib/active_support/core_ext/date_and_time/compatibility.rb#56
  def utc_to_local_returns_utc_offset_times; end

  class << self
    # --
    # This re-implements the behaviour of the mattr_reader, instead
    # of prepending on to it, to avoid overcomplicating a module that
    # is in turn included in several places. This will all go away in
    # Rails 8.0 anyway.
    #
    # source://activesupport//lib/active_support/core_ext/date_and_time/compatibility.rb#24
    def preserve_timezone; end

    # source://activesupport//lib/active_support/core_ext/date_and_time/compatibility.rb#15
    def preserve_timezone=(val); end

    # source://activesupport//lib/active_support/core_ext/date_and_time/compatibility.rb#56
    def utc_to_local_returns_utc_offset_times; end

    # source://activesupport//lib/active_support/core_ext/date_and_time/compatibility.rb#56
    def utc_to_local_returns_utc_offset_times=(val); end
  end
end

# source://activesupport//lib/active_support/core_ext/date_and_time/zones.rb#4
module DateAndTime::Zones
  # Returns the simultaneous time in <tt>Time.zone</tt> if a zone is given or
  # if Time.zone_default is set. Otherwise, it returns the current time.
  #
  #   Time.zone = 'Hawaii'        # => 'Hawaii'
  #   Time.utc(2000).in_time_zone # => Fri, 31 Dec 1999 14:00:00 HST -10:00
  #   Date.new(2000).in_time_zone # => Sat, 01 Jan 2000 00:00:00 HST -10:00
  #
  # This method is similar to Time#localtime, except that it uses <tt>Time.zone</tt> as the local zone
  # instead of the operating system's time zone.
  #
  # You can also pass in a TimeZone instance or string that identifies a TimeZone as an argument,
  # and the conversion will be based on that zone instead of <tt>Time.zone</tt>.
  #
  #   Time.utc(2000).in_time_zone('Alaska') # => Fri, 31 Dec 1999 15:00:00 AKST -09:00
  #   Date.new(2000).in_time_zone('Alaska') # => Sat, 01 Jan 2000 00:00:00 AKST -09:00
  #
  # source://activesupport//lib/active_support/core_ext/date_and_time/zones.rb#20
  def in_time_zone(zone = T.unsafe(nil)); end

  private

  # source://activesupport//lib/active_support/core_ext/date_and_time/zones.rb#32
  def time_with_zone(time, zone); end
end

# source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#5
class DateTime < ::Date
  # Layers additional behavior on DateTime#<=> so that Time and
  # ActiveSupport::TimeWithZone instances can be compared with a DateTime.
  #
  # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#208
  def <=>(other); end

  # Uses Date to provide precise Time calculations for years, months, and days.
  # The +options+ parameter takes a hash with any of these keys: <tt>:years</tt>,
  # <tt>:months</tt>, <tt>:weeks</tt>, <tt>:days</tt>, <tt>:hours</tt>,
  # <tt>:minutes</tt>, <tt>:seconds</tt>.
  #
  # Just like Date#advance, increments are applied in order of time units from
  # largest to smallest. This order can affect the result around the end of a
  # month.
  #
  # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#82
  def advance(options); end

  # Returns a new DateTime representing the time a number of seconds ago.
  # Do not use this method in combination with x.months, use months_ago instead!
  #
  # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#109
  def ago(seconds); end

  # source://activesupport//lib/active_support/core_ext/object/json.rb#221
  def as_json(options = T.unsafe(nil)); end

  # Returns a new DateTime representing the start of the day (0:00).
  #
  # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#122
  def at_beginning_of_day; end

  # Returns a new DateTime representing the start of the hour (hh:00:00).
  #
  # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#146
  def at_beginning_of_hour; end

  # Returns a new DateTime representing the start of the minute (hh:mm:00).
  #
  # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#158
  def at_beginning_of_minute; end

  # Returns a new DateTime representing the end of the day (23:59:59).
  #
  # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#140
  def at_end_of_day; end

  # Returns a new DateTime representing the end of the hour (hh:59:59).
  #
  # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#152
  def at_end_of_hour; end

  # Returns a new DateTime representing the end of the minute (hh:mm:59).
  #
  # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#164
  def at_end_of_minute; end

  # Returns a new DateTime representing the middle of the day (12:00)
  #
  # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#130
  def at_midday; end

  # Returns a new DateTime representing the middle of the day (12:00)
  #
  # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#130
  def at_middle_of_day; end

  # Returns a new DateTime representing the start of the day (0:00).
  #
  # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#122
  def at_midnight; end

  # Returns a new DateTime representing the middle of the day (12:00)
  #
  # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#130
  def at_noon; end

  # Returns a new DateTime representing the start of the day (0:00).
  #
  # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#122
  def beginning_of_day; end

  # Returns a new DateTime representing the start of the hour (hh:00:00).
  #
  # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#146
  def beginning_of_hour; end

  # Returns a new DateTime representing the start of the minute (hh:mm:00).
  #
  # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#158
  def beginning_of_minute; end

  # Returns a new DateTime where one or more of the elements have been changed
  # according to the +options+ parameter. The time options (<tt>:hour</tt>,
  # <tt>:min</tt>, <tt>:sec</tt>) reset cascadingly, so if only the hour is
  # passed, then minute and sec is set to 0. If the hour and minute is passed,
  # then sec is set to 0. The +options+ parameter takes a hash with any of these
  # keys: <tt>:year</tt>, <tt>:month</tt>, <tt>:day</tt>, <tt>:hour</tt>,
  # <tt>:min</tt>, <tt>:sec</tt>, <tt>:offset</tt>, <tt>:start</tt>.
  #
  #   DateTime.new(2012, 8, 29, 22, 35, 0).change(day: 1)              # => DateTime.new(2012, 8, 1, 22, 35, 0)
  #   DateTime.new(2012, 8, 29, 22, 35, 0).change(year: 1981, day: 1)  # => DateTime.new(1981, 8, 1, 22, 35, 0)
  #   DateTime.new(2012, 8, 29, 22, 35, 0).change(year: 1981, hour: 0) # => DateTime.new(1981, 8, 29, 0, 0, 0)
  #
  # @raise [ArgumentError]
  #
  # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#51
  def change(options); end

  # Returns a new DateTime representing the end of the day (23:59:59).
  #
  # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#140
  def end_of_day; end

  # Returns a new DateTime representing the end of the hour (hh:59:59).
  #
  # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#152
  def end_of_hour; end

  # Returns a new DateTime representing the end of the minute (hh:mm:59).
  #
  # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#164
  def end_of_minute; end

  # Returns a formatted string of the offset from UTC, or an alternative
  # string if the time zone is already UTC.
  #
  #   datetime = DateTime.civil(2000, 1, 1, 0, 0, 0, Rational(-6, 24))
  #   datetime.formatted_offset         # => "-06:00"
  #   datetime.formatted_offset(false)  # => "-0600"
  #
  # source://activesupport//lib/active_support/core_ext/date_time/conversions.rb#51
  def formatted_offset(colon = T.unsafe(nil), alternate_utc_string = T.unsafe(nil)); end

  # Returns a <tt>Time</tt> instance of the simultaneous time in the UTC timezone.
  #
  #   DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(-6, 24))     # => Mon, 21 Feb 2005 10:11:12 -0600
  #   DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(-6, 24)).utc # => Mon, 21 Feb 2005 16:11:12 UTC
  #
  # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#184
  def getgm; end

  # Returns a <tt>Time</tt> instance of the simultaneous time in the system timezone.
  #
  # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#170
  def getlocal(utc_offset = T.unsafe(nil)); end

  # Returns a <tt>Time</tt> instance of the simultaneous time in the UTC timezone.
  #
  #   DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(-6, 24))     # => Mon, 21 Feb 2005 10:11:12 -0600
  #   DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(-6, 24)).utc # => Mon, 21 Feb 2005 16:11:12 UTC
  #
  # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#184
  def getutc; end

  # Returns a <tt>Time</tt> instance of the simultaneous time in the UTC timezone.
  #
  #   DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(-6, 24))     # => Mon, 21 Feb 2005 10:11:12 -0600
  #   DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(-6, 24)).utc # => Mon, 21 Feb 2005 16:11:12 UTC
  #
  # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#184
  def gmtime; end

  # Returns a new DateTime representing the time a number of seconds since the
  # instance time. Do not use this method in combination with x.months, use
  # months_since instead!
  #
  # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#116
  def in(seconds); end

  # Overrides the default inspect method with a human readable one, e.g., "Mon, 21 Feb 2005 14:30:00 +0000".
  #
  # source://activesupport//lib/active_support/core_ext/date_time/conversions.rb#56
  def inspect; end

  # Returns a <tt>Time</tt> instance of the simultaneous time in the system timezone.
  #
  # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#170
  def localtime(utc_offset = T.unsafe(nil)); end

  # Returns a new DateTime representing the middle of the day (12:00)
  #
  # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#130
  def midday; end

  # Returns a new DateTime representing the middle of the day (12:00)
  #
  # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#130
  def middle_of_day; end

  # Returns a new DateTime representing the start of the day (0:00).
  #
  # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#122
  def midnight; end

  # Returns a new DateTime representing the middle of the day (12:00)
  #
  # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#130
  def noon; end

  # Returns the fraction of a second as nanoseconds
  #
  # source://activesupport//lib/active_support/core_ext/date_time/conversions.rb#94
  def nsec; end

  # Overrides the default inspect method with a human readable one, e.g., "Mon, 21 Feb 2005 14:30:00 +0000".
  #
  # source://activesupport//lib/active_support/core_ext/date_time/conversions.rb#56
  def readable_inspect; end

  # Returns the number of seconds since 00:00:00.
  #
  #   DateTime.new(2012, 8, 29,  0,  0,  0).seconds_since_midnight # => 0
  #   DateTime.new(2012, 8, 29, 12, 34, 56).seconds_since_midnight # => 45296
  #   DateTime.new(2012, 8, 29, 23, 59, 59).seconds_since_midnight # => 86399
  #
  # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#20
  def seconds_since_midnight; end

  # Returns the number of seconds until 23:59:59.
  #
  #   DateTime.new(2012, 8, 29,  0,  0,  0).seconds_until_end_of_day # => 86399
  #   DateTime.new(2012, 8, 29, 12, 34, 56).seconds_until_end_of_day # => 41103
  #   DateTime.new(2012, 8, 29, 23, 59, 59).seconds_until_end_of_day # => 0
  #
  # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#29
  def seconds_until_end_of_day; end

  # Returns a new DateTime representing the time a number of seconds since the
  # instance time. Do not use this method in combination with x.months, use
  # months_since instead!
  #
  # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#116
  def since(seconds); end

  # Returns the fraction of a second as a +Rational+
  #
  #   DateTime.new(2012, 8, 29, 0, 0, 0.5).subsec # => (1/2)
  #
  # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#36
  def subsec; end

  # Converts +self+ to a floating-point number of seconds, including fractional microseconds, since the Unix epoch.
  #
  # source://activesupport//lib/active_support/core_ext/date_time/conversions.rb#79
  def to_f; end

  # Convert to a formatted string. See Time::DATE_FORMATS for predefined formats.
  #
  # This method is aliased to <tt>to_formatted_s</tt>.
  #
  # === Examples
  #   datetime = DateTime.civil(2007, 12, 4, 0, 0, 0, 0)   # => Tue, 04 Dec 2007 00:00:00 +0000
  #
  #   datetime.to_fs(:db)            # => "2007-12-04 00:00:00"
  #   datetime.to_formatted_s(:db)   # => "2007-12-04 00:00:00"
  #   datetime.to_fs(:number)        # => "20071204000000"
  #   datetime.to_fs(:short)         # => "04 Dec 00:00"
  #   datetime.to_fs(:long)          # => "December 04, 2007 00:00"
  #   datetime.to_fs(:long_ordinal)  # => "December 4th, 2007 00:00"
  #   datetime.to_fs(:rfc822)        # => "Tue, 04 Dec 2007 00:00:00 +0000"
  #   datetime.to_fs(:iso8601)       # => "2007-12-04T00:00:00+00:00"
  #
  # == Adding your own datetime formats to to_fs
  # DateTime formats are shared with Time. You can add your own to the
  # Time::DATE_FORMATS hash. Use the format name as the hash key and
  # either a strftime string or Proc instance that takes a time or
  # datetime argument as the value.
  #
  #   # config/initializers/time_formats.rb
  #   Time::DATE_FORMATS[:month_and_year] = '%B %Y'
  #   Time::DATE_FORMATS[:short_ordinal] = lambda { |time| time.strftime("%B #{time.day.ordinalize}") }
  #
  # source://activesupport//lib/active_support/core_ext/date_time/conversions.rb#35
  def to_formatted_s(format = T.unsafe(nil)); end

  # Convert to a formatted string. See Time::DATE_FORMATS for predefined formats.
  #
  # This method is aliased to <tt>to_formatted_s</tt>.
  #
  # === Examples
  #   datetime = DateTime.civil(2007, 12, 4, 0, 0, 0, 0)   # => Tue, 04 Dec 2007 00:00:00 +0000
  #
  #   datetime.to_fs(:db)            # => "2007-12-04 00:00:00"
  #   datetime.to_formatted_s(:db)   # => "2007-12-04 00:00:00"
  #   datetime.to_fs(:number)        # => "20071204000000"
  #   datetime.to_fs(:short)         # => "04 Dec 00:00"
  #   datetime.to_fs(:long)          # => "December 04, 2007 00:00"
  #   datetime.to_fs(:long_ordinal)  # => "December 4th, 2007 00:00"
  #   datetime.to_fs(:rfc822)        # => "Tue, 04 Dec 2007 00:00:00 +0000"
  #   datetime.to_fs(:iso8601)       # => "2007-12-04T00:00:00+00:00"
  #
  # == Adding your own datetime formats to to_fs
  # DateTime formats are shared with Time. You can add your own to the
  # Time::DATE_FORMATS hash. Use the format name as the hash key and
  # either a strftime string or Proc instance that takes a time or
  # datetime argument as the value.
  #
  #   # config/initializers/time_formats.rb
  #   Time::DATE_FORMATS[:month_and_year] = '%B %Y'
  #   Time::DATE_FORMATS[:short_ordinal] = lambda { |time| time.strftime("%B #{time.day.ordinalize}") }
  #
  # source://activesupport//lib/active_support/core_ext/date_time/conversions.rb#35
  def to_fs(format = T.unsafe(nil)); end

  # Converts +self+ to an integer number of seconds since the Unix epoch.
  #
  # source://activesupport//lib/active_support/core_ext/date_time/conversions.rb#84
  def to_i; end

  # Returns the fraction of a second as microseconds
  #
  # source://activesupport//lib/active_support/core_ext/date_time/conversions.rb#89
  def usec; end

  # Returns a <tt>Time</tt> instance of the simultaneous time in the UTC timezone.
  #
  #   DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(-6, 24))     # => Mon, 21 Feb 2005 10:11:12 -0600
  #   DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(-6, 24)).utc # => Mon, 21 Feb 2005 16:11:12 UTC
  #
  # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#184
  def utc; end

  # Returns +true+ if <tt>offset == 0</tt>.
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#197
  def utc?; end

  # Returns the offset value in seconds.
  #
  # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#202
  def utc_offset; end

  private

  # source://activesupport//lib/active_support/core_ext/date_time/conversions.rb#99
  def offset_in_seconds; end

  # source://activesupport//lib/active_support/core_ext/date_time/conversions.rb#103
  def seconds_since_unix_epoch; end

  class << self
    # Returns DateTime with local offset for given year if format is local else
    # offset is zero.
    #
    #   DateTime.civil_from_format :local, 2012
    #   # => Sun, 01 Jan 2012 00:00:00 +0300
    #   DateTime.civil_from_format :local, 2012, 12, 17
    #   # => Mon, 17 Dec 2012 00:00:00 +0000
    #
    # source://activesupport//lib/active_support/core_ext/date_time/conversions.rb#69
    def civil_from_format(utc_or_local, year, month = T.unsafe(nil), day = T.unsafe(nil), hour = T.unsafe(nil), min = T.unsafe(nil), sec = T.unsafe(nil)); end

    # Returns <tt>Time.zone.now.to_datetime</tt> when <tt>Time.zone</tt> or
    # <tt>config.time_zone</tt> are set, otherwise returns
    # <tt>Time.now.to_datetime</tt>.
    #
    # source://activesupport//lib/active_support/core_ext/date_time/calculations.rb#10
    def current; end
  end
end

# source://activesupport//lib/active_support/core_ext/object/try.rb#117
class Delegator < ::BasicObject
  include ::ActiveSupport::Tryable
end

module ERB::Escape
  private

  def html_escape(_arg0); end

  class << self
    def html_escape(_arg0); end
  end
end

# source://activesupport//lib/active_support/core_ext/erb/util.rb#39
module ERB::Util
  include ::ActiveSupport::CoreExt::ERBUtil
  include ::ActiveSupport::CoreExt::ERBUtilPrivate
  extend ::ActiveSupport::CoreExt::ERBUtil

  private

  # A utility method for escaping HTML without affecting existing escaped entities.
  #
  #   html_escape_once('1 < 2 &amp; 3')
  #   # => "1 &lt; 2 &amp; 3"
  #
  #   html_escape_once('&lt;&lt; Accept & Checkout')
  #   # => "&lt;&lt; Accept &amp; Checkout"
  #
  # source://activesupport//lib/active_support/core_ext/erb/util.rb#63
  def html_escape_once(s); end

  # A utility method for escaping HTML entities in JSON strings. Specifically, the
  # &, > and < characters are replaced with their equivalent unicode escaped form -
  # \u0026, \u003e, and \u003c. The Unicode sequences \u2028 and \u2029 are also
  # escaped as they are treated as newline characters in some JavaScript engines.
  # These sequences have identical meaning as the original characters inside the
  # context of a JSON string, so assuming the input is a valid and well-formed
  # JSON value, the output will have equivalent meaning when parsed:
  #
  #   json = JSON.generate({ name: "</script><script>alert('PWNED!!!')</script>"})
  #   # => "{\"name\":\"</script><script>alert('PWNED!!!')</script>\"}"
  #
  #   json_escape(json)
  #   # => "{\"name\":\"\\u003C/script\\u003E\\u003Cscript\\u003Ealert('PWNED!!!')\\u003C/script\\u003E\"}"
  #
  #   JSON.parse(json) == JSON.parse(json_escape(json))
  #   # => true
  #
  # The intended use case for this method is to escape JSON strings before including
  # them inside a script tag to avoid XSS vulnerability:
  #
  #   <script>
  #     var currentUser = <%= raw json_escape(current_user.to_json) %>;
  #   </script>
  #
  # It is necessary to +raw+ the result of +json_escape+, so that quotation marks
  # don't get converted to <tt>&quot;</tt> entities. +json_escape+ doesn't
  # automatically flag the result as HTML safe, since the raw value is unsafe to
  # use inside HTML attributes.
  #
  # If your JSON is being used downstream for insertion into the DOM, be aware of
  # whether or not it is being inserted via <tt>html()</tt>. Most jQuery plugins do this.
  # If that is the case, be sure to +html_escape+ or +sanitize+ any user-generated
  # content returned by your JSON.
  #
  # If you need to output JSON elsewhere in your HTML, you can just do something
  # like this, as any unsafe characters (including quotation marks) will be
  # automatically escaped for you:
  #
  #   <div data-user-info="<%= current_user.to_json %>">...</div>
  #
  # WARNING: this helper only works with valid JSON. Using this on non-JSON values
  # will open up serious XSS vulnerabilities. For example, if you replace the
  # +current_user.to_json+ in the example above with user input instead, the browser
  # will happily <tt>eval()</tt> that string as JavaScript.
  #
  # The escaping performed in this method is identical to those performed in the
  # Active Support JSON encoder when +ActiveSupport.escape_html_entities_in_json+ is
  # set to true. Because this transformation is idempotent, this helper can be
  # applied even if +ActiveSupport.escape_html_entities_in_json+ is already true.
  #
  # Therefore, when you are unsure if +ActiveSupport.escape_html_entities_in_json+
  # is enabled, or if you are unsure where your JSON string originated from, it
  # is recommended that you always apply this helper (other libraries, such as the
  # JSON gem, do not provide this kind of protection by default; also some gems
  # might override +to_json+ to bypass Active Support's encoder).
  #
  # source://activesupport//lib/active_support/core_ext/erb/util.rb#124
  def json_escape(s); end

  # A utility method for escaping XML names of tags and names of attributes.
  #
  #   xml_name_escape('1 < 2 & 3')
  #   # => "1___2___3"
  #
  # It follows the requirements of the specification: https://www.w3.org/TR/REC-xml/#NT-Name
  #
  # source://activesupport//lib/active_support/core_ext/erb/util.rb#142
  def xml_name_escape(name); end

  class << self
    # source://activesupport//lib/active_support/core_ext/erb/util.rb#25
    def h(s); end

    # source://activesupport//lib/active_support/core_ext/erb/util.rb#25
    def html_escape(s); end

    # A utility method for escaping HTML without affecting existing escaped entities.
    #
    #   html_escape_once('1 < 2 &amp; 3')
    #   # => "1 &lt; 2 &amp; 3"
    #
    #   html_escape_once('&lt;&lt; Accept & Checkout')
    #   # => "&lt;&lt; Accept &amp; Checkout"
    #
    # source://activesupport//lib/active_support/core_ext/erb/util.rb#63
    def html_escape_once(s); end

    # A utility method for escaping HTML entities in JSON strings. Specifically, the
    # &, > and < characters are replaced with their equivalent unicode escaped form -
    # \u0026, \u003e, and \u003c. The Unicode sequences \u2028 and \u2029 are also
    # escaped as they are treated as newline characters in some JavaScript engines.
    # These sequences have identical meaning as the original characters inside the
    # context of a JSON string, so assuming the input is a valid and well-formed
    # JSON value, the output will have equivalent meaning when parsed:
    #
    #   json = JSON.generate({ name: "</script><script>alert('PWNED!!!')</script>"})
    #   # => "{\"name\":\"</script><script>alert('PWNED!!!')</script>\"}"
    #
    #   json_escape(json)
    #   # => "{\"name\":\"\\u003C/script\\u003E\\u003Cscript\\u003Ealert('PWNED!!!')\\u003C/script\\u003E\"}"
    #
    #   JSON.parse(json) == JSON.parse(json_escape(json))
    #   # => true
    #
    # The intended use case for this method is to escape JSON strings before including
    # them inside a script tag to avoid XSS vulnerability:
    #
    #   <script>
    #     var currentUser = <%= raw json_escape(current_user.to_json) %>;
    #   </script>
    #
    # It is necessary to +raw+ the result of +json_escape+, so that quotation marks
    # don't get converted to <tt>&quot;</tt> entities. +json_escape+ doesn't
    # automatically flag the result as HTML safe, since the raw value is unsafe to
    # use inside HTML attributes.
    #
    # If your JSON is being used downstream for insertion into the DOM, be aware of
    # whether or not it is being inserted via <tt>html()</tt>. Most jQuery plugins do this.
    # If that is the case, be sure to +html_escape+ or +sanitize+ any user-generated
    # content returned by your JSON.
    #
    # If you need to output JSON elsewhere in your HTML, you can just do something
    # like this, as any unsafe characters (including quotation marks) will be
    # automatically escaped for you:
    #
    #   <div data-user-info="<%= current_user.to_json %>">...</div>
    #
    # WARNING: this helper only works with valid JSON. Using this on non-JSON values
    # will open up serious XSS vulnerabilities. For example, if you replace the
    # +current_user.to_json+ in the example above with user input instead, the browser
    # will happily <tt>eval()</tt> that string as JavaScript.
    #
    # The escaping performed in this method is identical to those performed in the
    # Active Support JSON encoder when +ActiveSupport.escape_html_entities_in_json+ is
    # set to true. Because this transformation is idempotent, this helper can be
    # applied even if +ActiveSupport.escape_html_entities_in_json+ is already true.
    #
    # Therefore, when you are unsure if +ActiveSupport.escape_html_entities_in_json+
    # is enabled, or if you are unsure where your JSON string originated from, it
    # is recommended that you always apply this helper (other libraries, such as the
    # JSON gem, do not provide this kind of protection by default; also some gems
    # might override +to_json+ to bypass Active Support's encoder).
    #
    # source://activesupport//lib/active_support/core_ext/erb/util.rb#124
    def json_escape(s); end

    # Tokenizes a line of ERB.  This is really just for error reporting and
    # nobody should use it.
    #
    # source://activesupport//lib/active_support/core_ext/erb/util.rb#161
    def tokenize(source); end

    # source://activesupport//lib/active_support/core_ext/erb/util.rb#10
    def unwrapped_html_escape(s); end

    # A utility method for escaping XML names of tags and names of attributes.
    #
    #   xml_name_escape('1 < 2 & 3')
    #   # => "1___2___3"
    #
    # It follows the requirements of the specification: https://www.w3.org/TR/REC-xml/#NT-Name
    #
    # source://activesupport//lib/active_support/core_ext/erb/util.rb#142
    def xml_name_escape(name); end
  end
end

# source://activesupport//lib/active_support/core_ext/erb/util.rb#40
ERB::Util::HTML_ESCAPE = T.let(T.unsafe(nil), Hash)

# source://activesupport//lib/active_support/core_ext/erb/util.rb#41
ERB::Util::HTML_ESCAPE_ONCE_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://activesupport//lib/active_support/core_ext/erb/util.rb#49
ERB::Util::INVALID_TAG_NAME_FOLLOWING_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://activesupport//lib/active_support/core_ext/erb/util.rb#47
ERB::Util::INVALID_TAG_NAME_START_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://activesupport//lib/active_support/core_ext/erb/util.rb#50
ERB::Util::SAFE_XML_TAG_NAME_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://activesupport//lib/active_support/core_ext/erb/util.rb#48
ERB::Util::TAG_NAME_FOLLOWING_CODEPOINTS = T.let(T.unsafe(nil), String)

# source://activesupport//lib/active_support/core_ext/erb/util.rb#51
ERB::Util::TAG_NAME_REPLACEMENT_CHAR = T.let(T.unsafe(nil), String)

# Following XML requirements: https://www.w3.org/TR/REC-xml/#NT-Name
#
# source://activesupport//lib/active_support/core_ext/erb/util.rb#44
ERB::Util::TAG_NAME_START_CODEPOINTS = T.let(T.unsafe(nil), String)

# source://activesupport//lib/active_support/core_ext/object/json.rb#145
module Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder

  # source://activesupport//lib/active_support/core_ext/object/json.rb#146
  def as_json(options = T.unsafe(nil)); end
end

# source://activesupport//lib/active_support/core_ext/object/json.rb#256
class Exception
  # source://activesupport//lib/active_support/core_ext/object/json.rb#257
  def as_json(options = T.unsafe(nil)); end
end

# source://activesupport//lib/active_support/core_ext/object/to_query.rb#32
class FalseClass
  # source://activesupport//lib/active_support/core_ext/object/json.rb#87
  def as_json(options = T.unsafe(nil)); end

  # Returns +self+.
  #
  # source://activesupport//lib/active_support/core_ext/object/to_query.rb#34
  def to_param; end
end

# source://activesupport//lib/active_support/core_ext/object/json.rb#116
class Float < ::Numeric
  # Encoding Infinity or NaN to JSON should return "null". The default returns
  # "Infinity" or "NaN" which are not valid JSON.
  #
  # source://activesupport//lib/active_support/core_ext/object/json.rb#119
  def as_json(options = T.unsafe(nil)); end
end

# source://activesupport//lib/active_support/core_ext/hash/keys.rb#3
class Hash
  include ::Enumerable
  include ::ActiveSupport::DeepMergeable

  # source://activesupport//lib/active_support/core_ext/object/json.rb#175
  def as_json(options = T.unsafe(nil)); end

  # Validates all keys in a hash match <tt>*valid_keys</tt>, raising
  # +ArgumentError+ on a mismatch.
  #
  # Note that keys are treated differently than HashWithIndifferentAccess,
  # meaning that string and symbol keys will not match.
  #
  #   { name: 'Rob', years: '28' }.assert_valid_keys(:name, :age) # => raises "ArgumentError: Unknown key: :years. Valid keys are: :name, :age"
  #   { name: 'Rob', age: '28' }.assert_valid_keys('name', 'age') # => raises "ArgumentError: Unknown key: :name. Valid keys are: 'name', 'age'"
  #   { name: 'Rob', age: '28' }.assert_valid_keys(:name, :age)   # => passes, raises nothing
  #
  # source://activesupport//lib/active_support/core_ext/hash/keys.rb#48
  def assert_valid_keys(*valid_keys); end

  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/core_ext/hash/deep_merge.rb#40
  def deep_merge?(other); end

  # Returns a new hash with all keys converted to strings.
  # This includes the keys from the root hash and from all
  # nested hashes and arrays.
  #
  #   hash = { person: { name: 'Rob', age: '28' } }
  #
  #   hash.deep_stringify_keys
  #   # => {"person"=>{"name"=>"Rob", "age"=>"28"}}
  #
  # source://activesupport//lib/active_support/core_ext/hash/keys.rb#84
  def deep_stringify_keys; end

  # Destructively converts all keys to strings.
  # This includes the keys from the root hash and from all
  # nested hashes and arrays.
  #
  # source://activesupport//lib/active_support/core_ext/hash/keys.rb#91
  def deep_stringify_keys!; end

  # Returns a new hash with all keys converted to symbols, as long as
  # they respond to +to_sym+. This includes the keys from the root hash
  # and from all nested hashes and arrays.
  #
  #   hash = { 'person' => { 'name' => 'Rob', 'age' => '28' } }
  #
  #   hash.deep_symbolize_keys
  #   # => {:person=>{:name=>"Rob", :age=>"28"}}
  #
  # source://activesupport//lib/active_support/core_ext/hash/keys.rb#103
  def deep_symbolize_keys; end

  # Destructively converts all keys to symbols, as long as they respond
  # to +to_sym+. This includes the keys from the root hash and from all
  # nested hashes and arrays.
  #
  # source://activesupport//lib/active_support/core_ext/hash/keys.rb#110
  def deep_symbolize_keys!; end

  # Returns a new hash with all keys converted by the block operation.
  # This includes the keys from the root hash and from all
  # nested hashes and arrays.
  #
  #   hash = { person: { name: 'Rob', age: '28' } }
  #
  #   hash.deep_transform_keys{ |key| key.to_s.upcase }
  #   # => {"PERSON"=>{"NAME"=>"Rob", "AGE"=>"28"}}
  #
  # source://activesupport//lib/active_support/core_ext/hash/keys.rb#65
  def deep_transform_keys(&block); end

  # Destructively converts all keys by using the block operation.
  # This includes the keys from the root hash and from all
  # nested hashes and arrays.
  #
  # source://activesupport//lib/active_support/core_ext/hash/keys.rb#72
  def deep_transform_keys!(&block); end

  # Removes the given keys from hash and returns it.
  #   hash = { a: true, b: false, c: nil }
  #   hash.except!(:c) # => { a: true, b: false }
  #   hash             # => { a: true, b: false }
  #
  # source://activesupport//lib/active_support/core_ext/hash/except.rb#8
  def except!(*keys); end

  # Removes and returns the key/value pairs matching the given keys.
  #
  #   hash = { a: 1, b: 2, c: 3, d: 4 }
  #   hash.extract!(:a, :b) # => {:a=>1, :b=>2}
  #   hash                  # => {:c=>3, :d=>4}
  #
  # source://activesupport//lib/active_support/core_ext/hash/slice.rb#24
  def extract!(*keys); end

  # Replaces the hash with only the given keys.
  # Returns a hash containing the removed key/value pairs.
  #
  #   hash = { a: 1, b: 2, c: 3, d: 4 }
  #   hash.slice!(:a, :b)  # => {:c=>3, :d=>4}
  #   hash                 # => {:a=>1, :b=>2}
  #
  # source://activesupport//lib/active_support/core_ext/hash/slice.rb#10
  def slice!(*keys); end

  # Returns a new hash with all keys converted to strings.
  #
  #   hash = { name: 'Rob', age: '28' }
  #
  #   hash.stringify_keys
  #   # => {"name"=>"Rob", "age"=>"28"}
  #
  # source://activesupport//lib/active_support/core_ext/hash/keys.rb#10
  def stringify_keys; end

  # Destructively converts all keys to strings. Same as
  # +stringify_keys+, but modifies +self+.
  #
  # source://activesupport//lib/active_support/core_ext/hash/keys.rb#16
  def stringify_keys!; end

  # Returns a new hash with all keys converted to symbols, as long as
  # they respond to +to_sym+.
  #
  #   hash = { 'name' => 'Rob', 'age' => '28' }
  #
  #   hash.symbolize_keys
  #   # => {:name=>"Rob", :age=>"28"}
  #
  # source://activesupport//lib/active_support/core_ext/hash/keys.rb#27
  def symbolize_keys; end

  # Destructively converts all keys to symbols, as long as they respond
  # to +to_sym+. Same as +symbolize_keys+, but modifies +self+.
  #
  # source://activesupport//lib/active_support/core_ext/hash/keys.rb#34
  def symbolize_keys!; end

  # Returns a new hash with all keys converted to symbols, as long as
  # they respond to +to_sym+.
  #
  #   hash = { 'name' => 'Rob', 'age' => '28' }
  #
  #   hash.symbolize_keys
  #   # => {:name=>"Rob", :age=>"28"}
  #
  # source://activesupport//lib/active_support/core_ext/hash/keys.rb#27
  def to_options; end

  # Destructively converts all keys to symbols, as long as they respond
  # to +to_sym+. Same as +symbolize_keys+, but modifies +self+.
  #
  # source://activesupport//lib/active_support/core_ext/hash/keys.rb#34
  def to_options!; end

  # Returns a string representation of the receiver suitable for use as a URL
  # query string:
  #
  #   {name: 'David', nationality: 'Danish'}.to_query
  #   # => "name=David&nationality=Danish"
  #
  # An optional namespace can be passed to enclose key names:
  #
  #   {name: 'David', nationality: 'Danish'}.to_query('user')
  #   # => "user%5Bname%5D=David&user%5Bnationality%5D=Danish"
  #
  # The string pairs "key=value" that conform the query string
  # are sorted lexicographically in ascending order.
  #
  # source://activesupport//lib/active_support/core_ext/object/to_query.rb#75
  def to_param(namespace = T.unsafe(nil)); end

  # Returns a string representation of the receiver suitable for use as a URL
  # query string:
  #
  #   {name: 'David', nationality: 'Danish'}.to_query
  #   # => "name=David&nationality=Danish"
  #
  # An optional namespace can be passed to enclose key names:
  #
  #   {name: 'David', nationality: 'Danish'}.to_query('user')
  #   # => "user%5Bname%5D=David&user%5Bnationality%5D=Danish"
  #
  # The string pairs "key=value" that conform the query string
  # are sorted lexicographically in ascending order.
  #
  # source://activesupport//lib/active_support/core_ext/object/to_query.rb#75
  def to_query(namespace = T.unsafe(nil)); end

  private

  # Support methods for deep transforming nested hashes and arrays.
  #
  # source://activesupport//lib/active_support/core_ext/hash/keys.rb#116
  def _deep_transform_keys_in_object(object, &block); end

  # source://activesupport//lib/active_support/core_ext/hash/keys.rb#129
  def _deep_transform_keys_in_object!(object, &block); end
end

# source://activesupport//lib/active_support/core_ext/object/json.rb#151
class IO
  include ::Enumerable
  include ::File::Constants

  # source://activesupport//lib/active_support/core_ext/object/json.rb#152
  def as_json(options = T.unsafe(nil)); end
end

class IO::Buffer
  include ::Comparable

  def initialize(*_arg0); end

  def &(_arg0); end
  def <=>(_arg0); end
  def ^(_arg0); end
  def and!(_arg0); end
  def clear(*_arg0); end
  def copy(*_arg0); end
  def each(*_arg0); end
  def each_byte(*_arg0); end
  def empty?; end
  def external?; end
  def free; end
  def get_string(*_arg0); end
  def get_value(_arg0, _arg1); end
  def get_values(_arg0, _arg1); end
  def hexdump; end
  def inspect; end
  def internal?; end
  def locked; end
  def locked?; end
  def mapped?; end
  def not!; end
  def null?; end
  def or!(_arg0); end
  def pread(*_arg0); end
  def pwrite(*_arg0); end
  def read(*_arg0); end
  def readonly?; end
  def resize(_arg0); end
  def set_string(*_arg0); end
  def set_value(_arg0, _arg1, _arg2); end
  def set_values(_arg0, _arg1, _arg2); end
  def shared?; end
  def size; end
  def slice(*_arg0); end
  def to_s; end
  def transfer; end
  def valid?; end
  def values(*_arg0); end
  def write(*_arg0); end
  def xor!(_arg0); end
  def |(_arg0); end
  def ~; end

  private

  def initialize_copy(_arg0); end

  class << self
    def for(_arg0); end
    def map(*_arg0); end
    def size_of(_arg0); end
  end
end

class IO::Buffer::AccessError < ::RuntimeError; end
class IO::Buffer::AllocationError < ::RuntimeError; end
IO::Buffer::BIG_ENDIAN = T.let(T.unsafe(nil), Integer)
IO::Buffer::DEFAULT_SIZE = T.let(T.unsafe(nil), Integer)
IO::Buffer::EXTERNAL = T.let(T.unsafe(nil), Integer)
IO::Buffer::HOST_ENDIAN = T.let(T.unsafe(nil), Integer)
IO::Buffer::INTERNAL = T.let(T.unsafe(nil), Integer)
class IO::Buffer::InvalidatedError < ::RuntimeError; end
IO::Buffer::LITTLE_ENDIAN = T.let(T.unsafe(nil), Integer)
IO::Buffer::LOCKED = T.let(T.unsafe(nil), Integer)
class IO::Buffer::LockedError < ::RuntimeError; end
IO::Buffer::MAPPED = T.let(T.unsafe(nil), Integer)
class IO::Buffer::MaskError < ::ArgumentError; end
IO::Buffer::NETWORK_ENDIAN = T.let(T.unsafe(nil), Integer)
IO::Buffer::PAGE_SIZE = T.let(T.unsafe(nil), Integer)
IO::Buffer::PRIVATE = T.let(T.unsafe(nil), Integer)
IO::Buffer::READONLY = T.let(T.unsafe(nil), Integer)
IO::Buffer::SHARED = T.let(T.unsafe(nil), Integer)

class IO::ConsoleMode
  def echo=(_arg0); end
  def raw(*_arg0); end
  def raw!(*_arg0); end

  private

  def initialize_copy(_arg0); end
end

class IO::EAGAINWaitReadable < ::Errno::EAGAIN
  include ::IO::WaitReadable
end

class IO::EAGAINWaitWritable < ::Errno::EAGAIN
  include ::IO::WaitWritable
end

class IO::EINPROGRESSWaitReadable < ::Errno::EINPROGRESS
  include ::IO::WaitReadable
end

class IO::EINPROGRESSWaitWritable < ::Errno::EINPROGRESS
  include ::IO::WaitWritable
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable
IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable
IO::PRIORITY = T.let(T.unsafe(nil), Integer)
IO::READABLE = T.let(T.unsafe(nil), Integer)
class IO::TimeoutError < ::IOError; end
IO::WRITABLE = T.let(T.unsafe(nil), Integer)

# source://activesupport//lib/active_support/core_ext/object/json.rb#243
class IPAddr
  # source://activesupport//lib/active_support/core_ext/object/json.rb#244
  def as_json(options = T.unsafe(nil)); end
end

class Integer < ::Numeric; end

class LoadError < ::ScriptError
  include ::DidYouMean::Correctable
end

# == Attribute Accessors per Thread
#
# Extends the module object with class/module and instance accessors for
# class/module attributes, just like the native attr* accessors for instance
# attributes, but does so on a per-thread basis.
#
# So the values are scoped within the Thread.current space under the class name
# of the module.
#
# Note that it can also be scoped per-fiber if +Rails.application.config.active_support.isolation_level+
# is set to +:fiber+.
#
# source://activesupport//lib/active_support/core_ext/module/delegation.rb#3
class Module
  # source://activesupport//lib/active_support/core_ext/object/json.rb#53
  def as_json(options = T.unsafe(nil)); end

  # Defines both class and instance accessors for class attributes.
  # All class and instance methods created will be public, even if
  # this method is called with a private or protected access modifier.
  #
  #   module HairColors
  #     mattr_accessor :hair_colors
  #   end
  #
  #   class Person
  #     include HairColors
  #   end
  #
  #   HairColors.hair_colors = [:brown, :black, :blonde, :red]
  #   HairColors.hair_colors # => [:brown, :black, :blonde, :red]
  #   Person.new.hair_colors # => [:brown, :black, :blonde, :red]
  #
  # If a subclass changes the value then that would also change the value for
  # parent class. Similarly if parent class changes the value then that would
  # change the value of subclasses too.
  #
  #   class Citizen < Person
  #   end
  #
  #   Citizen.new.hair_colors << :blue
  #   Person.new.hair_colors # => [:brown, :black, :blonde, :red, :blue]
  #
  # To omit the instance writer method, pass <tt>instance_writer: false</tt>.
  # To omit the instance reader method, pass <tt>instance_reader: false</tt>.
  #
  #   module HairColors
  #     mattr_accessor :hair_colors, instance_writer: false, instance_reader: false
  #   end
  #
  #   class Person
  #     include HairColors
  #   end
  #
  #   Person.new.hair_colors = [:brown]  # => NoMethodError
  #   Person.new.hair_colors             # => NoMethodError
  #
  # Or pass <tt>instance_accessor: false</tt>, to omit both instance methods.
  #
  #   module HairColors
  #     mattr_accessor :hair_colors, instance_accessor: false
  #   end
  #
  #   class Person
  #     include HairColors
  #   end
  #
  #   Person.new.hair_colors = [:brown]  # => NoMethodError
  #   Person.new.hair_colors             # => NoMethodError
  #
  # You can set a default value for the attribute.
  #
  #   module HairColors
  #     mattr_accessor :hair_colors, default: [:brown, :black, :blonde, :red]
  #     mattr_accessor(:hair_styles) { [:long, :short] }
  #   end
  #
  #   class Person
  #     include HairColors
  #   end
  #
  #   Person.class_variable_get("@@hair_colors") # => [:brown, :black, :blonde, :red]
  #   Person.class_variable_get("@@hair_styles") # => [:long, :short]
  #
  # source://activesupport//lib/active_support/core_ext/module/attribute_accessors.rb#208
  def cattr_accessor(*syms, instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), &blk); end

  # Defines a class attribute and creates a class and instance reader methods.
  # The underlying class variable is set to +nil+, if it is not previously
  # defined. All class and instance methods created will be public, even if
  # this method is called with a private or protected access modifier.
  #
  #   module HairColors
  #     mattr_reader :hair_colors
  #   end
  #
  #   HairColors.hair_colors # => nil
  #   HairColors.class_variable_set("@@hair_colors", [:brown, :black])
  #   HairColors.hair_colors # => [:brown, :black]
  #
  # The attribute name must be a valid method name in Ruby.
  #
  #   module Foo
  #     mattr_reader :"1_Badname"
  #   end
  #   # => NameError: invalid attribute name: 1_Badname
  #
  # To omit the instance reader method, pass
  # <tt>instance_reader: false</tt> or <tt>instance_accessor: false</tt>.
  #
  #   module HairColors
  #     mattr_reader :hair_colors, instance_reader: false
  #   end
  #
  #   class Person
  #     include HairColors
  #   end
  #
  #   Person.new.hair_colors # => NoMethodError
  #
  # You can set a default value for the attribute.
  #
  #   module HairColors
  #     mattr_reader :hair_colors, default: [:brown, :black, :blonde, :red]
  #     mattr_reader(:hair_styles) { [:long, :short] }
  #   end
  #
  #   class Person
  #     include HairColors
  #   end
  #
  #   Person.new.hair_colors # => [:brown, :black, :blonde, :red]
  #   Person.new.hair_styles # => [:long, :short]
  #
  # @raise [TypeError]
  #
  # source://activesupport//lib/active_support/core_ext/module/attribute_accessors.rb#55
  def cattr_reader(*syms, instance_reader: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), location: T.unsafe(nil)); end

  # Defines a class attribute and creates a class and instance writer methods to
  # allow assignment to the attribute. All class and instance methods created
  # will be public, even if this method is called with a private or protected
  # access modifier.
  #
  #   module HairColors
  #     mattr_writer :hair_colors
  #   end
  #
  #   class Person
  #     include HairColors
  #   end
  #
  #   HairColors.hair_colors = [:brown, :black]
  #   Person.class_variable_get("@@hair_colors") # => [:brown, :black]
  #   Person.new.hair_colors = [:blonde, :red]
  #   HairColors.class_variable_get("@@hair_colors") # => [:blonde, :red]
  #
  # To omit the instance writer method, pass
  # <tt>instance_writer: false</tt> or <tt>instance_accessor: false</tt>.
  #
  #   module HairColors
  #     mattr_writer :hair_colors, instance_writer: false
  #   end
  #
  #   class Person
  #     include HairColors
  #   end
  #
  #   Person.new.hair_colors = [:blonde, :red] # => NoMethodError
  #
  # You can set a default value for the attribute.
  #
  #   module HairColors
  #     mattr_writer :hair_colors, default: [:brown, :black, :blonde, :red]
  #     mattr_writer(:hair_styles) { [:long, :short] }
  #   end
  #
  #   class Person
  #     include HairColors
  #   end
  #
  #   Person.class_variable_get("@@hair_colors") # => [:brown, :black, :blonde, :red]
  #   Person.class_variable_get("@@hair_styles") # => [:long, :short]
  #
  # @raise [TypeError]
  #
  # source://activesupport//lib/active_support/core_ext/module/attribute_accessors.rb#121
  def cattr_writer(*syms, instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), location: T.unsafe(nil)); end

  # Provides a +delegate+ class method to easily expose contained objects'
  # public methods as your own.
  #
  # ==== Options
  # * <tt>:to</tt> - Specifies the target object name as a symbol or string
  # * <tt>:prefix</tt> - Prefixes the new method with the target name or a custom prefix
  # * <tt>:allow_nil</tt> - If set to true, prevents a +ActiveSupport::DelegationError+
  #   from being raised
  # * <tt>:private</tt> - If set to true, changes method visibility to private
  #
  # The macro receives one or more method names (specified as symbols or
  # strings) and the name of the target object via the <tt>:to</tt> option
  # (also a symbol or string).
  #
  # Delegation is particularly useful with Active Record associations:
  #
  #   class Greeter < ActiveRecord::Base
  #     def hello
  #       'hello'
  #     end
  #
  #     def goodbye
  #       'goodbye'
  #     end
  #   end
  #
  #   class Foo < ActiveRecord::Base
  #     belongs_to :greeter
  #     delegate :hello, to: :greeter
  #   end
  #
  #   Foo.new.hello   # => "hello"
  #   Foo.new.goodbye # => NoMethodError: undefined method `goodbye' for #<Foo:0x1af30c>
  #
  # Multiple delegates to the same target are allowed:
  #
  #   class Foo < ActiveRecord::Base
  #     belongs_to :greeter
  #     delegate :hello, :goodbye, to: :greeter
  #   end
  #
  #   Foo.new.goodbye # => "goodbye"
  #
  # Methods can be delegated to instance variables, class variables, or constants
  # by providing them as a symbols:
  #
  #   class Foo
  #     CONSTANT_ARRAY = [0,1,2,3]
  #     @@class_array  = [4,5,6,7]
  #
  #     def initialize
  #       @instance_array = [8,9,10,11]
  #     end
  #     delegate :sum, to: :CONSTANT_ARRAY
  #     delegate :min, to: :@@class_array
  #     delegate :max, to: :@instance_array
  #   end
  #
  #   Foo.new.sum # => 6
  #   Foo.new.min # => 4
  #   Foo.new.max # => 11
  #
  # It's also possible to delegate a method to the class by using +:class+:
  #
  #   class Foo
  #     def self.hello
  #       "world"
  #     end
  #
  #     delegate :hello, to: :class
  #   end
  #
  #   Foo.new.hello # => "world"
  #
  # Delegates can optionally be prefixed using the <tt>:prefix</tt> option. If the value
  # is <tt>true</tt>, the delegate methods are prefixed with the name of the object being
  # delegated to.
  #
  #   Person = Struct.new(:name, :address)
  #
  #   class Invoice < Struct.new(:client)
  #     delegate :name, :address, to: :client, prefix: true
  #   end
  #
  #   john_doe = Person.new('John Doe', 'Vimmersvej 13')
  #   invoice = Invoice.new(john_doe)
  #   invoice.client_name    # => "John Doe"
  #   invoice.client_address # => "Vimmersvej 13"
  #
  # It is also possible to supply a custom prefix.
  #
  #   class Invoice < Struct.new(:client)
  #     delegate :name, :address, to: :client, prefix: :customer
  #   end
  #
  #   invoice = Invoice.new(john_doe)
  #   invoice.customer_name    # => 'John Doe'
  #   invoice.customer_address # => 'Vimmersvej 13'
  #
  # The delegated methods are public by default.
  # Pass <tt>private: true</tt> to change that.
  #
  #   class User < ActiveRecord::Base
  #     has_one :profile
  #     delegate :first_name, to: :profile
  #     delegate :date_of_birth, to: :profile, private: true
  #
  #     def age
  #       Date.today.year - date_of_birth.year
  #     end
  #   end
  #
  #   User.new.first_name # => "Tomas"
  #   User.new.date_of_birth # => NoMethodError: private method `date_of_birth' called for #<User:0x00000008221340>
  #   User.new.age # => 2
  #
  # If the target is +nil+ and does not respond to the delegated method a
  # +ActiveSupport::DelegationError+ is raised. If you wish to instead return +nil+,
  # use the <tt>:allow_nil</tt> option.
  #
  #   class User < ActiveRecord::Base
  #     has_one :profile
  #     delegate :age, to: :profile
  #   end
  #
  #   User.new.age
  #   # => ActiveSupport::DelegationError: User#age delegated to profile.age, but profile is nil
  #
  # But if not having a profile yet is fine and should not be an error
  # condition:
  #
  #   class User < ActiveRecord::Base
  #     has_one :profile
  #     delegate :age, to: :profile, allow_nil: true
  #   end
  #
  #   User.new.age # nil
  #
  # Note that if the target is not +nil+ then the call is attempted regardless of the
  # <tt>:allow_nil</tt> option, and thus an exception is still raised if said object
  # does not respond to the method:
  #
  #   class Foo
  #     def initialize(bar)
  #       @bar = bar
  #     end
  #
  #     delegate :name, to: :@bar, allow_nil: true
  #   end
  #
  #   Foo.new("Bar").name # raises NoMethodError: undefined method `name'
  #
  # The target method must be public, otherwise it will raise +NoMethodError+.
  #
  # source://activesupport//lib/active_support/core_ext/module/delegation.rb#160
  def delegate(*methods, to: T.unsafe(nil), prefix: T.unsafe(nil), allow_nil: T.unsafe(nil), private: T.unsafe(nil)); end

  # When building decorators, a common pattern may emerge:
  #
  #   class Partition
  #     def initialize(event)
  #       @event = event
  #     end
  #
  #     def person
  #       detail.person || creator
  #     end
  #
  #     private
  #       def respond_to_missing?(name, include_private = false)
  #         @event.respond_to?(name, include_private)
  #       end
  #
  #       def method_missing(method, *args, &block)
  #         @event.send(method, *args, &block)
  #       end
  #   end
  #
  # With <tt>Module#delegate_missing_to</tt>, the above is condensed to:
  #
  #   class Partition
  #     delegate_missing_to :@event
  #
  #     def initialize(event)
  #       @event = event
  #     end
  #
  #     def person
  #       detail.person || creator
  #     end
  #   end
  #
  # The target can be anything callable within the object, e.g. instance
  # variables, methods, constants, etc.
  #
  # The delegated method must be public on the target, otherwise it will
  # raise +ActiveSupport::DelegationError+. If you wish to instead return +nil+,
  # use the <tt>:allow_nil</tt> option.
  #
  # The <tt>marshal_dump</tt> and <tt>_dump</tt> methods are exempt from
  # delegation due to possible interference when calling
  # <tt>Marshal.dump(object)</tt>, should the delegation target method
  # of <tt>object</tt> add or remove instance variables.
  #
  # source://activesupport//lib/active_support/core_ext/module/delegation.rb#218
  def delegate_missing_to(target, allow_nil: T.unsafe(nil)); end

  # Defines both class and instance accessors for class attributes.
  # All class and instance methods created will be public, even if
  # this method is called with a private or protected access modifier.
  #
  #   module HairColors
  #     mattr_accessor :hair_colors
  #   end
  #
  #   class Person
  #     include HairColors
  #   end
  #
  #   HairColors.hair_colors = [:brown, :black, :blonde, :red]
  #   HairColors.hair_colors # => [:brown, :black, :blonde, :red]
  #   Person.new.hair_colors # => [:brown, :black, :blonde, :red]
  #
  # If a subclass changes the value then that would also change the value for
  # parent class. Similarly if parent class changes the value then that would
  # change the value of subclasses too.
  #
  #   class Citizen < Person
  #   end
  #
  #   Citizen.new.hair_colors << :blue
  #   Person.new.hair_colors # => [:brown, :black, :blonde, :red, :blue]
  #
  # To omit the instance writer method, pass <tt>instance_writer: false</tt>.
  # To omit the instance reader method, pass <tt>instance_reader: false</tt>.
  #
  #   module HairColors
  #     mattr_accessor :hair_colors, instance_writer: false, instance_reader: false
  #   end
  #
  #   class Person
  #     include HairColors
  #   end
  #
  #   Person.new.hair_colors = [:brown]  # => NoMethodError
  #   Person.new.hair_colors             # => NoMethodError
  #
  # Or pass <tt>instance_accessor: false</tt>, to omit both instance methods.
  #
  #   module HairColors
  #     mattr_accessor :hair_colors, instance_accessor: false
  #   end
  #
  #   class Person
  #     include HairColors
  #   end
  #
  #   Person.new.hair_colors = [:brown]  # => NoMethodError
  #   Person.new.hair_colors             # => NoMethodError
  #
  # You can set a default value for the attribute.
  #
  #   module HairColors
  #     mattr_accessor :hair_colors, default: [:brown, :black, :blonde, :red]
  #     mattr_accessor(:hair_styles) { [:long, :short] }
  #   end
  #
  #   class Person
  #     include HairColors
  #   end
  #
  #   Person.class_variable_get("@@hair_colors") # => [:brown, :black, :blonde, :red]
  #   Person.class_variable_get("@@hair_styles") # => [:long, :short]
  #
  # source://activesupport//lib/active_support/core_ext/module/attribute_accessors.rb#208
  def mattr_accessor(*syms, instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), &blk); end

  # Defines a class attribute and creates a class and instance reader methods.
  # The underlying class variable is set to +nil+, if it is not previously
  # defined. All class and instance methods created will be public, even if
  # this method is called with a private or protected access modifier.
  #
  #   module HairColors
  #     mattr_reader :hair_colors
  #   end
  #
  #   HairColors.hair_colors # => nil
  #   HairColors.class_variable_set("@@hair_colors", [:brown, :black])
  #   HairColors.hair_colors # => [:brown, :black]
  #
  # The attribute name must be a valid method name in Ruby.
  #
  #   module Foo
  #     mattr_reader :"1_Badname"
  #   end
  #   # => NameError: invalid attribute name: 1_Badname
  #
  # To omit the instance reader method, pass
  # <tt>instance_reader: false</tt> or <tt>instance_accessor: false</tt>.
  #
  #   module HairColors
  #     mattr_reader :hair_colors, instance_reader: false
  #   end
  #
  #   class Person
  #     include HairColors
  #   end
  #
  #   Person.new.hair_colors # => NoMethodError
  #
  # You can set a default value for the attribute.
  #
  #   module HairColors
  #     mattr_reader :hair_colors, default: [:brown, :black, :blonde, :red]
  #     mattr_reader(:hair_styles) { [:long, :short] }
  #   end
  #
  #   class Person
  #     include HairColors
  #   end
  #
  #   Person.new.hair_colors # => [:brown, :black, :blonde, :red]
  #   Person.new.hair_styles # => [:long, :short]
  #
  # @raise [TypeError]
  #
  # source://activesupport//lib/active_support/core_ext/module/attribute_accessors.rb#55
  def mattr_reader(*syms, instance_reader: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), location: T.unsafe(nil)); end

  # Defines a class attribute and creates a class and instance writer methods to
  # allow assignment to the attribute. All class and instance methods created
  # will be public, even if this method is called with a private or protected
  # access modifier.
  #
  #   module HairColors
  #     mattr_writer :hair_colors
  #   end
  #
  #   class Person
  #     include HairColors
  #   end
  #
  #   HairColors.hair_colors = [:brown, :black]
  #   Person.class_variable_get("@@hair_colors") # => [:brown, :black]
  #   Person.new.hair_colors = [:blonde, :red]
  #   HairColors.class_variable_get("@@hair_colors") # => [:blonde, :red]
  #
  # To omit the instance writer method, pass
  # <tt>instance_writer: false</tt> or <tt>instance_accessor: false</tt>.
  #
  #   module HairColors
  #     mattr_writer :hair_colors, instance_writer: false
  #   end
  #
  #   class Person
  #     include HairColors
  #   end
  #
  #   Person.new.hair_colors = [:blonde, :red] # => NoMethodError
  #
  # You can set a default value for the attribute.
  #
  #   module HairColors
  #     mattr_writer :hair_colors, default: [:brown, :black, :blonde, :red]
  #     mattr_writer(:hair_styles) { [:long, :short] }
  #   end
  #
  #   class Person
  #     include HairColors
  #   end
  #
  #   Person.class_variable_get("@@hair_colors") # => [:brown, :black, :blonde, :red]
  #   Person.class_variable_get("@@hair_styles") # => [:long, :short]
  #
  # @raise [TypeError]
  #
  # source://activesupport//lib/active_support/core_ext/module/attribute_accessors.rb#121
  def mattr_writer(*syms, instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), location: T.unsafe(nil)); end

  # source://activesupport//lib/active_support/core_ext/module/redefine_method.rb#30
  def method_visibility(method); end

  # Replaces the existing method definition, if there is one, with the passed
  # block as its body.
  #
  # source://activesupport//lib/active_support/core_ext/module/redefine_method.rb#17
  def redefine_method(method, &block); end

  # Replaces the existing singleton method definition, if there is one, with
  # the passed block as its body.
  #
  # source://activesupport//lib/active_support/core_ext/module/redefine_method.rb#26
  def redefine_singleton_method(method, &block); end

  # Marks the named method as intended to be redefined, if it exists.
  # Suppresses the Ruby method redefinition warning. Prefer
  # #redefine_method where possible.
  #
  # source://activesupport//lib/active_support/core_ext/module/redefine_method.rb#7
  def silence_redefinition_of_method(method); end
end

# source://activesupport//lib/active_support/core_ext/module/delegation.rb#5
Module::DelegationError = ActiveSupport::DelegationError

class NameError < ::StandardError
  include ::ErrorHighlight::CoreExt
  include ::DidYouMean::Correctable
end

# source://activesupport//lib/active_support/core_ext/object/to_query.rb#18
class NilClass
  include ::Treetop::Compiler::Metagrammar::LabeledExpressionSequenceBody0

  # source://activesupport//lib/active_support/core_ext/object/json.rb#93
  def as_json(options = T.unsafe(nil)); end

  # Returns +self+.
  #
  # source://activesupport//lib/active_support/core_ext/object/to_query.rb#20
  def to_param; end

  # Calling +try+ on +nil+ always returns +nil+.
  # It becomes especially helpful when navigating through associations that may return +nil+.
  #
  #   nil.try(:name) # => nil
  #
  # Without +try+
  #   @person && @person.children.any? && @person.children.first.name
  #
  # With +try+
  #   @person.try(:children).try(:first).try(:name)
  #
  # source://activesupport//lib/active_support/core_ext/object/try.rb#148
  def try(*_arg0); end

  # Calling +try!+ on +nil+ always returns +nil+.
  #
  #   nil.try!(:name) # => nil
  #
  # source://activesupport//lib/active_support/core_ext/object/try.rb#155
  def try!(*_arg0); end
end

# source://activesupport//lib/active_support/core_ext/string/output_safety.rb#12
class Numeric
  include ::Comparable

  # source://activesupport//lib/active_support/core_ext/object/json.rb#111
  def as_json(options = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#13
  def html_safe?; end
end

# --
# Most objects are cloneable, but not all. For example you can't dup methods:
#
#   method(:puts).dup # => TypeError: allocator undefined for Method
#
# Classes may signal their instances are not duplicable removing +dup+/+clone+
# or raising exceptions from them. So, to dup an arbitrary object you normally
# use an optimistic approach and are ready to catch an exception, say:
#
#   arbitrary_object.dup rescue object
#
# Rails dups objects in a few critical spots where they are not that arbitrary.
# That rescue is very expensive (like 40 times slower than a predicate), and it
# is often triggered.
#
# That's why we hardcode the following cases and check duplicable? instead of
# using that rescue idiom.
# ++
#
# source://activesupport//lib/active_support/core_ext/object/to_query.rb#5
class Object < ::BasicObject
  include ::Kernel
  include ::PP::ObjectMixin
  include ::ActiveSupport::Tryable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder

  # Provides a way to check whether some class acts like some other class based on the existence of
  # an appropriately-named marker method.
  #
  # A class that provides the same interface as <tt>SomeClass</tt> may define a marker method named
  # <tt>acts_like_some_class?</tt> to signal its compatibility to callers of
  # <tt>acts_like?(:some_class)</tt>.
  #
  # For example, Active Support extends <tt>Date</tt> to define an <tt>acts_like_date?</tt> method,
  # and extends <tt>Time</tt> to define <tt>acts_like_time?</tt>. As a result, developers can call
  # <tt>x.acts_like?(:time)</tt> and <tt>x.acts_like?(:date)</tt> to test duck-type compatibility,
  # and classes that are able to act like <tt>Time</tt> can also define an <tt>acts_like_time?</tt>
  # method to interoperate.
  #
  # Note that the marker method is only expected to exist. It isn't called, so its body or return
  # value are irrelevant.
  #
  # ==== Example: A class that provides the same interface as <tt>String</tt>
  #
  # This class may define:
  #
  #   class Stringish
  #     def acts_like_string?
  #     end
  #   end
  #
  # Then client code can query for duck-type-safeness this way:
  #
  #   Stringish.new.acts_like?(:string) # => true
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/core_ext/object/acts_like.rb#33
  def acts_like?(duck); end

  # source://activesupport//lib/active_support/core_ext/object/json.rb#59
  def as_json(options = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#7
  def html_safe?; end

  # Returns a hash with string keys that maps instance variable names without "@" to their
  # corresponding values.
  #
  #   class C
  #     def initialize(x, y)
  #       @x, @y = x, y
  #     end
  #   end
  #
  #   C.new(0, 1).instance_values # => {"x" => 0, "y" => 1}
  #
  # source://activesupport//lib/active_support/core_ext/object/instance_variables.rb#14
  def instance_values; end

  # Returns an array of instance variable names as strings including "@".
  #
  #   class C
  #     def initialize(x, y)
  #       @x, @y = x, y
  #     end
  #   end
  #
  #   C.new(0, 1).instance_variable_names # => ["@y", "@x"]
  #
  # source://activesupport//lib/active_support/core_ext/object/instance_variables.rb#29
  def instance_variable_names; end

  # Alias of <tt>to_s</tt>.
  #
  # source://activesupport//lib/active_support/core_ext/object/to_query.rb#7
  def to_param; end

  # Converts an object into a string suitable for use as a URL query string,
  # using the given <tt>key</tt> as the param name.
  #
  # source://activesupport//lib/active_support/core_ext/object/to_query.rb#13
  def to_query(key); end
end

# source://activesupport//lib/active_support/core_ext/object/json.rb#236
class Pathname
  # source://activesupport//lib/active_support/core_ext/object/json.rb#237
  def as_json(options = T.unsafe(nil)); end
end

# source://activesupport//lib/active_support/core_ext/object/json.rb#250
class Process::Status
  # source://activesupport//lib/active_support/core_ext/object/json.rb#251
  def as_json(options = T.unsafe(nil)); end
end

# source://activesupport//lib/active_support/core_ext/object/json.rb#157
class Range
  include ::Enumerable

  # source://activesupport//lib/active_support/core_ext/object/json.rb#158
  def as_json(options = T.unsafe(nil)); end
end

# source://activesupport//lib/active_support/core_ext/object/json.rb#139
class Regexp
  # source://activesupport//lib/active_support/core_ext/object/json.rb#140
  def as_json(options = T.unsafe(nil)); end
end

# String inflections define new methods on the String class to transform names for different purposes.
# For instance, you can figure out the name of a table from the name of a class.
#
#   'ScaleScore'.tableize # => "scale_scores"
#
# source://activesupport//lib/active_support/core_ext/string/multibyte.rb#5
class String
  include ::Comparable

  # Enables more predictable duck-typing on String-like classes. See <tt>Object#acts_like?</tt>.
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/core_ext/string/behavior.rb#5
  def acts_like_string?; end

  # source://activesupport//lib/active_support/core_ext/object/json.rb#99
  def as_json(options = T.unsafe(nil)); end

  # If you pass a single integer, returns a substring of one character at that
  # position. The first character of the string is at position 0, the next at
  # position 1, and so on. If a range is supplied, a substring containing
  # characters at offsets given by the range is returned. In both cases, if an
  # offset is negative, it is counted from the end of the string. Returns +nil+
  # if the initial offset falls outside the string. Returns an empty string if
  # the beginning of the range is greater than the end of the string.
  #
  #   str = "hello"
  #   str.at(0)      # => "h"
  #   str.at(1..3)   # => "ell"
  #   str.at(-2)     # => "l"
  #   str.at(-2..-1) # => "lo"
  #   str.at(5)      # => nil
  #   str.at(5..-1)  # => ""
  #
  # If a Regexp is given, the matching portion of the string is returned.
  # If a String is given, that given string is returned if it occurs in
  # the string. In both cases, +nil+ is returned if there is no match.
  #
  #   str = "hello"
  #   str.at(/lo/) # => "lo"
  #   str.at(/ol/) # => nil
  #   str.at("lo") # => "lo"
  #   str.at("ol") # => nil
  #
  # source://activesupport//lib/active_support/core_ext/string/access.rb#29
  def at(position); end

  # By default, +camelize+ converts strings to UpperCamelCase. If the argument to camelize
  # is set to <tt>:lower</tt> then camelize produces lowerCamelCase.
  #
  # +camelize+ will also convert '/' to '::' which is useful for converting paths to namespaces.
  #
  #   'active_record'.camelize                # => "ActiveRecord"
  #   'active_record'.camelize(:lower)        # => "activeRecord"
  #   'active_record/errors'.camelize         # => "ActiveRecord::Errors"
  #   'active_record/errors'.camelize(:lower) # => "activeRecord::Errors"
  #
  # See ActiveSupport::Inflector.camelize.
  #
  # source://activesupport//lib/active_support/core_ext/string/inflections.rb#101
  def camelcase(first_letter = T.unsafe(nil)); end

  # By default, +camelize+ converts strings to UpperCamelCase. If the argument to camelize
  # is set to <tt>:lower</tt> then camelize produces lowerCamelCase.
  #
  # +camelize+ will also convert '/' to '::' which is useful for converting paths to namespaces.
  #
  #   'active_record'.camelize                # => "ActiveRecord"
  #   'active_record'.camelize(:lower)        # => "activeRecord"
  #   'active_record/errors'.camelize         # => "ActiveRecord::Errors"
  #   'active_record/errors'.camelize(:lower) # => "activeRecord::Errors"
  #
  # See ActiveSupport::Inflector.camelize.
  #
  # source://activesupport//lib/active_support/core_ext/string/inflections.rb#101
  def camelize(first_letter = T.unsafe(nil)); end

  # Creates a class name from a plural table name like \Rails does for table names to models.
  # Note that this returns a string and not a class. (To convert to an actual class
  # follow +classify+ with +constantize+.)
  #
  #   'ham_and_eggs'.classify # => "HamAndEgg"
  #   'posts'.classify        # => "Post"
  #
  # See ActiveSupport::Inflector.classify.
  #
  # source://activesupport//lib/active_support/core_ext/string/inflections.rb#239
  def classify; end

  # +constantize+ tries to find a declared constant with the name specified
  # in the string. It raises a NameError when the name is not in CamelCase
  # or is not initialized.
  #
  #   'Module'.constantize  # => Module
  #   'Class'.constantize   # => Class
  #   'blargle'.constantize # => NameError: wrong constant name blargle
  #
  # See ActiveSupport::Inflector.constantize.
  #
  # source://activesupport//lib/active_support/core_ext/string/inflections.rb#73
  def constantize; end

  # Replaces underscores with dashes in the string.
  #
  #   'puni_puni'.dasherize # => "puni-puni"
  #
  # See ActiveSupport::Inflector.dasherize.
  #
  # source://activesupport//lib/active_support/core_ext/string/inflections.rb#148
  def dasherize; end

  # Removes the rightmost segment from the constant expression in the string.
  #
  #   'Net::HTTP'.deconstantize   # => "Net"
  #   '::Net::HTTP'.deconstantize # => "::Net"
  #   'String'.deconstantize      # => ""
  #   '::String'.deconstantize    # => ""
  #   ''.deconstantize            # => ""
  #
  # See ActiveSupport::Inflector.deconstantize.
  #
  # See also +demodulize+.
  #
  # source://activesupport//lib/active_support/core_ext/string/inflections.rb#177
  def deconstantize; end

  # Removes the module part from the constant expression in the string.
  #
  #   'ActiveSupport::Inflector::Inflections'.demodulize # => "Inflections"
  #   'Inflections'.demodulize                           # => "Inflections"
  #   '::Inflections'.demodulize                         # => "Inflections"
  #   ''.demodulize                                      # => ''
  #
  # See ActiveSupport::Inflector.demodulize.
  #
  # See also +deconstantize+.
  #
  # source://activesupport//lib/active_support/core_ext/string/inflections.rb#162
  def demodulize; end

  # Converts the first character to lowercase.
  #
  #   'If they enjoyed The Matrix'.downcase_first # => "if they enjoyed The Matrix"
  #   'I'.downcase_first                          # => "i"
  #   ''.downcase_first                           # => ""
  #
  # See ActiveSupport::Inflector.downcase_first.
  #
  # source://activesupport//lib/active_support/core_ext/string/inflections.rb#284
  def downcase_first; end

  # Returns the first character. If a limit is supplied, returns a substring
  # from the beginning of the string until it reaches the limit value. If the
  # given limit is greater than or equal to the string length, returns a copy of self.
  #
  #   str = "hello"
  #   str.first    # => "h"
  #   str.first(1) # => "h"
  #   str.first(2) # => "he"
  #   str.first(0) # => ""
  #   str.first(6) # => "hello"
  #
  # source://activesupport//lib/active_support/core_ext/string/access.rb#78
  def first(limit = T.unsafe(nil)); end

  # Creates a foreign key name from a class name.
  # +separate_class_name_and_id_with_underscore+ sets whether
  # the method should put '_' between the name and 'id'.
  #
  #   'Message'.foreign_key        # => "message_id"
  #   'Message'.foreign_key(false) # => "messageid"
  #   'Admin::Post'.foreign_key    # => "post_id"
  #
  # See ActiveSupport::Inflector.foreign_key.
  #
  # source://activesupport//lib/active_support/core_ext/string/inflections.rb#297
  def foreign_key(separate_class_name_and_id_with_underscore = T.unsafe(nil)); end

  # Returns a substring from the given position to the end of the string.
  # If the position is negative, it is counted from the end of the string.
  #
  #   str = "hello"
  #   str.from(0)  # => "hello"
  #   str.from(3)  # => "lo"
  #   str.from(-2) # => "lo"
  #
  # You can mix it with +to+ method and do fun things like:
  #
  #   str = "hello"
  #   str.from(0).to(-1) # => "hello"
  #   str.from(1).to(-2) # => "ell"
  #
  # source://activesupport//lib/active_support/core_ext/string/access.rb#46
  def from(position); end

  # Marks a string as trusted safe. It will be inserted into HTML with no
  # additional escaping performed. It is your responsibility to ensure that the
  # string contains no malicious content. This method is equivalent to the
  # +raw+ helper in views. It is recommended that you use +sanitize+ instead of
  # this method. It should never be called on user input.
  #
  # source://activesupport//lib/active_support/core_ext/string/output_safety.rb#225
  def html_safe; end

  # Capitalizes the first word, turns underscores into spaces, and (by default) strips a
  # trailing '_id' if present.
  # Like +titleize+, this is meant for creating pretty output.
  #
  # The capitalization of the first word can be turned off by setting the
  # optional parameter +capitalize+ to false.
  # By default, this parameter is true.
  #
  # The trailing '_id' can be kept and capitalized by setting the
  # optional parameter +keep_id_suffix+ to true.
  # By default, this parameter is false.
  #
  #   'employee_salary'.humanize                    # => "Employee salary"
  #   'author_id'.humanize                          # => "Author"
  #   'author_id'.humanize(capitalize: false)       # => "author"
  #   '_id'.humanize                                # => "Id"
  #   'author_id'.humanize(keep_id_suffix: true)    # => "Author id"
  #
  # See ActiveSupport::Inflector.humanize.
  #
  # source://activesupport//lib/active_support/core_ext/string/inflections.rb#262
  def humanize(capitalize: T.unsafe(nil), keep_id_suffix: T.unsafe(nil)); end

  # Returns +true+ if string has utf_8 encoding.
  #
  #   utf_8_str = "some string".encode "UTF-8"
  #   iso_str = "some string".encode "ISO-8859-1"
  #
  #   utf_8_str.is_utf8? # => true
  #   iso_str.is_utf8?   # => false
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/core_ext/string/multibyte.rb#48
  def is_utf8?; end

  # Returns the last character of the string. If a limit is supplied, returns a substring
  # from the end of the string until it reaches the limit value (counting backwards). If
  # the given limit is greater than or equal to the string length, returns a copy of self.
  #
  #   str = "hello"
  #   str.last    # => "o"
  #   str.last(1) # => "o"
  #   str.last(2) # => "lo"
  #   str.last(0) # => ""
  #   str.last(6) # => "hello"
  #
  # source://activesupport//lib/active_support/core_ext/string/access.rb#92
  def last(limit = T.unsafe(nil)); end

  # == Multibyte proxy
  #
  # +mb_chars+ is a multibyte safe proxy for string methods.
  #
  # It creates and returns an instance of the ActiveSupport::Multibyte::Chars class which
  # encapsulates the original string. A Unicode safe version of all the String methods are defined on this proxy
  # class. If the proxy class doesn't respond to a certain method, it's forwarded to the encapsulated string.
  #
  #   >> "ǉ".mb_chars.upcase.to_s
  #   => "Ǉ"
  #
  # NOTE: Ruby 2.4 and later support native Unicode case mappings:
  #
  #   >> "ǉ".upcase
  #   => "Ǉ"
  #
  # == \Method chaining
  #
  # All the methods on the Chars proxy which normally return a string will return a Chars object. This allows
  # method chaining on the result of any of these methods.
  #
  #   name.mb_chars.reverse.length # => 12
  #
  # == Interoperability and configuration
  #
  # The Chars object tries to be as interchangeable with String objects as possible: sorting and comparing between
  # String and Char work like expected. The bang! methods change the internal string representation in the Chars
  # object. Interoperability problems can be resolved easily with a +to_s+ call.
  #
  # For more information about the methods defined on the Chars proxy see ActiveSupport::Multibyte::Chars. For
  # information about how to change the default Multibyte behavior see ActiveSupport::Multibyte.
  #
  # source://activesupport//lib/active_support/core_ext/string/multibyte.rb#37
  def mb_chars; end

  # Replaces special characters in a string so that it may be used as part of a 'pretty' URL.
  #
  # If the optional parameter +locale+ is specified,
  # the word will be parameterized as a word of that language.
  # By default, this parameter is set to <tt>nil</tt> and it will use
  # the configured <tt>I18n.locale</tt>.
  #
  #   class Person
  #     def to_param
  #       "#{id}-#{name.parameterize}"
  #     end
  #   end
  #
  #   @person = Person.find(1)
  #   # => #<Person id: 1, name: "Donald E. Knuth">
  #
  #   <%= link_to(@person.name, person_path) %>
  #   # => <a href="/person/1-donald-e-knuth">Donald E. Knuth</a>
  #
  # To preserve the case of the characters in a string, use the +preserve_case+ argument.
  #
  #   class Person
  #     def to_param
  #       "#{id}-#{name.parameterize(preserve_case: true)}"
  #     end
  #   end
  #
  #   @person = Person.find(1)
  #   # => #<Person id: 1, name: "Donald E. Knuth">
  #
  #   <%= link_to(@person.name, person_path) %>
  #   # => <a href="/person/1-Donald-E-Knuth">Donald E. Knuth</a>
  #
  # See ActiveSupport::Inflector.parameterize.
  #
  # source://activesupport//lib/active_support/core_ext/string/inflections.rb#215
  def parameterize(separator: T.unsafe(nil), preserve_case: T.unsafe(nil), locale: T.unsafe(nil)); end

  # Returns the plural form of the word in the string.
  #
  # If the optional parameter +count+ is specified,
  # the singular form will be returned if <tt>count == 1</tt>.
  # For any other value of +count+ the plural will be returned.
  #
  # If the optional parameter +locale+ is specified,
  # the word will be pluralized as a word of that language.
  # By default, this parameter is set to <tt>:en</tt>.
  # You must define your own inflection rules for languages other than English.
  #
  #   'post'.pluralize             # => "posts"
  #   'octopus'.pluralize          # => "octopi"
  #   'sheep'.pluralize            # => "sheep"
  #   'words'.pluralize            # => "words"
  #   'the blue mailman'.pluralize # => "the blue mailmen"
  #   'CamelOctopus'.pluralize     # => "CamelOctopi"
  #   'apple'.pluralize(1)         # => "apple"
  #   'apple'.pluralize(2)         # => "apples"
  #   'ley'.pluralize(:es)         # => "leyes"
  #   'ley'.pluralize(1, :es)      # => "ley"
  #
  # See ActiveSupport::Inflector.pluralize.
  #
  # source://activesupport//lib/active_support/core_ext/string/inflections.rb#35
  def pluralize(count = T.unsafe(nil), locale = T.unsafe(nil)); end

  # +safe_constantize+ tries to find a declared constant with the name specified
  # in the string. It returns +nil+ when the name is not in CamelCase
  # or is not initialized.
  #
  #   'Module'.safe_constantize  # => Module
  #   'Class'.safe_constantize   # => Class
  #   'blargle'.safe_constantize # => nil
  #
  # See ActiveSupport::Inflector.safe_constantize.
  #
  # source://activesupport//lib/active_support/core_ext/string/inflections.rb#86
  def safe_constantize; end

  # The reverse of +pluralize+, returns the singular form of a word in a string.
  #
  # If the optional parameter +locale+ is specified,
  # the word will be singularized as a word of that language.
  # By default, this parameter is set to <tt>:en</tt>.
  # You must define your own inflection rules for languages other than English.
  #
  #   'posts'.singularize            # => "post"
  #   'octopi'.singularize           # => "octopus"
  #   'sheep'.singularize            # => "sheep"
  #   'word'.singularize             # => "word"
  #   'the blue mailmen'.singularize # => "the blue mailman"
  #   'CamelOctopi'.singularize      # => "CamelOctopus"
  #   'leyes'.singularize(:es)       # => "ley"
  #
  # See ActiveSupport::Inflector.singularize.
  #
  # source://activesupport//lib/active_support/core_ext/string/inflections.rb#60
  def singularize(locale = T.unsafe(nil)); end

  # Creates the name of a table like \Rails does for models to table names. This method
  # uses the +pluralize+ method on the last word in the string.
  #
  #   'RawScaledScorer'.tableize # => "raw_scaled_scorers"
  #   'ham_and_egg'.tableize     # => "ham_and_eggs"
  #   'fancyCategory'.tableize   # => "fancy_categories"
  #
  # See ActiveSupport::Inflector.tableize.
  #
  # source://activesupport//lib/active_support/core_ext/string/inflections.rb#227
  def tableize; end

  # Capitalizes all the words and replaces some characters in the string to create
  # a nicer looking title. +titleize+ is meant for creating pretty output. It is not
  # used in the \Rails internals.
  #
  # The trailing '_id','Id'.. can be kept and capitalized by setting the
  # optional parameter +keep_id_suffix+ to true.
  # By default, this parameter is false.
  #
  #   'man from the boondocks'.titleize                       # => "Man From The Boondocks"
  #   'x-men: the last stand'.titleize                        # => "X Men: The Last Stand"
  #   'string_ending_with_id'.titleize(keep_id_suffix: true)  # => "String Ending With Id"
  #
  # See ActiveSupport::Inflector.titleize.
  #
  # source://activesupport//lib/active_support/core_ext/string/inflections.rb#126
  def titlecase(keep_id_suffix: T.unsafe(nil)); end

  # Capitalizes all the words and replaces some characters in the string to create
  # a nicer looking title. +titleize+ is meant for creating pretty output. It is not
  # used in the \Rails internals.
  #
  # The trailing '_id','Id'.. can be kept and capitalized by setting the
  # optional parameter +keep_id_suffix+ to true.
  # By default, this parameter is false.
  #
  #   'man from the boondocks'.titleize                       # => "Man From The Boondocks"
  #   'x-men: the last stand'.titleize                        # => "X Men: The Last Stand"
  #   'string_ending_with_id'.titleize(keep_id_suffix: true)  # => "String Ending With Id"
  #
  # See ActiveSupport::Inflector.titleize.
  #
  # source://activesupport//lib/active_support/core_ext/string/inflections.rb#126
  def titleize(keep_id_suffix: T.unsafe(nil)); end

  # Returns a substring from the beginning of the string to the given position.
  # If the position is negative, it is counted from the end of the string.
  #
  #   str = "hello"
  #   str.to(0)  # => "h"
  #   str.to(3)  # => "hell"
  #   str.to(-2) # => "hell"
  #
  # You can mix it with +from+ method and do fun things like:
  #
  #   str = "hello"
  #   str.from(0).to(-1) # => "hello"
  #   str.from(1).to(-2) # => "ell"
  #
  # source://activesupport//lib/active_support/core_ext/string/access.rb#63
  def to(position); end

  # The reverse of +camelize+. Makes an underscored, lowercase form from the expression in the string.
  #
  # +underscore+ will also change '::' to '/' to convert namespaces to paths.
  #
  #   'ActiveModel'.underscore         # => "active_model"
  #   'ActiveModel::Errors'.underscore # => "active_model/errors"
  #
  # See ActiveSupport::Inflector.underscore.
  #
  # source://activesupport//lib/active_support/core_ext/string/inflections.rb#139
  def underscore; end

  # Converts the first character to uppercase.
  #
  #   'what a Lovely Day'.upcase_first # => "What a Lovely Day"
  #   'w'.upcase_first                 # => "W"
  #   ''.upcase_first                  # => ""
  #
  # See ActiveSupport::Inflector.upcase_first.
  #
  # source://activesupport//lib/active_support/core_ext/string/inflections.rb#273
  def upcase_first; end
end

# source://activesupport//lib/active_support/core_ext/object/json.rb#74
class Struct
  include ::Enumerable

  # source://activesupport//lib/active_support/core_ext/object/json.rb#75
  def as_json(options = T.unsafe(nil)); end
end

# source://activesupport//lib/active_support/core_ext/object/json.rb#104
class Symbol
  include ::Comparable

  # source://activesupport//lib/active_support/core_ext/object/json.rb#105
  def as_json(options = T.unsafe(nil)); end
end

# source://activesupport//lib/active_support/core_ext/time/acts_like.rb#5
class Time
  include ::Comparable
  include ::DateAndTime::Zones

  # Duck-types as a Time-like class. See Object#acts_like?.
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/core_ext/time/acts_like.rb#7
  def acts_like_time?; end

  # source://activesupport//lib/active_support/core_ext/object/json.rb#201
  def as_json(options = T.unsafe(nil)); end

  # Returns a formatted string of the offset from UTC, or an alternative
  # string if the time zone is already UTC.
  #
  #   Time.local(2000).formatted_offset        # => "-06:00"
  #   Time.local(2000).formatted_offset(false) # => "-0600"
  #
  # source://activesupport//lib/active_support/core_ext/time/conversions.rb#69
  def formatted_offset(colon = T.unsafe(nil), alternate_utc_string = T.unsafe(nil)); end

  # Converts to a formatted string. See DATE_FORMATS for built-in formats.
  #
  # This method is aliased to <tt>to_formatted_s</tt>.
  #
  #   time = Time.now                    # => 2007-01-18 06:10:17 -06:00
  #
  #   time.to_fs(:time)                  # => "06:10"
  #   time.to_formatted_s(:time)         # => "06:10"
  #
  #   time.to_fs(:db)           # => "2007-01-18 06:10:17"
  #   time.to_fs(:number)       # => "20070118061017"
  #   time.to_fs(:short)        # => "18 Jan 06:10"
  #   time.to_fs(:long)         # => "January 18, 2007 06:10"
  #   time.to_fs(:long_ordinal) # => "January 18th, 2007 06:10"
  #   time.to_fs(:rfc822)       # => "Thu, 18 Jan 2007 06:10:17 -0600"
  #   time.to_fs(:rfc2822)       # => "Thu, 18 Jan 2007 06:10:17 -0600"
  #   time.to_fs(:iso8601)      # => "2007-01-18T06:10:17-06:00"
  #
  # == Adding your own time formats to +to_fs+
  # You can add your own formats to the Time::DATE_FORMATS hash.
  # Use the format name as the hash key and either a strftime string
  # or Proc instance that takes a time argument as the value.
  #
  #   # config/initializers/time_formats.rb
  #   Time::DATE_FORMATS[:month_and_year] = '%B %Y'
  #   Time::DATE_FORMATS[:short_ordinal]  = ->(time) { time.strftime("%B #{time.day.ordinalize}") }
  #
  # source://activesupport//lib/active_support/core_ext/time/conversions.rb#55
  def to_formatted_s(format = T.unsafe(nil)); end

  # Converts to a formatted string. See DATE_FORMATS for built-in formats.
  #
  # This method is aliased to <tt>to_formatted_s</tt>.
  #
  #   time = Time.now                    # => 2007-01-18 06:10:17 -06:00
  #
  #   time.to_fs(:time)                  # => "06:10"
  #   time.to_formatted_s(:time)         # => "06:10"
  #
  #   time.to_fs(:db)           # => "2007-01-18 06:10:17"
  #   time.to_fs(:number)       # => "20070118061017"
  #   time.to_fs(:short)        # => "18 Jan 06:10"
  #   time.to_fs(:long)         # => "January 18, 2007 06:10"
  #   time.to_fs(:long_ordinal) # => "January 18th, 2007 06:10"
  #   time.to_fs(:rfc822)       # => "Thu, 18 Jan 2007 06:10:17 -0600"
  #   time.to_fs(:rfc2822)       # => "Thu, 18 Jan 2007 06:10:17 -0600"
  #   time.to_fs(:iso8601)      # => "2007-01-18T06:10:17-06:00"
  #
  # == Adding your own time formats to +to_fs+
  # You can add your own formats to the Time::DATE_FORMATS hash.
  # Use the format name as the hash key and either a strftime string
  # or Proc instance that takes a time argument as the value.
  #
  #   # config/initializers/time_formats.rb
  #   Time::DATE_FORMATS[:month_and_year] = '%B %Y'
  #   Time::DATE_FORMATS[:short_ordinal]  = ->(time) { time.strftime("%B #{time.day.ordinalize}") }
  #
  # source://activesupport//lib/active_support/core_ext/time/conversions.rb#55
  def to_fs(format = T.unsafe(nil)); end

  class << self
    # Returns a TimeZone instance matching the time zone provided.
    # Accepts the time zone in any format supported by <tt>Time.zone=</tt>.
    # Returns +nil+ for invalid time zones.
    #
    #   Time.find_zone "America/New_York" # => #<ActiveSupport::TimeZone @name="America/New_York" ...>
    #   Time.find_zone "NOT-A-TIMEZONE"   # => nil
    #
    # source://activesupport//lib/active_support/core_ext/time/zones.rb#93
    def find_zone(time_zone); end

    # Returns a TimeZone instance matching the time zone provided.
    # Accepts the time zone in any format supported by <tt>Time.zone=</tt>.
    # Raises an +ArgumentError+ for invalid time zones.
    #
    #   Time.find_zone! "America/New_York" # => #<ActiveSupport::TimeZone @name="America/New_York" ...>
    #   Time.find_zone! "EST"              # => #<ActiveSupport::TimeZone @name="EST" ...>
    #   Time.find_zone! -5.hours           # => #<ActiveSupport::TimeZone @name="Bogota" ...>
    #   Time.find_zone! nil                # => nil
    #   Time.find_zone! false              # => false
    #   Time.find_zone! "NOT-A-TIMEZONE"   # => ArgumentError: Invalid Timezone: NOT-A-TIMEZONE
    #
    # source://activesupport//lib/active_support/core_ext/time/zones.rb#81
    def find_zone!(time_zone); end

    # Allows override of <tt>Time.zone</tt> locally inside supplied block;
    # resets <tt>Time.zone</tt> to existing value when done.
    #
    #   class ApplicationController < ActionController::Base
    #     around_action :set_time_zone
    #
    #     private
    #       def set_time_zone
    #         Time.use_zone(current_user.timezone) { yield }
    #       end
    #   end
    #
    # NOTE: This won't affect any ActiveSupport::TimeWithZone
    # objects that have already been created, e.g. any model timestamp
    # attributes that have been read before the block will remain in
    # the application's default timezone.
    #
    # source://activesupport//lib/active_support/core_ext/time/zones.rb#61
    def use_zone(time_zone); end

    # Returns the TimeZone for the current request, if this has been set (via Time.zone=).
    # If <tt>Time.zone</tt> has not been set for the current request, returns the TimeZone specified in <tt>config.time_zone</tt>.
    #
    # source://activesupport//lib/active_support/core_ext/time/zones.rb#14
    def zone; end

    # Sets <tt>Time.zone</tt> to a TimeZone object for the current request/thread.
    #
    # This method accepts any of the following:
    #
    # * A \Rails TimeZone object.
    # * An identifier for a \Rails TimeZone object (e.g., "Eastern \Time (US & Canada)", <tt>-5.hours</tt>).
    # * A +TZInfo::Timezone+ object.
    # * An identifier for a +TZInfo::Timezone+ object (e.g., "America/New_York").
    #
    # Here's an example of how you might set <tt>Time.zone</tt> on a per request basis and reset it when the request is done.
    # <tt>current_user.time_zone</tt> just needs to return a string identifying the user's preferred time zone:
    #
    #   class ApplicationController < ActionController::Base
    #     around_action :set_time_zone
    #
    #     def set_time_zone
    #       if logged_in?
    #         Time.use_zone(current_user.time_zone) { yield }
    #       else
    #         yield
    #       end
    #     end
    #   end
    #
    # source://activesupport//lib/active_support/core_ext/time/zones.rb#41
    def zone=(time_zone); end

    # Returns the value of attribute zone_default.
    #
    # source://activesupport//lib/active_support/core_ext/time/zones.rb#10
    def zone_default; end

    # Sets the attribute zone_default
    #
    # @param value the value to set the attribute zone_default to.
    #
    # source://activesupport//lib/active_support/core_ext/time/zones.rb#10
    def zone_default=(_arg0); end
  end
end

# source://activesupport//lib/active_support/core_ext/time/conversions.rb#8
Time::DATE_FORMATS = T.let(T.unsafe(nil), Hash)

# source://activesupport//lib/active_support/core_ext/object/to_query.rb#25
class TrueClass
  # source://activesupport//lib/active_support/core_ext/object/json.rb#81
  def as_json(options = T.unsafe(nil)); end

  # Returns +self+.
  #
  # source://activesupport//lib/active_support/core_ext/object/to_query.rb#27
  def to_param; end
end

# source://activesupport//lib/active_support/core_ext/object/json.rb#230
class URI::Generic
  include ::URI

  # source://activesupport//lib/active_support/core_ext/object/json.rb#231
  def as_json(options = T.unsafe(nil)); end
end
