# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `tty-exit` gem.
# Please instead update this file by running `bin/tapioca gem tty-exit`.


# source://tty-exit//lib/tty/exit/code.rb#3
module TTY; end

# Terminal exit codes for humans and machines
#
# source://tty-exit//lib/tty/exit/code.rb#4
module TTY::Exit
  extend ::TTY::Exit

  # Provide exit code for a name or status
  #
  # @api public
  # @example
  #   TTY::Exit.exit_code(:usage_error)
  #   # => 64
  # @param name_or_code [String, Integer]
  # @return [Integer] the exit code
  #
  # source://tty-exit//lib/tty/exit.rb#180
  def exit_code(name_or_code = T.unsafe(nil)); end

  # Provide a list of reserved codes
  #
  # @api public
  #
  # source://tty-exit//lib/tty/exit.rb#201
  def exit_codes; end

  # A user friendly explanation of the exit code
  #
  # @api public
  # @example
  #   TTY::Exit.exit_message(:usage_error)
  #   # => "Command line usage error"
  # @param name_or_code [String, Integer]
  #
  # source://tty-exit//lib/tty/exit.rb#156
  def exit_message(name_or_code = T.unsafe(nil)); end

  # Provide a list of reserved status messages
  #
  # @api public
  #
  # source://tty-exit//lib/tty/exit.rb#164
  def exit_messages; end

  # Check if an exit code is already defined by Unix system
  #
  # @api public
  # @param code [Integer] the code to check
  # @return [Boolean]
  #
  # source://tty-exit//lib/tty/exit.rb#132
  def exit_reserved?(code); end

  # Check if the exit status was successful.
  #
  # @api public
  # @param code [Integer]
  # @return [Boolean]
  #
  # source://tty-exit//lib/tty/exit.rb#143
  def exit_success?(code); end

  # Check if an exit code is valid, that it's within the 0-255 (inclusive)
  #
  # @api public
  # @param code [Integer] the code to check
  # @return [Boolean]
  #
  # source://tty-exit//lib/tty/exit.rb#120
  def exit_valid?(code); end

  # Exit this process with a given status code
  #
  # @api public
  # @param name_or_code [String, Integer] The name for an exit code or code itself
  # @param message [String] The message to print to io stream
  # @param io [IO] The io to print message to
  # @return [nil]
  #
  # source://tty-exit//lib/tty/exit.rb#217
  def exit_with(name_or_code = T.unsafe(nil), message = T.unsafe(nil), io: T.unsafe(nil)); end

  class << self
    # @api private
    # @private
    #
    # source://tty-exit//lib/tty/exit.rb#15
    def included(base); end
  end
end

# source://tty-exit//lib/tty/exit.rb#71
TTY::Exit::CODE_TO_EXIT_MESSAGE = T.let(T.unsafe(nil), Hash)

# All reserved exit codes as constants
#
# source://tty-exit//lib/tty/exit/code.rb#6
module TTY::Exit::Code; end

# This indicates that program received SIGABRT signal.
#
# source://tty-exit//lib/tty/exit/code.rb#118
TTY::Exit::Code::ABORT = T.let(T.unsafe(nil), Integer)

# This indicates that program received SIGALARM signal.
#
# source://tty-exit//lib/tty/exit/code.rb#134
TTY::Exit::Code::ALARM = T.let(T.unsafe(nil), Integer)

# The start base code to reduce possibility of clashing with other
# exit statuses that programs may already run.
#
# source://tty-exit//lib/tty/exit/code.rb#19
TTY::Exit::Code::BASE = T.let(T.unsafe(nil), Integer)

# This indicates that program received SIGBUS signal.
# Access to an undefined portion of a memory object
#
# source://tty-exit//lib/tty/exit/code.rb#125
TTY::Exit::Code::BUS_ERROR = T.let(T.unsafe(nil), Integer)

# Command invoked cannot execute. This may be due to permission
# issues.
#
# source://tty-exit//lib/tty/exit/code.rb#85
TTY::Exit::Code::CANNOT_EXECUTE = T.let(T.unsafe(nil), Integer)

# A (user specified) output file cannot be created.
#
# source://tty-exit//lib/tty/exit/code.rb#61
TTY::Exit::Code::CANT_CREATE = T.let(T.unsafe(nil), Integer)

# "command not found", possible typos in shell command or
# unrecognized characters
#
# source://tty-exit//lib/tty/exit/code.rb#89
TTY::Exit::Code::COMMAND_NOT_FOUND = T.let(T.unsafe(nil), Integer)

# Something was found in an unconfigured or misconfigured state.
#
# source://tty-exit//lib/tty/exit/code.rb#81
TTY::Exit::Code::CONFIG_ERROR = T.let(T.unsafe(nil), Integer)

# The input data was incorrect in some way.
# This should only be used for user's data & not system files.
#
# source://tty-exit//lib/tty/exit/code.rb#27
TTY::Exit::Code::DATA_ERROR = T.let(T.unsafe(nil), Integer)

# Catchall for general errors
#
# source://tty-exit//lib/tty/exit/code.rb#11
TTY::Exit::Code::ERROR = T.let(T.unsafe(nil), Integer)

# This indicates that program received SIGHUP signal.
# It means that the controlling pseudo or virtual terminal
# has been closed.
#
# source://tty-exit//lib/tty/exit/code.rb#101
TTY::Exit::Code::HANGUP = T.let(T.unsafe(nil), Integer)

# This indicates that program received SIGQUIT signal.
#
# source://tty-exit//lib/tty/exit/code.rb#112
TTY::Exit::Code::ILLEGAL_INSTRUCTION = T.let(T.unsafe(nil), Integer)

# This indicates that program received SIGINT signal.
# An interrupt signal that by default this causes the
# process to terminate.
#
# source://tty-exit//lib/tty/exit/code.rb#106
TTY::Exit::Code::INTERRUPT = T.let(T.unsafe(nil), Integer)

# Exit takes only integer args in the range 0 - 255,
# e.g. exit 3.14159 is invalid.
#
# source://tty-exit//lib/tty/exit/code.rb#96
TTY::Exit::Code::INVALID_ARGUMENT = T.let(T.unsafe(nil), Integer)

# An error occurred while doing I/O on some file.
#
# source://tty-exit//lib/tty/exit/code.rb#64
TTY::Exit::Code::IO_ERROR = T.let(T.unsafe(nil), Integer)

# This indicates that program received SIGKILL signal.
#
# source://tty-exit//lib/tty/exit/code.rb#121
TTY::Exit::Code::KILL = T.let(T.unsafe(nil), Integer)

# This indicates that program received SIGSEGV signal.
#
# source://tty-exit//lib/tty/exit/code.rb#128
TTY::Exit::Code::MEMORY_ERROR = T.let(T.unsafe(nil), Integer)

# The host specified did not exist. This is used in mail addresses
# or network requests.
#
# source://tty-exit//lib/tty/exit/code.rb#38
TTY::Exit::Code::NO_HOST = T.let(T.unsafe(nil), Integer)

# An input file (not a system file) did not exist or was not readable.
#
# source://tty-exit//lib/tty/exit/code.rb#30
TTY::Exit::Code::NO_INPUT = T.let(T.unsafe(nil), Integer)

# You did not have sufficient permission to perform the operation.
# This is not intended for file system problems, which should use
# NO_INPUT or CANT_CREATE, but rather for higher level permissions.
#
# source://tty-exit//lib/tty/exit/code.rb#78
TTY::Exit::Code::NO_PERM = T.let(T.unsafe(nil), Integer)

# The user specified did not exist. This might be used for mail
# addresses or remote logins.
#
# source://tty-exit//lib/tty/exit/code.rb#34
TTY::Exit::Code::NO_USER = T.let(T.unsafe(nil), Integer)

# This indicates that program received SIGPIPE signal.
#
# source://tty-exit//lib/tty/exit/code.rb#131
TTY::Exit::Code::PIPE = T.let(T.unsafe(nil), Integer)

# The remote system returned something that was 'not possible' during
# a protocol exchange.
#
# source://tty-exit//lib/tty/exit/code.rb#73
TTY::Exit::Code::PROTOCOL = T.let(T.unsafe(nil), Integer)

# This indicates that program received SIGQUIT signal.
#
# source://tty-exit//lib/tty/exit/code.rb#109
TTY::Exit::Code::QUIT = T.let(T.unsafe(nil), Integer)

# A service is unavailable. This can occur if a support program
# or file does not exist. This can also be used as a catchall
# message when something you wanted to do doesn't work,
# but you don't know why.
#
# source://tty-exit//lib/tty/exit/code.rb#44
TTY::Exit::Code::SERVICE_UNAVAILABLE = T.let(T.unsafe(nil), Integer)

# Missing keyword or command, or permission problem
# (and diff return code on a failed binary file comparison).
#
# source://tty-exit//lib/tty/exit/code.rb#15
TTY::Exit::Code::SHELL_MISUSE = T.let(T.unsafe(nil), Integer)

# The start base code for the system interrupt signals.
#
# source://tty-exit//lib/tty/exit/code.rb#92
TTY::Exit::Code::SIGNAL_BASE = T.let(T.unsafe(nil), Integer)

# An internal software error has been detected. This should be
# limited to non-operating system related errors as possible.
#
# source://tty-exit//lib/tty/exit/code.rb#48
TTY::Exit::Code::SOFTWARE_ERROR = T.let(T.unsafe(nil), Integer)

# No errors
#
# source://tty-exit//lib/tty/exit/code.rb#8
TTY::Exit::Code::SUCCESS = T.let(T.unsafe(nil), Integer)

# An operating system error has been detected. This is intended
# to be used for such things as "cannot fork", "cannot create pipe",
# or the like. It includes things like getuid returning a user that
# does not exist in the passwd file.
#
# source://tty-exit//lib/tty/exit/code.rb#54
TTY::Exit::Code::SYSTEM_ERROR = T.let(T.unsafe(nil), Integer)

# Some system file (e.g., /etc/passwd, /etc/utmp, etc.) does not exist,
# cannot be opened, or has some sort of error (e.g., syntax error).
#
# source://tty-exit//lib/tty/exit/code.rb#58
TTY::Exit::Code::SYSTEM_FILE_MISSING = T.let(T.unsafe(nil), Integer)

# Temporary failure, indicating something that is not really an error.
# For example that a mailer could not create a connection, and the
# request should be reattempted later.
#
# source://tty-exit//lib/tty/exit/code.rb#69
TTY::Exit::Code::TEMP_FAIL = T.let(T.unsafe(nil), Integer)

# This indicates that program received SIGTRAP signal.
#
# source://tty-exit//lib/tty/exit/code.rb#115
TTY::Exit::Code::TRACE_TRAP = T.let(T.unsafe(nil), Integer)

# The command was used incorrectly, e.g., with the wrong number
# of arguments, a bad flag, a bad syntax in a parameter, or whatever.
#
# source://tty-exit//lib/tty/exit/code.rb#23
TTY::Exit::Code::USAGE_ERROR = T.let(T.unsafe(nil), Integer)

# This indicates that program received SIGUSR1 signal.
#
# source://tty-exit//lib/tty/exit/code.rb#137
TTY::Exit::Code::USER1 = T.let(T.unsafe(nil), Integer)

# This indicates that program received SIGUSR2 signal.
#
# source://tty-exit//lib/tty/exit/code.rb#140
TTY::Exit::Code::USER2 = T.let(T.unsafe(nil), Integer)

# source://tty-exit//lib/tty/exit.rb#12
class TTY::Exit::Error < ::StandardError; end

# source://tty-exit//lib/tty/exit.rb#23
TTY::Exit::NAME_TO_EXIT_CODE = T.let(T.unsafe(nil), Hash)

# source://tty-exit//lib/tty/exit/registry.rb#5
module TTY::Exit::Registry
  class << self
    # A storage for custom exit codes
    #
    # @api private
    #
    # source://tty-exit//lib/tty/exit/registry.rb#9
    def exits; end

    # Register a custom exit code
    #
    # @api public
    # @param name [String]
    # @param code [Integer]
    # @param message [String]
    #
    # source://tty-exit//lib/tty/exit/registry.rb#20
    def register_exit(name, code, message); end
  end
end

# source://tty-exit//lib/tty/exit/version.rb#5
TTY::Exit::VERSION = T.let(T.unsafe(nil), String)
