# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `prawn` gem.
# Please instead update this file by running `bin/tapioca gem prawn`.


# @private
#
# source://prawn//lib/prawn/security/arcfour.rb#14
class Arcfour
  # @return [Arcfour] a new instance of Arcfour
  #
  # source://prawn//lib/prawn/security/arcfour.rb#15
  def initialize(key); end

  # source://prawn//lib/prawn/security/arcfour.rb#41
  def encrypt(string); end

  private

  # Produces the next byte of key material in the stream (3.2 Stream Generation)
  #
  # source://prawn//lib/prawn/security/arcfour.rb#48
  def key_byte; end
end

# @private
#
# source://prawn//lib/prawn/security.rb#212
module PDF; end

# source://prawn//lib/prawn/security.rb#213
module PDF::Core
  private

  # Like pdf_object, but returns an encrypted result if required.
  # For direct objects, requires the object identifier and generation number
  # from the indirect object referencing obj.
  #
  # @private
  #
  # source://prawn//lib/prawn/security.rb#221
  def encrypted_pdf_object(obj, key, id, gen, in_content_stream = T.unsafe(nil)); end

  # source://pdf-core/0.9.0/lib/pdf/core/pdf_object.rb#51
  def pdf_object(obj, in_content_stream = T.unsafe(nil)); end

  # source://pdf-core/0.9.0/lib/pdf/core/pdf_object.rb#15
  def real(num); end

  # source://pdf-core/0.9.0/lib/pdf/core/pdf_object.rb#19
  def real_params(array); end

  # source://pdf-core/0.9.0/lib/pdf/core/pdf_object.rb#31
  def string_to_hex(str); end

  # source://pdf-core/0.9.0/lib/pdf/core/pdf_object.rb#23
  def utf8_to_utf16(str); end

  class << self
    # Like pdf_object, but returns an encrypted result if required.
    # For direct objects, requires the object identifier and generation number
    # from the indirect object referencing obj.
    #
    # @private
    #
    # source://prawn//lib/prawn/security.rb#221
    def encrypted_pdf_object(obj, key, id, gen, in_content_stream = T.unsafe(nil)); end

    # source://pdf-core/0.9.0/lib/pdf/core/pdf_object.rb#51
    def pdf_object(obj, in_content_stream = T.unsafe(nil)); end

    # source://pdf-core/0.9.0/lib/pdf/core/pdf_object.rb#15
    def real(num); end

    # source://pdf-core/0.9.0/lib/pdf/core/pdf_object.rb#19
    def real_params(array); end

    # source://pdf-core/0.9.0/lib/pdf/core/pdf_object.rb#31
    def string_to_hex(str); end

    # source://pdf-core/0.9.0/lib/pdf/core/pdf_object.rb#23
    def utf8_to_utf16(str); end
  end
end

# @private
#
# source://prawn//lib/prawn/security.rb#282
class PDF::Core::Reference
  # source://pdf-core/0.9.0/lib/pdf/core/reference.rb#22
  def initialize(id, data); end

  # source://pdf-core/0.9.0/lib/pdf/core/reference.rb#41
  def <<(io); end

  # source://pdf-core/0.9.0/lib/pdf/core/reference.rb#14
  def data; end

  # source://pdf-core/0.9.0/lib/pdf/core/reference.rb#14
  def data=(_arg0); end

  # source://pdf-core/0.9.0/lib/pdf/core/reference.rb#56
  def deep_copy(share = T.unsafe(nil)); end

  # Returns the object definition for the object this references, keyed from
  # +key+.
  #
  # source://prawn//lib/prawn/security.rb#285
  def encrypted_object(key); end

  # source://pdf-core/0.9.0/lib/pdf/core/reference.rb#14
  def gen; end

  # source://pdf-core/0.9.0/lib/pdf/core/reference.rb#14
  def gen=(_arg0); end

  # source://pdf-core/0.9.0/lib/pdf/core/reference.rb#14
  def identifier; end

  # source://pdf-core/0.9.0/lib/pdf/core/reference.rb#14
  def identifier=(_arg0); end

  # source://pdf-core/0.9.0/lib/pdf/core/reference.rb#29
  def object; end

  # source://pdf-core/0.9.0/lib/pdf/core/reference.rb#14
  def offset; end

  # source://pdf-core/0.9.0/lib/pdf/core/reference.rb#14
  def offset=(_arg0); end

  # source://pdf-core/0.9.0/lib/pdf/core/reference.rb#76
  def replace(other_ref); end

  # source://pdf-core/0.9.0/lib/pdf/core/reference.rb#14
  def stream; end

  # source://pdf-core/0.9.0/lib/pdf/core/reference.rb#14
  def stream=(_arg0); end

  # source://pdf-core/0.9.0/lib/pdf/core/reference.rb#49
  def to_s; end
end

# @private
#
# source://prawn//lib/prawn/security.rb#267
class PDF::Core::Stream
  # source://pdf-core/0.9.0/lib/pdf/core/stream.rb#14
  def initialize(io = T.unsafe(nil)); end

  # source://pdf-core/0.9.0/lib/pdf/core/stream.rb#20
  def <<(io); end

  # source://pdf-core/0.9.0/lib/pdf/core/stream.rb#26
  def compress!; end

  # source://pdf-core/0.9.0/lib/pdf/core/stream.rb#33
  def compressed?; end

  # source://pdf-core/0.9.0/lib/pdf/core/stream.rb#71
  def data; end

  # source://pdf-core/0.9.0/lib/pdf/core/stream.rb#37
  def empty?; end

  # source://prawn//lib/prawn/security.rb#268
  def encrypted_object(key, id, gen); end

  # source://pdf-core/0.9.0/lib/pdf/core/stream.rb#41
  def filtered_stream; end

  # source://pdf-core/0.9.0/lib/pdf/core/stream.rb#12
  def filters; end

  # source://pdf-core/0.9.0/lib/pdf/core/stream.rb#92
  def inspect; end

  # source://pdf-core/0.9.0/lib/pdf/core/stream.rb#59
  def length; end

  # source://pdf-core/0.9.0/lib/pdf/core/stream.rb#63
  def object; end
end

# source://prawn//lib/prawn.rb#11
module Prawn
  private

  # When set to true, Prawn will verify hash options to ensure only valid keys
  # are used.  Off by default.
  #
  # Example:
  #   >> Prawn::Document.new(:tomato => "Juicy")
  #   Prawn::Errors::UnknownOption:
  #   Detected unknown option(s): [:tomato]
  #   Accepted options are: [:page_size, :page_layout, :left_margin, ...]
  #
  # @private
  #
  # source://prawn//lib/prawn.rb#34
  def debug; end

  # When set to true, Prawn will verify hash options to ensure only valid keys
  # are used.  Off by default.
  #
  # Example:
  #   >> Prawn::Document.new(:tomato => "Juicy")
  #   Prawn::Errors::UnknownOption:
  #   Detected unknown option(s): [:tomato]
  #   Accepted options are: [:page_size, :page_layout, :left_margin, ...]
  #
  # @private
  #
  # source://prawn//lib/prawn.rb#34
  def debug=(_arg0); end

  # @private
  #
  # source://prawn//lib/prawn.rb#41
  def verify_options(accepted, actual); end

  class << self
    # When set to true, Prawn will verify hash options to ensure only valid keys
    # are used.  Off by default.
    #
    # Example:
    #   >> Prawn::Document.new(:tomato => "Juicy")
    #   Prawn::Errors::UnknownOption:
    #   Detected unknown option(s): [:tomato]
    #   Accepted options are: [:page_size, :page_layout, :left_margin, ...]
    #
    # @private
    #
    # source://prawn//lib/prawn.rb#34
    def debug; end

    # When set to true, Prawn will verify hash options to ensure only valid keys
    # are used.  Off by default.
    #
    # Example:
    #   >> Prawn::Document.new(:tomato => "Juicy")
    #   Prawn::Errors::UnknownOption:
    #   Detected unknown option(s): [:tomato]
    #   Accepted options are: [:page_size, :page_layout, :left_margin, ...]
    #
    # @private
    #
    # source://prawn//lib/prawn.rb#34
    def debug=(_arg0); end

    # source://prawn//lib/prawn/image_handler.rb#12
    def image_handler; end

    # @private
    #
    # source://prawn//lib/prawn.rb#41
    def verify_options(accepted, actual); end
  end
end

# The base source directory for Prawn as installed on the system
#
# source://prawn//lib/prawn.rb#19
Prawn::BASEDIR = T.let(T.unsafe(nil), String)

# source://prawn//lib/prawn.rb#20
Prawn::DATADIR = T.let(T.unsafe(nil), String)

# The Prawn::Document class is how you start creating a PDF document.
#
# There are three basic ways you can instantiate PDF Documents in Prawn, they
# are through assignment, implicit block or explicit block.  Below is an
# example of each type, each example does exactly the same thing, makes a PDF
# document with all the defaults and puts in the default font "Hello There"
# and then saves it to the current directory as "example.pdf"
#
# For example, assignment can be like this:
#
#   pdf = Prawn::Document.new
#   pdf.text "Hello There"
#   pdf.render_file "example.pdf"
#
# Or you can do an implied block form:
#
#   Prawn::Document.generate "example.pdf" do
#     text "Hello There"
#   end
#
# Or if you need to access a variable outside the scope of the block, the
# explicit block form:
#
#   words = "Hello There"
#   Prawn::Document.generate "example.pdf" do |pdf|
#     pdf.text words
#   end
#
# Usually, the block forms are used when you are simply creating a PDF
# document that you want to immediately save or render out.
#
# See the new and generate methods for further details on the above.
#
# source://prawn//lib/prawn/security.rb#14
class Prawn::Document
  include ::Prawn::Document::Internals
  include ::PDF::Core::Annotations
  include ::PDF::Core::Destinations
  include ::Prawn::Document::Security
  include ::PDF::Core::Text
  include ::Prawn::Text::Formatted
  include ::Prawn::Text
  include ::Prawn::Graphics::BlendMode
  include ::Prawn::Graphics::Color
  include ::Prawn::Graphics::Dash
  include ::Prawn::Graphics::CapStyle
  include ::Prawn::Graphics::JoinStyle
  include ::Prawn::Graphics::Transparency
  include ::Prawn::Graphics::Transformation
  include ::Prawn::Graphics::Patterns
  include ::Prawn::Graphics
  include ::Prawn::Images
  include ::Prawn::Stamp
  include ::Prawn::SoftMask
  include ::Prawn::TransformationStack

  # Creates a new PDF Document.  The following options are available (with
  # the default values marked in [])
  #
  # <tt>:page_size</tt>:: One of the PDF::Core::PageGeometry sizes [LETTER]
  # <tt>:page_layout</tt>:: Either <tt>:portrait</tt> or <tt>:landscape</tt>
  # <tt>:margin</tt>:: Sets the margin on all sides in points [0.5 inch]
  # <tt>:left_margin</tt>:: Sets the left margin in points [0.5 inch]
  # <tt>:right_margin</tt>:: Sets the right margin in points [0.5 inch]
  # <tt>:top_margin</tt>:: Sets the top margin in points [0.5 inch]
  # <tt>:bottom_margin</tt>:: Sets the bottom margin in points [0.5 inch]
  # <tt>:skip_page_creation</tt>:: Creates a document without starting the
  #                                first page [false]
  # <tt>:compress</tt>:: Compresses content streams before rendering them
  #                      [false]
  # <tt>:background</tt>:: An image path to be used as background on all pages
  #                        [nil]
  # <tt>:background_scale</tt>:: Backgound image scale [1] [nil]
  # <tt>:info</tt>:: Generic hash allowing for custom metadata properties
  #                  [nil]
  # <tt>:text_formatter</tt>: The text formatter to use for
  #                           <tt>:inline_format</tt>ted text
  #                           [Prawn::Text::Formatted::Parser]
  #
  # Setting e.g. the :margin to 100 points and the :left_margin to 50 will
  # result in margins of 100 points on every side except for the left, where
  # it will be 50.
  #
  # The :margin can also be an array much like CSS shorthand:
  #
  #   # Top and bottom are 20, left and right are 100.
  #   :margin => [20, 100]
  #   # Top is 50, left and right are 100, bottom is 20.
  #   :margin => [50, 100, 20]
  #   # Top is 10, right is 20, bottom is 30, left is 40.
  #   :margin => [10, 20, 30, 40]
  #
  # Additionally, :page_size can be specified as a simple two value array
  # giving the width and height of the document you need in PDF Points.
  #
  # Usage:
  #
  #   # New document, US Letter paper, portrait orientation
  #   pdf = Prawn::Document.new
  #
  #   # New document, A4 paper, landscaped
  #   pdf = Prawn::Document.new(page_size: "A4", page_layout: :landscape)
  #
  #   # New document, Custom size
  #   pdf = Prawn::Document.new(page_size: [200, 300])
  #
  #   # New document, with background
  #   pdf = Prawn::Document.new(
  #     background: "#{Prawn::DATADIR}/images/pigs.jpg"
  #   )
  #
  # @return [Document] a new instance of Document
  #
  # source://prawn//lib/prawn/document.rb#204
  def initialize(options = T.unsafe(nil), &block); end

  # :call-seq:
  #   bounding_box(point, options={}, &block)
  #
  # A bounding box serves two important purposes:
  # * Provide bounds for flowing text, starting at a given point
  # * Translate the origin (0,0) for graphics primitives
  #
  # A point and :width must be provided. :height is optional.
  # (See stretchyness below)
  #
  # ==Positioning
  #
  # Bounding boxes are positioned relative to their top left corner and
  # the width measurement is towards the right and height measurement is
  # downwards.
  #
  # Usage:
  #
  # * Bounding box 100pt x 100pt in the absolute bottom left of the
  #   containing box:
  #
  #   pdf.bounding_box([0,100], :width => 100, :height => 100)
  #     stroke_bounds
  #   end
  #
  # * Bounding box 200pt x 400pt high in the center of the page:
  #
  #   x_pos = ((bounds.width / 2) - 150)
  #   y_pos = ((bounds.height / 2) + 200)
  #   pdf.bounding_box([x_pos, y_pos], :width => 300, :height => 400) do
  #     stroke_bounds
  #   end
  #
  # ==Flowing Text
  #
  # When flowing text, the usage of a bounding box is simple. Text will
  # begin at the point specified, flowing the width of the bounding box.
  # After the block exits, the cursor position will be moved to
  # the bottom of the bounding box (y - height). If flowing text exceeds
  # the height of the bounding box, the text will be continued on the next
  # page, starting again at the top-left corner of the bounding box.
  #
  # Usage:
  #
  #   pdf.bounding_box([100,500], :width => 100, :height => 300) do
  #     pdf.text "This text will flow in a very narrow box starting" +
  #      "from [100,500]. The pointer will then be moved to [100,200]" +
  #      "and return to the margin_box"
  #   end
  #
  # Note, this is a low level tool and is designed primarily for building
  # other abstractions.  If you just need to flow text on the page, you
  # will want to look at span() and text_box() instead
  #
  # ==Translating Coordinates
  #
  # When translating coordinates, the idea is to allow the user to draw
  # relative to the origin, and then translate their drawing to a specified
  # area of the document, rather than adjust all their drawing coordinates
  # to match this new region.
  #
  # Take for example two triangles which share one point, drawn from the
  # origin:
  #
  #   pdf.polygon [0,250], [0,0], [150,100]
  #   pdf.polygon [100,0], [150,100], [200,0]
  #
  # It would be easy enough to translate these triangles to another point,
  # e.g [200,200]
  #
  #   pdf.polygon [200,450], [200,200], [350,300]
  #   pdf.polygon [300,200], [350,300], [400,200]
  #
  # However, each time you want to move the drawing, you'd need to alter
  # every point in the drawing calls, which as you might imagine, can become
  # tedious.
  #
  # If instead, we think of the drawing as being bounded by a box, we can
  # see that the image is 200 points wide by 250 points tall.
  #
  # To translate it to a new origin, we simply select a point at (x,y+height)
  #
  # Using the [200,200] example:
  #
  #   pdf.bounding_box([200,450], :width => 200, :height => 250) do
  #     pdf.stroke do
  #       pdf.polygon [0,250], [0,0], [150,100]
  #       pdf.polygon [100,0], [150,100], [200,0]
  #     end
  #   end
  #
  # Notice that the drawing is still relative to the origin. If we want to
  # move this drawing around the document, we simply need to recalculate the
  # top-left corner of the rectangular bounding-box, and all of our graphics
  # calls remain unmodified.
  #
  # ==Nesting Bounding Boxes
  #
  # At the top level, bounding boxes are specified relative to the document's
  # margin_box (which is itself a bounding box).  You can also nest bounding
  # boxes, allowing you to build components which are relative to each other
  #
  # Usage:
  #
  #  pdf.bounding_box([200,450], :width => 200, :height => 250) do
  #    pdf.stroke_bounds   # Show the containing bounding box
  #    pdf.bounding_box([50,200], :width => 50, :height => 50) do
  #      # a 50x50 bounding box that starts 50 pixels left and 50 pixels down
  #      # the parent bounding box.
  #      pdf.stroke_bounds
  #    end
  #  end
  #
  # ==Stretchyness
  #
  # If you do not specify a height to a bounding box, it will become stretchy
  # and its height will be calculated automatically as you stretch the box
  # downwards.
  #
  #  pdf.bounding_box([100,400], :width => 400) do
  #    pdf.text("The height of this box is #{pdf.bounds.height}")
  #    pdf.text('this is some text')
  #    pdf.text('this is some more text')
  #    pdf.text('and finally a bit more')
  #    pdf.text("Now the height of this box is #{pdf.bounds.height}")
  #  end
  #
  # ==Absolute Positioning
  #
  # If you wish to position the bounding boxes at absolute coordinates rather
  # than relative to the margins or other bounding boxes, you can use canvas()
  #
  #  pdf.bounding_box([50,500], :width => 200, :height => 300) do
  #    pdf.stroke_bounds
  #    pdf.canvas do
  #      Positioned outside the containing box at the 'real' (300,450)
  #      pdf.bounding_box([300,450], :width => 200, :height => 200) do
  #        pdf.stroke_bounds
  #      end
  #    end
  #  end
  #
  # Of course, if you use canvas, you will be responsible for ensuring that
  # you remain within the printable area of your document.
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#158
  def bounding_box(point, *args, &block); end

  # The bounds method returns the current bounding box you are currently in,
  # which is by default the box represented by the margin box on the
  # document itself.  When called from within a created <tt>bounding_box</tt>
  # block, the box defined by that call will be returned instead of the
  # document margin box.
  #
  # Another important point about bounding boxes is that all x and
  # y measurements within a bounding box code block are relative to the bottom
  # left corner of the bounding box.
  #
  # For example:
  #
  #  Prawn::Document.new do
  #    # In the default "margin box" of a Prawn document of 0.5in along each
  #    # edge
  #
  #    # Draw a border around the page (the manual way)
  #    stroke do
  #      line(bounds.bottom_left, bounds.bottom_right)
  #      line(bounds.bottom_right, bounds.top_right)
  #      line(bounds.top_right, bounds.top_left)
  #      line(bounds.top_left, bounds.bottom_left)
  #    end
  #
  #    # Draw a border around the page (the easy way)
  #    stroke_bounds
  #  end
  #
  # source://prawn//lib/prawn/document.rb#440
  def bounds; end

  # Sets Document#bounds to the BoundingBox provided.  See above for a brief
  # description of what a bounding box is.  This function is useful if you
  # really need to change the bounding box manually, but usually, just
  # entering and exiting bounding box code blocks is good enough.
  #
  # source://prawn//lib/prawn/document.rb#456
  def bounds=(bounding_box); end

  # A shortcut to produce a bounding box which is mapped to the document's
  # absolute coordinates, regardless of how things are nested or margin sizes.
  #
  #   pdf.canvas do
  #     pdf.line pdf.bounds.bottom_left, pdf.bounds.top_right
  #   end
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#172
  def canvas(&block); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#21
  def cell(options = T.unsafe(nil)); end

  # A column box is a bounding box with the additional property that when
  # text flows past the bottom, it will wrap first to another column on the
  # same page, and only flow to the next page when all the columns are
  # filled.
  #
  # column_box accepts the same parameters as bounding_box, as well as the
  # number of :columns and a :spacer (in points) between columns. If resetting
  # the top margin is desired on a new page (e.g. to allow for initial page
  # wide column titles) the option :reflow_margins => true can be set.
  #
  # Defaults are :columns = 3, :spacer = font_size, and
  # :reflow_margins => false
  #
  # Under PDF::Writer, "spacer" was known as "gutter"
  #
  # source://prawn//lib/prawn/document/column_box.rb#30
  def column_box(*args, &block); end

  # The current y drawing position relative to the innermost bounding box,
  # or to the page margins at the top level.
  #
  # source://prawn//lib/prawn/document.rb#361
  def cursor; end

  # Defines the grid system for a particular document.  Takes the number of
  # rows and columns and the width to use for the gutter as the
  # keys :rows, :columns, :gutter, :row_gutter, :column_gutter
  #
  # Note that a completely new grid object is built each time define_grid()
  # is called. This means that all subsequent calls to grid() will use
  # the newly defined Grid object -- grids are not nestable like
  # bounding boxes are.
  #
  # source://prawn//lib/prawn/grid.rb#22
  def define_grid(options = T.unsafe(nil)); end

  # Remove page of the document by index
  #
  #   pdf = Prawn::Document.new
  #   pdf.page_count #=> 1
  #   3.times { pdf.start_new_page }
  #   pdf.page_count #=> 4
  #   pdf.delete_page(-1)
  #   pdf.page_count #=> 3
  #
  # source://prawn//lib/prawn/document.rb#319
  def delete_page(index); end

  # Looks up the given font using the given criteria. Once a font has been
  # found by that matches the criteria, it will be cached to subsequent
  # lookups for that font will return the same object.
  # --
  # Challenges involved: the name alone is not sufficient to uniquely identify
  # a font (think dfont suitcases that can hold multiple different fonts in a
  # single file). Thus, the :name key is included in the cache key.
  #
  # It is further complicated, however, since fonts in some formats (like the
  # dfont suitcases) can be identified either by numeric index, OR by their
  # name within the suitcase, and both should hash to the same font object (to
  # avoid the font being embedded multiple times). This is not yet
  # implemented, which means if someone selects a font both by name, and by
  # index, the font will be embedded twice. Since we do font subsetting, this
  # double embedding won't be catastrophic, just annoying.
  # ++
  #
  # @private
  #
  # source://prawn//lib/prawn/font.rb#237
  def find_font(name, options = T.unsafe(nil)); end

  # Executes a block and then restores the original y position. If new pages
  # were created during this block, it will teleport back to the original
  # page when done.
  #
  #   pdf.text "A"
  #
  #   pdf.float do
  #     pdf.move_down 100
  #     pdf.text "C"
  #   end
  #
  #   pdf.text "B"
  #
  # source://prawn//lib/prawn/document.rb#384
  def float; end

  # Without arguments, this returns the currently selected font. Otherwise,
  # it sets the current font. When a block is used, the font is applied
  # transactionally and is rolled back when the block exits.
  #
  #   Prawn::Document.generate("font.pdf") do
  #     text "Default font is Helvetica"
  #
  #     font "Times-Roman"
  #     text "Now using Times-Roman"
  #
  #     font("DejaVuSans.ttf") do
  #       text "Using TTF font from file DejaVuSans.ttf"
  #       font "Courier", :style => :bold
  #       text "You see this in bold Courier"
  #     end
  #
  #     text "Times-Roman, again"
  #   end
  #
  # The :name parameter must be a string. It can be one of the 14 built-in
  # fonts supported by PDF, or the location of a TTF file. The
  # Fonts::AFM::BUILT_INS array specifies the valid built in font values.
  #
  # If a ttf font is specified, the glyphs necessary to render your document
  # will be embedded in the rendered PDF. This should be your preferred option
  # in most cases. It will increase the size of the resulting file, but also
  # make it more portable.
  #
  # The options parameter is an optional hash providing size and style. To use
  # the :style option you need to map those font styles to their respective
  # font files.
  # See font_families for more information.
  #
  # source://prawn//lib/prawn/font.rb#48
  def font(name = T.unsafe(nil), options = T.unsafe(nil)); end

  # Hash that maps font family names to their styled individual font names.
  #
  # To add support for another font family, append to this hash, e.g:
  #
  #   pdf.font_families.update(
  #    "MyTrueTypeFamily" => { :bold        => "foo-bold.ttf",
  #                            :italic      => "foo-italic.ttf",
  #                            :bold_italic => "foo-bold-italic.ttf",
  #                            :normal      => "foo.ttf" })
  #
  # This will then allow you to use the fonts like so:
  #
  #   pdf.font("MyTrueTypeFamily", :style => :bold)
  #   pdf.text "Some bold text"
  #   pdf.font("MyTrueTypeFamily")
  #   pdf.text "Some normal text"
  #
  # This assumes that you have appropriate TTF fonts for each style you
  # wish to support.
  #
  # By default the styles :bold, :italic, :bold_italic, and :normal are
  # defined for fonts "Courier", "Times-Roman" and "Helvetica". When
  # defining your own font families, you can map any or all of these
  # styles to whatever font files you'd like.
  #
  # source://prawn//lib/prawn/font.rb#171
  def font_families; end

  # Hash of Font objects keyed by names
  #
  # source://prawn//lib/prawn/font.rb#258
  def font_registry; end

  # When called with no argument, returns the current font size.
  #
  # When called with a single argument but no block, sets the current font
  # size.  When a block is used, the font size is applied transactionally and
  # is rolled back when the block exits.  You may still change the font size
  # within a transactional block for individual text segments, or nested calls
  # to font_size.
  #
  #   Prawn::Document.generate("font_size.pdf") do
  #     font_size 16
  #     text "At size 16"
  #
  #     font_size(10) do
  #       text "At size 10"
  #       text "At size 6", :size => 6
  #       text "At size 10"
  #     end
  #
  #     text "At size 16"
  #   end
  #
  # When called without an argument, this method returns the current font
  # size.
  #
  # source://prawn//lib/prawn/font.rb#95
  def font_size(points = T.unsafe(nil)); end

  # Sets the font size
  #
  # source://prawn//lib/prawn/font.rb#105
  def font_size=(size); end

  # Re-opens the page with the given (1-based) page number so that you can
  # draw on it.
  #
  # See Prawn::Document#number_pages for a sample usage of this capability.
  #
  # source://prawn//lib/prawn/document.rb#346
  def go_to_page(page_number); end

  # A method that can either be used to access a particular grid on the page
  # or work with the grid system directly.
  #
  #   @pdf.grid                 # Get the Grid directly
  #   @pdf.grid([0,1])          # Get the GridBox at [0,1]
  #   @pdf.grid([0,1], [1,2])   # Get a multi-box spanning from [0,1] to [1,2]
  #
  # source://prawn//lib/prawn/grid.rb#34
  def grid(*args); end

  # Attempts to group the given block vertically within the current context.
  # First attempts to render it in the current position on the current page.
  # If that attempt overflows, it is tried anew after starting a new context
  # (page or column). Returns a logically true value if the content fits in
  # one page/column, false if a new page or column was needed.
  #
  # Raises CannotGroup if the provided content is too large to fit alone in
  # the current page or column.
  #
  # @private
  # @raise [NotImplementedError]
  #
  # source://prawn//lib/prawn/document.rb#625
  def group(*_arguments); end

  # Indents the specified number of PDF points for the duration of the block
  #
  #  pdf.text "some text"
  #  pdf.indent(20) do
  #    pdf.text "This is indented 20 points"
  #  end
  #  pdf.text "This starts 20 points left of the above line " +
  #           "and is flush with the first line"
  #  pdf.indent 20, 20 do
  #    pdf.text "This line is indented on both sides."
  #  end
  #
  # source://prawn//lib/prawn/document.rb#527
  def indent(left, right = T.unsafe(nil), &block); end

  # source://prawn//lib/prawn/document.rb#681
  def initialize_first_page(options); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#33
  def make_cell(content, options = T.unsafe(nil)); end

  # Returns the value of attribute margin_box.
  #
  # source://prawn//lib/prawn/document.rb#107
  def margin_box; end

  # Sets the attribute margin_box
  #
  # @param value the value to set the attribute margin_box to.
  #
  # source://prawn//lib/prawn/document.rb#107
  def margin_box=(_arg0); end

  # Returns the value of attribute margins.
  #
  # source://prawn//lib/prawn/document.rb#108
  def margins; end

  # @private
  #
  # source://prawn//lib/prawn/document.rb#669
  def mask(*fields); end

  # Moves to the specified y position in relative terms to the bottom margin.
  #
  # source://prawn//lib/prawn/document.rb#367
  def move_cursor_to(new_y); end

  # Moves down the document by n points relative to the current position
  # inside the current bounding box.
  #
  # source://prawn//lib/prawn/document.rb#470
  def move_down(amount); end

  # Moves up the document by n points relative to the current position inside
  # the current bounding box.
  #
  # source://prawn//lib/prawn/document.rb#463
  def move_up(amount); end

  # Places a text box on specified pages for page numbering.  This should be
  # called towards the end of document creation, after all your content is
  # already in place.  In your template string, <page> refers to the current
  # page, and <total> refers to the total amount of pages in the document.
  # Page numbering should occur at the end of your Prawn::Document.generate
  # block because the method iterates through existing pages after they are
  # created.
  #
  # Parameters are:
  #
  # <tt>string</tt>:: Template string for page number wording.
  #                   Should include '<page>' and, optionally, '<total>'.
  # <tt>options</tt>:: A hash for page numbering and text box options.
  #     <tt>:page_filter</tt>:: A filter to specify which pages to place page
  #                             numbers on. Refer to the method 'page_match?'
  #     <tt>:start_count_at</tt>:: The starting count to increment pages from.
  #     <tt>:total_pages</tt>:: If provided, will replace <total> with the
  #                             value given. Useful to override the total
  #                             number of pages when using the start_count_at
  #                             option.
  #     <tt>:color</tt>:: Text fill color.
  #
  #     Please refer to Prawn::Text::text_box for additional options
  #     concerning text formatting and placement.
  #
  # Example:
  #   Print page numbers on every page except for the first. Start counting
  #   from five.
  #
  #     Prawn::Document.generate("page_with_numbering.pdf") do
  #       number_pages "<page> in a total of <total>", {
  #         start_count_at: 5,
  #         page_filter: lambda { |pg| pg != 1 },
  #         at: [bounds.right - 50, 0],
  #         align: :right,
  #         size: 14
  #       }
  #     end
  #
  # source://prawn//lib/prawn/document.rb#570
  def number_pages(string, options = T.unsafe(nil)); end

  # Lazily instantiates a Prawn::Outline object for document. This is used as
  # point of entry to methods to build the outline tree for a document's table
  # of contents.
  #
  # source://prawn//lib/prawn/outline.rb#10
  def outline; end

  # Moves down the document by y, executes a block, then moves down the
  # document by y again.
  #
  #   pdf.text "some text"
  #   pdf.pad(100) do
  #     pdf.text "This is 100 points below the previous line of text"
  #   end
  #   pdf.text "This is 100 points below the previous line of text"
  #
  # source://prawn//lib/prawn/document.rb#509
  def pad(y); end

  # Executes a block then moves down the document
  #
  #   pdf.text "some text"
  #   pdf.pad_bottom(100) do
  #     pdf.text "This text appears right below the previous line of text"
  #   end
  #   pdf.text "This is 100 points below the previous line of text"
  #
  # source://prawn//lib/prawn/document.rb#495
  def pad_bottom(y); end

  # Moves down the document and then executes a block.
  #
  #   pdf.text "some text"
  #   pdf.pad_top(100) do
  #     pdf.text "This is 100 points below the previous line of text"
  #   end
  #   pdf.text "This text appears right below the previous line of text"
  #
  # source://prawn//lib/prawn/document.rb#482
  def pad_top(y); end

  # @private
  #
  # source://prawn//lib/prawn/document.rb#695
  def page; end

  # Returns the number of pages in the document
  #
  #   pdf = Prawn::Document.new
  #   pdf.page_count #=> 1
  #   3.times { pdf.start_new_page }
  #   pdf.page_count #=> 4
  #
  # source://prawn//lib/prawn/document.rb#337
  def page_count; end

  # Provides a way to execute a block of code repeatedly based on a
  # page_filter.
  #
  # Available page filters are:
  #   :all         repeats on every page
  #   :odd         repeats on odd pages
  #   :even        repeats on even pages
  #   some_array   repeats on every page listed in the array
  #   some_range   repeats on every page included in the range
  #   some_lambda  yields page number and repeats for true return values
  #
  # @return [Boolean]
  #
  # source://prawn//lib/prawn/document.rb#652
  def page_match?(page_filter, page_number); end

  # Returns the value of attribute page_number.
  #
  # source://prawn//lib/prawn/document.rb#109
  def page_number; end

  # Sets the attribute page_number
  #
  # @param value the value to set the attribute page_number to.
  #
  # source://prawn//lib/prawn/document.rb#109
  def page_number=(_arg0); end

  # Returns the innermost non-stretchy bounding box.
  #
  # @private
  #
  # source://prawn//lib/prawn/document.rb#447
  def reference_bounds; end

  # Renders the PDF document to string.
  # Pass an open file descriptor to render to file.
  #
  # source://prawn//lib/prawn/document.rb#395
  def render(*arguments, &block); end

  # Renders the PDF document to file.
  #
  #   pdf.render_file "foo.pdf"
  #
  # source://prawn//lib/prawn/document.rb#408
  def render_file(filename); end

  # Provides a way to execute a block of code repeatedly based on
  # a page_filter.  Since Stamp is used under the hood, this method is very
  # space efficient.
  #
  # Available page filters are:
  #   :all        -- repeats on every page
  #   :odd        -- repeats on odd pages
  #   :even       -- repeats on even pages
  #   some_array  -- repeats on every page listed in the array
  #   some_range  -- repeats on every page included in the range
  #   some_lambda -- yields page number and repeats for true return values
  #
  # Also accepts an optional second argument for dynamic content which
  # executes the code in the context of the filtered pages without using
  # a Stamp.
  #
  # Example:
  #
  #   Prawn::Document.generate("repeat.pdf", :skip_page_creation => true) do
  #
  #     repeat :all do
  #       draw_text "ALLLLLL", :at => bounds.top_left
  #     end
  #
  #     repeat :odd do
  #       draw_text "ODD", :at => [0,0]
  #     end
  #
  #     repeat :even do
  #       draw_text "EVEN", :at => [0,0]
  #     end
  #
  #     repeat [1,2] do
  #       draw_text "[1,2]", :at => [100,0]
  #     end
  #
  #     repeat 2..4 do
  #       draw_text "2..4", :at => [200,0]
  #     end
  #
  #     repeat(lambda { |pg| pg % 3 == 0 }) do
  #       draw_text "Every third", :at => [250, 20]
  #     end
  #
  #     10.times do
  #       start_new_page
  #       draw_text "A wonderful page", :at => [400,400]
  #     end
  #
  #     repeat(:all, :dynamic => true) do
  #       text page_number, :at => [500, 0]
  #     end
  #
  #   end
  #
  # source://prawn//lib/prawn/repeater.rb#78
  def repeat(page_filter, options = T.unsafe(nil), &block); end

  # A list of all repeaters in the document.
  # See Document#repeat for details
  #
  # @private
  #
  # source://prawn//lib/prawn/repeater.rb#17
  def repeaters; end

  # Saves the current font, and then yields. When the block
  # finishes, the original font is restored.
  #
  # source://prawn//lib/prawn/font.rb#209
  def save_font; end

  # Sets the font directly, given an actual Font object
  # and size.
  #
  # source://prawn//lib/prawn/font.rb#201
  def set_font(font, size = T.unsafe(nil)); end

  # A span is a special purpose bounding box that allows a column of
  # elements to be positioned relative to the margin_box.
  #
  # Arguments:
  # +width+:: The width of the column in PDF points
  #
  # Options:
  # <tt>:position</tt>:: One of :left, :center, :right or an x offset
  #
  # This method is typically used for flowing a column of text from one
  # page to the next.
  #
  #  span(350, :position => :center) do
  #    text "Here's some centered text in a 350 point column. " * 100
  #  end
  #
  # source://prawn//lib/prawn/document/span.rb#29
  def span(width, options = T.unsafe(nil)); end

  # Creates and advances to a new page in the document.
  #
  # Page size, margins, and layout can also be set when generating a
  # new page. These values will become the new defaults for page creation
  #
  #   pdf.start_new_page #=> Starts new page keeping current values
  #   pdf.start_new_page(:size => "LEGAL", :layout => :landscape)
  #   pdf.start_new_page(:left_margin => 50, :right_margin => 50)
  #   pdf.start_new_page(:margin => 100)
  #
  # source://prawn//lib/prawn/document.rb#255
  def start_new_page(options = T.unsafe(nil)); end

  # @private
  #
  # source://prawn//lib/prawn/document.rb#692
  def state; end

  # @private
  #
  # source://prawn//lib/prawn/document.rb#692
  def state=(_arg0); end

  # Returns the value of attribute text_formatter.
  #
  # source://prawn//lib/prawn/document.rb#113
  def text_formatter; end

  # Sets the attribute text_formatter
  #
  # @param value the value to set the attribute text_formatter to.
  #
  # source://prawn//lib/prawn/document.rb#113
  def text_formatter=(_arg0); end

  # @private
  # @raise [NotImplementedError]
  #
  # source://prawn//lib/prawn/document.rb#634
  def transaction; end

  # Returns the width of the given string using the given font. If :size is
  # not specified as one of the options, the string is measured using the
  # current font size. You can also pass :kerning as an option to indicate
  # whether kerning should be used when measuring the width (defaults to
  # +false+).
  #
  # Note that the string _must_ be encoded properly for the font being used.
  # For AFM fonts, this is WinAnsi. For TTF, make sure the font is encoded as
  # UTF-8. You can use the Font#normalize_encoding method to make sure strings
  # are in an encoding appropriate for the current font.
  # --
  # For the record, this method used to be a method of Font (and still
  # delegates to width computations on Font). However, having the primary
  # interface for calculating string widths exist on Font made it tricky to
  # write extensions for Prawn in which widths are computed differently (e.g.,
  # taking formatting tags into account, or the like).
  #
  # By putting width_of here, on Document itself, extensions may easily
  # override it and redefine the width calculation behavior.
  # ++
  #
  # source://prawn//lib/prawn/font.rb#129
  def width_of(string, options = T.unsafe(nil)); end

  # Returns the value of attribute y.
  #
  # source://prawn//lib/prawn/document.rb#108
  def y; end

  # source://prawn//lib/prawn/document.rb#353
  def y=(new_y); end

  private

  # source://prawn//lib/prawn/document.rb#737
  def apply_margin_options(options); end

  # source://prawn//lib/prawn/document.rb#756
  def font_metric_cache; end

  # source://prawn//lib/prawn/document.rb#712
  def generate_margin_box; end

  # @yield [parent_box]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#187
  def init_bounding_box(user_block, options = T.unsafe(nil)); end

  # @yield [parent_box]
  #
  # source://prawn//lib/prawn/document/column_box.rb#39
  def init_column_box(user_block, options = T.unsafe(nil)); end

  # source://prawn//lib/prawn/grid.rb#318
  def multi_box(box1, box2); end

  # source://prawn//lib/prawn/grid.rb#314
  def single_box(rows, columns); end

  # setting override_settings to true ensures that a new graphic state does
  # not end up using previous settings.
  #
  # source://prawn//lib/prawn/document.rb#703
  def use_graphic_settings(override_settings = T.unsafe(nil)); end

  # source://prawn//lib/prawn/font.rb#264
  def width_of_inline_formatted_string(string, options = T.unsafe(nil)); end

  # source://prawn//lib/prawn/font.rb#274
  def width_of_string(string, options = T.unsafe(nil)); end

  class << self
    # Any module added to this array will be included into instances of
    # Prawn::Document at the per-object level.  These will also be inherited by
    # any subclasses.
    #
    # Example:
    #
    #   module MyFancyModule
    #
    #     def party!
    #       text "It's a big party!"
    #     end
    #
    #   end
    #
    #   Prawn::Document.extensions << MyFancyModule
    #
    #   Prawn::Document.generate("foo.pdf") do
    #     party!
    #   end
    #
    # source://prawn//lib/prawn/document.rb#95
    def extensions; end

    # Creates and renders a PDF document.
    #
    # When using the implicit block form, Prawn will evaluate the block
    # within an instance of Prawn::Document, simplifying your syntax.
    # However, please note that you will not be able to reference variables
    # from the enclosing scope within this block.
    #
    #   # Using implicit block form and rendering to a file
    #   Prawn::Document.generate "example.pdf" do
    #     # self here is set to the newly instantiated Prawn::Document
    #     # and so any variables in the outside scope are unavailable
    #     font "Times-Roman"
    #     draw_text "Hello World", :at => [200,720], :size => 32
    #   end
    #
    # If you need to access your local and instance variables, use the explicit
    # block form shown below.  In this case, Prawn yields an instance of
    # PDF::Document and the block is an ordinary closure:
    #
    #   # Using explicit block form and rendering to a file
    #   content = "Hello World"
    #   Prawn::Document.generate "example.pdf" do |pdf|
    #     # self here is left alone
    #     pdf.font "Times-Roman"
    #     pdf.draw_text content, :at => [200,720], :size => 32
    #   end
    #
    # source://prawn//lib/prawn/document.rb#144
    def generate(filename, options = T.unsafe(nil), &block); end

    # @private
    # @private
    #
    # source://prawn//lib/prawn/document.rb#100
    def inherited(base); end
  end
end

# Low level layout helper that simplifies coordinate math.
#
# See Prawn::Document#bounding_box for a description of what this class
# is used for.
#
# source://prawn//lib/prawn/document/bounding_box.rb#225
class Prawn::Document::BoundingBox
  # @private
  # @return [BoundingBox] a new instance of BoundingBox
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#233
  def initialize(document, parent, point, options = T.unsafe(nil)); end

  # Absolute bottom y-coordinate of the bottom box
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#434
  def absolute_bottom; end

  # Absolute bottom-left point of the bounding box
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#452
  def absolute_bottom_left; end

  # Absolute bottom-left point of the bounding box
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#458
  def absolute_bottom_right; end

  # Absolute left x-coordinate of the bounding box
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#416
  def absolute_left; end

  # Absolute right x-coordinate of the bounding box
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#422
  def absolute_right; end

  # Absolute top y-coordinate of the bounding box
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#428
  def absolute_top; end

  # Absolute top-left point of the bounding box
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#440
  def absolute_top_left; end

  # Absolute top-right point of the bounding box
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#446
  def absolute_top_right; end

  # Increase the left padding of the bounding box.
  #
  # @private
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#305
  def add_left_padding(left_padding); end

  # Increase the right padding of the bounding box.
  #
  # @private
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#321
  def add_right_padding(right_padding); end

  # The translated origin (x,y-height) which describes the location
  # of the bottom left corner of the bounding box
  #
  # @private
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#264
  def anchor; end

  # Relative bottom y-coordinate of the bounding box (Always 0)
  #
  # Example, position some text 3 pts from the bottom of the containing box:
  #
  #  draw_text('hello', :at => [0, (bounds.bottom + 3)])
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#360
  def bottom; end

  # Relative bottom-left point of the bounding box
  #
  # Example, draw a line along the left hand side of the page:
  #
  #  stroke do
  #    line(bounds.bottom_left, bounds.top_left)
  #  end
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#410
  def bottom_left; end

  # Relative bottom-right point of the bounding box
  #
  # Example, draw a line along the right hand side of the page:
  #
  #  stroke do
  #    line(bounds.bottom_right, bounds.top_right)
  #  end
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#398
  def bottom_right; end

  # Returns a deep copy of these bounds (including all parent bounds but
  # not copying the reference to the Document).
  #
  # @private
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#529
  def deep_copy; end

  # @private
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#250
  def document; end

  # Height of the bounding box.  If the box is 'stretchy' (unspecified
  # height attribute), height is calculated as the distance from the top of
  # the box to the current drawing position.
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#469
  def height; end

  # Temporarily adjust the @x coordinate to allow for left_padding
  #
  # Example:
  #
  #  indent 20 do
  #     text "20 points in"
  #     indent 30 do
  #       text "50 points in"
  #     end
  #   end
  #
  #  indent 20, 20 do
  #    text "indented on both sides"
  #  end
  #
  # @private
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#294
  def indent(left_padding, right_padding = T.unsafe(nil)); end

  # Relative left x-coordinate of the bounding box. (Always 0)
  #
  # Example, position some text 3 pts from the left of the containing box:
  #
  #  draw_text('hello', :at => [(bounds.left + 3), 0])
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#274
  def left; end

  # an alias for absolute_left
  #
  # @private
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#480
  def left_side; end

  # Moves to the top of the next page of the document, starting a new page
  # if necessary.
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#495
  def move_past_bottom; end

  # @private
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#250
  def parent; end

  # Returns the innermost non-stretchy bounding box.
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#513
  def reference_bounds; end

  # Relative right x-coordinate of the bounding box. (Equal to the box
  # width)
  #
  # Example, position some text 3 pts from the right of the containing box:
  #
  #  draw_text('hello', :at => [(bounds.right - 3), 0])
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#340
  def right; end

  # an alias for absolute_right
  #
  # @private
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#486
  def right_side; end

  # Returns +false+ when the box has a defined height, +true+ when the
  # height is being calculated on the fly based on the current vertical
  # position.
  #
  # @return [Boolean]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#507
  def stretchy?; end

  # Decrease the left padding of the bounding box.
  #
  # @private
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#313
  def subtract_left_padding(left_padding); end

  # Decrease the right padding of the bounding box.
  #
  # @private
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#328
  def subtract_right_padding(right_padding); end

  # Relative top y-coordinate of the bounding box. (Equal to the box height)
  #
  # Example, position some text 3 pts from the top of the containing box:
  #
  #  draw_text('hello', :at => [0, (bounds.top - 3)])
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#350
  def top; end

  # Relative top-left point of the bounding_box
  #
  # Example, draw a line from the top left of the box diagonally to the
  # bottom right:
  #
  #  stroke do
  #    line(bounds.top_left, bounds.bottom_right)
  #  end
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#373
  def top_left; end

  # Relative top-right point of the bounding box
  #
  # Example, draw a line from the top_right of the box diagonally to the
  # bottom left:
  #
  #  stroke do
  #    line(bounds.top_right, bounds.bottom_left)
  #  end
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#386
  def top_right; end

  # The current indentation of the left side of the bounding box.
  #
  # @private
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#254
  def total_left_padding; end

  # The current indentation of the right side of the bounding box.
  #
  # @private
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#258
  def total_right_padding; end

  # Height of the bounding box.  If the box is 'stretchy' (unspecified
  # height attribute), height is calculated as the distance from the top of
  # the box to the current drawing position.
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#469
  def update_height; end

  # Width of the bounding box
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#463
  def width; end

  class << self
    # Restores a copy of the bounds taken by BoundingBox.deep_copy in the
    # context of the given +document+. Does *not* set the bounds of the
    # document to the resulting BoundingBox, only returns it.
    #
    # @private
    #
    # source://prawn//lib/prawn/document/bounding_box.rb#547
    def restore_deep_copy(bounds, document); end
  end
end

# source://prawn//lib/prawn/document/bounding_box.rb#226
class Prawn::Document::BoundingBox::NoReferenceBounds < ::StandardError
  # @return [NoReferenceBounds] a new instance of NoReferenceBounds
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#227
  def initialize(message = T.unsafe(nil)); end
end

# Implements the necessary functionality to allow Document#column_box to
# work.
#
# source://prawn//lib/prawn/document/column_box.rb#54
class Prawn::Document::ColumnBox < ::Prawn::Document::BoundingBox
  # @return [ColumnBox] a new instance of ColumnBox
  #
  # source://prawn//lib/prawn/document/column_box.rb#55
  def initialize(document, parent, point, options = T.unsafe(nil)); end

  # Override the padding functions so as not to split the padding amount
  # between all columns on the page.
  #
  # source://prawn//lib/prawn/document/column_box.rb#123
  def add_left_padding(left_padding); end

  # source://prawn//lib/prawn/document/column_box.rb#133
  def add_right_padding(right_padding); end

  # The column width, not the width of the whole box,
  # before left and/or right padding
  #
  # source://prawn//lib/prawn/document/column_box.rb#65
  def bare_column_width; end

  # Relative position of the left edge of the current column
  #
  # source://prawn//lib/prawn/document/column_box.rb#90
  def left; end

  # x coordinate of the left edge of the current column
  #
  # source://prawn//lib/prawn/document/column_box.rb#84
  def left_side; end

  # Moves to the next column or starts a new page if currently positioned at
  # the rightmost column.
  #
  # source://asciidoctor-pdf/2.3.19/lib/asciidoctor/pdf/ext/prawn/document/column_box.rb#10
  def move_past_bottom; end

  # Relative position of the right edge of the current column.
  #
  # source://prawn//lib/prawn/document/column_box.rb#103
  def right; end

  # x co-orordinate of the right edge of the current column
  #
  # source://prawn//lib/prawn/document/column_box.rb#96
  def right_side; end

  # source://prawn//lib/prawn/document/column_box.rb#128
  def subtract_left_padding(left_padding); end

  # source://prawn//lib/prawn/document/column_box.rb#137
  def subtract_right_padding(right_padding); end

  # The column width after padding.
  # Used to calculate how long a line of text can be.
  #
  # source://prawn//lib/prawn/document/column_box.rb#72
  def width; end

  # Column width including the spacer.
  #
  # source://prawn//lib/prawn/document/column_box.rb#78
  def width_of_column; end
end

# A Grid represents the entire grid system of a Page and calculates
# the column width and row height of the base box.
#
# source://prawn//lib/prawn/grid.rb#57
class Prawn::Document::Grid
  # @return [Grid] a new instance of Grid
  #
  # source://prawn//lib/prawn/grid.rb#60
  def initialize(pdf, options = T.unsafe(nil)); end

  # Returns the value of attribute column_gutter.
  #
  # source://prawn//lib/prawn/grid.rb#58
  def column_gutter; end

  # Calculates the base width of boxes.
  #
  # source://prawn//lib/prawn/grid.rb#71
  def column_width; end

  # Returns the value of attribute columns.
  #
  # source://prawn//lib/prawn/grid.rb#58
  def columns; end

  # Returns the value of attribute gutter.
  #
  # source://prawn//lib/prawn/grid.rb#58
  def gutter; end

  # Returns the value of attribute pdf.
  #
  # source://prawn//lib/prawn/grid.rb#58
  def pdf; end

  # Returns the value of attribute row_gutter.
  #
  # source://prawn//lib/prawn/grid.rb#58
  def row_gutter; end

  # Calculates the base height of boxes.
  #
  # source://prawn//lib/prawn/grid.rb#76
  def row_height; end

  # Returns the value of attribute rows.
  #
  # source://prawn//lib/prawn/grid.rb#58
  def rows; end

  # Diagnostic tool to show all of the grids.  Defaults to gray.
  #
  # source://prawn//lib/prawn/grid.rb#81
  def show_all(color = T.unsafe(nil)); end

  private

  # source://prawn//lib/prawn/grid.rb#95
  def apply_gutter(options); end

  # source://prawn//lib/prawn/grid.rb#91
  def subdivide(total, num, gutter); end
end

# A Box is a class that represents a bounded area of a page.
# A Grid object has methods that allow easy access to the coordinates of
# its corners, which can be plugged into most existing prawnmethods.
#
# source://prawn//lib/prawn/grid.rb#113
class Prawn::Document::GridBox
  # @return [GridBox] a new instance of GridBox
  #
  # source://prawn//lib/prawn/grid.rb#116
  def initialize(pdf, rows, columns); end

  # y-coordinate of the bottom
  #
  # source://prawn//lib/prawn/grid.rb#165
  def bottom; end

  # x,y coordinates of bottom left corner
  #
  # source://prawn//lib/prawn/grid.rb#180
  def bottom_left; end

  # x,y coordinates of bottom right corner
  #
  # source://prawn//lib/prawn/grid.rb#185
  def bottom_right; end

  # Creates a standard bounding box based on the grid box.
  #
  # source://prawn//lib/prawn/grid.rb#190
  def bounding_box(&blk); end

  # Width of the gutter
  #
  # source://prawn//lib/prawn/grid.rb#145
  def gutter; end

  # Height of a box
  #
  # source://prawn//lib/prawn/grid.rb#140
  def height; end

  # x-coordinate of left side
  #
  # source://prawn//lib/prawn/grid.rb#150
  def left; end

  # Mostly diagnostic method that outputs the name of a box as
  # col_num, row_num
  #
  # source://prawn//lib/prawn/grid.rb#125
  def name; end

  # Returns the value of attribute pdf.
  #
  # source://prawn//lib/prawn/grid.rb#114
  def pdf; end

  # x-coordinate of right side
  #
  # source://prawn//lib/prawn/grid.rb#155
  def right; end

  # Diagnostic method
  #
  # source://prawn//lib/prawn/grid.rb#195
  def show(grid_color = T.unsafe(nil)); end

  # y-coordinate of the top
  #
  # source://prawn//lib/prawn/grid.rb#160
  def top; end

  # x,y coordinates of top left corner
  #
  # source://prawn//lib/prawn/grid.rb#170
  def top_left; end

  # x,y coordinates of top right corner
  #
  # source://prawn//lib/prawn/grid.rb#175
  def top_right; end

  # :nodoc
  #
  # source://prawn//lib/prawn/grid.rb#130
  def total_height; end

  # Width of a box
  #
  # source://prawn//lib/prawn/grid.rb#135
  def width; end

  private

  # source://prawn//lib/prawn/grid.rb#209
  def grid; end
end

# This module exposes a few low-level PDF features for those who want
# to extend Prawn's core functionality.  If you are not comfortable with
# low level PDF functionality as defined by Adobe's specification, chances
# are you won't need anything you find here.
#
# @private
#
# source://prawn//lib/prawn/document/internals.rb#19
module Prawn::Document::Internals
  extend ::Forwardable

  # source://forwardable/1.3.3/forwardable.rb#231
  def add_content(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def compression_enabled?(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def deref(*args, **_arg1, &block); end

  # source://prawn-templates/0.1.2/lib/prawn/document/internals.rb#13
  def fresh_content_streams(options = T.unsafe(nil)); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def graphic_state(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def names(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def on_page_create(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def open_graphics_state(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def ref(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def ref!(*args, **_arg1, &block); end

  # source://prawn//lib/prawn/document/internals.rb#62
  def renderer; end

  # source://prawn//lib/prawn/document/internals.rb#36
  def restore_graphics_state; end

  # source://prawn//lib/prawn/document/internals.rb#31
  def save_graphics_state(state = T.unsafe(nil), &block); end
end

# A MultiBox is specified by 2 Boxes and spans the areas between.
#
# source://prawn//lib/prawn/grid.rb#217
class Prawn::Document::MultiBox
  # @return [MultiBox] a new instance of MultiBox
  #
  # source://prawn//lib/prawn/grid.rb#218
  def initialize(pdf, box1, box2); end

  # source://prawn//lib/prawn/grid.rb#257
  def bottom; end

  # source://prawn//lib/prawn/grid.rb#269
  def bottom_left; end

  # source://prawn//lib/prawn/grid.rb#273
  def bottom_right; end

  # source://prawn//lib/prawn/grid.rb#277
  def bounding_box(&blk); end

  # source://prawn//lib/prawn/grid.rb#241
  def gutter; end

  # source://prawn//lib/prawn/grid.rb#237
  def height; end

  # source://prawn//lib/prawn/grid.rb#245
  def left; end

  # source://prawn//lib/prawn/grid.rb#225
  def name; end

  # Returns the value of attribute pdf.
  #
  # source://prawn//lib/prawn/grid.rb#223
  def pdf; end

  # source://prawn//lib/prawn/grid.rb#249
  def right; end

  # source://prawn//lib/prawn/grid.rb#281
  def show(grid_color = T.unsafe(nil)); end

  # source://prawn//lib/prawn/grid.rb#253
  def top; end

  # source://prawn//lib/prawn/grid.rb#261
  def top_left; end

  # source://prawn//lib/prawn/grid.rb#265
  def top_right; end

  # source://prawn//lib/prawn/grid.rb#229
  def total_height; end

  # source://prawn//lib/prawn/grid.rb#233
  def width; end

  private

  # source://prawn//lib/prawn/grid.rb#307
  def bottom_box; end

  # source://prawn//lib/prawn/grid.rb#295
  def left_box; end

  # source://prawn//lib/prawn/grid.rb#299
  def right_box; end

  # source://prawn//lib/prawn/grid.rb#303
  def top_box; end
end

# Implements PDF encryption (password protection and permissions) as
# specified in the PDF Reference, version 1.3, section 3.5 "Encryption".
#
# source://prawn//lib/prawn/security.rb#17
module Prawn::Document::Security
  # Encrypts the document, to protect confidential data or control
  # modifications to the document. The encryption algorithm used is
  # detailed in the PDF Reference 1.3, section 3.5 "Encryption", and it is
  # implemented by all major PDF readers.
  #
  # +options+ can contain the following:
  #
  # <tt>:user_password</tt>:: Password required to open the document. If
  #                           this is omitted or empty, no password will be
  #                           required. The document will still be
  #                           encrypted, but anyone can read it.
  #
  # <tt>:owner_password</tt>:: Password required to make modifications to
  #                            the document or change or override its
  #                            permissions. If this is set to
  #                            <tt>:random</tt>, a random password will be
  #                            used; this can be useful if you never want
  #                            users to be able to override the document
  #                            permissions.
  #
  # <tt>:permissions</tt>:: A hash mapping permission symbols (see below) to
  #                         <tt>true</tt> or <tt>false</tt>. True means
  #                         "permitted", and false means "not permitted".
  #                         All permissions default to <tt>true</tt>.
  #
  # The following permissions can be specified:
  #
  # <tt>:print_document</tt>:: Print document.
  #
  # <tt>:modify_contents</tt>:: Modify contents of document (other than text
  #                             annotations and interactive form fields).
  #
  # <tt>:copy_contents</tt>:: Copy text and graphics from document.
  #
  # <tt>:modify_annotations</tt>:: Add or modify text annotations and
  #                                interactive form fields.
  #
  # == Examples
  #
  # Deny printing to everyone, but allow anyone to open without a password:
  #
  #   encrypt_document :permissions => { :print_document => false },
  #                    :owner_password => :random
  #
  # Set a user and owner password on the document, with full permissions for
  # both the user and the owner:
  #
  #   encrypt_document :user_password => 'foo', :owner_password => 'bar'
  #
  # Set no passwords, grant all permissions (This is useful because the
  # default in some readers, if no permissions are specified, is "deny"):
  #
  #   encrypt_document
  #
  # == Caveats
  #
  # * The encryption used is weak; the key is password-derived and is
  #   limited to 40 bits, due to US export controls in effect at the time
  #   the PDF standard was written.
  #
  # * There is nothing technologically requiring PDF readers to respect the
  #   permissions embedded in a document. Many PDF readers do not.
  #
  # * In short, you have <b>no security at all</b> against a moderately
  #   motivated person. Don't use this for anything super-serious. This is
  #   not a limitation of Prawn, but is rather a built-in limitation of the
  #   PDF format.
  #
  # source://prawn//lib/prawn/security.rb#88
  def encrypt_document(options = T.unsafe(nil)); end

  private

  # Provides the values for the trailer encryption dictionary.
  #
  # source://prawn//lib/prawn/security.rb#124
  def encryption_dictionary; end

  # The O (owner) value in the encryption dictionary. Algorithm 3.3.
  #
  # source://prawn//lib/prawn/security.rb#195
  def owner_password_hash; end

  # Pads or truncates a password to 32 bytes as per Alg 3.2.
  #
  # source://prawn//lib/prawn/security.rb#178
  def pad_password(password); end

  # source://prawn//lib/prawn/security.rb#147
  def permissions=(perms = T.unsafe(nil)); end

  # source://prawn//lib/prawn/security.rb#169
  def permissions_value; end

  # source://prawn//lib/prawn/security.rb#183
  def user_encryption_key; end

  # The U (user) value in the encryption dictionary. Algorithm 3.4.
  #
  # source://prawn//lib/prawn/security.rb#204
  def user_password_hash; end

  class << self
    # Encrypts the given string under the given key, also requiring the
    # object ID and generation number of the reference.
    # See Algorithm 3.1.
    #
    # source://prawn//lib/prawn/security.rb#110
    def encrypt_string(str, key, id, gen); end
  end
end

# source://prawn//lib/prawn/security.rb#144
Prawn::Document::Security::FULL_PERMISSIONS = T.let(T.unsafe(nil), Integer)

# source://prawn//lib/prawn/security.rb#173
Prawn::Document::Security::PASSWORD_PADDING = T.let(T.unsafe(nil), String)

# Flags in the permissions word, numbered as LSB = 1
#
# source://prawn//lib/prawn/security.rb#136
Prawn::Document::Security::PERMISSIONS_BITS = T.let(T.unsafe(nil), Hash)

# @private
#
# source://prawn//lib/prawn/encoding.rb#9
module Prawn::Encoding; end

# Map between unicode and WinAnsiEnoding
#
# source://prawn//lib/prawn/encoding.rb#12
class Prawn::Encoding::WinAnsi; end

# source://prawn//lib/prawn/encoding.rb#13
Prawn::Encoding::WinAnsi::CHARACTERS = T.let(T.unsafe(nil), Array)

# source://prawn//lib/prawn/errors.rb#10
module Prawn::Errors; end

# This error is raised when a block is required, but not provided
#
# source://prawn//lib/prawn/errors.rb#71
class Prawn::Errors::BlockRequired < ::StandardError; end

# Raised when Prawn is asked to draw something into a too-small box
#
# source://prawn//lib/prawn/errors.rb#26
class Prawn::Errors::CannotFit < ::StandardError; end

# Raised if group() is called with a block that is too big to be
# rendered in the current context.
#
# source://prawn//lib/prawn/errors.rb#31
class Prawn::Errors::CannotGroup < ::StandardError; end

# This error is raised when Prawn is being used on a M17N aware VM,
# and the user attempts to add text that isn't compatible with UTF-8
# to their document
#
# source://prawn//lib/prawn/errors.rb#37
class Prawn::Errors::IncompatibleStringEncoding < ::StandardError; end

# This error is rased when a graphics method is called with improper
# arguments
#
# source://prawn//lib/prawn/errors.rb#75
class Prawn::Errors::InvalidGraphicsPath < ::StandardError; end

# This error is raised when an incompatible join style is specified
#
# source://prawn//lib/prawn/errors.rb#82
class Prawn::Errors::InvalidJoinStyle < ::StandardError; end

# This error is raised when a name is not a valid format
#
# source://prawn//lib/prawn/errors.rb#57
class Prawn::Errors::InvalidName < ::StandardError; end

# Raised when a table is spanned in an impossible way.
#
# source://prawn//lib/prawn/errors.rb#13
class Prawn::Errors::InvalidTableSpan < ::StandardError; end

# This error is raised when a named element has alredy been
# created. For example, in the stamp module, stamps must have
# unique names within a document
#
# source://prawn//lib/prawn/errors.rb#54
class Prawn::Errors::NameTaken < ::StandardError; end

# This error is raised when a method requiring a current page is called
# without being on a page.
#
# source://prawn//lib/prawn/errors.rb#18
class Prawn::Errors::NotOnPage < ::StandardError; end

# This error is raised when a required option has not been set
#
# source://prawn//lib/prawn/errors.rb#64
class Prawn::Errors::RequiredOption < ::StandardError; end

# This error is raised when an object is attempted to be
# referenced by name, but no such name is associated with an object
#
# source://prawn//lib/prawn/errors.rb#61
class Prawn::Errors::UndefinedObjectName < ::StandardError; end

# This error is raised when Prawn cannot find a specified font
#
# source://prawn//lib/prawn/errors.rb#22
class Prawn::Errors::UnknownFont < ::StandardError; end

# This error is raised when Prawn encounters an unknown key in functions
# that accept an options hash.  This usually means there is a typo in your
# code or that the option you are trying to use has a different name than
# what you have specified.
#
# source://prawn//lib/prawn/errors.rb#44
class Prawn::Errors::UnknownOption < ::StandardError; end

# This error is raised when a requested outline item with a given title does
# not exist
#
# source://prawn//lib/prawn/errors.rb#68
class Prawn::Errors::UnknownOutlineTitle < ::StandardError; end

# Raised when unrecognized content is provided for a table cell.
#
# source://prawn//lib/prawn/errors.rb#79
class Prawn::Errors::UnrecognizedTableContent < ::StandardError; end

# this error is raised when a user attempts to embed an image of an
# unsupported type. This can either a completely unsupported format, or
# a dialect of a supported format (ie. some types of PNG)
#
# source://prawn//lib/prawn/errors.rb#49
class Prawn::Errors::UnsupportedImageType < ::StandardError; end

# Provides font information and helper functions.
#
# source://prawn//lib/prawn/font.rb#281
class Prawn::Font
  # @return [Font] a new instance of Font
  #
  # source://prawn//lib/prawn/font.rb#329
  def initialize(document, name, options = T.unsafe(nil)); end

  # Registers the given subset of the current font with the current PDF
  # page. This is safe to call multiple times for a given font and subset,
  # as it will only add the font the first time it is called.
  #
  # source://prawn//lib/prawn/font.rb#395
  def add_to_current_page(subset); end

  # The size of the font ascender in PDF points
  #
  # source://prawn//lib/prawn/font.rb#343
  def ascender; end

  # The size of the font descender in PDF points
  #
  # source://prawn//lib/prawn/font.rb#349
  def descender; end

  # Compliments the #hash implementation above
  #
  # @return [Boolean]
  #
  # source://prawn//lib/prawn/font.rb#421
  def eql?(other); end

  # The current font family
  #
  # source://prawn//lib/prawn/font.rb#298
  def family; end

  # Return a hash (as in Object#hash) for the font based on the output of
  # #inspect. This is required since font objects are used as keys in hashes
  # that cache certain values (See
  # Prawn::Table::Text#styled_with_of_single_character)
  #
  # source://prawn//lib/prawn/font.rb#415
  def hash; end

  # Gets height of current font in PDF points at current font size
  #
  # source://prawn//lib/prawn/font.rb#387
  def height; end

  # Gets height of current font in PDF points at the given font size
  #
  # source://prawn//lib/prawn/font.rb#380
  def height_at(size); end

  # source://prawn//lib/prawn/font.rb#402
  def identifier_for(subset); end

  # source://prawn//lib/prawn/font.rb#406
  def inspect; end

  # The size of the recommended gap between lines of text in PDF points
  #
  # source://prawn//lib/prawn/font.rb#355
  def line_gap; end

  # The current font name
  #
  # source://prawn//lib/prawn/font.rb#295
  def name; end

  # Normalizes the encoding of the string to an encoding supported by the
  # font. The string is expected to be UTF-8 going in. It will be re-encoded
  # and the new string will be returned. For an in-place (destructive)
  # version, see normalize_encoding!.
  #
  # @raise [NotImplementedError]
  #
  # source://prawn//lib/prawn/font.rb#363
  def normalize_encoding(_string); end

  # Destructive version of normalize_encoding; normalizes the encoding of a
  # string in place.
  #
  # @deprecated
  #
  # source://prawn//lib/prawn/font.rb#372
  def normalize_encoding!(str); end

  # The options hash used to initialize the font
  #
  # source://prawn//lib/prawn/font.rb#301
  def options; end

  protected

  # source://prawn//lib/prawn/font.rb#450
  def size; end

  private

  # generate a font identifier that hasn't been used on the current page yet
  #
  # source://prawn//lib/prawn/font.rb#430
  def generate_unique_id; end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/font.rb#442
  def key_is_unique?(test_key); end

  class << self
    # source://prawn//lib/prawn/font.rb#317
    def font_format(src, options); end

    # Shortcut interface for constructing a font object.  Filenames of the form
    # *.ttf will call Fonts::TTF.new, *.dfont Fonts::DFont.new, *.ttc goes to
    # Fonts::TTC.new, and anything else will be passed through to
    # Fonts::AFM.new()
    #
    # source://prawn//lib/prawn/font.rb#307
    def load(document, src, options = T.unsafe(nil)); end
  end
end

# @deprecated
#
# source://prawn//lib/prawn/font.rb#289
#Prawn::Font::AFM = Prawn::Fonts::AFM

# source://prawn//lib/prawn/font.rb#291
Prawn::Font::DFont = Prawn::Fonts::DFont

# source://prawn//lib/prawn/font.rb#292
Prawn::Font::TTC = Prawn::Fonts::TTC

# source://prawn//lib/prawn/font.rb#290
Prawn::Font::TTF = Prawn::Fonts::TTF

# Cache used internally by Prawn::Document instances to calculate the width
# of various strings for layout purposes.
#
# @private
#
# source://prawn//lib/prawn/font_metric_cache.rb#15
class Prawn::FontMetricCache
  # @return [FontMetricCache] a new instance of FontMetricCache
  #
  # source://prawn//lib/prawn/font_metric_cache.rb#18
  def initialize(document); end

  # source://prawn//lib/prawn/font_metric_cache.rb#24
  def width_of(string, options); end
end

# source://prawn//lib/prawn/font_metric_cache.rb#16
class Prawn::FontMetricCache::CacheEntry < ::Struct
  # source://asciidoctor-pdf/2.3.19/lib/asciidoctor/pdf/ext/prawn/font_metric_cache.rb#5
  def initialize(font, options, size); end

  # Returns the value of attribute font
  #
  # @return [Object] the current value of font
  def font; end

  # Sets the attribute font
  #
  # @param value [Object] the value to set the attribute font to.
  # @return [Object] the newly set value
  def font=(_); end

  # Returns the value of attribute options
  #
  # @return [Object] the current value of options
  def options; end

  # Sets the attribute options
  #
  # @param value [Object] the value to set the attribute options to.
  # @return [Object] the newly set value
  def options=(_); end

  # Returns the value of attribute string
  #
  # @return [Object] the current value of string
  def string; end

  # Sets the attribute string
  #
  # @param value [Object] the value to set the attribute string to.
  # @return [Object] the newly set value
  def string=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://prawn//lib/prawn/fonts/afm.rb#12
module Prawn::Fonts; end

# @private
#
# source://prawn//lib/prawn/fonts/afm.rb#15
class Prawn::Fonts::AFM < ::Prawn::Font
  # @return [AFM] a new instance of AFM
  #
  # source://prawn//lib/prawn/fonts/afm.rb#54
  def initialize(document, name, options = T.unsafe(nil)); end

  # source://prawn//lib/prawn/fonts/afm.rb#47
  def attributes; end

  # The font bbox, as an array of integers
  #
  # source://prawn//lib/prawn/fonts/afm.rb#82
  def bbox; end

  # Returns the number of characters in +str+ (a WinAnsi-encoded string).
  #
  # source://prawn//lib/prawn/fonts/afm.rb#129
  def character_count(str); end

  # NOTE: String *must* be encoded as WinAnsi
  #
  # source://prawn//lib/prawn/fonts/afm.rb#87
  def compute_width_of(string, options = T.unsafe(nil)); end

  # Perform any changes to the string that need to happen
  # before it is rendered to the canvas. Returns an array of
  # subset "chunks", where each chunk is an array of two elements.
  # The first element is the font subset number, and the second
  # is either a string or an array (for kerned text).
  #
  # For Adobe fonts, there is only ever a single subset, so
  # the first element of the array is "0", and the second is
  # the string itself (or an array, if kerning is performed).
  #
  # The +text+ parameter must be in WinAnsi encoding (cp1252).
  #
  # source://prawn//lib/prawn/fonts/afm.rb#145
  def encode_text(text, options = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/fonts/afm.rb#149
  def glyph_present?(char); end

  # Returns true if the font has kerning data, false otherwise
  #
  #
  # @return [Boolean]
  #
  # source://prawn//lib/prawn/fonts/afm.rb#102
  def has_kerning_data?; end

  # built-in fonts only work with winansi encoding, so translate the
  # string. Changes the encoding in-place, so the argument itself
  # is replaced with a string in WinAnsi encoding.
  #
  # source://asciidoctor-pdf/2.3.19/lib/asciidoctor/pdf/ext/prawn/font/afm.rb#22
  def normalize_encoding(text); end

  # source://prawn//lib/prawn/fonts/afm.rb#123
  def to_utf8(text); end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/fonts/afm.rb#29
  def unicode?; end

  private

  # source://prawn//lib/prawn/fonts/afm.rb#174
  def find_font(file); end

  # converts a string into an array with spacing offsets
  # bewteen characters that need to be kerned
  #
  # String *must* be encoded as WinAnsi
  #
  # source://prawn//lib/prawn/fonts/afm.rb#261
  def kern(string); end

  # source://prawn//lib/prawn/fonts/afm.rb#183
  def parse_afm(file_name); end

  # source://prawn//lib/prawn/fonts/afm.rb#243
  def parse_generic_afm_attribute(line, hash); end

  # source://prawn//lib/prawn/fonts/afm.rb#157
  def register(_subset); end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/fonts/afm.rb#170
  def symbolic?; end

  # source://prawn//lib/prawn/fonts/afm.rb#285
  def unscaled_width_of(string); end

  class << self
    # parse each ATM font file once only
    #
    # source://prawn//lib/prawn/fonts/afm.rb#50
    def font_data; end

    # Returns the value of attribute hide_m17n_warning.
    #
    # source://prawn//lib/prawn/fonts/afm.rb#17
    def hide_m17n_warning; end

    # Sets the attribute hide_m17n_warning
    #
    # @param value the value to set the attribute hide_m17n_warning to.
    #
    # source://prawn//lib/prawn/fonts/afm.rb#17
    def hide_m17n_warning=(_arg0); end

    # source://prawn//lib/prawn/fonts/afm.rb#33
    def metrics_path; end
  end
end

# source://prawn//lib/prawn/fonts/afm.rb#22
Prawn::Fonts::AFM::BUILT_INS = T.let(T.unsafe(nil), Array)

# @private
#
# source://prawn//lib/prawn/fonts/dfont.rb#8
class Prawn::Fonts::DFont < ::Prawn::Fonts::TTF
  private

  # source://prawn//lib/prawn/fonts/dfont.rb#31
  def read_ttf_file; end

  class << self
    # Returns the number of fonts contained in the dfont file.
    #
    # source://prawn//lib/prawn/fonts/dfont.rb#23
    def font_count(file); end

    # Returns a list of the names of all named fonts in the given dfont file.
    # Note that fonts are not required to be named in a dfont file, so the
    # list may be empty even if the file does contain fonts. Also, note that
    # the list is returned in no particular order, so the first font in the
    # list is not necessarily the font at index 0 in the file.
    #
    # source://prawn//lib/prawn/fonts/dfont.rb#15
    def named_fonts(file); end
  end
end

# @private
#
# source://prawn//lib/prawn/fonts/otf.rb#8
class Prawn::Fonts::OTF < ::Prawn::Fonts::TTF; end

# @private
#
# source://prawn//lib/prawn/fonts/ttc.rb#8
class Prawn::Fonts::TTC < ::Prawn::Fonts::TTF
  private

  # source://prawn//lib/prawn/fonts/ttc.rb#27
  def font_option_to_index(file, option); end

  # source://prawn//lib/prawn/fonts/ttc.rb#20
  def read_ttf_file; end

  class << self
    # Returns a list of the names of all named fonts in the given ttc file.
    # They are returned in order of their appearance in the file.
    #
    # source://prawn//lib/prawn/fonts/ttc.rb#12
    def font_names(file); end
  end
end

# @private
#
# source://prawn//lib/prawn/fonts/ttf.rb#16
class Prawn::Fonts::TTF < ::Prawn::Font
  # @return [TTF] a new instance of TTF
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#46
  def initialize(document, name, options = T.unsafe(nil)); end

  # source://prawn//lib/prawn/fonts/ttf.rb#136
  def basename; end

  # The font bbox, as an array of integers
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#83
  def bbox; end

  # source://prawn//lib/prawn/fonts/ttf.rb#161
  def cap_height; end

  # Returns the number of characters in +str+ (a UTF-8-encoded string).
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#221
  def character_count(str); end

  # NOTE: +string+ must be UTF8-encoded.
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#64
  def compute_width_of(string, options = T.unsafe(nil)); end

  # Perform any changes to the string that need to happen
  # before it is rendered to the canvas. Returns an array of
  # subset "chunks", where the even-numbered indices are the
  # font subset number, and the following entry element is
  # either a string or an array (for kerned text).
  #
  # The +text+ parameter must be UTF8-encoded.
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#103
  def encode_text(text, options = T.unsafe(nil)); end

  # source://prawn//lib/prawn/fonts/ttf.rb#175
  def family_class; end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#214
  def glyph_present?(char); end

  # Returns true if the font has kerning data, false otherwise
  #
  #
  # @return [Boolean]
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#90
  def has_kerning_data?; end

  # source://prawn//lib/prawn/fonts/ttf.rb#145
  def italic_angle; end

  # source://prawn//lib/prawn/fonts/ttf.rb#200
  def normalize_encoding(text); end

  # source://prawn//lib/prawn/fonts/ttf.rb#187
  def pdf_flags; end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#183
  def script?; end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#179
  def serif?; end

  # not sure how to compute this for true-type fonts...
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#141
  def stem_v; end

  # Returns the value of attribute subsets.
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#40
  def subsets; end

  # source://prawn//lib/prawn/fonts/ttf.rb#210
  def to_utf8(text); end

  # Returns the value of attribute ttf.
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#40
  def ttf; end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#42
  def unicode?; end

  # source://prawn//lib/prawn/fonts/ttf.rb#169
  def x_height; end

  private

  # source://prawn//lib/prawn/fonts/ttf.rb#266
  def character_width_by_code(code); end

  # source://prawn//lib/prawn/fonts/ttf.rb#227
  def cmap; end

  # @raise [NoPostscriptName]
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#291
  def embed(reference, subset); end

  # source://prawn//lib/prawn/fonts/ttf.rb#262
  def hmtx; end

  # +string+ must be UTF8-encoded.
  #
  # Returns an array. If an element is a numeric, it represents the
  # kern amount to inject at that position. Otherwise, the element
  # is an array of UTF-16 characters.
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#236
  def kern(string); end

  # source://prawn//lib/prawn/fonts/ttf.rb#253
  def kern_pairs_table; end

  # source://prawn//lib/prawn/fonts/ttf.rb#398
  def read_ttf_file; end

  # source://prawn//lib/prawn/fonts/ttf.rb#280
  def register(subset); end

  # source://prawn//lib/prawn/fonts/ttf.rb#276
  def scale_factor; end
end

# source://prawn//lib/prawn/fonts/ttf.rb#17
class Prawn::Fonts::TTF::Error < ::StandardError
  # @return [Error] a new instance of Error
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#21
  def initialize(message = T.unsafe(nil), font: T.unsafe(nil)); end
end

# source://prawn//lib/prawn/fonts/ttf.rb#18
Prawn::Fonts::TTF::Error::DEFAULT_MESSAGE = T.let(T.unsafe(nil), String)

# source://prawn//lib/prawn/fonts/ttf.rb#19
Prawn::Fonts::TTF::Error::MESSAGE_WITH_FONT = T.let(T.unsafe(nil), String)

# source://prawn//lib/prawn/fonts/ttf.rb#35
class Prawn::Fonts::TTF::NoPostscriptName < ::Prawn::Fonts::TTF::Error; end

# source://prawn//lib/prawn/fonts/ttf.rb#36
Prawn::Fonts::TTF::NoPostscriptName::DEFAULT_MESSAGE = T.let(T.unsafe(nil), String)

# source://prawn//lib/prawn/fonts/ttf.rb#37
Prawn::Fonts::TTF::NoPostscriptName::MESSAGE_WITH_FONT = T.let(T.unsafe(nil), String)

# source://prawn//lib/prawn/fonts/ttf.rb#30
class Prawn::Fonts::TTF::NoUnicodeCMap < ::Prawn::Fonts::TTF::Error; end

# source://prawn//lib/prawn/fonts/ttf.rb#31
Prawn::Fonts::TTF::NoUnicodeCMap::DEFAULT_MESSAGE = T.let(T.unsafe(nil), String)

# source://prawn//lib/prawn/fonts/ttf.rb#32
Prawn::Fonts::TTF::NoUnicodeCMap::MESSAGE_WITH_FONT = T.let(T.unsafe(nil), String)

# source://prawn//lib/prawn/fonts/ttf.rb#377
Prawn::Fonts::TTF::UNICODE_CMAP_TEMPLATE = T.let(T.unsafe(nil), String)

# Implements the drawing facilities for Prawn::Document.
# Use this to draw the most beautiful imaginable things.
#
# This file lifts and modifies several of PDF::Writer's graphics functions
# ruby-pdf.rubyforge.org
#
# source://prawn//lib/prawn/graphics/blend_mode.rb#11
module Prawn::Graphics
  include ::Prawn::Graphics::BlendMode
  include ::Prawn::Graphics::Color
  include ::Prawn::Graphics::Dash
  include ::Prawn::Graphics::CapStyle
  include ::Prawn::Graphics::JoinStyle
  include ::Prawn::Graphics::Transparency
  include ::Prawn::Graphics::Transformation
  include ::Prawn::Graphics::Patterns

  # Draws a circle of radius <tt>radius</tt> with the centre-point at
  # <tt>point</tt> as a complete subpath. The drawing point will be moved to
  # the centre-point upon completion of the drawing the circle.
  #
  #    pdf.circle [100,100], 25
  #
  # source://prawn//lib/prawn/graphics.rb#195
  def circle(center, radius); end

  # Closes and strokes the current path. If a block is provided, yields to
  # the block before closing the path. See Graphics::Color for color details.
  #
  # source://prawn//lib/prawn/graphics.rb#298
  def close_and_stroke; end

  # Closes the current path.
  #
  # source://prawn//lib/prawn/graphics.rb#417
  def close_path; end

  # Draws a Bezier curve between two points, bounded by two additional
  # points
  #
  #    pdf.curve [50,100], [100,100], :bounds => [[90,90],[75,75]]
  #
  # source://prawn//lib/prawn/graphics.rb#179
  def curve(origin, dest, options = T.unsafe(nil)); end

  # Draws a Bezier curve from the current drawing position to the
  # specified point, bounded by two additional points.
  #
  #   pdf.curve_to [100,100], :bounds => [[90,90],[75,75]]
  #
  # source://prawn//lib/prawn/graphics.rb#68
  def curve_to(dest, options = T.unsafe(nil)); end

  # Draws an ellipse of +x+ radius <tt>radius1</tt> and +y+ radius
  # <tt>radius2</tt> with the centre-point at <tt>point</tt> as a complete
  # subpath. The drawing point will be moved to the centre-point upon
  # completion of the drawing the ellipse.
  #
  #    # draws an ellipse with x-radius 25 and y-radius 50
  #    pdf.ellipse [100,100], 25, 50
  #
  # source://prawn//lib/prawn/graphics.rb#207
  def ellipse(point, radius1, radius2 = T.unsafe(nil)); end

  # Closes and fills the current path. See Graphics::Color for color details.
  #
  # If the option :fill_rule => :even_odd is specified, Prawn will use the
  # even-odd rule to fill the path. Otherwise, the nonzero winding number rule
  # will be used. See the PDF reference, "Graphics -> Path Construction and
  # Painting -> Clipping Path Operators" for details on the difference.
  #
  # source://prawn//lib/prawn/graphics.rb#396
  def fill(options = T.unsafe(nil)); end

  # Closes, fills, and strokes the current path. If a block is provided,
  # yields to the block before closing the path. See Graphics::Color for
  # color details.
  #
  # If the option :fill_rule => :even_odd is specified, Prawn will use the
  # even-odd rule to fill the path. Otherwise, the nonzero winding number rule
  # will be used. See the PDF reference, "Graphics -> Path Construction and
  # Painting -> Clipping Path Operators" for details on the difference.
  #
  # source://prawn//lib/prawn/graphics.rb#410
  def fill_and_stroke(options = T.unsafe(nil)); end

  # source://prawn//lib/prawn/graphics.rb#636
  def fill_and_stroke_circle(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def fill_and_stroke_circle_at(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def fill_and_stroke_curve(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def fill_and_stroke_curve_to(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def fill_and_stroke_ellipse(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def fill_and_stroke_ellipse_at(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def fill_and_stroke_horizontal_line(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def fill_and_stroke_horizontal_rule(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def fill_and_stroke_line(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def fill_and_stroke_line_to(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def fill_and_stroke_polygon(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def fill_and_stroke_rectangle(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def fill_and_stroke_rounded_polygon(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def fill_and_stroke_rounded_rectangle(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def fill_and_stroke_rounded_vertex(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def fill_and_stroke_vertical_line(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def fill_circle(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def fill_circle_at(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def fill_curve(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def fill_curve_to(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def fill_ellipse(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def fill_ellipse_at(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def fill_horizontal_line(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def fill_horizontal_rule(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def fill_line(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def fill_line_to(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def fill_polygon(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def fill_rectangle(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def fill_rounded_polygon(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def fill_rounded_rectangle(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def fill_rounded_vertex(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def fill_vertical_line(*args); end

  # Draws a horizontal line from <tt>x1</tt> to <tt>x2</tt> at the
  # current <tt>y</tt> position, or the position specified by the :at option.
  #
  #  # draw a line from [25, 75] to [100, 75]
  #  horizontal_line 25, 100, :at => 75
  #
  # source://prawn//lib/prawn/graphics.rb#152
  def horizontal_line(x1, x2, options = T.unsafe(nil)); end

  # Draws a horizontal line from the left border to the right border of the
  # bounding box at the current <tt>y</tt> position.
  #
  # source://prawn//lib/prawn/graphics.rb#161
  def horizontal_rule; end

  # Draws a line from one point to another. Points may be specified as
  # tuples or flattened argument list:
  #
  #   pdf.line [100,100], [200,250]
  #   pdf.line(100,100,200,250)
  #
  # source://prawn//lib/prawn/graphics.rb#140
  def line(*points); end

  # Draws a line from the current drawing position to the specified point.
  # The destination may be described as a tuple or a flattened list:
  #
  #   pdf.line_to [50,50]
  #   pdf.line_to(50,50)
  #
  # source://prawn//lib/prawn/graphics.rb#58
  def line_to(*point); end

  # When called without an argument, returns the current line thickness.
  # When called with an argument, sets the line thickness to the specified
  # value (in PDF points)
  #
  #   pdf.line_width #=> 1
  #   pdf.line_width(5)
  #   pdf.line_width #=> 5
  #
  # source://prawn//lib/prawn/graphics.rb#126
  def line_width(width = T.unsafe(nil)); end

  # Sets line thickness to the <tt>width</tt> specified.
  #
  # source://prawn//lib/prawn/graphics.rb#113
  def line_width=(width); end

  # Moves the drawing position to a given point.  The point can be
  # specified as a tuple or a flattened argument list
  #
  #   pdf.move_to [100,50]
  #   pdf.move_to(100,50)
  #
  # source://prawn//lib/prawn/graphics.rb#47
  def move_to(*point); end

  # Draws a polygon from the specified points.
  #
  #    # draws a snazzy triangle
  #    pdf.polygon [100,100], [100,200], [200,200]
  #
  # source://prawn//lib/prawn/graphics.rb#238
  def polygon(*points); end

  # Draws a rectangle given <tt>point</tt>, <tt>width</tt> and
  # <tt>height</tt>.  The rectangle is bounded by its upper-left corner.
  #
  #    pdf.rectangle [300,300], 100, 200
  #
  # source://prawn//lib/prawn/graphics.rb#87
  def rectangle(point, width, height); end

  # Draws a rounded polygon from specified points using the radius to define
  # bezier curves
  #
  #   # draws a rounded filled in polygon
  #   pdf.fill_and_stroke_rounded_polygon(
  #     10, [100, 250], [200, 300], [300, 250], [300, 150], [200, 100],
  #     [100, 150]
  #   )
  #
  # source://prawn//lib/prawn/graphics.rb#255
  def rounded_polygon(radius, *points); end

  # Draws a rounded rectangle given <tt>point</tt>, <tt>width</tt> and
  # <tt>height</tt> and <tt>radius</tt> for the rounded corner. The rectangle
  # is bounded by its upper-left corner.
  #
  #    pdf.rounded_rectangle [300,300], 100, 200, 10
  #
  # source://prawn//lib/prawn/graphics.rb#100
  def rounded_rectangle(point, width, height, radius); end

  # Creates a rounded vertex for a line segment used for building a rounded
  # polygon requires a radius to define bezier curve and three points. The
  # first two points define the line segment and the third point helps define
  # the curve for the vertex.
  #
  # source://prawn//lib/prawn/graphics.rb#270
  def rounded_vertex(radius, *points); end

  # Strokes the current path. If a block is provided, yields to the block
  # before closing the path. See Graphics::Color for color details.
  #
  # source://prawn//lib/prawn/graphics.rb#290
  def stroke; end

  # Draws and strokes X and Y axes rulers beginning at the current bounding
  # box origin (or at a custom location).
  #
  # == Options
  #
  # +:at+::
  #   Origin of the X and Y axes (default: [0, 0] = origin of the bounding
  #   box)
  #
  # +:width+::
  #   Length of the X axis (default: width of the bounding box)
  #
  # +:height+::
  #   Length of the Y axis (default: height of the bounding box)
  #
  # +:step_length+::
  #   Length of the step between markers (default: 100)
  #
  # +:negative_axes_length+::
  #   Length of the negative parts of the axes (default: 20)
  #
  # +:color+:
  #   The color of the axes and the text.
  #
  # source://prawn//lib/prawn/graphics.rb#333
  def stroke_axis(options = T.unsafe(nil)); end

  # Draws and strokes a rectangle represented by the current bounding box
  #
  # source://prawn//lib/prawn/graphics.rb#305
  def stroke_bounds; end

  # source://prawn//lib/prawn/graphics.rb#636
  def stroke_circle(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def stroke_circle_at(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def stroke_curve(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def stroke_curve_to(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def stroke_ellipse(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def stroke_ellipse_at(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def stroke_horizontal_line(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def stroke_horizontal_rule(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def stroke_line(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def stroke_line_to(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def stroke_polygon(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def stroke_rectangle(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def stroke_rounded_polygon(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def stroke_rounded_rectangle(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def stroke_rounded_vertex(*args); end

  # source://prawn//lib/prawn/graphics.rb#636
  def stroke_vertical_line(*args); end

  # Draws a vertical line at the x cooordinate given by :at from y1 to y2.
  #
  #   # draw a line from [25, 100] to [25, 300]
  #   vertical_line 100, 300, :at => 25
  #
  # source://prawn//lib/prawn/graphics.rb#170
  def vertical_line(y1, y2, params); end

  private

  # source://prawn//lib/prawn/graphics.rb#645
  def current_line_width; end

  # source://prawn//lib/prawn/graphics.rb#649
  def current_line_width=(width); end

  # source://prawn//lib/prawn/graphics.rb#666
  def degree_to_rad(angle); end

  # source://prawn//lib/prawn/graphics.rb#657
  def map_to_absolute(*point); end

  # source://prawn//lib/prawn/graphics.rb#662
  def map_to_absolute!(point); end

  # Returns the coordinates for a point on a line that is a given distance
  # away from the second point defining the line segement
  #
  # source://prawn//lib/prawn/graphics.rb#672
  def point_on_line(distance_from_end, *points); end

  # source://prawn//lib/prawn/graphics.rb#653
  def write_line_width; end
end

# The Prawn::BlendMode module is used to change the way
# two layers are blended together.
#
# Passing an array of blend modes is allowed. PDF viewers should
# blend layers based on the first recognized blend mode.
#
# Valid blend modes in v1.4 of the PDF spec include :Normal, :Multiply,
# :Screen, :Overlay, :Darken, :Lighten, :ColorDodge, :ColorBurn, :HardLight,
# :SoftLight, :Difference, :Exclusion, :Hue, :Saturation, :Color, and
# :Luminosity.
#
# Example:
#   pdf.fill_color('0000ff')
#   pdf.fill_rectangle([x, y+25], 50, 50)
#   pdf.blend_mode(:Multiply) do
#     pdf.fill_color('ff0000')
#     pdf.fill_circle([x, y], 25)
#   end
#
# source://prawn//lib/prawn/graphics/blend_mode.rb#31
module Prawn::Graphics::BlendMode
  # source://prawn//lib/prawn/graphics/blend_mode.rb#34
  def blend_mode(blend_mode = T.unsafe(nil)); end

  private

  # source://prawn//lib/prawn/graphics/blend_mode.rb#51
  def blend_mode_dictionary_name(blend_mode); end

  # source://prawn//lib/prawn/graphics/blend_mode.rb#47
  def blend_mode_dictionary_registry; end
end

# source://prawn//lib/prawn/graphics/cap_style.rb#11
module Prawn::Graphics::CapStyle
  # Sets the cap style for stroked lines and curves
  #
  # style is one of :butt, :round, or :projecting_square
  #
  # NOTE: If this method is never called, :butt will be used by default.
  #
  # source://prawn//lib/prawn/graphics/cap_style.rb#22
  def cap_style(style = T.unsafe(nil)); end

  # Sets the cap style for stroked lines and curves
  #
  # style is one of :butt, :round, or :projecting_square
  #
  # NOTE: If this method is never called, :butt will be used by default.
  #
  # source://prawn//lib/prawn/graphics/cap_style.rb#22
  def cap_style=(style = T.unsafe(nil)); end

  private

  # source://prawn//lib/prawn/graphics/cap_style.rb#34
  def current_cap_style; end

  # source://prawn//lib/prawn/graphics/cap_style.rb#38
  def current_cap_style=(style); end

  # source://prawn//lib/prawn/graphics/cap_style.rb#42
  def write_stroke_cap_style; end
end

# source://prawn//lib/prawn/graphics/cap_style.rb#14
Prawn::Graphics::CapStyle::CAP_STYLES = T.let(T.unsafe(nil), Hash)

# source://prawn//lib/prawn/graphics/color.rb#11
module Prawn::Graphics::Color
  # Sets or returns the fill color.
  #
  # When called with no argument, it returns the current fill color.
  #
  # If a single argument is provided, it should be a 6 digit HTML color
  # code.
  #
  #   pdf.fill_color "f0ffc1"
  #
  # If 4 arguments are provided, the color is assumed to be a CMYK value
  # Values range from 0 - 100.
  #
  #   pdf.fill_color 0, 99, 95, 0
  #
  # source://prawn//lib/prawn/graphics/color.rb#28
  def fill_color(*color); end

  # Sets or returns the fill color.
  #
  # When called with no argument, it returns the current fill color.
  #
  # If a single argument is provided, it should be a 6 digit HTML color
  # code.
  #
  #   pdf.fill_color "f0ffc1"
  #
  # If 4 arguments are provided, the color is assumed to be a CMYK value
  # Values range from 0 - 100.
  #
  #   pdf.fill_color 0, 99, 95, 0
  #
  # source://prawn//lib/prawn/graphics/color.rb#28
  def fill_color=(*color); end

  # Sets or returns the line stroking color.
  #
  # When called with no argument, it returns the current stroking color.
  #
  # If a single argument is provided, it should be a 6 digit HTML color
  # code.
  #
  #   pdf.stroke_color "f0ffc1"
  #
  # If 4 arguments are provided, the color is assumed to be a CMYK value
  # Values range from 0 - 100.
  #
  #   pdf.stroke_color 0, 99, 95, 0
  #
  # source://prawn//lib/prawn/graphics/color.rb#51
  def stroke_color(*color); end

  # Sets or returns the line stroking color.
  #
  # When called with no argument, it returns the current stroking color.
  #
  # If a single argument is provided, it should be a 6 digit HTML color
  # code.
  #
  #   pdf.stroke_color "f0ffc1"
  #
  # If 4 arguments are provided, the color is assumed to be a CMYK value
  # Values range from 0 - 100.
  #
  #   pdf.stroke_color 0, 99, 95, 0
  #
  # source://prawn//lib/prawn/graphics/color.rb#51
  def stroke_color=(*color); end

  private

  # source://prawn//lib/prawn/graphics/color.rb#133
  def color_space(color); end

  # source://prawn//lib/prawn/graphics/color.rb#129
  def color_to_s(color); end

  # source://prawn//lib/prawn/graphics/color.rb#98
  def color_type(color); end

  # source://prawn//lib/prawn/graphics/color.rb#204
  def current_color_space(type); end

  # source://prawn//lib/prawn/graphics/color.rb#213
  def current_fill_color; end

  # source://prawn//lib/prawn/graphics/color.rb#217
  def current_fill_color=(color); end

  # source://prawn//lib/prawn/graphics/color.rb#221
  def current_stroke_color; end

  # source://prawn//lib/prawn/graphics/color.rb#225
  def current_stroke_color=(color); end

  # Converts hex string into RGB value array:
  #
  #  >> Prawn::Graphics::Color.hex2rgb("ff7808")
  #  => [255, 120, 8]
  #
  # source://prawn//lib/prawn/graphics/color.rb#78
  def hex2rgb(hex); end

  # source://prawn//lib/prawn/graphics/color.rb#118
  def normalize_color(color); end

  # source://prawn//lib/prawn/graphics/color.rb#87
  def process_color(*color); end

  # Converts RGB value array to hex string suitable for use with fill_color
  # and stroke_color
  #
  #   >> Prawn::Graphics::Color.rgb2hex([255,120,8])
  #   => "ff7808"
  #
  # source://prawn//lib/prawn/graphics/color.rb#69
  def rgb2hex(rgb); end

  # source://prawn//lib/prawn/graphics/color.rb#170
  def set_color(type, color, options = T.unsafe(nil)); end

  # source://prawn//lib/prawn/graphics/color.rb#144
  def set_color_space(type, color_space); end

  # source://prawn//lib/prawn/graphics/color.rb#208
  def set_current_color_space(color_space, type); end

  # source://prawn//lib/prawn/graphics/color.rb#191
  def set_fill_color(color = T.unsafe(nil)); end

  # source://prawn//lib/prawn/graphics/color.rb#195
  def set_stroke_color(color = T.unsafe(nil)); end

  # source://prawn//lib/prawn/graphics/color.rb#199
  def update_colors; end

  # source://prawn//lib/prawn/graphics/color.rb#229
  def write_color(color, operator); end

  class << self
    # Converts hex string into RGB value array:
    #
    #  >> Prawn::Graphics::Color.hex2rgb("ff7808")
    #  => [255, 120, 8]
    #
    # source://prawn//lib/prawn/graphics/color.rb#78
    def hex2rgb(hex); end

    # Converts RGB value array to hex string suitable for use with fill_color
    # and stroke_color
    #
    #   >> Prawn::Graphics::Color.rgb2hex([255,120,8])
    #   => "ff7808"
    #
    # source://prawn//lib/prawn/graphics/color.rb#69
    def rgb2hex(rgb); end
  end
end

# source://prawn//lib/prawn/graphics/color.rb#142
Prawn::Graphics::Color::COLOR_SPACES = T.let(T.unsafe(nil), Array)

# source://prawn//lib/prawn/graphics/dash.rb#11
module Prawn::Graphics::Dash
  # Sets the dash pattern for stroked lines and curves or return the
  # current dash pattern setting if +length+ is nil.
  #
  # There are two ways to set the dash pattern:
  #
  # * If the parameter +length+ is an Integer/Float, it specifies
  #   the length of the dash and of the gap. The length of the gap
  #   can be customized by setting the :space option.
  #
  #   Examples:
  #
  #     length = 3
  #       3 on, 3 off, 3 on, 3 off, ...
  #     length = 3, :space =2
  #       3 on, 2 off, 3 on, 2 off, ...
  #
  # * If the parameter +length+ is an array, it specifies the
  #   lengths of alternating dashes and gaps. The numbers must be
  #   non-negative and not all zero. The :space option is ignored
  #   in this case.
  #
  #   Examples:
  #
  #     length = [2, 1]
  #       2 on, 1 off, 2 on, 1 off, ...
  #     length = [3, 1, 2, 3]
  #       3 on, 1 off, 2 on, 3 off, 3 on, 1 off, ...
  #     length = [3, 0, 1]
  #       3 on, 0 off, 1 on, 3 off, 0 on, 1 off, ...
  #
  # Options may contain the keys :space and :phase
  #
  # :space:: The space between the dashes (only used when +length+
  #          is not an array)
  #
  # :phase:: The distance into the dash pattern at which to start
  #          the dash. For example, a phase of 0 starts at the
  #          beginning of the dash; whereas, if the phase is equal
  #          to the length of the dash, then stroking will begin at
  #          the beginning of the space. Default is 0.
  #
  # Integers or Floats may be used for length and the option values.
  # Dash units are in PDF points (1/72 inch).
  #
  # source://prawn//lib/prawn/graphics/dash.rb#58
  def dash(length = T.unsafe(nil), options = T.unsafe(nil)); end

  # Sets the dash pattern for stroked lines and curves or return the
  # current dash pattern setting if +length+ is nil.
  #
  # There are two ways to set the dash pattern:
  #
  # * If the parameter +length+ is an Integer/Float, it specifies
  #   the length of the dash and of the gap. The length of the gap
  #   can be customized by setting the :space option.
  #
  #   Examples:
  #
  #     length = 3
  #       3 on, 3 off, 3 on, 3 off, ...
  #     length = 3, :space =2
  #       3 on, 2 off, 3 on, 2 off, ...
  #
  # * If the parameter +length+ is an array, it specifies the
  #   lengths of alternating dashes and gaps. The numbers must be
  #   non-negative and not all zero. The :space option is ignored
  #   in this case.
  #
  #   Examples:
  #
  #     length = [2, 1]
  #       2 on, 1 off, 2 on, 1 off, ...
  #     length = [3, 1, 2, 3]
  #       3 on, 1 off, 2 on, 3 off, 3 on, 1 off, ...
  #     length = [3, 0, 1]
  #       3 on, 0 off, 1 on, 3 off, 0 on, 1 off, ...
  #
  # Options may contain the keys :space and :phase
  #
  # :space:: The space between the dashes (only used when +length+
  #          is not an array)
  #
  # :phase:: The distance into the dash pattern at which to start
  #          the dash. For example, a phase of 0 starts at the
  #          beginning of the dash; whereas, if the phase is equal
  #          to the length of the dash, then stroking will begin at
  #          the beginning of the space. Default is 0.
  #
  # Integers or Floats may be used for length and the option values.
  # Dash units are in PDF points (1/72 inch).
  #
  # source://prawn//lib/prawn/graphics/dash.rb#58
  def dash=(length = T.unsafe(nil), options = T.unsafe(nil)); end

  # Returns when stroke is dashed, false otherwise
  #
  # @return [Boolean]
  #
  # source://prawn//lib/prawn/graphics/dash.rb#93
  def dashed?; end

  # Stops dashing, restoring solid stroked lines and curves
  #
  # source://prawn//lib/prawn/graphics/dash.rb#86
  def undash; end

  private

  # source://prawn//lib/prawn/graphics/dash.rb#111
  def current_dash_state; end

  # source://prawn//lib/prawn/graphics/dash.rb#107
  def current_dash_state=(dash_options); end

  # source://prawn//lib/prawn/graphics/dash.rb#115
  def dash_setting; end

  # source://prawn//lib/prawn/graphics/dash.rb#103
  def undashed_setting; end

  # source://prawn//lib/prawn/graphics/dash.rb#99
  def write_stroke_dash; end
end

# source://prawn//lib/prawn/graphics/join_style.rb#11
module Prawn::Graphics::JoinStyle
  # Sets the join style for stroked lines and curves
  #
  # style is one of :miter, :round, or :bevel
  #
  # NOTE: if this method is never called, :miter will be used for join style
  # throughout the document
  #
  # source://prawn//lib/prawn/graphics/join_style.rb#23
  def join_style(style = T.unsafe(nil)); end

  # Sets the join style for stroked lines and curves
  #
  # style is one of :miter, :round, or :bevel
  #
  # NOTE: if this method is never called, :miter will be used for join style
  # throughout the document
  #
  # source://prawn//lib/prawn/graphics/join_style.rb#23
  def join_style=(style = T.unsafe(nil)); end

  private

  # source://prawn//lib/prawn/graphics/join_style.rb#41
  def current_join_style; end

  # source://prawn//lib/prawn/graphics/join_style.rb#45
  def current_join_style=(style); end

  # source://prawn//lib/prawn/graphics/join_style.rb#49
  def write_stroke_join_style; end
end

# source://prawn//lib/prawn/graphics/join_style.rb#12
Prawn::Graphics::JoinStyle::JOIN_STYLES = T.let(T.unsafe(nil), Hash)

# This constant is used to approximate a symmetrical arc using a cubic
# Bezier curve.
#
# source://prawn//lib/prawn/graphics.rb#187
Prawn::Graphics::KAPPA = T.let(T.unsafe(nil), Float)

# source://prawn//lib/prawn/graphics/patterns.rb#14
module Prawn::Graphics::Patterns
  # Sets the fill gradient.
  # old arguments:
  #   from, to, color1, color2
  #   or
  #   from, r1, to, r2, color1, color2
  # new arguments:
  #    from: [x, y]
  #    to: [x, y]
  #    r1: radius
  #    r2: radius
  #    stops: [color, color, ...] or
  #           { position => color, position => color, ... }
  #    apply_transformations: true
  #
  # Examples:
  #
  #     # draws a horizontal axial gradient that starts at red on the left
  #     # and ends at blue on the right
  #     fill_gradient from: [0, 0], to: [100, 0], stops: ['red', 'blue']
  #
  #     # draws a horizontal radial gradient that starts at red, is green
  #     # 80% of the way through, and finishes blue
  #     fill_gradient from: [0, 0], r1: 0, to: [100, 0], r2: 180,
  #       stops: { 0 => 'red', 0.8 => 'green', 1 => 'blue' }
  #
  # <tt>from</tt> and <tt>to</tt> specify the axis of where the gradient
  # should be painted.
  #
  # <tt>r1</tt> and <tt>r2</tt>, if specified, make a radial gradient with
  # the starting circle of radius <tt>r1</tt> centered at <tt>from</tt>
  # and ending at a circle of radius <tt>r2</tt> centered at <tt>to</tt>.
  # If <tt>r1</tt> is not specified, a axial gradient will be drawn.
  #
  # <tt>stops</tt> is an array or hash of stops.  Each stop is either just a
  # string indicating the color, in which case the stops will be evenly
  # distributed across the gradient, or a hash where the key is
  # a position between 0 and 1 indicating what distance through the
  # gradient the color should change, and the value is a color string.
  #
  # Option <tt>apply_transformations</tt>, if set true, will transform the
  # gradient's co-ordinate space so it matches the current co-ordinate
  # space of the document.  This option will be the default from Prawn v3,
  # and is default true if you use the new arguments format.
  # The default for the old arguments format, false, will mean if you
  # (for example) scale your document by 2 and put a gradient inside, you
  # will have to manually multiply your co-ordinates by 2 so the gradient
  # is correctly positioned.
  #
  # source://prawn//lib/prawn/graphics/patterns.rb#69
  def fill_gradient(*args, **kwargs); end

  # Sets the stroke gradient.
  # See fill_gradient for a description of the arguments to this method.
  #
  # source://prawn//lib/prawn/graphics/patterns.rb#75
  def stroke_gradient(*args, **kwargs); end

  private

  # source://prawn//lib/prawn/graphics/patterns.rb#191
  def create_gradient_pattern(gradient); end

  # source://prawn//lib/prawn/graphics/patterns.rb#253
  def gradient_coordinates(gradient); end

  # source://prawn//lib/prawn/graphics/patterns.rb#187
  def gradient_registry; end

  # source://prawn//lib/prawn/graphics/patterns.rb#173
  def gradient_registry_key(gradient); end

  # source://prawn//lib/prawn/graphics/patterns.rb#113
  def parse_gradient_arguments(*arguments, from: T.unsafe(nil), to: T.unsafe(nil), r1: T.unsafe(nil), r2: T.unsafe(nil), stops: T.unsafe(nil), apply_transformations: T.unsafe(nil)); end

  # source://prawn//lib/prawn/graphics/patterns.rb#81
  def set_gradient(type, *grad, **kwargs); end
end

# source://prawn//lib/prawn/graphics/patterns.rb#16
class Prawn::Graphics::Patterns::Gradient < ::Struct
  # Returns the value of attribute apply_transformations
  #
  # @return [Object] the current value of apply_transformations
  def apply_transformations; end

  # Sets the attribute apply_transformations
  #
  # @param value [Object] the value to set the attribute apply_transformations to.
  # @return [Object] the newly set value
  def apply_transformations=(_); end

  # Returns the value of attribute from
  #
  # @return [Object] the current value of from
  def from; end

  # Sets the attribute from
  #
  # @param value [Object] the value to set the attribute from to.
  # @return [Object] the newly set value
  def from=(_); end

  # Returns the value of attribute r1
  #
  # @return [Object] the current value of r1
  def r1; end

  # Sets the attribute r1
  #
  # @param value [Object] the value to set the attribute r1 to.
  # @return [Object] the newly set value
  def r1=(_); end

  # Returns the value of attribute r2
  #
  # @return [Object] the current value of r2
  def r2; end

  # Sets the attribute r2
  #
  # @param value [Object] the value to set the attribute r2 to.
  # @return [Object] the newly set value
  def r2=(_); end

  # Returns the value of attribute stops
  #
  # @return [Object] the current value of stops
  def stops; end

  # Sets the attribute stops
  #
  # @param value [Object] the value to set the attribute stops to.
  # @return [Object] the newly set value
  def stops=(_); end

  # Returns the value of attribute to
  #
  # @return [Object] the current value of to
  def to; end

  # Sets the attribute to
  #
  # @param value [Object] the value to set the attribute to to.
  # @return [Object] the newly set value
  def to=(_); end

  # Returns the value of attribute type
  #
  # @return [Object] the current value of type
  def type; end

  # Sets the attribute type
  #
  # @param value [Object] the value to set the attribute type to.
  # @return [Object] the newly set value
  def type=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://prawn//lib/prawn/graphics/patterns.rb#15
class Prawn::Graphics::Patterns::GradientStop < ::Struct
  # Returns the value of attribute color
  #
  # @return [Object] the current value of color
  def color; end

  # Sets the attribute color
  #
  # @param value [Object] the value to set the attribute color to.
  # @return [Object] the newly set value
  def color=(_); end

  # Returns the value of attribute position
  #
  # @return [Object] the current value of position
  def position; end

  # Sets the attribute position
  #
  # @param value [Object] the value to set the attribute position to.
  # @return [Object] the newly set value
  def position=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://prawn//lib/prawn/graphics/transformation.rb#12
module Prawn::Graphics::Transformation
  # Rotate the user space.  If a block is not provided, then you must save
  # and restore the graphics state yourself.
  #
  # == Options
  # <tt>:origin</tt>:: <tt>[number, number]</tt>. The point around which to
  #                    rotate. A block must be provided if using the :origin
  #
  # raises <tt>Prawn::Errors::BlockRequired</tt> if an :origin option is
  # provided, but no block is given
  #
  # Example without a block:
  #
  #   save_graphics_state
  #   rotate 30
  #   text "rotated text"
  #   restore_graphics_state
  #
  # Example with a block: rotating a rectangle around its upper-left corner
  #
  #   x = 300
  #   y = 300
  #   width = 150
  #   height = 200
  #   angle = 30
  #   pdf.rotate(angle, :origin => [x, y]) do
  #     pdf.stroke_rectangle([x, y], width, height)
  #   end
  #
  # source://prawn//lib/prawn/graphics/transformation.rb#43
  def rotate(angle, options = T.unsafe(nil), &block); end

  # Scale the user space.  If a block is not provided, then you must save
  # and restore the graphics state yourself.
  #
  # == Options
  # <tt>:origin</tt>:: <tt>[number, number]</tt>. The point from which to
  #                    scale. A block must be provided if using the :origin
  #
  # raises <tt>Prawn::Errors::BlockRequired</tt> if an :origin option is
  # provided, but no block is given
  #
  # Example without a block:
  #
  #   save_graphics_state
  #   scale 1.5
  #   text "scaled text"
  #   restore_graphics_state
  #
  # Example with a block: scale a rectangle from its upper-left corner
  #
  #   x = 300
  #   y = 300
  #   width = 150
  #   height = 200
  #   factor = 1.5
  #   pdf.scale(angle, :origin => [x, y]) do
  #     pdf.stroke_rectangle([x, y], width, height)
  #   end
  #
  # source://prawn//lib/prawn/graphics/transformation.rb#116
  def scale(factor, options = T.unsafe(nil), &block); end

  # Transform the user space (see notes for rotate regarding graphics state)
  # Generally, one would use the rotate, scale, translate, and skew
  # convenience methods instead of calling transformation_matrix directly
  #
  # source://prawn//lib/prawn/graphics/transformation.rb#147
  def transformation_matrix(*matrix); end

  # Translate the user space.  If a block is not provided, then you must
  # save and restore the graphics state yourself.
  #
  # Example without a block: move the text up and over 10
  #
  #   save_graphics_state
  #   translate(10, 10)
  #   text "scaled text"
  #   restore_graphics_state
  #
  # Example with a block: draw a rectangle with its upper-left corner at
  #                       x + 10, y + 10
  #
  #   x = 300
  #   y = 300
  #   width = 150
  #   height = 200
  #   pdf.translate(10, 10) do
  #     pdf.stroke_rectangle([x, y], width, height)
  #   end
  #
  # source://prawn//lib/prawn/graphics/transformation.rb#84
  def translate(x, y, &block); end
end

# The Prawn::Transparency module is used to place transparent
# content on the page. It has the capacity for separate
# transparency values for stroked content and all other content.
#
# Example:
#   # both the fill and stroke will be at 50% opacity
#   pdf.transparent(0.5) do
#     pdf.text("hello world")
#     pdf.fill_and_stroke_circle([x, y], 25)
#   end
#
#   # the fill will be at 50% opacity, but the stroke will
#   # be at 75% opacity
#   pdf.transparent(0.5, 0.75) do
#     pdf.text("hello world")
#     pdf.fill_and_stroke_circle([x, y], 25)
#   end
#
# source://prawn//lib/prawn/graphics/transparency.rb#30
module Prawn::Graphics::Transparency
  # Sets the <tt>opacity</tt> and <tt>stroke_opacity</tt> for all
  # the content within the <tt>block</tt>
  # If <tt>stroke_opacity</tt> is not provided, then it takes on
  # the same value as <tt>opacity</tt>
  #
  # Valid ranges for both paramters are 0.0 to 1.0
  #
  # Example:
  #   # both the fill and stroke will be at 50% opacity
  #   pdf.transparent(0.5) do
  #     pdf.text("hello world")
  #     pdf.fill_and_stroke_circle([x, y], 25)
  #   end
  #
  #   # the fill will be at 50% opacity, but the stroke will
  #   # be at 75% opacity
  #   pdf.transparent(0.5, 0.75) do
  #     pdf.text("hello world")
  #     pdf.fill_and_stroke_circle([x, y], 25)
  #   end
  #
  # source://prawn//lib/prawn/graphics/transparency.rb#54
  def transparent(opacity, stroke_opacity = T.unsafe(nil)); end

  private

  # source://prawn//lib/prawn/graphics/transparency.rb#74
  def next_opacity_dictionary_id; end

  # source://prawn//lib/prawn/graphics/transparency.rb#78
  def opacity_dictionary_name(opacity, stroke_opacity); end

  # source://prawn//lib/prawn/graphics/transparency.rb#70
  def opacity_dictionary_registry; end
end

# source://prawn//lib/prawn/image_handler.rb#16
class Prawn::ImageHandler
  # @return [ImageHandler] a new instance of ImageHandler
  #
  # source://prawn//lib/prawn/image_handler.rb#17
  def initialize; end

  # @raise [Prawn::Errors::UnsupportedImageType]
  #
  # source://prawn//lib/prawn/image_handler.rb#35
  def find(image_blob); end

  # source://prawn//lib/prawn/image_handler.rb#21
  def register(handler); end

  # source://prawn//lib/prawn/image_handler.rb#26
  def register!(handler); end

  # source://prawn//lib/prawn/image_handler.rb#31
  def unregister(handler); end
end

# source://prawn//lib/prawn/images.rb#15
module Prawn::Images
  # Builds an info object (Prawn::Images::*) and a PDF reference representing
  # the given image. Return a pair: [pdf_obj, info].
  #
  # @private
  #
  # source://prawn//lib/prawn/images.rb#84
  def build_image_object(file); end

  # Given a PDF image resource <tt>pdf_obj</tt> that has been added to the
  # page's resources and an <tt>info</tt> object (the pair returned from
  # build_image_object), embed the image according to the <tt>options</tt>
  # given.
  #
  # @private
  #
  # source://prawn//lib/prawn/images.rb#115
  def embed_image(pdf_obj, info, options); end

  # Add the image at filename to the current page. Currently only
  # JPG and PNG files are supported. (Note that processing PNG
  # images with alpha channels can be processor and memory intensive.)
  #
  # Arguments:
  # <tt>file</tt>:: path to file or an object that responds to #read and
  #   #rewind
  #
  # Options:
  # <tt>:at</tt>:: an array [x,y] with the location of the top left corner of
  #   the image.
  # <tt>:position</tt>::  One of (:left, :center, :right) or an x-offset
  # <tt>:vposition</tt>::  One of (:top, :center, :bottom) or an y-offset
  # <tt>:height</tt>:: the height of the image [actual height of the image]
  # <tt>:width</tt>:: the width of the image [actual width of the image]
  # <tt>:scale</tt>:: scale the dimensions of the image proportionally
  # <tt>:fit</tt>:: scale the dimensions of the image proportionally to fit
  #   inside [width,height]
  #
  #   Prawn::Document.generate("image2.pdf", :page_layout => :landscape) do
  #     pigs = "#{Prawn::DATADIR}/images/pigs.jpg"
  #     image pigs, :at => [50,450], :width => 450
  #
  #     dice = "#{Prawn::DATADIR}/images/dice.png"
  #     image dice, :at => [50, 450], :scale => 0.75
  #   end
  #
  # If only one of :width / :height are provided, the image will be scaled
  # proportionally.  When both are provided, the image will be stretched to
  # fit the dimensions without maintaining the aspect ratio.
  #
  #
  # If :at is provided, the image will be place in the current page but
  # the text position will not be changed.
  #
  #
  # If instead of an explicit filename, an object with a read method is
  # passed as +file+, you can embed images from IO objects and things
  # that act like them (including Tempfiles and open-uri objects).
  #
  #   require "open-uri"
  #
  #   Prawn::Document.generate("remote_images.pdf") do
  #     image open("http://prawnpdf.org/media/prawn_logo.png")
  #   end
  #
  # This method returns an image info object which can be used to check the
  # dimensions of an image object if needed.
  # (See also: Prawn::Images::PNG , Prawn::Images::JPG)
  #
  # source://prawn//lib/prawn/images.rb#68
  def image(file, options = T.unsafe(nil)); end

  private

  # source://prawn//lib/prawn/images.rb#188
  def determine_y_with_page_flow(height); end

  # source://prawn//lib/prawn/images.rb#156
  def image_position(width, height, options); end

  # source://prawn//lib/prawn/images.rb#199
  def image_registry; end

  # source://prawn//lib/prawn/images.rb#203
  def next_image_id; end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/images.rb#195
  def overruns_page?(height); end

  # @raise [ArgumentError]
  #
  # source://prawn//lib/prawn/images.rb#137
  def verify_and_read_image(io_or_path); end
end

# source://prawn//lib/prawn/images/image.rb#13
class Prawn::Images::Image
  # source://prawn//lib/prawn/images/image.rb#16
  def calc_image_dimensions(options); end
end

# A convenience class that wraps the logic for extracting the parts
# of a JPG image that we need to embed them in a PDF
#
# source://prawn//lib/prawn/images/jpg.rb#18
class Prawn::Images::JPG < ::Prawn::Images::Image
  # Process a new JPG image
  #
  # <tt>:data</tt>:: A binary string of JPEG data
  #
  # @return [JPG] a new instance of JPG
  #
  # source://prawn//lib/prawn/images/jpg.rb#39
  def initialize(data); end

  # Returns the value of attribute bits.
  #
  # source://prawn//lib/prawn/images/jpg.rb#23
  def bits; end

  # Build a PDF object representing this image in +document+, and return
  # a Reference to it.
  #
  # source://prawn//lib/prawn/images/jpg.rb#63
  def build_pdf_object(document); end

  # Returns the value of attribute channels.
  #
  # source://prawn//lib/prawn/images/jpg.rb#23
  def channels; end

  # Returns the value of attribute height.
  #
  # source://prawn//lib/prawn/images/jpg.rb#23
  def height; end

  # Returns the value of attribute scaled_height.
  #
  # source://prawn//lib/prawn/images/jpg.rb#24
  def scaled_height; end

  # Sets the attribute scaled_height
  #
  # @param value the value to set the attribute scaled_height to.
  #
  # source://prawn//lib/prawn/images/jpg.rb#24
  def scaled_height=(_arg0); end

  # Returns the value of attribute scaled_width.
  #
  # source://prawn//lib/prawn/images/jpg.rb#24
  def scaled_width; end

  # Sets the attribute scaled_width
  #
  # @param value the value to set the attribute scaled_width to.
  #
  # source://prawn//lib/prawn/images/jpg.rb#24
  def scaled_width=(_arg0); end

  # Returns the value of attribute width.
  #
  # source://prawn//lib/prawn/images/jpg.rb#23
  def width; end

  class << self
    # @return [Boolean]
    #
    # source://prawn//lib/prawn/images/jpg.rb#31
    def can_render?(image_blob); end
  end
end

# source://prawn//lib/prawn/images/jpg.rb#19
class Prawn::Images::JPG::FormatError < ::StandardError; end

# source://prawn//lib/prawn/images/jpg.rb#26
Prawn::Images::JPG::JPEG_SOF_BLOCKS = T.let(T.unsafe(nil), Array)

# A convenience class that wraps the logic for extracting the parts
# of a PNG image that we need to embed them in a PDF
#
# source://prawn//lib/prawn/images/png.rb#19
class Prawn::Images::PNG < ::Prawn::Images::Image
  # Process a new PNG image
  #
  # <tt>data</tt>:: A binary string of PNG data
  #
  # @return [PNG] a new instance of PNG
  #
  # source://prawn//lib/prawn/images/png.rb#36
  def initialize(data); end

  # Returns the value of attribute alpha_channel.
  #
  # source://prawn//lib/prawn/images/png.rb#25
  def alpha_channel; end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/images/png.rb#120
  def alpha_channel?; end

  # Returns the value of attribute bits.
  #
  # source://prawn//lib/prawn/images/png.rb#23
  def bits; end

  # Build a PDF object representing this image in +document+, and return
  # a Reference to it.
  #
  # source://prawn//lib/prawn/images/png.rb#130
  def build_pdf_object(document); end

  # Returns the value of attribute color_type.
  #
  # source://prawn//lib/prawn/images/png.rb#24
  def color_type; end

  # number of color components to each pixel
  #
  # source://prawn//lib/prawn/images/png.rb#98
  def colors; end

  # Returns the value of attribute compression_method.
  #
  # source://prawn//lib/prawn/images/png.rb#24
  def compression_method; end

  # Returns the value of attribute filter_method.
  #
  # source://prawn//lib/prawn/images/png.rb#24
  def filter_method; end

  # Returns the value of attribute height.
  #
  # source://prawn//lib/prawn/images/png.rb#23
  def height; end

  # Returns the value of attribute img_data.
  #
  # source://prawn//lib/prawn/images/png.rb#22
  def img_data; end

  # Returns the value of attribute interlace_method.
  #
  # source://prawn//lib/prawn/images/png.rb#25
  def interlace_method; end

  # Returns the minimum PDF version required to support this image.
  #
  # source://prawn//lib/prawn/images/png.rb#250
  def min_pdf_version; end

  # Returns the value of attribute palette.
  #
  # source://prawn//lib/prawn/images/png.rb#22
  def palette; end

  # Returns the value of attribute scaled_height.
  #
  # source://prawn//lib/prawn/images/png.rb#26
  def scaled_height; end

  # Sets the attribute scaled_height
  #
  # @param value the value to set the attribute scaled_height to.
  #
  # source://prawn//lib/prawn/images/png.rb#26
  def scaled_height=(_arg0); end

  # Returns the value of attribute scaled_width.
  #
  # source://prawn//lib/prawn/images/png.rb#26
  def scaled_width; end

  # Sets the attribute scaled_width
  #
  # @param value the value to set the attribute scaled_width to.
  #
  # source://prawn//lib/prawn/images/png.rb#26
  def scaled_width=(_arg0); end

  # split the alpha channel data from the raw image data in images
  # where it's required.
  #
  # source://prawn//lib/prawn/images/png.rb#110
  def split_alpha_channel!; end

  # Returns the value of attribute transparency.
  #
  # source://prawn//lib/prawn/images/png.rb#22
  def transparency; end

  # Returns the value of attribute width.
  #
  # source://prawn//lib/prawn/images/png.rb#23
  def width; end

  private

  # source://prawn//lib/prawn/images/png.rb#300
  def generate_alpha_channel; end

  # source://prawn//lib/prawn/images/png.rb#264
  def split_image_data; end

  class << self
    # @return [Boolean]
    #
    # source://prawn//lib/prawn/images/png.rb#28
    def can_render?(image_blob); end
  end
end

# source://prawn//lib/prawn/measurements.rb#12
module Prawn::Measurements
  # metric conversions
  #
  # source://prawn//lib/prawn/measurements.rb#14
  def cm2mm(cm); end

  # source://prawn//lib/prawn/measurements.rb#57
  def cm2pt(cm); end

  # source://prawn//lib/prawn/measurements.rb#18
  def dm2mm(dm); end

  # source://prawn//lib/prawn/measurements.rb#61
  def dm2pt(dm); end

  # imperial conversions
  # from http://en.wikipedia.org/wiki/Imperial_units
  #
  # source://prawn//lib/prawn/measurements.rb#28
  def ft2in(ft); end

  # source://prawn//lib/prawn/measurements.rb#45
  def ft2pt(ft); end

  # source://prawn//lib/prawn/measurements.rb#41
  def in2pt(inch); end

  # source://prawn//lib/prawn/measurements.rb#22
  def m2mm(m); end

  # source://prawn//lib/prawn/measurements.rb#65
  def m2pt(m); end

  # source://prawn//lib/prawn/measurements.rb#53
  def mm2pt(mm); end

  # source://prawn//lib/prawn/measurements.rb#69
  def pt2mm(pt); end

  # PostscriptPoint-converisons
  #
  # source://prawn//lib/prawn/measurements.rb#37
  def pt2pt(pt); end

  # source://prawn//lib/prawn/measurements.rb#32
  def yd2in(yd); end

  # source://prawn//lib/prawn/measurements.rb#49
  def yd2pt(yd); end
end

# The Outline class organizes the outline tree items for the document.
# Note that the prev and parent instance variables are adjusted while
# navigating through the nested blocks. These variables along with the
# presence or absense of blocks are the primary means by which the relations
# for the various OutlineItems and the OutlineRoot are set. Unfortunately, the
# best way to understand how this works is to follow the method calls through
# a real example.
#
# Some ideas for the organization of this class were gleaned from name_tree.
# In particular the way in which the OutlineItems are finally rendered into
# document objects in PdfObject through a hash.
#
# source://prawn//lib/prawn/outline.rb#27
class Prawn::Outline
  # @return [Outline] a new instance of Outline
  #
  # source://prawn//lib/prawn/outline.rb#31
  def initialize(document); end

  # Inserts an outline section to the outline tree (see outline#define).
  # Although you will probably choose to exclusively use outline#define so
  # that your outline tree is contained and easy to manage, this method gives
  # you the option to insert sections to the outline tree at any point during
  # document generation. This method allows you to add a child subsection to
  # any other item at any level in the outline tree.  Currently the only way
  # to locate the place of entry is with the title for the item. If your title
  # names are not unique consider using define_outline.
  # The method takes the following arguments:
  #   title: a string that must match an outline title to add
  #     the subsection to
  #   position: either :first or :last (the default) where the subsection will
  #     be placed relative to other child elements. If you need to position
  #     your subsection in between other elements then consider using
  #     #insert_section_after
  #   block: uses the same DSL syntax as outline#define, for example:
  #
  # Consider using this method inside of outline.update if you want to have
  # the outline object to be scoped as self (see #insert_section_after
  # example).
  #
  #   go_to_page 2
  #   start_new_page
  #   text "Inserted Page"
  #   outline.add_subsection_to :title => 'Page 2', :first do
  #     outline.page :destination => page_number, :title => "Inserted Page"
  #   end
  #
  # source://prawn//lib/prawn/outline.rb#108
  def add_subsection_to(title, position = T.unsafe(nil), &block); end

  # Defines/Updates an outline for the document.
  # The outline is an optional nested index that appears on the side of a PDF
  # document usually with direct links to pages. The outline DSL is defined by
  # nested blocks involving two methods: section and page; see the
  # documentation on those methods for their arguments and options. Note that
  # one can also use outline#update to add more sections to the end of the
  # outline tree using the same syntax and scope.
  #
  # The syntax is best illustrated with an example:
  #
  # Prawn::Document.generate(outlined_document.pdf) do
  #   text "Page 1. This is the first Chapter. "
  #   start_new_page
  #   text "Page 2. More in the first Chapter. "
  #   start_new_page
  #   outline.define do
  #     section 'Chapter 1', :destination => 1, :closed => true do
  #       page :destination => 1, :title => 'Page 1'
  #       page :destination => 2, :title => 'Page 2'
  #     end
  #   end
  #   start_new_page do
  #   outline.update do
  #     section 'Chapter 2', :destination =>  2, do
  #       page :destination => 3, :title => 'Page 3'
  #     end
  #   end
  # end
  #
  # source://prawn//lib/prawn/outline.rb#74
  def define(&block); end

  # @private
  #
  # source://prawn//lib/prawn/outline.rb#29
  def document; end

  # @private
  #
  # source://prawn//lib/prawn/outline.rb#29
  def document=(_arg0); end

  # Inserts an outline section to the outline tree (see outline#define).
  # Although you will probably choose to exclusively use outline#define so
  # that your outline tree is contained and easy to manage, this method gives
  # you the option to insert sections to the outline tree at any point during
  # document generation. Unlike outline.add_section, this method allows you to
  # enter a section after any other item at any level in the outline tree.
  # Currently the only way to locate the place of entry is with the title for
  # the item. If your title names are not unique consider using
  # define_outline.
  # The method takes the following arguments:
  #   title: the title of other section or page to insert new section after
  #   block: uses the same DSL syntax as outline#define, for example:
  #
  #   go_to_page 2
  #   start_new_page
  #   text "Inserted Page"
  #   update_outline do
  #     insert_section_after :title => 'Page 2' do
  #       page :destination => page_number, :title => "Inserted Page"
  #     end
  #   end
  #
  # source://prawn//lib/prawn/outline.rb#141
  def insert_section_after(title, &block); end

  # @private
  #
  # source://prawn//lib/prawn/outline.rb#29
  def items; end

  # @private
  #
  # source://prawn//lib/prawn/outline.rb#29
  def items=(_arg0); end

  # See Outline#define above for more documentation on how it is used in that
  # context
  #
  # Adds a page to the outline.
  # Although you will probably choose to exclusively use outline#define so
  # that your outline tree is contained and easy to manage, this method also
  # gives you the option to add pages to the root of outline tree at any point
  # during document generation. Note that the page will be added at the top
  # level after the other root outline elements. For more flexible placement
  # try using outline#insert_section_after and/or outline#add_subsection_to.
  #
  # Takes the following arguments:
  #   options:
  #     title - REQUIRED. The outline text that appears for the page.
  #     destination - optional integer defining the page number for
  #             a destination link to the top of the page (using a :FIT
  #             destination).
  #             or an array with a custom destination (see the dest_* methods
  #             of the PDF::Destination module)
  #     closed - whether the section should show its nested outline elements.
  #            - defaults to false.
  # example usage:
  #
  #   outline.page :title => "Very Last Page"
  #
  # Note: this method is almost identical to section except that it does not
  # accept a block thereby defining the outline item as a leaf on the outline
  # tree structure.
  #
  # source://prawn//lib/prawn/outline.rb#213
  def page(options = T.unsafe(nil)); end

  # Returns the current page number of the document
  #
  # source://prawn//lib/prawn/outline.rb#41
  def page_number; end

  # @private
  #
  # source://prawn//lib/prawn/outline.rb#29
  def parent; end

  # @private
  #
  # source://prawn//lib/prawn/outline.rb#29
  def parent=(_arg0); end

  # @private
  #
  # source://prawn//lib/prawn/outline.rb#29
  def prev; end

  # @private
  #
  # source://prawn//lib/prawn/outline.rb#29
  def prev=(_arg0); end

  # See outline#define above for documentation on how this is used in that
  # context
  #
  # Adds an outine section to the outline tree.
  # Although you will probably choose to exclusively use outline#define so
  # that your outline tree is contained and easy to manage, this method gives
  # you the option to add sections to the outline tree at any point during
  # document generation. When not being called from within another #section
  # block the section will be added at the top level after the other root
  # elements of the outline.  For more flexible placement try using
  # outline#insert_section_after and/or outline#add_subsection_to
  #
  # Takes the following arguments:
  #   title: the outline text that appears for the section.
  #   options: destination - optional integer defining the page number for
  #                 a destination link to the top of the page (using a :FIT
  #                 destination).
  #                 - or an array with a custom destination (see the #dest_*
  #                 methods of the PDF::Destination module)
  #            closed - whether the section should show its nested outline
  #                     elements.
  #                   - defaults to false.
  #            block: more nested subsections and/or page blocks
  #
  # example usage:
  #
  #   outline.section 'Added Section', :destination => 3 do
  #     outline.page :destionation => 3, :title => 'Page 3'
  #   end
  #
  # source://prawn//lib/prawn/outline.rb#181
  def section(title, options = T.unsafe(nil), &block); end

  # Defines/Updates an outline for the document.
  # The outline is an optional nested index that appears on the side of a PDF
  # document usually with direct links to pages. The outline DSL is defined by
  # nested blocks involving two methods: section and page; see the
  # documentation on those methods for their arguments and options. Note that
  # one can also use outline#update to add more sections to the end of the
  # outline tree using the same syntax and scope.
  #
  # The syntax is best illustrated with an example:
  #
  # Prawn::Document.generate(outlined_document.pdf) do
  #   text "Page 1. This is the first Chapter. "
  #   start_new_page
  #   text "Page 2. More in the first Chapter. "
  #   start_new_page
  #   outline.define do
  #     section 'Chapter 1', :destination => 1, :closed => true do
  #       page :destination => 1, :title => 'Page 1'
  #       page :destination => 2, :title => 'Page 2'
  #     end
  #   end
  #   start_new_page do
  #   outline.update do
  #     section 'Chapter 2', :destination =>  2, do
  #       page :destination => 3, :title => 'Page 3'
  #     end
  #   end
  # end
  #
  # source://prawn//lib/prawn/outline.rb#74
  def update(&block); end

  private

  # source://prawn//lib/prawn/outline.rb#233
  def add_outline_item(title, options, &block); end

  # source://prawn//lib/prawn/outline.rb#297
  def adjust_relations(nxt, last); end

  # source://prawn//lib/prawn/outline.rb#242
  def create_outline_item(title, options); end

  # source://prawn//lib/prawn/outline.rb#257
  def establish_relations(outline_item); end

  # source://prawn//lib/prawn/outline.rb#263
  def increase_count; end

  # source://prawn//lib/prawn/outline.rb#288
  def insert_section(nxt, &block); end

  # source://prawn//lib/prawn/outline.rb#281
  def reset_parent(outline_item); end

  # source://prawn//lib/prawn/outline.rb#305
  def reset_root_positioning; end

  # The Outline dictionary (12.3.3) for this document.  It is
  # lazily initialized, so that documents that do not have an outline
  # do not incur the additional overhead.
  #
  # source://prawn//lib/prawn/outline.rb#228
  def root; end

  # source://prawn//lib/prawn/outline.rb#276
  def set_variables_for_block(outline_item, block); end
end

# source://prawn//lib/prawn/repeater.rb#86
class Prawn::Repeater
  # @return [Repeater] a new instance of Repeater
  #
  # source://prawn//lib/prawn/repeater.rb#97
  def initialize(document, page_filter, dynamic = T.unsafe(nil), &block); end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/repeater.rb#109
  def match?(page_number); end

  # Returns the value of attribute name.
  #
  # source://prawn//lib/prawn/repeater.rb#95
  def name; end

  # source://prawn//lib/prawn/repeater.rb#113
  def run(page_number); end

  class << self
    # source://prawn//lib/prawn/repeater.rb#90
    def count; end

    # Sets the attribute count
    #
    # @param value the value to set the attribute count to.
    #
    # source://prawn//lib/prawn/repeater.rb#88
    def count=(_arg0); end
  end
end

# The Prawn::SoftMask module is used to create arbitrary transparency in
# document. Using a soft mask allows creating more visually rich documents.
#
# You must group soft mask and graphics it's applied to under
# save_graphics_state because soft mask is a part of graphic state in PDF.
#
# Example:
#   pdf.save_graphics_state do
#     pdf.soft_mask do
#       pdf.fill_color "444444"
#       pdf.fill_polygon [0, 40], [60, 10], [120, 40], [60, 68]
#     end
#     pdf.fill_color '000000'
#     pdf.fill_rectangle [0, 50], 120, 68
#   end
#
# source://prawn//lib/prawn/soft_mask.rb#27
module Prawn::SoftMask
  # source://prawn//lib/prawn/soft_mask.rb#30
  def soft_mask(&block); end

  private

  # source://prawn//lib/prawn/soft_mask.rb#89
  def soft_mask_registry; end
end

# The Prawn::Stamp module is used to create content that will be
# included multiple times in a document. Using a stamp has three
# advantages over creating content anew each time it is placed on
# the page:
#   i.   faster document creation
#   ii.  smaller final document
#   iii. faster display on subsequent displays of the repeated
#   element because the viewer application can cache the rendered
#   results
#
# Example:
#   pdf.create_stamp("my_stamp") {
#     pdf.fill_circle([10, 15], 5)
#     pdf.draw_text("hello world", :at => [20, 10])
#   }
#   pdf.stamp("my_stamp")
#
# source://prawn//lib/prawn/stamp.rb#27
module Prawn::Stamp
  # Creates a re-usable stamp named <tt>name</tt>
  #
  # raises <tt>Prawn::Errors::NameTaken</tt> if a stamp already
  # exists in this document with this name
  # raises <tt>Prawn::Errors::InvalidName</tt> if name.empty?
  #
  # Example:
  #   pdf.create_stamp("my_stamp") {
  #     pdf.fill_circle([10, 15], 5)
  #     pdf.draw_text("hello world", :at => [20, 10])
  #   }
  #
  # source://prawn//lib/prawn/stamp.rb#78
  def create_stamp(name, &block); end

  # Renders the stamp named <tt>name</tt> to the page
  # raises <tt>Prawn::Errors::InvalidName</tt> if name.empty?
  # raises <tt>Prawn::Errors::UndefinedObjectName</tt> if no stamp
  # has been created with this name
  #
  # Example:
  #   pdf.create_stamp("my_stamp") {
  #     pdf.fill_circle([10, 15], 5)
  #     pdf.text("hello world", :at => [20, 10])
  #   }
  #   pdf.stamp("my_stamp")
  #
  # source://prawn//lib/prawn/stamp.rb#42
  def stamp(name); end

  # Renders the stamp named <tt>name</tt> at a position offset from
  # the initial coords at which the elements of the stamp was
  # created
  #
  # Example:
  #   pdf.create_stamp("circle") do
  #     pdf.fill_circle([0, 0], 25)
  #   end
  #   # draws a circle at 100, 100
  #   pdf.stamp_at("circle", [100, 100])
  #
  # See stamp() for exceptions that might be raised
  #
  # source://prawn//lib/prawn/stamp.rb#62
  def stamp_at(name, point); end

  private

  # @raise [Prawn::Errors::InvalidName]
  #
  # source://prawn//lib/prawn/stamp.rb#107
  def create_stamp_dictionary(name); end

  # source://prawn//lib/prawn/stamp.rb#143
  def freeze_stamp_graphics; end

  # source://prawn//lib/prawn/stamp.rb#90
  def next_stamp_dictionary_id; end

  # @raise [Prawn::Errors::InvalidName]
  #
  # source://prawn//lib/prawn/stamp.rb#94
  def stamp_dictionary(name); end

  # source://prawn//lib/prawn/stamp.rb#86
  def stamp_dictionary_registry; end

  # Referencing annotations from a stamp XObject doesn't result
  # in a working link. Instead, the references must be appended
  # to the /Annot dictionary of the object that contains the
  # call to the stamp object.
  #
  # source://prawn//lib/prawn/stamp.rb#136
  def update_annotation_references(annots); end
end

# @private
#
# source://prawn//lib/prawn/utilities.rb#18
class Prawn::SynchronizedCache
  # As an optimization, this could access the hash directly on VMs with
  # a global interpreter lock (like MRI)
  #
  # @return [SynchronizedCache] a new instance of SynchronizedCache
  #
  # source://prawn//lib/prawn/utilities.rb#21
  def initialize; end

  # source://prawn//lib/prawn/utilities.rb#26
  def [](key); end

  # source://prawn//lib/prawn/utilities.rb#30
  def []=(key, value); end
end

# source://prawn//lib/prawn/text/formatted/line_wrap.rb#12
module Prawn::Text
  include ::PDF::Core::Text
  include ::Prawn::Text::Formatted

  # Draws text on the page, beginning at the point specified by the :at option
  # the string is assumed to be pre-formatted to properly fit the page.
  #
  #   pdf.draw_text "Hello World", :at => [100,100]
  #   pdf.draw_text "Goodbye World", :at => [50,50], :size => 16
  #
  # If your font contains kerning pair data that Prawn can parse, the
  # text will be kerned by default. You can disable kerning by including
  # a false <tt>:kerning</tt> option. If you want to disable kerning on an
  # entire document, set default_kerning = false for that document
  #
  # === Text Positioning Details:
  #
  # Prawn will position your text by the left-most edge of its baseline, and
  # flow along a single line.  (This means that :align will not work)
  #
  # == Rotation
  #
  # Text can be rotated before it is placed on the canvas by specifying the
  # <tt>:rotate</tt> option with a given angle. Rotation occurs
  # counter-clockwise.
  #
  # == Encoding
  #
  # Note that strings passed to this function should be encoded as UTF-8.
  # If you get unexpected characters appearing in your rendered document,
  # check this.
  #
  # If the current font is a built-in one, although the string must be
  # encoded as UTF-8, only characters that are available in WinAnsi
  # are allowed.
  #
  # If an empty box is rendered to your PDF instead of the character you
  # wanted it usually means the current font doesn't include that character.
  #
  # == Options (default values marked in [])
  #
  # <tt>:at</tt>:: <tt>[x, y]</tt>(required). The position at which to start
  #                the text
  # <tt>:kerning</tt>:: <tt>boolean</tt>. Whether or not to use kerning (if it
  #                     is available with the current font)
  #                     [value of default_kerning?]
  # <tt>:size</tt>:: <tt>number</tt>. The font size to use. [current font
  #                  size]
  # <tt>:style</tt>:: The style to use. The requested style must be part of
  #                   the current font familly. [current style]
  #
  # <tt>:rotate</tt>:: <tt>number</tt>. The angle to which to rotate text
  #
  # == Exceptions
  #
  # Raises <tt>ArgumentError</tt> if <tt>:at</tt> option omitted
  #
  # Raises <tt>ArgumentError</tt> if <tt>:align</tt> option included
  #
  # source://prawn//lib/prawn/text.rb#276
  def draw_text(text, options); end

  # Low level text placement method. All font and size alterations
  # should already be set
  #
  # source://prawn//lib/prawn/text.rb#291
  def draw_text!(text, options); end

  # Draws formatted text to the page.
  # Formatted text is comprised of an array of hashes, where each hash defines
  # text and format information. See Text::Formatted#formatted_text_box for
  # more information on the structure of this array
  #
  # == Example
  #
  #   text([{ :text => "hello" },
  #         { :text => "world",
  #           :size => 24,
  #           :styles => [:bold, :italic] }])
  #
  # == Options
  #
  # Accepts the same options as #text
  #
  # == Exceptions
  #
  # Same as for #text
  #
  # source://prawn//lib/prawn/text.rb#190
  def formatted_text(array, options = T.unsafe(nil)); end

  # Gets height of text in PDF points.
  # Same options as #text, except as noted.
  # Not compatible with :indent_paragraphs option
  #
  # ==Example
  #
  #   height_of("hello\nworld")
  #
  # == Exceptions
  #
  # Raises <tt>NotImplementedError</tt> if <tt>:indent_paragraphs</tt>
  # option included
  #
  # Raises <tt>Prawn::Errrors::CannotFit</tt> if not wide enough to print
  # any text
  #
  # source://prawn//lib/prawn/text.rb#322
  def height_of(string, options = T.unsafe(nil)); end

  # Gets height of formatted text in PDF points.
  # See documentation for #height_of.
  #
  # ==Example
  #
  #   height_of_formatted([{ :text => "hello" },
  #                        { :text => "world",
  #                          :size => 24,
  #                          :styles => [:bold, :italic] }])
  #
  # source://prawn//lib/prawn/text.rb#336
  def height_of_formatted(array, options = T.unsafe(nil)); end

  # If you want text to flow onto a new page or between columns, this is the
  # method to use. If, instead, if you want to place bounded text outside of
  # the flow of a document (for captions, labels, charts, etc.), use Text::Box
  # or its convenience method text_box.
  #
  # Draws text on the page. Prawn attempts to wrap the text to fit within your
  # current bounding box (or margin_box if no bounding box is being used).
  # Text will flow onto the next page when it reaches the bottom of the
  # bounding box. Text wrap in Prawn does not re-flow linebreaks, so if you
  # want fully automated text wrapping, be sure to remove newlines before
  # attempting to draw your string.
  #
  # == Examples
  #
  #   pdf.text "Will be wrapped when it hits the edge of your bounding box"
  #   pdf.text "This will be centered", :align => :center
  #   pdf.text "This will be right aligned", :align => :right
  #   pdf.text "This <i>includes <b>inline</b></i> <font size='24'>" +
  #            "formatting</font>", :inline_format => true
  #
  # If your font contains kerning pair data that Prawn can parse, the
  # text will be kerned by default. You can disable kerning by including
  # a false <tt>:kerning</tt> option. If you want to disable kerning on an
  # entire document, set default_kerning = false for that document
  #
  # === Text Positioning Details
  #
  # The text is positioned at font.ascender below the baseline,
  # making it easy to use this method within bounding boxes and spans.
  #
  # == Encoding
  #
  # Note that strings passed to this function should be encoded as UTF-8.
  # If you get unexpected characters appearing in your rendered document,
  # check this.
  #
  # If the current font is a built-in one, although the string must be
  # encoded as UTF-8, only characters that are available in WinAnsi
  # are allowed.
  #
  # If an empty box is rendered to your PDF instead of the character you
  # wanted it usually means the current font doesn't include that character.
  #
  # == Options (default values marked in [])
  #
  # <tt>:inline_format</tt>::
  #      <tt>boolean</tt>. If true, then the string parameter is interpreted
  #      as a HTML-esque string that recognizes the following tags
  #      (assuming the default text formatter is used):
  #      <tt>\<b></b></tt>:: bold
  #      <tt>\<i></i></tt>:: italic
  #      <tt>\<u></u></tt>:: underline
  #      <tt>\<strikethrough></strikethrough></tt>:: strikethrough
  #      <tt>\<sub></sub></tt>:: subscript
  #      <tt>\<sup></sup></tt>:: superscript
  #      <tt>\<font></font></tt>::
  #          with the following attributes (using double or single quotes)
  #            <tt>size="24"</tt>::
  #                attribute for setting size
  #            <tt>character_spacing="2.5"</tt>::
  #                attribute for setting character spacing
  #            <tt>name="Helvetica"</tt>::
  #                attribute for setting the font. The font name must be an
  #                AFM font with the desired faces or must be a font that is
  #                already registered using Prawn::Document#font_families
  #      <tt>\<color></color></tt>::
  #          with the following attributes
  #            <tt>rgb="ffffff" or rgb="#ffffff"</tt>::
  #            <tt>c="100" m="100" y="100" k="100"</tt>::
  #      <tt>\<link></link></tt>::
  #          with the following attributes
  #            <tt>href="http://example.com"</tt>:: an external link
  #          Note that you must explicitly underline and color using the
  #          appropriate tags if you which to draw attention to the link
  #
  # <tt>:kerning</tt>:: <tt>boolean</tt>. Whether or not to use kerning (if it
  #                     is available with the current font)
  #                     [value of document.default_kerning?]
  # <tt>:size</tt>:: <tt>number</tt>. The font size to use. [current font
  #                  size]
  # <tt>:color</tt>:: an RGB color ("ff0000") or CMYK array [10, 20, 30, 40].
  # <tt>:character_spacing</tt>:: <tt>number</tt>. The amount of space to add
  #                               to or remove from the default character
  #                               spacing. [0]
  # <tt>:style</tt>:: The style to use. The requested style must be part of
  #                   the current font familly. [current style]
  # <tt>:indent_paragraphs</tt>:: <tt>number</tt>. The amount to indent the
  #                               first line of each paragraph. Omit this
  #                               option if you do not want indenting.
  # <tt>:direction</tt>::
  #     <tt>:ltr</tt>, <tt>:rtl</tt>, Direction of the text (left-to-right
  #     or right-to-left) [value of document.text_direction]
  # <tt>:fallback_fonts</tt>::
  #     An array of font names. Each name must be the name of an AFM font or
  #     the name that was used to register a family of TTF fonts (see
  #     Prawn::Document#font_families). If present, then each glyph will be
  #     rendered using the first font that includes the glyph, starting with
  #     the current font and then moving through :fallback_fonts from
  #     left to right.
  # <tt>:align</tt>::
  #     <tt>:left</tt>, <tt>:center</tt>, <tt>:right</tt>, or
  #     <tt>:justify</tt> Alignment within the bounding box
  #     [:left if direction is :ltr, :right if direction is :rtl]
  # <tt>:valign</tt>:: <tt>:top</tt>, <tt>:center</tt>, or <tt>:bottom</tt>.
  #                    Vertical alignment within the bounding box [:top]
  # <tt>:leading</tt>::
  #     <tt>number</tt>. Additional space between lines [value of
  #     document.default_leading]
  # <tt>:final_gap</tt>:: <tt>boolean</tt>. If true, then the space between
  #                       each line is included below the last line;
  #                       otherwise, document.y is placed just below the
  #                       descender of the last line printed [true]
  # <tt>:mode</tt>:: The text rendering mode to use. Use this to specify if
  #                  the text should render with the fill color, stroke color
  #                  or both. See the comments to text_rendering_mode() to see
  #                  a list of valid options. [0]
  #
  # == Exceptions
  #
  # Raises <tt>ArgumentError</tt> if <tt>:at</tt> option included
  #
  # Raises <tt>Prawn::Errrors::CannotFit</tt> if not wide enough to print
  # any text
  #
  # source://prawn//lib/prawn/text.rb#152
  def text(string, options = T.unsafe(nil)); end

  # Draws the requested text into a box. When the text overflows
  # the rectangle, you shrink to fit, or truncate the text. Text
  # boxes are independent of the document y position.
  #
  # == Encoding
  #
  # Note that strings passed to this function should be encoded as UTF-8.
  # If you get unexpected characters appearing in your rendered document,
  # check this.
  #
  # If the current font is a built-in one, although the string must be
  # encoded as UTF-8, only characters that are available in WinAnsi
  # are allowed.
  #
  # If an empty box is rendered to your PDF instead of the character you
  # wanted it usually means the current font doesn't include that character.
  #
  # == Options (default values marked in [])
  #
  # <tt>:kerning</tt>:: <tt>boolean</tt>. Whether or not to use kerning (if it
  #                     is available with the current font)
  #                     [value of document.default_kerning?]
  # <tt>:size</tt>:: <tt>number</tt>. The font size to use. [current font
  #                  size]
  # <tt>:character_spacing</tt>:: <tt>number</tt>. The amount of space to add
  #                               to or remove from the default character
  #                               spacing. [0]
  # <tt>:disable_wrap_by_char</tt>:: <tt>boolean</tt> Whether
  # or not to prevent mid-word breaks when text does not fit in box. [false]
  # <tt>:mode</tt>:: <tt>symbol</tt>. The text rendering mode. See
  #                  documentation for Prawn::Document#text_rendering_mode
  #                  for a list of valid options. [:fill]
  # <tt>:style</tt>:: The style to use. The requested style must be part of
  #                   the current font familly. [current style]
  #
  # <tt>:at</tt>::
  #     <tt>[x, y]</tt>. The upper left corner of the box
  #     [@document.bounds.left, @document.bounds.top]
  # <tt>:width</tt>::
  #     <tt>number</tt>. The width of the box
  #     [@document.bounds.right - @at[0]]
  # <tt>:height</tt>::
  #     <tt>number</tt>. The height of the box [default_height()]
  # <tt>:direction</tt>::
  #     <tt>:ltr</tt>, <tt>:rtl</tt>, Direction of the text (left-to-right
  #     or right-to-left) [value of document.text_direction]
  # <tt>:fallback_fonts</tt>::
  #     An array of font names. Each name must be the name of an AFM font or
  #     the name that was used to register a family of external fonts (see
  #     Prawn::Document#font_families). If present, then each glyph will be
  #     rendered using the first font that includes the glyph, starting with
  #     the current font and then moving through :fallback_fonts from
  #     left to right.
  # <tt>:align</tt>::
  #     <tt>:left</tt>, <tt>:center</tt>, <tt>:right</tt>, or
  #     <tt>:justify</tt> Alignment within the bounding box
  #     [:left if direction is :ltr, :right if direction is :rtl]
  # <tt>:valign</tt>::
  #     <tt>:top</tt>, <tt>:center</tt>, or <tt>:bottom</tt>. Vertical
  #     alignment within the bounding box [:top]
  # <tt>:rotate</tt>::
  #     <tt>number</tt>. The angle to rotate the text
  # <tt>:rotate_around</tt>::
  #     <tt>:center</tt>, <tt>:upper_left</tt>, <tt>:upper_right</tt>,
  #     <tt>:lower_right</tt>, or <tt>:lower_left</tt>. The point around which
  #     to rotate the text [:upper_left]
  # <tt>:leading</tt>::
  #     <tt>number</tt>. Additional space between lines [value of
  #     document.default_leading]
  # <tt>:single_line</tt>::
  #     <tt>boolean</tt>. If true, then only the first line will be drawn
  #     [false]
  # <tt>:overflow</tt>::
  #     <tt>:truncate</tt>, <tt>:shrink_to_fit</tt>, or <tt>:expand</tt>
  #     This controls the behavior when the amount of text
  #     exceeds the available space. [:truncate]
  # <tt>:min_font_size</tt>::
  #     <tt>number</tt>. The minimum font size to use when :overflow is set to
  #     :shrink_to_fit (that is the font size will not be reduced to less than
  #     this value, even if it means that some text will be cut off). [5]
  #
  # == Returns
  #
  # Returns any text that did not print under the current settings.
  #
  # == Exceptions
  #
  # Raises <tt>Prawn::Errors::CannotFit</tt> if not wide enough to print
  # any text
  #
  # source://prawn//lib/prawn/text/box.rb#106
  def text_box(string, options = T.unsafe(nil)); end

  # source://prawn-templates/0.1.2/lib/prawn/text.rb#3
  def text_rendering_mode(mode = T.unsafe(nil)); end

  private

  # source://prawn//lib/prawn/text.rb#364
  def draw_indented_formatted_line(string, options); end

  # source://prawn//lib/prawn/text.rb#355
  def draw_remaining_formatted_text_on_new_pages(remaining_text, options); end

  # source://prawn//lib/prawn/text.rb#377
  def fill_formatted_text_box(text, options); end

  # source://prawn//lib/prawn/text.rb#406
  def inspect_options_for_draw_text(options); end

  # source://prawn//lib/prawn/text.rb#421
  def inspect_options_for_text(options); end

  # source://prawn//lib/prawn/text.rb#390
  def merge_text_box_positioning_options(options); end

  # source://prawn//lib/prawn/text.rb#443
  def move_text_position(amount); end

  # source://prawn//lib/prawn/text.rb#433
  def process_final_gap_option(options); end

  # source://prawn//lib/prawn/text.rb#438
  def process_indent_paragraphs_option(options); end
end

# Generally, one would use the Prawn::Text#text_box convenience
# method. However, using Text::Box.new in conjunction with
# #render(:dry_run=> true) enables one to do look-ahead calculations prior
# to placing text on the page, or to determine how much vertical space was
# consumed by the printed text
#
# source://prawn//lib/prawn/text/box.rb#131
class Prawn::Text::Box < ::Prawn::Text::Formatted::Box
  # @return [Box] a new instance of Box
  #
  # source://prawn//lib/prawn/text/box.rb#132
  def initialize(string, options = T.unsafe(nil)); end

  # source://prawn//lib/prawn/text/box.rb#136
  def render(flags = T.unsafe(nil)); end
end

# source://prawn//lib/prawn/text/formatted/line_wrap.rb#13
module Prawn::Text::Formatted
  # Draws the requested formatted text into a box. When the text overflows
  # the rectangle shrink to fit or truncate the text. Text boxes are
  # independent of the document y position.
  #
  # == Formatted Text Array
  #
  # Formatted text is comprised of an array of hashes, where each hash
  # defines text and format information. As of the time of writing, the
  # following hash options are supported:
  #
  # <tt>:text</tt>::
  #     the text to format according to the other hash options
  # <tt>:styles</tt>::
  #     an array of styles to apply to this text. Available styles include
  #     :bold, :italic, :underline, :strikethrough, :subscript, and
  #     :superscript
  # <tt>:size</tt>::
  #     a number denoting the font size to apply to this text
  # <tt>:character_spacing</tt>::
  #     a number denoting how much to increase or decrease the default
  #     spacing between characters
  # <tt>:font</tt>::
  #     the name of a font. The name must be an AFM font with the desired
  #     faces or must be a font that is already registered using
  #     Prawn::Document#font_families
  # <tt>:color</tt>::
  #     anything compatible with Prawn::Graphics::Color#fill_color and
  #     Prawn::Graphics::Color#stroke_color
  # <tt>:link</tt>::
  #     a URL to which to create a link. A clickable link will be created
  #     to that URL. Note that you must explicitly underline and color using
  #     the appropriate tags if you which to draw attention to the link
  # <tt>:anchor</tt>::
  #     a destination that has already been or will be registered using
  #     PDF::Core::Destinations#add_dest. A clickable link will be
  #     created to that destination. Note that you must explicitly underline
  #     and color using the appropriate tags if you which to draw attention
  #     to the link
  # <tt>:local</tt>::
  #     a file or application to be opened locally. A clickable link will be
  #     created to the provided local file or application. If the file is
  #     another PDF, it will be opened in a new window. Note that you must
  #     explicitly underline and color using the appropriate tags if you
  #     which to draw attention to the link
  # <tt>:draw_text_callback</tt>:
  #     if provided, this Proc will be called instead of #draw_text! once
  #     per fragment for every low-level addition of text to the page.
  # <tt>:callback</tt>::
  #     an object (or array of such objects) with two methods:
  #     #render_behind and #render_in_front, which are called immediately
  #     prior to and immediately after rendring the text fragment and which
  #     are passed the fragment as an argument
  #
  # == Example
  #
  #   formatted_text_box([{ :text => "hello" },
  #                       { :text => "world",
  #                         :size => 24,
  #                         :styles => [:bold, :italic] }])
  #
  # == Options
  #
  # Accepts the same options as Text::Box with the below exceptions
  #
  # == Returns
  #
  # Returns a formatted text array representing any text that did not print
  # under the current settings.
  #
  # == Exceptions
  #
  # Raises "Bad font family" if no font family is defined for the current
  # font
  #
  # Raises <tt>Prawn::Errors::CannotFit</tt> if not wide enough to print
  # any text
  #
  # source://prawn//lib/prawn/text/formatted/box.rb#92
  def formatted_text_box(array, options = T.unsafe(nil)); end
end

# @private
#
# source://prawn//lib/prawn/text/formatted/arranger.rb#15
class Prawn::Text::Formatted::Arranger
  # @return [Arranger] a new instance of Arranger
  #
  # source://asciidoctor-pdf/2.3.19/lib/asciidoctor/pdf/ext/prawn/formatted_text/arranger.rb#8
  def initialize(*_args); end

  # source://prawn//lib/prawn/text/formatted/arranger.rb#154
  def apply_color_and_font_settings(fragment, &block); end

  # source://prawn//lib/prawn/text/formatted/arranger.rb#168
  def apply_font_settings(fragment = T.unsafe(nil), &block); end

  # source://asciidoctor-pdf/2.3.19/lib/asciidoctor/pdf/ext/prawn/formatted_text/arranger.rb#40
  def apply_font_size(size, styles); end

  # Returns the value of attribute consumed.
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#39
  def consumed; end

  # Sets the attribute consumed
  #
  # @param value the value to set the attribute consumed to.
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#39
  def consumed=(_arg0); end

  # Returns the value of attribute current_format_state.
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#44
  def current_format_state; end

  # source://asciidoctor-pdf/2.3.19/lib/asciidoctor/pdf/ext/prawn/formatted_text/arranger.rb#20
  def finalize_line; end

  # Returns the value of attribute finalized.
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#38
  def finalized; end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#126
  def finished?; end

  # source://prawn//lib/prawn/text/formatted/arranger.rb#236
  def font_style(styles); end

  # source://asciidoctor-pdf/2.3.19/lib/asciidoctor/pdf/ext/prawn/formatted_text/arranger.rb#15
  def format_array=(array); end

  # Returns the value of attribute fragments.
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#43
  def fragments; end

  # source://prawn//lib/prawn/text/formatted/arranger.rb#116
  def initialize_line; end

  # source://prawn//lib/prawn/text/formatted/arranger.rb#73
  def line; end

  # source://prawn//lib/prawn/text/formatted/arranger.rb#63
  def line_width; end

  # Returns the value of attribute max_ascender.
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#37
  def max_ascender; end

  # Returns the value of attribute max_descender.
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#36
  def max_descender; end

  # Returns the value of attribute max_line_height.
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#35
  def max_line_height; end

  # source://asciidoctor-pdf/2.3.19/lib/asciidoctor/pdf/ext/prawn/formatted_text/arranger.rb#25
  def next_string; end

  # source://prawn//lib/prawn/text/formatted/arranger.rb#146
  def preview_next_string; end

  # source://prawn//lib/prawn/text/formatted/arranger.rb#225
  def repack_unretrieved; end

  # source://prawn//lib/prawn/text/formatted/arranger.rb#217
  def retrieve_fragment; end

  # source://prawn//lib/prawn/text/formatted/arranger.rb#53
  def space_count; end

  # The following present only for testing purposes
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#42
  def unconsumed; end

  # source://prawn//lib/prawn/text/formatted/arranger.rb#198
  def update_last_string(printed, unprinted, normalized_soft_hyphen = T.unsafe(nil)); end

  private

  # source://prawn//lib/prawn/text/formatted/arranger.rb#306
  def fragment_measurements=(fragment); end

  # source://prawn//lib/prawn/text/formatted/arranger.rb#318
  def line_measurement_maximums=(fragment); end

  # source://prawn//lib/prawn/text/formatted/arranger.rb#251
  def load_previous_format_state; end

  # source://prawn//lib/prawn/text/formatted/arranger.rb#290
  def omit_trailing_whitespace_from_line_width; end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#278
  def subscript?(styles); end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#284
  def superscript?(styles); end
end

# source://prawn//lib/prawn/text/formatted/arranger.rb#29
class Prawn::Text::Formatted::Arranger::BadFontFamily < ::StandardError
  # @return [BadFontFamily] a new instance of BadFontFamily
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#30
  def initialize(message = T.unsafe(nil)); end
end

# source://prawn//lib/prawn/text/formatted/arranger.rb#16
class Prawn::Text::Formatted::Arranger::NotFinalized < ::StandardError
  # @return [NotFinalized] a new instance of NotFinalized
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#20
  def initialize(message = T.unsafe(nil), method: T.unsafe(nil)); end
end

# source://prawn//lib/prawn/text/formatted/arranger.rb#17
Prawn::Text::Formatted::Arranger::NotFinalized::DEFAULT_MESSAGE = T.let(T.unsafe(nil), String)

# source://prawn//lib/prawn/text/formatted/arranger.rb#18
Prawn::Text::Formatted::Arranger::NotFinalized::MESSAGE_WITH_METHOD = T.let(T.unsafe(nil), String)

# Generally, one would use the Prawn::Text::Formatted#formatted_text_box
# convenience method. However, using Text::Formatted::Box.new in
# conjunction with #render(:dry_run => true) enables one to do look-ahead
# calculations prior to placing text on the page, or to determine how much
# vertical space was consumed by the printed text
#
# source://prawn//lib/prawn/text/formatted/box.rb#102
class Prawn::Text::Formatted::Box
  include ::Asciidoctor::PDF::Measurements
  include ::Asciidoctor::Logging
  include ::Prawn::Text::Formatted::Wrap

  # See Prawn::Text#text_box for valid options
  #
  # @return [Box] a new instance of Box
  #
  # source://asciidoctor-pdf/2.3.19/lib/asciidoctor/pdf/ext/prawn/formatted_text/box.rb#6
  def initialize(formatted_text, options = T.unsafe(nil)); end

  # source://asciidoctor-pdf/2.3.19/lib/asciidoctor/pdf/ext/prawn/formatted_text/box.rb#37
  def analyze_glyphs_for_fallback_font_support(fragment_hash); end

  # The height of the ascender of the last line printed
  #
  # source://prawn//lib/prawn/text/formatted/box.rb#128
  def ascender; end

  # The upper left corner of the text box
  #
  # source://prawn//lib/prawn/text/formatted/box.rb#124
  def at; end

  # The width available at this point in the box
  #
  # source://prawn//lib/prawn/text/formatted/box.rb#244
  def available_width; end

  # The height of the descender of the last line printed
  #
  # source://prawn//lib/prawn/text/formatted/box.rb#130
  def descender; end

  # <tt>fragment</tt> is a Prawn::Text::Formatted::Fragment object
  #
  # source://prawn//lib/prawn/text/formatted/box.rb#258
  def draw_fragment(fragment, accumulated_width = T.unsafe(nil), line_width = T.unsafe(nil), word_spacing = T.unsafe(nil)); end

  # source://asciidoctor-pdf/2.3.19/lib/asciidoctor/pdf/ext/prawn/formatted_text/box.rb#21
  def draw_fragment_overlay_styles(fragment); end

  # True if everything printed (or, if <tt>dry_run</tt> was
  # used, everything would have been successfully printed)
  #
  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/box.rb#119
  def everything_printed?; end

  # source://asciidoctor-pdf/2.3.19/lib/asciidoctor/pdf/ext/prawn/formatted_text/box.rb#64
  def find_font_for_this_glyph(char, current_font, current_font_opts = T.unsafe(nil), fallback_fonts_to_check = T.unsafe(nil), original_font = T.unsafe(nil)); end

  # The height actually used during the previous <tt>render</tt>
  #
  # source://prawn//lib/prawn/text/formatted/box.rb#250
  def height; end

  # The leading used during printing
  #
  # source://prawn//lib/prawn/text/formatted/box.rb#132
  def leading; end

  # source://prawn//lib/prawn/text/formatted/box.rb#134
  def line_gap; end

  # The line height of the last line printed
  #
  # source://prawn//lib/prawn/text/formatted/box.rb#126
  def line_height; end

  # True if nothing printed (or, if <tt>dry_run</tt> was
  # used, nothing would have been successfully printed)
  #
  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/box.rb#113
  def nothing_printed?; end

  # source://asciidoctor-pdf/2.3.19/lib/asciidoctor/pdf/ext/prawn/formatted_text/box.rb#96
  def process_vertical_alignment(text); end

  # Render text to the document based on the settings defined in
  # initialize.
  #
  # In order to facilitate look-ahead calculations, <tt>render</tt>
  # accepts a <tt>:dry_run => true</tt> option. If provided, then
  # everything is executed as if rendering, with the exception that
  # nothing is drawn on the page. Useful for look-ahead computations of
  # height, unprinted text, etc.
  #
  # Returns any text that did not print under the current settings.
  #
  # source://prawn//lib/prawn/text/formatted/box.rb#211
  def render(flags = T.unsafe(nil)); end

  # The text that was successfully printed (or, if <tt>dry_run</tt> was
  # used, the text that would have been successfully printed)
  #
  # source://prawn//lib/prawn/text/formatted/box.rb#109
  def text; end

  # source://prawn//lib/prawn/text/formatted/box.rb#351
  def valid_options; end

  private

  # Returns the default height to be used if none is provided or if the
  # overflow option is set to :expand. If we are in a stretchy bounding
  # box, assume we can stretch to the bottom of the innermost non-stretchy
  # box.
  #
  # source://prawn//lib/prawn/text/formatted/box.rb#493
  def default_height; end

  # source://prawn//lib/prawn/text/formatted/box.rb#615
  def draw_fragment_overlay_anchor(fragment); end

  # source://prawn//lib/prawn/text/formatted/box.rb#600
  def draw_fragment_overlay_link(fragment); end

  # source://prawn//lib/prawn/text/formatted/box.rb#626
  def draw_fragment_overlay_local(fragment); end

  # source://prawn//lib/prawn/text/formatted/box.rb#590
  def draw_fragment_overlays(fragment); end

  # source://prawn//lib/prawn/text/formatted/box.rb#584
  def draw_fragment_underlays(fragment); end

  # source://prawn//lib/prawn/text/formatted/box.rb#460
  def form_fragments_from_like_font_glyph_pairs(font_glyph_pairs, hash); end

  # source://prawn//lib/prawn/text/formatted/box.rb#480
  def move_baseline_down; end

  # source://prawn//lib/prawn/text/formatted/box.rb#386
  def normalize_encoding; end

  # source://prawn//lib/prawn/text/formatted/box.rb#370
  def normalized_text(flags); end

  # source://prawn//lib/prawn/text/formatted/box.rb#378
  def original_text; end

  # source://prawn//lib/prawn/text/formatted/box.rb#382
  def original_text=(formatted_text); end

  # source://prawn//lib/prawn/text/formatted/box.rb#406
  def process_fallback_fonts(formatted_text); end

  # source://prawn//lib/prawn/text/formatted/box.rb#549
  def process_options; end

  # source://prawn//lib/prawn/text/formatted/box.rb#557
  def render_rotated(text); end

  # Decrease the font size until the text fits or the min font
  # size is reached
  #
  # source://prawn//lib/prawn/text/formatted/box.rb#529
  def shrink_to_fit(text); end

  class << self
    # Example (see Prawn::Text::Core::Formatted::Wrap for what is required
    # of the wrap method if you want to override the default wrapping
    # algorithm):
    #
    #
    #   module MyWrap
    #
    #     def wrap(array)
    #       initialize_wrap([{ :text => 'all your base are belong to us' }])
    #       @line_wrap.wrap_line(:document => @document,
    #                            :kerning => @kerning,
    #                            :width => 10000,
    #                            :arranger => @arranger)
    #       fragment = @arranger.retrieve_fragment
    #       format_and_draw_fragment(fragment, 0, @line_wrap.width, 0)
    #       []
    #     end
    #
    #   end
    #
    #   Prawn::Text::Formatted::Box.extensions << MyWrap
    #
    #   box = Prawn::Text::Formatted::Box.new('hello world')
    #   box.render('why can't I print anything other than' +
    #              '"all your base are belong to us"?')
    #
    # source://prawn//lib/prawn/text/formatted/box.rb#341
    def extensions; end

    # @private
    # @private
    #
    # source://prawn//lib/prawn/text/formatted/box.rb#346
    def inherited(base); end
  end
end

# Prawn::Text::Formatted::Fragment is a state store for a formatted text
# fragment. It does not render anything.
#
# @private
#
# source://prawn//lib/prawn/text/formatted/fragment.rb#16
class Prawn::Text::Formatted::Fragment
  # @return [Fragment] a new instance of Fragment
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#22
  def initialize(text, format_state, document); end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#185
  def absolute_bottom; end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#197
  def absolute_bottom_left; end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#201
  def absolute_bottom_right; end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#62
  def absolute_bounding_box; end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#173
  def absolute_left; end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#177
  def absolute_right; end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#181
  def absolute_top; end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#189
  def absolute_top_left; end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#193
  def absolute_top_right; end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#89
  def anchor; end

  # Returns the value of attribute ascender.
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#19
  def ascender; end

  # Sets the attribute ascender
  #
  # @param value the value to set the attribute ascender to.
  #
  # source://asciidoctor-pdf/2.3.19/lib/asciidoctor/pdf/ext/prawn/formatted_text/fragment.rb#29
  def ascender=(val); end

  # Returns the value of attribute baseline.
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#20
  def baseline; end

  # Sets the attribute baseline
  #
  # @param value the value to set the attribute baseline to.
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#20
  def baseline=(_arg0); end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#153
  def bottom; end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#169
  def bottom_left; end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#165
  def bottom_right; end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#58
  def bounding_box; end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#134
  def callback_objects; end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#109
  def character_spacing; end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#97
  def color; end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#118
  def default_direction=(direction); end

  # Returns the value of attribute descender.
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#19
  def descender; end

  # Sets the attribute descender
  #
  # @param value the value to set the attribute descender to.
  #
  # source://asciidoctor-pdf/2.3.19/lib/asciidoctor/pdf/ext/prawn/formatted_text/fragment.rb#35
  def descender=(val); end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#114
  def direction; end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#101
  def font; end

  # Returns the value of attribute format_state.
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#17
  def format_state; end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#39
  def height; end

  # source://asciidoctor-pdf/2.3.19/lib/asciidoctor/pdf/ext/prawn/formatted_text/fragment.rb#17
  def include_trailing_white_space!; end

  # Returns the value of attribute left.
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#20
  def left; end

  # Sets the attribute left
  #
  # @param value the value to set the attribute left to.
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#20
  def left=(_arg0); end

  # Returns the value of attribute line_height.
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#19
  def line_height; end

  # Sets the attribute line_height
  #
  # @param value the value to set the attribute line_height to.
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#19
  def line_height=(_arg0); end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#85
  def link; end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#93
  def local; end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#145
  def right; end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#105
  def size; end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#130
  def space_count; end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#76
  def strikethrough_points; end

  # source://asciidoctor-pdf/2.3.19/lib/asciidoctor/pdf/ext/prawn/formatted_text/fragment.rb#23
  def strip_zero_width_spaces(string); end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#81
  def styles; end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#43
  def subscript?; end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#47
  def superscript?; end

  # Returns the value of attribute text.
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#17
  def text; end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#149
  def top; end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#157
  def top_left; end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#161
  def top_right; end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#71
  def underline_points; end

  # source://asciidoctor-pdf/2.3.19/lib/asciidoctor/pdf/ext/prawn/formatted_text/fragment.rb#39
  def width; end

  # Sets the attribute width
  #
  # @param value the value to set the attribute width to.
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#18
  def width=(_arg0); end

  # Returns the value of attribute word_spacing.
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#20
  def word_spacing; end

  # Sets the attribute word_spacing
  #
  # @param value the value to set the attribute word_spacing to.
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#20
  def word_spacing=(_arg0); end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#51
  def y_offset; end

  private

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#227
  def exclude_trailing_white_space?; end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#235
  def normalized_soft_hyphen; end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#239
  def process_soft_hyphens(string); end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#207
  def process_text(text); end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#231
  def soft_hyphens_need_processing?(string); end
end

# @private
#
# source://prawn//lib/prawn/text/formatted/line_wrap.rb#15
class Prawn::Text::Formatted::LineWrap
  # returns true if all text was printed without running into the end of
  # the line
  #
  # source://asciidoctor-pdf/2.3.19/lib/asciidoctor/pdf/ext/prawn/formatted_text/line_wrap.rb#4
  def add_fragment_to_line(fragment); end

  # Whether this line is the last line in the paragraph
  #
  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#26
  def paragraph_finished?; end

  # The number of spaces in the last wrapped line
  #
  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#23
  def space_count; end

  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#30
  def tokenize(fragment); end

  # The width of the last wrapped line
  #
  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#18
  def width; end

  # Work in conjunction with the PDF::Formatted::Arranger
  # defined in the :arranger option to determine what formatted text
  # will fit within the width defined by the :width option
  #
  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#38
  def wrap_line(options); end

  private

  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#311
  def append_char(char); end

  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#77
  def apply_font_settings_and_add_fragment_to_line(fragment); end

  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#178
  def break_chars(encoding = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#65
  def empty_line?(fragment); end

  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#297
  def end_of_the_line_reached(segment); end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#61
  def first_fragment_on_this_line?(fragment); end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#283
  def fragment_begins_with_breakable?(fragment); end

  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#226
  def fragment_finished(fragment); end

  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#197
  def hyphen(_encoding = T.unsafe(nil)); end

  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#208
  def initialize_line(options); end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#204
  def line_empty?; end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#287
  def line_finished?; end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#73
  def next_string_newline?; end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#279
  def previous_fragment_ended_with_breakable?; end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#258
  def pull_preceding_fragment_to_join_this_one?(current_fragment); end

  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#268
  def remember_this_fragment_for_backward_looking_ops; end

  # The pattern used to determine chunks of text to place on a given line
  #
  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#129
  def scan_pattern(encoding = T.unsafe(nil)); end

  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#171
  def soft_hyphen(encoding = T.unsafe(nil)); end

  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#291
  def update_line_status_based_on_last_output; end

  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#241
  def update_output_based_on_last_fragment(fragment, normalized_soft_hyphen = T.unsafe(nil)); end

  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#193
  def whitespace(encoding = T.unsafe(nil)); end

  # The pattern used to determine whether any word breaks exist on a
  # current line, which in turn determines whether character level
  # word breaking is needed
  #
  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#155
  def word_division_scan_pattern(encoding = T.unsafe(nil)); end

  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#305
  def wrap_by_char(segment); end

  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#186
  def zero_width_space(encoding = T.unsafe(nil)); end
end

# source://prawn//lib/prawn/text/formatted/parser.rb#14
class Prawn::Text::Formatted::Parser
  class << self
    # source://prawn//lib/prawn/text/formatted/parser.rb#126
    def array_from_tokens(tokens); end

    # source://prawn//lib/prawn/text/formatted/parser.rb#103
    def array_paragraphs(array); end

    # source://prawn//lib/prawn/text/formatted/parser.rb#36
    def format(string, *_args); end

    # source://prawn//lib/prawn/text/formatted/parser.rb#41
    def to_string(array); end
  end
end

# source://prawn//lib/prawn/text/formatted/parser.rb#17
Prawn::Text::Formatted::Parser::PARSER_REGEX = T.let(T.unsafe(nil), Regexp)

# @private
#
# source://prawn//lib/prawn/text/formatted/wrap.rb#17
module Prawn::Text::Formatted::Wrap
  # source://prawn//lib/prawn/text/formatted/wrap.rb#18
  def initialize(_array, options); end

  # See the developer documentation for PDF::Core::Text#wrap
  #
  # Formatted#wrap should set the following variables:
  #   <tt>@line_height</tt>::
  #        the height of the tallest fragment in the last printed line
  #   <tt>@descender</tt>::
  #        the descender height of the tallest fragment in the last
  #        printed line
  #   <tt>@ascender</tt>::
  #        the ascender heigth of the tallest fragment in the last
  #        printed line
  #   <tt>@baseline_y</tt>::
  #       the baseline of the current line
  #   <tt>@nothing_printed</tt>::
  #       set to true until something is printed, then false
  #   <tt>@everything_printed</tt>::
  #       set to false until everything printed, then true
  #
  # Returns any formatted text that was not printed
  #
  # source://prawn//lib/prawn/text/formatted/wrap.rb#47
  def wrap(array); end

  private

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/wrap.rb#123
  def enough_height_for_this_line?; end

  # source://prawn//lib/prawn/text/formatted/wrap.rb#158
  def format_and_draw_fragment(fragment, accumulated_width, line_width, word_spacing); end

  # source://prawn//lib/prawn/text/formatted/wrap.rb#143
  def initialize_wrap(array); end

  # source://prawn//lib/prawn/text/formatted/wrap.rb#79
  def print_line; end

  # source://prawn//lib/prawn/text/formatted/wrap.rb#114
  def word_spacing_for_this_line; end
end

# No-Break Space
#
# source://prawn//lib/prawn/text.rb#20
Prawn::Text::NBSP = T.let(T.unsafe(nil), String)

# Soft Hyphen (invisible, except when causing a line break)
#
# source://prawn//lib/prawn/text.rb#24
Prawn::Text::SHY = T.let(T.unsafe(nil), String)

# Zero Width Space (indicate word boundaries without a space)
#
# source://prawn//lib/prawn/text.rb#22
Prawn::Text::ZWSP = T.let(T.unsafe(nil), String)

# source://prawn//lib/prawn/transformation_stack.rb#14
module Prawn::TransformationStack
  # source://prawn//lib/prawn/transformation_stack.rb#15
  def add_to_transformation_stack(a, b, c, d, e, f); end

  # source://prawn//lib/prawn/transformation_stack.rb#29
  def current_transformation_matrix_with_translation(x = T.unsafe(nil), y = T.unsafe(nil)); end

  # source://prawn//lib/prawn/transformation_stack.rb#25
  def restore_transformation_stack; end

  # source://prawn//lib/prawn/transformation_stack.rb#20
  def save_transformation_stack; end
end

# source://prawn//lib/prawn/version.rb#4
Prawn::VERSION = T.let(T.unsafe(nil), String)

# This mixin allows you to create modular Prawn code without the
# need to create subclasses of Prawn::Document.
#
#     class Greeter
#       include Prawn::View
#
#       # Optional override: allows you to set document options or even use
#       # a custom document class
#       def document
#         @document ||= Prawn::Document.new(page_size: 'A4')
#       end
#
#       def initialize(name)
#         @name = name
#       end
#
#       def say_hello
#         text "Hello, #{@name}!"
#       end
#
#       def say_goodbye
#         font("Courier") do
#           text "Goodbye, #{@name}!"
#         end
#       end
#    end
#
#    greeter = Greeter.new("Gregory")
#
#    greeter.say_hello
#    greeter.say_goodbye
#
#    greeter.save_as("greetings.pdf")
#
# The short story about why you should use this mixin rather than
# creating subclasses of +Prawn::Document+ is that it helps
# prevent accidental conflicts between your code and Prawn's
# code.
#
# Here's the slightly longer story...
#
# By using composition rather than inheritance under the hood, this
# mixin allows you to keep your state separate from +Prawn::Document+'s
# state, and also will prevent unexpected method name collisions due
# to late binding effects.
#
# This mixin is mostly meant for extending Prawn's functionality
# with your own additions, but you can also use it to replace or
# wrap existing Prawn methods. Calling +super+ will still work
# as expected, and alternatively you can explictly call
# +document.some_method+ to delegate to Prawn where needed.
#
# source://prawn//lib/prawn/view.rb#59
module Prawn::View
  # Lazily instantiates a +Prawn::Document+ object.
  #
  # You can also redefine this method in your own classes to use
  # a custom document class.
  #
  # source://prawn//lib/prawn/view.rb#66
  def document; end

  # Delegates all unhandled calls to object returned by +document+ method.
  # (which is an instance of Prawn::Document by default)
  #
  # source://prawn//lib/prawn/view.rb#72
  def method_missing(method_name, *arguments, &block); end

  # Syntatic sugar that calls +document.render_file+ under the hood.
  #
  #    greeter.save_as("greetings.pdf")
  #
  # source://prawn//lib/prawn/view.rb#97
  def save_as(filename); end

  # Syntactic sugar that uses +instance_eval+ under the hood to provide
  # a block-based DSL.
  #
  #    greeter.update do
  #      say_hello
  #      say_goodbye
  #    end
  #
  # source://prawn//lib/prawn/view.rb#90
  def update(&block); end

  private

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/view.rb#78
  def respond_to_missing?(method_name, _include_all = T.unsafe(nil)); end
end
