# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `pygments.rb` gem.
# Please instead update this file by running `bin/tapioca gem pygments.rb`.


# Error class
#
# source://pygments.rb//lib/pygments/popen.rb#9
class MentosError < ::IOError; end

# Pygments provides access to the Pygments library via a pipe and a long-running
# Python process.
#
# source://pygments.rb//lib/pygments/lexer.rb#5
module Pygments
  class << self
    # source://forwardable/1.3.3/forwardable.rb#231
    def css(*args, **_arg1, &block); end

    # source://pygments.rb//lib/pygments.rb#16
    def engine; end

    # source://forwardable/1.3.3/forwardable.rb#231
    def filters(*args, **_arg1, &block); end

    # source://forwardable/1.3.3/forwardable.rb#231
    def formatters(*args, **_arg1, &block); end

    # source://forwardable/1.3.3/forwardable.rb#231
    def highlight(*args, **_arg1, &block); end

    # source://pygments.rb//lib/pygments.rb#21
    def lexer_name_for(*args); end

    # source://forwardable/1.3.3/forwardable.rb#231
    def lexer_names_for(*args, **_arg1, &block); end

    # source://pygments.rb//lib/pygments.rb#12
    def lexers; end

    # source://forwardable/1.3.3/forwardable.rb#231
    def lexers!(*args, **_arg1, &block); end

    # source://forwardable/1.3.3/forwardable.rb#231
    def pygments_version(*args, **_arg1, &block); end

    # source://forwardable/1.3.3/forwardable.rb#231
    def start(*args, **_arg1, &block); end

    # source://forwardable/1.3.3/forwardable.rb#231
    def styles(*args, **_arg1, &block); end
  end
end

# source://pygments.rb//lib/pygments/lexer.rb#6
class Pygments::Lexer < ::Struct
  def ==(_arg0); end
  def eql?(_arg0); end

  # Public: Highlight syntax of text
  #
  # text    - String of code to be highlighted
  # options - Hash of options (defaults to {})
  #
  # Returns html String
  #
  # source://pygments.rb//lib/pygments/lexer.rb#100
  def highlight(text, options = T.unsafe(nil)); end

  class << self
    # Public: Alias for find.
    #
    # @param name [String]
    # @return [Lexer, nil]
    #
    # source://pygments.rb//lib/pygments/lexer.rb#30
    def [](name); end

    # Public: Get all Lexers
    #
    # @return [Array<Lexer>]
    #
    # source://pygments.rb//lib/pygments/lexer.rb#10
    def all; end

    # Public: Look up Lexer by name or alias.
    #
    # name - A String name or alias
    #
    #   Lexer.find('Ruby')
    #   => #<Lexer name="Ruby">
    #
    # @return [Lexer, nil]
    #
    # source://pygments.rb//lib/pygments/lexer.rb#22
    def find(name); end

    # Public: Look up Lexer by one of its aliases.
    #
    # name - A String alias of the Lexer
    #
    # Examples
    #
    #   Lexer.find_by_alias('rb')
    #   # => #<Lexer name="Ruby">
    #
    # @param name [String]
    # @return [Lexer, nil]
    #
    # source://pygments.rb//lib/pygments/lexer.rb#60
    def find_by_alias(name); end

    # Public: Look up Lexer by one of it's file extensions.
    #
    # extname - A String file extension.
    #
    # Examples
    #
    #  Lexer.find_by_extname('.rb')
    #  # => #<Lexer name="Ruby">
    #
    # @param extname [String]
    # @return [Lexer, nil]
    #
    # source://pygments.rb//lib/pygments/lexer.rb#75
    def find_by_extname(extname); end

    # Public: Look up Lexer by one of it's mime types.
    #
    # type - A mime type String.
    #
    # Examples
    #
    #  Lexer.find_by_mimetype('application/x-ruby')
    #  # => #<Lexer name="Ruby">
    #
    # @param type [String]
    # @return [Lexer, nil]
    #
    # source://pygments.rb//lib/pygments/lexer.rb#90
    def find_by_mimetype(type); end

    # Public: Look up Lexer by its proper name.
    #
    # name - The String name of the Lexer
    #
    # Examples
    #
    #   Lexer.find_by_name('Ruby')
    #   # => #<Lexer name="Ruby">
    #
    # @param name [String]
    # @return [Lexer, nil]
    #
    # source://pygments.rb//lib/pygments/lexer.rb#45
    def find_by_name(name); end
  end
end

# source://pygments.rb//lib/pygments/lexer.rb#109
class Pygments::LexerCache
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # @return [LexerCache] a new instance of LexerCache
  #
  # source://pygments.rb//lib/pygments/lexer.rb#127
  def initialize; end

  # @return [Map<String, Lexer]] Map<String, Lexer]
  #
  # source://pygments.rb//lib/pygments/lexer.rb#119
  def alias_index; end

  # @return [Map<String, Lexer>]
  #
  # source://pygments.rb//lib/pygments/lexer.rb#121
  def extname_index; end

  # @return [Map<String, Lexer>]
  #
  # source://pygments.rb//lib/pygments/lexer.rb#115
  def index; end

  # @return [Array<Lexer>]
  #
  # source://pygments.rb//lib/pygments/lexer.rb#113
  def lexers; end

  # @return [Map<String, Lexer>]
  #
  # source://pygments.rb//lib/pygments/lexer.rb#123
  def mimetypes_index; end

  # @return [Map<String, Lexer>]
  #
  # source://pygments.rb//lib/pygments/lexer.rb#117
  def name_index; end

  # Returns the value of attribute raw_lexers.
  #
  # source://pygments.rb//lib/pygments/lexer.rb#125
  def raw_lexers; end

  class << self
    private

    def allocate; end
    def new(*_arg0); end
  end
end

# source://pygments.rb//lib/pygments/popen.rb#15
class Pygments::Popen
  # Check for a @pid variable, and then hit `kill -0` with the pid to
  # check if the pid is still in the process table. If this function
  # gives us an ENOENT or ESRCH, we can also safely return false (no process
  # to worry about). Defensively, if EPERM is raised, in a odd/rare
  # dying process situation (e.g., mentos is checking on the pid of a dead
  # process and the pid has already been re-used) we'll want to raise
  # that as a more informative Mentos exception.
  #
  # @return [Boolean] true if the child is alive.
  #
  # source://pygments.rb//lib/pygments/popen.rb#79
  def alive?; end

  # @return [String] css for highlighted code
  #
  # source://pygments.rb//lib/pygments/popen.rb#138
  def css(klass = T.unsafe(nil), opts = T.unsafe(nil)); end

  # @return [Array<String>] an array of all available filters
  #
  # source://pygments.rb//lib/pygments/popen.rb#128
  def filters; end

  # Public: Get an array of available Pygments formatters
  #
  # @return [Array<String>] an array of formatters
  #
  # source://pygments.rb//lib/pygments/popen.rb#99
  def formatters; end

  # Public: Highlight code.
  #
  # Takes a first-position argument of the code to be highlighted,
  # and a second-position hash of various arguments specifying
  # highlighting properties.
  #
  # Returns the highlighted string
  # or nil when the request to the Python process timed out.
  #
  # source://pygments.rb//lib/pygments/popen.rb#168
  def highlight(code, opts = T.unsafe(nil)); end

  # @return [[String], nil] aliases of a lexer.
  #
  # source://pygments.rb//lib/pygments/popen.rb#147
  def lexer_names_for(*args); end

  # Get all available lexers from mentos itself
  # Do not use this method directly, instead use Pygments#lexers
  #
  # @return [Array<String>] an array of lexers
  #
  # source://pygments.rb//lib/pygments/popen.rb#115
  def lexers!; end

  # Public: Returns version of underlying Pygments library
  #
  # @return [Integer]
  #
  # source://pygments.rb//lib/pygments/popen.rb#92
  def pygments_version; end

  # source://pygments.rb//lib/pygments/popen.rb#38
  def python_binary; end

  # Sets the attribute python_binary
  #
  # @param value the value to set the attribute python_binary to.
  #
  # source://pygments.rb//lib/pygments/popen.rb#42
  def python_binary=(_arg0); end

  # Get things started by opening a pipe to mentos (the freshmaker), a
  # Python process that talks to the Pygments library. We'll talk back and
  # forth across this pipe.
  #
  # source://pygments.rb//lib/pygments/popen.rb#19
  def start(pygments_path = T.unsafe(nil)); end

  # Stop the child process by issuing a kill -9.
  #
  # We then call waitpid() with the pid, which waits for that particular
  # child and reaps it.
  #
  # kill() can set errno to ESRCH if, for some reason, the file
  # is gone; regardless the final outcome of this method
  # will be to set our @pid variable to nil.
  #
  # Technically, kill() can also fail with EPERM or EINVAL (wherein
  # the signal isn't sent); but we have permissions, and
  # we're not doing anything invalid here.
  #
  # @param reason [String]
  #
  # source://pygments.rb//lib/pygments/popen.rb#57
  def stop(reason); end

  # @return [Array<String>] an array of all available styles
  #
  # source://pygments.rb//lib/pygments/popen.rb#133
  def styles; end

  private

  # Detect a suitable Python binary to use.
  #
  # source://pygments.rb//lib/pygments/popen.rb#197
  def find_python_binary; end

  # @param timeout [Integer, nil]
  # @return [Integer]
  #
  # source://pygments.rb//lib/pygments/popen.rb#323
  def get_timeout(timeout); end

  # Based on the header we receive, determine if we need
  # to read more bytes, and read those bytes if necessary.
  #
  # @param header [String, nil]
  # @raise [MentosError]
  # @return [String, nil] either highlighted text or metadata.
  #
  # source://pygments.rb//lib/pygments/popen.rb#334
  def handle_header_and_return(header); end

  # Convert a text header into JSON for easy access.
  #
  # @param header [String]
  # @raise [MentosError]
  # @return [JSON]
  #
  # source://pygments.rb//lib/pygments/popen.rb#362
  def header_to_json(header); end

  # Our 'rpc'-ish request to mentos. Requires a method name, and then optional
  # args, kwargs, code.
  #
  # source://pygments.rb//lib/pygments/popen.rb#260
  def mentos(method, args = T.unsafe(nil), kwargs = T.unsafe(nil), code = T.unsafe(nil)); end

  # @param argv [Array<String>]
  #
  # source://pygments.rb//lib/pygments/popen.rb#188
  def popen4(argv); end

  # @return Ruby objects for the methods that want them, text otherwise.
  #
  # source://pygments.rb//lib/pygments/popen.rb#353
  def return_result(res, method); end

  # Cross platform which command
  # from http://stackoverflow.com/a/5471032/284795
  #
  # source://pygments.rb//lib/pygments/popen.rb#210
  def which(command); end

  # @param timeout [Integer]
  # @param error_message [String]
  # @yield
  #
  # source://pygments.rb//lib/pygments/popen.rb#224
  def with_watchdog(timeout, error_message); end

  # @param header [String]
  # @param code [String, nil]
  #
  # source://pygments.rb//lib/pygments/popen.rb#309
  def write_header(header, code); end
end
