# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `asciidoctor-pdf` gem.
# Please instead update this file by running `bin/tapioca gem asciidoctor-pdf`.


# source://asciidoctor-pdf//lib/asciidoctor/pdf/version.rb#3
module Asciidoctor
  class << self
    # source://asciidoctor/2.0.23/lib/asciidoctor.rb#529
    def const_missing(name); end

    # source://asciidoctor/2.0.23/lib/asciidoctor/convert.rb#34
    def convert(input, options = T.unsafe(nil)); end

    # source://asciidoctor/2.0.23/lib/asciidoctor/convert.rb#189
    def convert_file(filename, options = T.unsafe(nil)); end

    # source://asciidoctor/2.0.23/lib/asciidoctor/load.rb#17
    def load(input, options = T.unsafe(nil)); end

    # source://asciidoctor/2.0.23/lib/asciidoctor/load.rb#115
    def load_file(filename, options = T.unsafe(nil)); end

    # source://asciidoctor/2.0.23/lib/asciidoctor/convert.rb#34
    def render(input, options = T.unsafe(nil)); end

    # source://asciidoctor/2.0.23/lib/asciidoctor/convert.rb#189
    def render_file(filename, options = T.unsafe(nil)); end
  end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/asciidoctor/document.rb#3
class Asciidoctor::Document < ::Asciidoctor::AbstractBlock
  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#253
  def initialize(data = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#807
  def <<(block); end

  # Internal: Returns whether the specified attribute has never been set and is not locked.
  #
  # @return [Boolean]
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/asciidoctor/document.rb#28
  def attr_unspecified?(name); end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#900
  def attribute_locked?(name); end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#747
  def author; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#756
  def authors; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#190
  def backend; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#214
  def base_dir; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#676
  def basebackend?(base); end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#650
  def callouts; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#199
  def catalog; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#187
  def compat_mode; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#1009
  def content; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#929
  def convert(opts = T.unsafe(nil)); end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#232
  def converter; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#567
  def counter(name, seed = T.unsafe(nil)); end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#586
  def counter_increment(counter_name, block); end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#205
  def counters; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#885
  def delete_attribute(name); end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#1027
  def docinfo(location = T.unsafe(nil), suffix = T.unsafe(nil)); end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#1075
  def docinfo_processors?(location = T.unsafe(nil)); end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#721
  def doctitle(opts = T.unsafe(nil)); end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#193
  def doctype; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#658
  def embedded?; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#238
  def extensions; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#662
  def extensions?; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#817
  def finalize_header(unrooted_attributes, header_valid = T.unsafe(nil)); end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#791
  def first_section; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#646
  def footnotes; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#642
  def footnotes?; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#795
  def has_header?; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#208
  def header; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#795
  def header?; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#586
  def increment_and_store_counter(counter_name, block); end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#721
  def name(opts = T.unsafe(nil)); end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#654
  def nested?; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#787
  def nofooter; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#783
  def noheader; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#779
  def notitle; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#217
  def options; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#220
  def outfilesuffix; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#223
  def parent_document; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#520
  def parse(data = T.unsafe(nil)); end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#557
  def parsed?; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#229
  def path_resolver; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#825
  def playback_attributes(block_attributes); end

  # promote preface block (i.e., preamble block with title in book doctype) to preface section
  # FIXME: this should be handled by core
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/asciidoctor/document.rb#6
  def promote_preface_block; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#226
  def reader; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#199
  def references; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#593
  def register(type, value); end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#929
  def render(opts = T.unsafe(nil)); end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#612
  def resolve_id(text); end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#841
  def restore_attributes; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#775
  def revdate; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#176
  def safe; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#638
  def sections?; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#857
  def set_attribute(name, value = T.unsafe(nil)); end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#915
  def set_header_attribute(name, value = T.unsafe(nil), overwrite = T.unsafe(nil)); end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#667
  def source; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#672
  def source_lines; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#196
  def sourcemap; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#196
  def sourcemap=(_arg0); end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#235
  def syntax_highlighter; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#683
  def title; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#695
  def title=(title); end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#1086
  def to_s; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#986
  def write(output, target); end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#740
  def xreftext(xrefstyle = T.unsafe(nil)); end

  private

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#1102
  def apply_attribute_value_subs(value); end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#1160
  def clear_playback_attributes(attributes); end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#1141
  def create_converter(backend, delegate_backend); end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#1257
  def fill_datetime_attributes(attrs, input_mtime); end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#1120
  def limit_bytesize(str, max); end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#1134
  def resolve_docinfo_subs; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#1168
  def save_attributes; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#1289
  def update_backend_attributes(new_backend, init = T.unsafe(nil)); end

  # source://asciidoctor/2.0.23/lib/asciidoctor/document.rb#1372
  def update_doctype_attributes(new_doctype); end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/asciidoctor/image.rb#4
module Asciidoctor::Image
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/asciidoctor/image.rb#21
  def target_and_format; end

  class << self
    # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/asciidoctor/image.rb#9
    def format(image_path); end

    # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/asciidoctor/image.rb#13
    def target_and_format(image_path, attributes = T.unsafe(nil)); end
  end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/asciidoctor/image.rb#5
module Asciidoctor::Image::Base64Encoded; end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/asciidoctor/image.rb#6
Asciidoctor::Image::DataUriRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/asciidoctor/image.rb#7
Asciidoctor::Image::FormatAliases = T.let(T.unsafe(nil), Hash)

# TODO: add these methods to Asciidoctor core
#
# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/asciidoctor/list.rb#4
class Asciidoctor::List < ::Asciidoctor::AbstractBlock
  # source://asciidoctor/2.0.23/lib/asciidoctor/list.rb#13
  def initialize(parent, context, opts = T.unsafe(nil)); end

  # source://asciidoctor/2.0.23/lib/asciidoctor/abstract_block.rb#5
  def content; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/list.rb#24
  def convert; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/abstract_block.rb#5
  def items; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/abstract_block.rb#127
  def items?; end

  # Get the nesting level of this list within the broader list (unordered or ordered) structure.
  #
  # This method differs from the level property in that it considers only list ancestors.
  # It's important for selecting the marker for an unordered list.
  #
  # Return the 1-based level of this list within the list structure.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/asciidoctor/list.rb#18
  def list_level; end

  # Check whether this list is nested inside the item of another list.
  #
  # Return true if the parent of this list is a list item. Otherwise, return false.
  #
  # @return [Boolean]
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/asciidoctor/list.rb#8
  def nested?; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/list.rb#20
  def outline?; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/list.rb#24
  def render; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/list.rb#37
  def to_s; end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/version.rb#4
module Asciidoctor::PDF; end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#12
class Asciidoctor::PDF::Converter < ::Prawn::Document
  include ::Asciidoctor::Converter
  include ::Asciidoctor::Converter::BackendTraits
  include ::Asciidoctor::Logging
  include ::Asciidoctor::Writer
  include ::Asciidoctor::PDF::Measurements
  include ::Asciidoctor::PDF::Sanitizer
  include ::Asciidoctor::PDF::TextTransformer
  include ::Asciidoctor::Prawn::Extensions
  extend ::Asciidoctor::Converter::Config
  extend ::Asciidoctor::Logging

  # @return [Converter] a new instance of Converter
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#135
  def initialize(backend, opts); end

  # If an id is provided or the node passed as the first argument has an id,
  # add a named destination to the document equivalent to the node id at the
  # current y position. If the node does not have an id and an id is not
  # specified, do nothing.
  #
  # If the node is a section, and the current y position is the top of the
  # page, set the y position equal to the page height to improve the navigation
  # experience. If the current x position is at or inside the left margin, set
  # the x position equal to 0 (left edge of page) to improve the navigation
  # experience.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#2741
  def add_dest_for_block(node, id: T.unsafe(nil), y: T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#2757
  def add_outline(doc, num_levels, toc_page_nums, num_front_matter_pages, has_front_cover); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#2805
  def add_outline_level(outline, sections, num_levels, expand_levels); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#3324
  def allocate_running_content_layout(doc, page, periphery, cache); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#3842
  def allocate_toc(doc, toc_num_levels, toc_start_cursor, break_after_toc); end

  # Returns the value of attribute allow_uri_read.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#20
  def allow_uri_read; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#2821
  def apply_subs_discretely(doc, value, opts = T.unsafe(nil)); end

  # Position the cursor for where to ink the specified section title or discrete heading node.
  #
  # This method computes whether there's enough room on the page to prevent the specified node
  # from being orphaned. If there's not enough room, the method will advance the cursor to
  # the next page. This method is not called if the cursor is already at the top of the page or
  # whether this node has no node that follows it in document order.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#2852
  def arrange_heading(node, title, opts); end

  # FIXME: Pdfmark should use the PDF info result
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#514
  def build_pdf_info(doc); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#453
  def build_pdf_options(doc, theme); end

  # Returns the value of attribute cache_uri.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#22
  def cache_uri; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#149
  def convert(node, name = T.unsafe(nil), _opts = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#789
  def convert_abstract(node); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#884
  def convert_admonition(node); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#1894
  def convert_audio(node); end

  # QUESTION: can we avoid arranging fragments multiple times (conums & autofit) by eagerly preparing arranger?
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#1044
  def convert_code(node); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#1353
  def convert_colist(node); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#1377
  def convert_colist_item(node, opts); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#1218
  def convert_collapsible(node); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#1395
  def convert_dlist(node); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#161
  def convert_document(doc); end

  # NOTE: embedded only makes sense if perhaps we are building
  # on an existing Prawn::Document instance; for now, just treat
  # it the same as a full document.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#161
  def convert_embedded(doc); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#1236
  def convert_example(node); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#697
  def convert_floating_title(node); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#1707
  def convert_image(node, opts = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#727
  def convert_index_categories(categories, pagenum_sequence_style = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#712
  def convert_index_section(node); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#741
  def convert_index_term(term, pagenum_sequence_style = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#2440
  def convert_inline_anchor(node); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#2503
  def convert_inline_break(node); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#2507
  def convert_inline_button(node); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#2511
  def convert_inline_callout(node); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#2520
  def convert_inline_footnote(node); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#2537
  def convert_inline_icon(node); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#2604
  def convert_inline_image(node); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#2645
  def convert_inline_indexterm(node); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#2669
  def convert_inline_kbd(node); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#2677
  def convert_inline_menu(node); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#2689
  def convert_inline_quoted(node); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#1577
  def convert_list(node); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#1616
  def convert_list_item(node, list, opts = T.unsafe(nil)); end

  # QUESTION: can we avoid arranging fragments multiple times (conums & autofit) by eagerly preparing arranger?
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#1044
  def convert_listing(node); end

  # QUESTION: can we avoid arranging fragments multiple times (conums & autofit) by eagerly preparing arranger?
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#1044
  def convert_listing_or_literal(node); end

  # QUESTION: can we avoid arranging fragments multiple times (conums & autofit) by eagerly preparing arranger?
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#1044
  def convert_literal(node); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#1506
  def convert_olist(node); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#1255
  def convert_open(node); end

  # NOTE: to insert sequential page breaks, you must put {nbsp} between page breaks
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#1941
  def convert_page_break(node); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#844
  def convert_paragraph(node, opts = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#1964
  def convert_pass(node); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#779
  def convert_preamble(node); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#1272
  def convert_quote(node); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#1272
  def convert_quote_or_verse(node); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#637
  def convert_section(sect, _opts = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#1334
  def convert_sidebar(node); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#1971
  def convert_stem(node); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#1986
  def convert_table(node); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#2363
  def convert_thematic_break(node); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#2374
  def convert_toc(node, opts = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#1541
  def convert_ulist(node); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#1272
  def convert_verse(node); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#1903
  def convert_video(node); end

  # NOTE: only used when tabsize attribute is not specified
  # tabs must always be replaced with spaces in order for the indentation guards to work
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#2896
  def expand_tabs(string); end

  # Extract callout marks from string, indexed by 0-based line number
  # Return an Array with the processed string as the first argument
  # and the mapping of lines to conums as the second.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#2946
  def extract_conums(string); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#3025
  def fallback_svg_font_name; end

  # Returns the value of attribute font_color.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#26
  def font_color; end

  # Sets the attribute font_color
  #
  # @param value the value to set the attribute font_color to.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#26
  def font_color=(_arg0); end

  # Returns the value of attribute font_scale.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#28
  def font_scale; end

  # Sets the attribute font_scale
  #
  # @param value the value to set the attribute font_scale to.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#28
  def font_scale=(_arg0); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#3864
  def get_entries_for_toc(node); end

  # Add an indentation guard at the start of indented lines.
  # Expand tabs to spaces if tabs are present
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#3031
  def guard_indentation(string); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#3039
  def guard_indentation_in_fragments(fragments); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#3053
  def height_of_typeset_text(string, opts = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#621
  def indent_section; end

  # Returns the value of attribute index.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#30
  def index; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#363
  def init_pdf(doc); end

  # Render the caption in the current document. If the dry_run option is true, return the height.
  #
  # The subject argument can either be a String or an AbstractNode. If
  # subject is an AbstractNode, only call this method if the node has a
  # title (i.e., subject.title? returns true).
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#3071
  def ink_caption(subject, opts = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#3179
  def ink_chapter_title(node, title, opts = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#3185
  def ink_cover_page(doc, face); end

  # QUESTION: if a footnote ref appears in a separate chapter, should the footnote def be duplicated?
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#3213
  def ink_footnotes(node); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#3240
  def ink_general_heading(_node, title, opts = T.unsafe(nil)); end

  # NOTE: ink_heading doesn't set the theme font because it's used for various types of headings
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#3245
  def ink_heading(string, opts = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#3179
  def ink_part_title(node, title, opts = T.unsafe(nil)); end

  # NOTE: inline_format option is true by default
  # NOTE: single_line option is not compatible with this method
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#3294
  def ink_prose(string, opts = T.unsafe(nil)); end

  # TODO: delegate to ink_page_header and ink_page_footer per page
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#3505
  def ink_running_content(periphery, doc, skip = T.unsafe(nil), body_start_page_number = T.unsafe(nil)); end

  # Render the caption for a table and return the height of the rendered content
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#3175
  def ink_table_caption(node, table_alignment = T.unsafe(nil), table_width = T.unsafe(nil), max_width = T.unsafe(nil), end_ = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#3737
  def ink_title_page(doc); end

  # NOTE: num_front_matter_pages not used during a dry run
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#3869
  def ink_toc(doc, num_levels, toc_page_number, start_cursor, num_front_matter_pages = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#3909
  def ink_toc_level(entries, num_levels, dot_leader, num_front_matter_pages); end

  # Retrieve the intrinsic image dimensions for the specified path in pt.
  #
  # Returns a Hash containing :width and :height keys that map to the image's
  # intrinsic width and height values (in pt).
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#3998
  def intrinsic_image_dimensions(path, format); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4015
  def intrinsic_image_width(path, format); end

  # Returns the value of attribute jail_dir.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#24
  def jail_dir; end

  # Render the caption in the current document. If the dry_run option is true, return the height.
  #
  # The subject argument can either be a String or an AbstractNode. If
  # subject is an AbstractNode, only call this method if the node has a
  # title (i.e., subject.title? returns true).
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#3071
  def layout_caption(subject, opts = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#3179
  def layout_chapter_title(node, title, opts = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#3185
  def layout_cover_page(doc, face); end

  # QUESTION: if a footnote ref appears in a separate chapter, should the footnote def be duplicated?
  # Deprecated method names
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#3213
  def layout_footnotes(node); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#3240
  def layout_general_heading(_node, title, opts = T.unsafe(nil)); end

  # NOTE: ink_heading doesn't set the theme font because it's used for various types of headings
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#3245
  def layout_heading(string, opts = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#3179
  def layout_part_title(node, title, opts = T.unsafe(nil)); end

  # NOTE: inline_format option is true by default
  # NOTE: single_line option is not compatible with this method
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#3294
  def layout_prose(string, opts = T.unsafe(nil)); end

  # TODO: delegate to ink_page_header and ink_page_footer per page
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#3505
  def layout_running_content(periphery, doc, skip = T.unsafe(nil), body_start_page_number = T.unsafe(nil)); end

  # Render the caption for a table and return the height of the rendered content
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#3175
  def layout_table_caption(node, table_alignment = T.unsafe(nil), table_width = T.unsafe(nil), max_width = T.unsafe(nil), end_ = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#3737
  def layout_title_page(doc); end

  # NOTE: num_front_matter_pages not used during a dry run
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#3869
  def layout_toc(doc, num_levels, toc_page_number, start_cursor, num_front_matter_pages = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#3909
  def layout_toc_level(entries, num_levels, dot_leader, num_front_matter_pages); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#542
  def load_theme(doc); end

  # Sends the specified message to the log unless this method is called from the scratch document
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4020
  def log(severity, message = T.unsafe(nil), &block); end

  # Insert a margin at the specified side if the cursor is not at the top of
  # the page. Start a new page if amount is greater than the remaining space on
  # the page.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4027
  def margin(amount, _side); end

  # Insert a bottom margin equal to amount unless cursor is at the top of the
  # page (not likely). Start a new page instead if amount is greater than the
  # remaining space on the page.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4043
  def margin_bottom(amount); end

  # Insert a top margin equal to amount if cursor is not at the top of the
  # page. Start a new page instead if amount is greater than the remaining
  # space on the page.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4050
  def margin_top(amount); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4054
  def next_enclosed_block(block, descend: T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#629
  def outdent_section(enabled = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#570
  def prepare_theme(theme); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4075
  def register_fonts(font_catalog, fonts_dir); end

  # Compute the rendered width of a char, taking fallback fonts into account
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4092
  def rendered_width_of_char(char, opts = T.unsafe(nil)); end

  # Compute the rendered width of a string, taking fallback fonts into account
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4104
  def rendered_width_of_string(str, opts = T.unsafe(nil)); end

  # Deprecated
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4378
  def resolve_alignment_from_role(roles, query_theme: T.unsafe(nil), remove_predefined: T.unsafe(nil)); end

  # Resolve the path and sizing of the background image either from a document attribute or theme key.
  #
  # Returns the argument list for the image method if the document attribute or theme key is found. Otherwise,
  # nothing. The first argument in the argument list is the image path. If that value is nil, the background
  # image is disabled. The second argument is the options hash to specify the dimensions, such as width and fit.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4121
  def resolve_background_image(doc, theme, key, opts = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4162
  def resolve_doctitle(doc, partition = T.unsafe(nil)); end

  # Resolves the explicit width, if specified, as a PDF pt value.
  #
  # Resolves the explicit width, first considering the pdfwidth attribute, then the scaledwidth
  # attribute, then the theme default (if enabled by the :use_fallback option), and finally the
  # width attribute. If the specified value is in pixels, the value is scaled by 75% to perform
  # approximate CSS px to PDF pt conversion. If the value is a percentage, and the
  # bounds_width option is given, the percentage of the bounds_width value is returned.
  # Otherwise, the percentage width is returned.
  # --
  # QUESTION: should we enforce positive result?
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4182
  def resolve_explicit_width(attrs, opts = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4226
  def resolve_image_options(image_path, image_format, image_attrs, opts = T.unsafe(nil)); end

  # Resolve the system path of the specified image path.
  #
  # Resolve and normalize the absolute system path of the specified image,
  # taking into account the imagesdir attribute. If an image path is not
  # specified, the path is read from the target attribute of the specified
  # document node.
  #
  # If the target is a URI and the allow-uri-read attribute is set on the
  # document, read the file contents to a temporary file and return the path to
  # the temporary file. If the target is a URI and the allow-uri-read attribute
  # is not set, or the URI cannot be read, this method returns a nil value.
  #
  # When a temporary file is used, the file is stored in @tmp_files to be cleaned up after conversion.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4309
  def resolve_image_path(node, image_path, image_format, relative_to = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4357
  def resolve_page_margin(value); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4378
  def resolve_text_align_from_role(roles, query_theme: T.unsafe(nil), remove_predefined: T.unsafe(nil)); end

  # Restore the conums into the Array of formatted text fragments
  # --
  # QUESTION: can this be done more efficiently?
  # QUESTION: can we reuse arrange_fragments_by_line?
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#2978
  def restore_conums(fragments, conum_mapping, linenums = T.unsafe(nil), highlight_lines = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#614
  def save_theme; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4395
  def stamp_foreground_image(doc, has_front_cover); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4415
  def start_new_chapter(chapter); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4415
  def start_new_part(chapter); end

  # Returns a Boolean indicating whether the title page was created
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4423
  def start_title_page(doc); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4447
  def start_toc_page(node, placement); end

  # @return [Boolean]
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4452
  def supports_float_wrapping?(node); end

  # Returns the value of attribute text_decoration_width.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#34
  def text_decoration_width; end

  # Returns the value of attribute theme.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#32
  def theme; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4456
  def theme_fill_and_stroke_block(category, extent, opts = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4517
  def theme_fill_and_stroke_bounds(category, opts = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4524
  def theme_font(category, opts = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4575
  def theme_font_cascade(categories, &block); end

  # Lookup margin for theme element and side, then delegate to margin method.
  # If margin value is not found, assume 0.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4592
  def theme_margin(category, side, node = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#2399
  def traverse(node, opts = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#2422
  def traverse_list_item(node, list_type, opts = T.unsafe(nil)); end

  # QUESTION: combine with typeset_text?
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4622
  def typeset_formatted_text(fragments, line_metrics, opts = T.unsafe(nil)); end

  # TODO: document me, esp the first line formatting functionality
  # NOTE: single_line option should only be used if height option is specified
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4603
  def typeset_text(string, line_metrics, opts = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4635
  def write(pdf_doc, target); end

  private

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4692
  def add_dest_for_top(doc); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4703
  def add_link_to_image(uri, image_info, image_opts); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4730
  def admonition_icon_data(key); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4747
  def allocate_space_for_list_item(line_metrics); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4751
  def apply_text_decoration(styles, category, level = T.unsafe(nil)); end

  # Arrange fragments by line in an arranger and return an unfinalized arranger.
  #
  # Finalizing the arranger is deferred since it must be done in the context of
  # the global font settings you want applied to each fragment.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4767
  def arrange_fragments_by_line(fragments, _opts = T.unsafe(nil)); end

  # NOTE: assume URL is escaped (i.e., contains character references such as &amp;)
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4783
  def breakable_uri(uri); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#5286
  def clear_scratch; end

  # Calculate the font size (down to the minimum font size) that would allow
  # all the specified fragments to fit in the available width without wrapping lines.
  #
  # Return the calculated font size if an adjustment is necessary or nil if no
  # font size adjustment is necessary.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4799
  def compute_autofit_font_size(fragments, category); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4834
  def consolidate_fragments(fragments); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4816
  def consolidate_ranges(nums); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4848
  def conum_glyph(number); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#5245
  def create_scratch_prototype; end

  # Derive a PDF-safe, ASCII-only anchor name from the given value.
  # Encodes value into hex if it contains characters outside the ASCII range.
  # If value is nil, derive an anchor name from the default_value, if given.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4855
  def derive_anchor_from_id(value, default_value = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4863
  def draw_image_border(top, w, h, alignment); end

  # Reduce icon height to fit inside bounds.height. Icons will not render
  # properly if they are larger than the current bounds.height.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4881
  def fit_icon_to_bounds(preferred_size); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4885
  def fit_trim_box(page_ = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4894
  def font_path(font_file, fonts_dir); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4899
  def generate_manname_section(node); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4912
  def get_char(code); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4933
  def get_icon_image_path(node, type, resolve = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4916
  def get_page_bg_image(doc, theme_, layout, side); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4942
  def init_float_box(_node, block_width, block_height, float_to); end

  # NOTE: init_page is not called for imported pages, cover pages, image pages, and pages in the scratch document
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4957
  def init_page(doc, _self); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#5258
  def init_scratch(originator); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4987
  def ink_paragraph_in_float_box(node, float_box, prose_opts, role_keys, block_next, insert_margin_bottom); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#5044
  def insert_toc_section(doc, toc_title, toc_page_nums); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#5068
  def load_open_uri; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#5076
  def on_image_error(_reason, node, target, opts); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#5096
  def page_color_space; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#5278
  def pop_scratch(doc); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#5269
  def push_scratch(doc); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#5100
  def remove_tmp_files; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#5104
  def resolve_background_position(value, default_value = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#5136
  def resolve_font_kerning(keyword); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#5140
  def resolve_pagenums(val); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#5166
  def resolve_text_transform(key, use_fallback = T.unsafe(nil)); end

  # QUESTION: should we pass a category as an argument?
  # QUESTION: should we make this a method on the theme ostruct? (e.g., @theme.resolve_color key, fallback)
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#5176
  def resolve_theme_color(key, fallback_color = T.unsafe(nil), transparent_color = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#5154
  def resolve_top(val); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#5182
  def unlink_tmp_file(path); end

  # @return [Boolean]
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#5190
  def url?(str); end

  # Calculate the width that is needed to print all the
  # fragments without wrapping any lines.
  #
  # This method assumes endlines are represented as discrete entries in the
  # fragments array.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#5199
  def width_of_fragments(fragments); end

  # Promotes author to primary author attributes around block; restores original attributes after block executes
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#5212
  def with_author(doc, author, primary); end

  class << self
    # intercepts "class CustomPDFConverter < (Asciidoctor::Converter.for 'pdf')"
    #
    # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4674
    def method_added(method_sym); end

    # intercepts "(Asciidoctor::Converter.for 'pdf').prepend CustomConverterExtensions"
    #
    # source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#4684
    def prepend(*mods); end
  end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#42
Asciidoctor::PDF::Converter::AdmonitionIcons = T.let(T.unsafe(nil), Hash)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#56
Asciidoctor::PDF::Converter::AlignmentTable = T.let(T.unsafe(nil), Hash)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#70
Asciidoctor::PDF::Converter::AuthorAttributeNames = T.let(T.unsafe(nil), Hash)

# NOTE: default theme font uses ballot boxes from FontAwesome
#
# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#97
Asciidoctor::PDF::Converter::BallotBox = T.let(T.unsafe(nil), Hash)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#119
Asciidoctor::PDF::Converter::BlankLineRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#55
Asciidoctor::PDF::Converter::BlockAlignmentNames = T.let(T.unsafe(nil), Array)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#54
Asciidoctor::PDF::Converter::BlockFloatNames = T.let(T.unsafe(nil), Array)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#90
Asciidoctor::PDF::Converter::Bullets = T.let(T.unsafe(nil), Hash)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#111
Asciidoctor::PDF::Converter::CalloutExtractRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#120
Asciidoctor::PDF::Converter::CjkLineBreakRx = T.let(T.unsafe(nil), Regexp)

# NOTE: require_library doesn't support require_relative and we don't modify the load path for this gem
#
# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#37
Asciidoctor::PDF::Converter::CodeRayRequirePath = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#57
Asciidoctor::PDF::Converter::ColumnPositions = T.let(T.unsafe(nil), Array)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#101
Asciidoctor::PDF::Converter::ConumSets = T.let(T.unsafe(nil), Hash)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#85
Asciidoctor::PDF::Converter::DigitsRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#86
Asciidoctor::PDF::Converter::DotLeaderTextDefault = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#73
Asciidoctor::PDF::Converter::DoubleLF = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#71
Asciidoctor::PDF::Converter::DoubleSpace = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#122
Asciidoctor::PDF::Converter::DoubleSpaceRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#126
Asciidoctor::PDF::Converter::DropAnchorRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#84
Asciidoctor::PDF::Converter::DummyText = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#87
Asciidoctor::PDF::Converter::EmDash = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#53
Asciidoctor::PDF::Converter::FontKerningTable = T.let(T.unsafe(nil), Hash)

# a no-break space is used to replace a leading space to prevent Prawn from trimming indentation
# a leading zero-width space can't be used as it gets dropped when calculating the line width
#
# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#78
Asciidoctor::PDF::Converter::GuardedIndent = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#79
Asciidoctor::PDF::Converter::GuardedInnerIndent = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#124
Asciidoctor::PDF::Converter::HexColorRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#112
Asciidoctor::PDF::Converter::ImageAttributeValueRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#129
module Asciidoctor::PDF::Converter::ImageWidth; end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#50
Asciidoctor::PDF::Converter::IndentableTextAlignments = T.let(T.unsafe(nil), Hash)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#106
Asciidoctor::PDF::Converter::InlineFormatSniffRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#75
Asciidoctor::PDF::Converter::InnerIndent = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#72
Asciidoctor::PDF::Converter::LF = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#118
Asciidoctor::PDF::Converter::LineScanRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#89
Asciidoctor::PDF::Converter::LowercaseGreekA = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#109
Asciidoctor::PDF::Converter::MeasurementPartsRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#108
Asciidoctor::PDF::Converter::MeasurementRxt = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#82
Asciidoctor::PDF::Converter::NoBreakSpace = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#40
Asciidoctor::PDF::Converter::OptimizerRequirePath = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#69
Asciidoctor::PDF::Converter::PDFVersions = T.let(T.unsafe(nil), Hash)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#58
Asciidoctor::PDF::Converter::PageLayouts = T.let(T.unsafe(nil), Array)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#59
Asciidoctor::PDF::Converter::PageModes = T.let(T.unsafe(nil), Hash)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#68
Asciidoctor::PDF::Converter::PageSides = T.let(T.unsafe(nil), Array)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#110
Asciidoctor::PDF::Converter::PageSizeRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#39
Asciidoctor::PDF::Converter::PygmentsRequirePath = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#88
Asciidoctor::PDF::Converter::RightPointer = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#38
Asciidoctor::PDF::Converter::RougeRequirePath = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#107
Asciidoctor::PDF::Converter::SimpleAttributeRefRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#127
Asciidoctor::PDF::Converter::SourceHighlighters = T.let(T.unsafe(nil), Set)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#113
Asciidoctor::PDF::Converter::StopPunctRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#74
Asciidoctor::PDF::Converter::TAB = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#81
Asciidoctor::PDF::Converter::TabIndentRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#80
Asciidoctor::PDF::Converter::TabRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#49
Asciidoctor::PDF::Converter::TextAlignmentNames = T.let(T.unsafe(nil), Hash)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#51
Asciidoctor::PDF::Converter::TextAlignmentRoles = T.let(T.unsafe(nil), Hash)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#52
Asciidoctor::PDF::Converter::TextDecorationStyleTable = T.let(T.unsafe(nil), Hash)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#130
Asciidoctor::PDF::Converter::TitleStyles = T.let(T.unsafe(nil), Hash)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#105
Asciidoctor::PDF::Converter::TypographicQuotes = T.let(T.unsafe(nil), Array)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#115
Asciidoctor::PDF::Converter::UriBreakCharRepl = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#114
Asciidoctor::PDF::Converter::UriBreakCharsRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#116
Asciidoctor::PDF::Converter::UriSchemeBoundaryRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#117
Asciidoctor::PDF::Converter::UrlSniffRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#123
Asciidoctor::PDF::Converter::ValueSeparatorRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#128
module Asciidoctor::PDF::Converter::ViewportWidth; end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#125
Asciidoctor::PDF::Converter::VimeoThumbnailRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#121
Asciidoctor::PDF::Converter::WhitespaceChars = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/converter.rb#83
Asciidoctor::PDF::Converter::ZeroWidthSpace = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#7
module Asciidoctor::PDF::FormattedText; end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/formatter.rb#6
class Asciidoctor::PDF::FormattedText::Formatter
  include ::Asciidoctor::Logging
  extend ::Asciidoctor::Logging

  # @return [Formatter] a new instance of Formatter
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/formatter.rb#14
  def initialize(options = T.unsafe(nil)); end

  # The original purpose of this method is to split paragraphs, but our formatter only works on paragraphs that have
  # been presplit. Therefore, we just need to wrap the fragments in a single-element array (representing a single
  # paragraph) and return them.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/formatter.rb#37
  def array_paragraphs(fragments); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/formatter.rb#20
  def format(string, *args); end

  # Returns the value of attribute scratch.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/formatter.rb#9
  def scratch; end

  # Sets the attribute scratch
  #
  # @param value the value to set the attribute scratch to.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/formatter.rb#9
  def scratch=(_arg0); end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/formatter.rb#11
Asciidoctor::PDF::FormattedText::Formatter::FormattingSnifferPattern = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/formatter.rb#12
Asciidoctor::PDF::FormattedText::Formatter::WHITESPACE = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/fragment_position_renderer.rb#4
class Asciidoctor::PDF::FormattedText::FragmentPositionRenderer
  # Returns the value of attribute bottom.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/fragment_position_renderer.rb#7
  def bottom; end

  # Returns the value of attribute left.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/fragment_position_renderer.rb#8
  def left; end

  # Returns the value of attribute page_number.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/fragment_position_renderer.rb#9
  def page_number; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/fragment_position_renderer.rb#11
  def render_behind(fragment); end

  # Returns the value of attribute right.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/fragment_position_renderer.rb#6
  def right; end

  # Returns the value of attribute top.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/fragment_position_renderer.rb#5
  def top; end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/inline_destination_marker.rb#4
module Asciidoctor::PDF::FormattedText::InlineDestinationMarker
  private

  # render_behind is called before the text is printed
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/inline_destination_marker.rb#8
  def render_behind(fragment); end

  class << self
    # render_behind is called before the text is printed
    #
    # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/inline_destination_marker.rb#8
    def render_behind(fragment); end
  end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/inline_image_arranger.rb#4
module Asciidoctor::PDF::FormattedText::InlineImageArranger
  include ::Asciidoctor::PDF::Measurements
  include ::Asciidoctor::Logging
  extend ::Asciidoctor::Logging

  # Iterates over the fragments that represent inline images and prepares the
  # image data to be embedded into the document.
  #
  # This method populates the image_width, image_height, image_obj and
  # image_info (PNG only) keys on the fragment. The text is replaced with
  # placeholder text that will be used to reserve enough room in the line to
  # fit the image.
  #
  # The image height is scaled down to 75% of the specified width (px to pt
  # conversion). If the image height is more than 1.5x the height of the
  # surrounding line of text, the font size and line metrics of the fragment
  # are modified to fit the image in the line.
  #
  # If this is the scratch document, the image renderer callback is removed so
  # that the image is not embedded.
  #
  # When this method is called, the cursor is positioned at start of where this
  # group of fragments will be written (offset by the leading padding).
  #
  # This method is called each time the set of fragments overflow to another
  # page, so it's necessary to short-circuit if that case is detected.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/inline_image_arranger.rb#36
  def arrange_images(fragments); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/inline_image_arranger.rb#10
  def wrap(fragments); end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/inline_image_arranger.rb#8
Asciidoctor::PDF::FormattedText::InlineImageArranger::PlaceholderChar = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/inline_image_renderer.rb#4
module Asciidoctor::PDF::FormattedText::InlineImageRenderer
  include ::Asciidoctor::Logging
  extend ::Asciidoctor::Logging

  private

  # Embeds the image object in this fragment into the document in place of the
  # text that was previously used to reserve space for the image in the line.
  #
  # If the image height is less than 1.5x the height of the surrounding text,
  # it is centered vertically in the line. If the image height is greater, then
  # the image is aligned to the bottom of the text.
  #
  # Note that render_behind is called before the text is printed.
  #
  # This handler is only used on the main document (not the scratch document).
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/inline_image_renderer.rb#20
  def render_behind(fragment); end

  class << self
    # Embeds the image object in this fragment into the document in place of the
    # text that was previously used to reserve space for the image in the line.
    #
    # If the image height is less than 1.5x the height of the surrounding text,
    # it is centered vertically in the line. If the image height is greater, then
    # the image is aligned to the bottom of the text.
    #
    # Note that render_behind is called before the text is printed.
    #
    # This handler is only used on the main document (not the scratch document).
    #
    # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/inline_image_renderer.rb#20
    def render_behind(fragment); end
  end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/inline_text_aligner.rb#4
module Asciidoctor::PDF::FormattedText::InlineTextAligner
  private

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/inline_text_aligner.rb#7
  def render_behind(fragment); end

  class << self
    # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/inline_text_aligner.rb#7
    def render_behind(fragment); end
  end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#8
module Asciidoctor::PDF::FormattedText::Markup
  include ::Treetop::Runtime

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#608
  def _nt_attribute; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#567
  def _nt_attributes; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#776
  def _nt_cdata; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#948
  def _nt_character_decimal; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#992
  def _nt_character_hex; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#1036
  def _nt_character_name; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#842
  def _nt_charref; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#39
  def _nt_complex; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#108
  def _nt_element; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#722
  def _nt_end_tag; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#1128
  def _nt_spaces; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#284
  def _nt_start_tag; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#336
  def _nt_tag_name; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#15
  def _nt_text; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#178
  def _nt_void_element; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#512
  def _nt_void_tag_name; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#11
  def root; end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#595
module Asciidoctor::PDF::FormattedText::Markup::Attribute0
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#596
  def spaces; end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#602
module Asciidoctor::PDF::FormattedText::Markup::Attribute1
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#603
  def content; end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#556
module Asciidoctor::PDF::FormattedText::Markup::Attributes0
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#557
  def content; end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#770
module Asciidoctor::PDF::FormattedText::Markup::Cdata0
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#771
  def content; end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#815
module Asciidoctor::PDF::FormattedText::Markup::Charref0
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#816
  def character_decimal; end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#821
module Asciidoctor::PDF::FormattedText::Markup::Charref1
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#822
  def character_hex; end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#827
module Asciidoctor::PDF::FormattedText::Markup::Charref2; end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#830
module Asciidoctor::PDF::FormattedText::Markup::Charref3
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#831
  def content; end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#33
module Asciidoctor::PDF::FormattedText::Markup::Complex0
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#34
  def content; end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#87
module Asciidoctor::PDF::FormattedText::Markup::Element0
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#92
  def complex; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#96
  def end_tag; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#88
  def start_tag; end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#101
module Asciidoctor::PDF::FormattedText::Markup::Element1
  # NOTE: content only applies to non-void elements (second part of rule)
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#103
  def content; end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#709
module Asciidoctor::PDF::FormattedText::Markup::EndTag0
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#710
  def tag_name; end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#716
module Asciidoctor::PDF::FormattedText::Markup::EndTag1
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#717
  def name; end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#263
module Asciidoctor::PDF::FormattedText::Markup::StartTag0
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#268
  def attributes; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#264
  def tag_name; end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#274
module Asciidoctor::PDF::FormattedText::Markup::StartTag1
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#279
  def attributes; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#275
  def name; end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#158
module Asciidoctor::PDF::FormattedText::Markup::VoidElement0; end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#161
module Asciidoctor::PDF::FormattedText::Markup::VoidElement1
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#166
  def attributes; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#162
  def void_tag_name; end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#172
module Asciidoctor::PDF::FormattedText::Markup::VoidElement2
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#173
  def content; end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/parser.rb#1168
class Asciidoctor::PDF::FormattedText::MarkupParser < ::Treetop::Runtime::CompiledParser
  include ::Asciidoctor::PDF::FormattedText::Markup
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/source_wrap.rb#47
module Asciidoctor::PDF::FormattedText::SourceLineWrap
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/source_wrap.rb#48
  def update_line_status_based_on_last_output; end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/source_wrap.rb#6
module Asciidoctor::PDF::FormattedText::SourceWrap
  # Override Prawn::Text::Formatted::Box#wrap method to add line numbers in source blocks.
  # Note that this implementation assumes that the :single_line option is falsy.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/source_wrap.rb#11
  def wrap(array); end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/source_wrap.rb#7
Asciidoctor::PDF::FormattedText::SourceWrap::NoBreakSpace = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/text_background_and_border_renderer.rb#4
module Asciidoctor::PDF::FormattedText::TextBackgroundAndBorderRenderer
  private

  # render_behind is called before the text is printed
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/text_background_and_border_renderer.rb#10
  def render_behind(fragment); end

  class << self
    # render_behind is called before the text is printed
    #
    # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/text_background_and_border_renderer.rb#10
    def render_behind(fragment); end
  end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/text_background_and_border_renderer.rb#7
Asciidoctor::PDF::FormattedText::TextBackgroundAndBorderRenderer::DummyText = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/transform.rb#6
class Asciidoctor::PDF::FormattedText::Transform
  include ::Asciidoctor::PDF::TextTransformer

  # @return [Transform] a new instance of Transform
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/transform.rb#29
  def initialize(options = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/transform.rb#154
  def apply(parsed, fragments = T.unsafe(nil), inherited = T.unsafe(nil)); end

  private

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/transform.rb#265
  def build_fragment(fragment, tag_name, attrs); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/transform.rb#378
  def clone_fragment(fragment, append = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/transform.rb#426
  def extract_text(pcdata); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/transform.rb#438
  def restore_text(pcdata, text_chunks); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/transform.rb#390
  def to_styles(font_style, text_decoration = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/transform.rb#408
  def update_fragment(fragment, props); end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/transform.rb#11
Asciidoctor::PDF::FormattedText::Transform::CharEntityTable = T.let(T.unsafe(nil), Hash)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/transform.rb#12
Asciidoctor::PDF::FormattedText::Transform::CharRefRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/transform.rb#13
Asciidoctor::PDF::FormattedText::Transform::HexColorRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/transform.rb#9
Asciidoctor::PDF::FormattedText::Transform::LF = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/transform.rb#14
Asciidoctor::PDF::FormattedText::Transform::TextDecorationTable = T.let(T.unsafe(nil), Hash)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/transform.rb#15
Asciidoctor::PDF::FormattedText::Transform::ThemeKeyToFragmentProperty = T.let(T.unsafe(nil), Hash)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_text/transform.rb#10
Asciidoctor::PDF::FormattedText::Transform::ZeroWidthSpace = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/index_catalog.rb#5
class Asciidoctor::PDF::IndexCatalog
  include ::Asciidoctor::PDF::TextTransformer

  # @return [IndexCatalog] a new instance of IndexCatalog
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/index_catalog.rb#12
  def initialize; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/index_catalog.rb#72
  def categories; end

  # @return [Boolean]
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/index_catalog.rb#68
  def empty?; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/index_catalog.rb#53
  def find_category(name); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/index_catalog.rb#48
  def init_category(name); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/index_catalog.rb#61
  def link_dest_to_page(anchor, physical_page_number); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/index_catalog.rb#19
  def next_anchor_name; end

  # Returns the value of attribute start_page_number.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/index_catalog.rb#10
  def start_page_number; end

  # Sets the attribute start_page_number
  #
  # @param value the value to set the attribute start_page_number to.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/index_catalog.rb#10
  def start_page_number=(_arg0); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/index_catalog.rb#57
  def store_dest(dest); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/index_catalog.rb#33
  def store_primary_term(name, dest = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/index_catalog.rb#38
  def store_secondary_term(primary_name, secondary_name, dest = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/index_catalog.rb#23
  def store_term(names, dest); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/index_catalog.rb#43
  def store_tertiary_term(primary_name, secondary_name, tertiary_name, dest); end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/index_catalog.rb#8
Asciidoctor::PDF::IndexCatalog::LeadingAlphaRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/index_catalog.rb#103
class Asciidoctor::PDF::IndexTerm < ::Asciidoctor::PDF::IndexTermGroup
  # @return [IndexTerm] a new instance of IndexTerm
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/index_catalog.rb#104
  def initialize(name); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/index_catalog.rb#111
  def add_dest(dest); end

  # @return [Boolean]
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/index_catalog.rb#120
  def container?; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/index_catalog.rb#116
  def dests; end

  # @return [Boolean]
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/index_catalog.rb#124
  def leaf?; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/index_catalog.rb#92
  def subterms; end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/index_catalog.rb#101
class Asciidoctor::PDF::IndexTermCategory < ::Asciidoctor::PDF::IndexTermGroup; end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/index_catalog.rb#77
class Asciidoctor::PDF::IndexTermGroup
  include ::Comparable

  # @return [IndexTermGroup] a new instance of IndexTermGroup
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/index_catalog.rb#81
  def initialize(name); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/index_catalog.rb#96
  def <=>(other); end

  # Returns the value of attribute name.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/index_catalog.rb#79
  def name; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/index_catalog.rb#86
  def store_term(name, dest); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/index_catalog.rb#92
  def terms; end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/measurements.rb#5
module Asciidoctor::PDF::Measurements
  # Resolve measurement values in the string to PDF points.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/measurements.rb#53
  def resolve_measurement_values(str); end

  # Convert the specified string value to a pt value from the
  # specified unit of measurement (e.g., in, cm, mm, etc).
  # If the unit of measurement is not recognized, assume pt.
  #
  # Examples:
  #
  #  0.5in => 36.0
  #  100px => 75.0
  #  72blah => 72.0
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/measurements.rb#20
  def str_to_pt(val); end

  # Converts the specified float value to a pt value from the
  # specified unit of measurement (e.g., in, cm, mm, etc).
  # Raises an argument error if the unit of measurement is not recognized.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/measurements.rb#27
  def to_pt(num, units); end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/measurements.rb#7
Asciidoctor::PDF::Measurements::InsetMeasurementValueRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/measurements.rb#8
Asciidoctor::PDF::Measurements::MeasurementValueHintRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/measurements.rb#6
Asciidoctor::PDF::Measurements::MeasurementValueRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/pdfmark.rb#5
class Asciidoctor::PDF::Pdfmark
  include ::Asciidoctor::PDF::Sanitizer

  # @return [Pdfmark] a new instance of Pdfmark
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/pdfmark.rb#8
  def initialize(doc); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/pdfmark.rb#12
  def generate; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/pdfmark.rb#41
  def generate_file(pdf_file); end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/roman_numeral.rb#34
class Asciidoctor::PDF::RomanNumeral
  # @return [RomanNumeral] a new instance of RomanNumeral
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/roman_numeral.rb#51
  def initialize(initial_value, letter_case); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/roman_numeral.rb#68
  def next; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/roman_numeral.rb#72
  def next!; end

  # @return [Boolean]
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/roman_numeral.rb#81
  def nil_or_empty?; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/roman_numeral.rb#77
  def pred; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/roman_numeral.rb#60
  def to_r; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/roman_numeral.rb#56
  def to_s; end

  class << self
    # source://asciidoctor-pdf//lib/asciidoctor/pdf/roman_numeral.rb#85
    def int_to_roman(value); end

    # source://asciidoctor-pdf//lib/asciidoctor/pdf/roman_numeral.rb#96
    def roman_to_int(value); end
  end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/roman_numeral.rb#35
Asciidoctor::PDF::RomanNumeral::BaseDigits = T.let(T.unsafe(nil), Hash)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/sanitizer.rb#5
module Asciidoctor::PDF::Sanitizer
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/sanitizer.rb#49
  def encode_quotes(string); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/sanitizer.rb#45
  def escape_amp(string); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/sanitizer.rb#37
  def escape_xml(string); end

  # Strip leading, trailing and repeating whitespace, remove XML tags along with an enclosed null character, and
  # resolve all entities in the specified string.
  #
  # FIXME: move to a module so we can mix it in elsewhere
  # FIXME: add option to control escaping entities, or a filter mechanism in general
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/sanitizer.rb#31
  def sanitize(string, compact: T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/sanitizer.rb#41
  def unescape_xml(string); end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/sanitizer.rb#14
Asciidoctor::PDF::Sanitizer::BuiltInNamedEntities = T.let(T.unsafe(nil), Hash)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/sanitizer.rb#23
Asciidoctor::PDF::Sanitizer::CharRefRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/sanitizer.rb#12
Asciidoctor::PDF::Sanitizer::InverseXMLSpecialChars = T.let(T.unsafe(nil), Hash)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/sanitizer.rb#13
Asciidoctor::PDF::Sanitizer::InverseXMLSpecialCharsRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/sanitizer.rb#22
Asciidoctor::PDF::Sanitizer::SanitizeXMLRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/sanitizer.rb#24
Asciidoctor::PDF::Sanitizer::UnescapedAmpersandRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/sanitizer.rb#6
Asciidoctor::PDF::Sanitizer::XMLSpecialChars = T.let(T.unsafe(nil), Hash)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/sanitizer.rb#11
Asciidoctor::PDF::Sanitizer::XMLSpecialCharsRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/section_info_by_page.rb#5
class Asciidoctor::PDF::SectionInfoByPage
  # @return [SectionInfoByPage] a new instance of SectionInfoByPage
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/section_info_by_page.rb#6
  def initialize(title_method); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/section_info_by_page.rb#19
  def [](pgnum); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/section_info_by_page.rb#11
  def []=(pgnum, val); end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/text_transformer.rb#5
module Asciidoctor::PDF::TextTransformer
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/text_transformer.rb#29
  def capitalize_words(string); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/text_transformer.rb#21
  def capitalize_words_pcdata(string); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/text_transformer.rb#49
  def hyphenate_words(string, hyphenator); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/text_transformer.rb#33
  def hyphenate_words_pcdata(string, hyphenator); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/text_transformer.rb#53
  def lowercase_pcdata(string); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/text_transformer.rb#77
  def smallcaps(string); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/text_transformer.rb#69
  def smallcaps_pcdata(string); end

  # Apply the text transform to the specified text.
  #
  # Supported transform values are "uppercase", "lowercase", or "none" (passed
  # as either a String or a Symbol). When the uppercase transform is applied to
  # the text, it correctly uppercases visible text while leaving markup and
  # named character entities unchanged. The none transform returns the text
  # unmodified.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/text_transformer.rb#89
  def transform_text(text, transform); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/text_transformer.rb#61
  def uppercase_pcdata(string); end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/text_transformer.rb#11
Asciidoctor::PDF::TextTransformer::BareClassRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/text_transformer.rb#9
Asciidoctor::PDF::TextTransformer::ContiguousCharsRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/text_transformer.rb#12
Asciidoctor::PDF::TextTransformer::Hyphen = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/text_transformer.rb#14
Asciidoctor::PDF::TextTransformer::LowerAlphaChars = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/text_transformer.rb#7
Asciidoctor::PDF::TextTransformer::PCDATAFilterRx = T.let(T.unsafe(nil), Regexp)

# NOTE: use more widely-supported ғ instead of ꜰ as replacement for F
# NOTE: use more widely-supported ǫ instead of ꞯ as replacement for Q
# NOTE: use more widely-supported s (lowercase latin "s") instead of ꜱ as replacement for S
# NOTE: in small caps, x (lowercase latin "x") remains unchanged
#
# source://asciidoctor-pdf//lib/asciidoctor/pdf/text_transformer.rb#19
Asciidoctor::PDF::TextTransformer::SmallCapsChars = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/text_transformer.rb#13
Asciidoctor::PDF::TextTransformer::SoftHyphen = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/text_transformer.rb#8
Asciidoctor::PDF::TextTransformer::TagFilterRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/text_transformer.rb#10
Asciidoctor::PDF::TextTransformer::WordRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/text_transformer.rb#6
Asciidoctor::PDF::TextTransformer::XMLMarkupRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_data.rb#5
class Asciidoctor::PDF::ThemeData
  # @return [ThemeData] a new instance of ThemeData
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_data.rb#8
  def initialize(data = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_data.rb#12
  def [](name); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_data.rb#16
  def []=(name, value); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_data.rb#28
  def delete_field(name); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_data.rb#32
  def dup; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_data.rb#20
  def each_pair(&block); end

  # @return [Boolean]
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_data.rb#24
  def eql?(other); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_data.rb#36
  def method_missing(name, *args); end

  # @return [Boolean]
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_data.rb#44
  def respond_to?(name, _include_all = T.unsafe(nil)); end

  # Returns the value of attribute table.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_data.rb#6
  def table; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_data.rb#52
  def to_h; end

  private

  # @return [Boolean]
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_data.rb#48
  def respond_to_missing?(name, _include_all = T.unsafe(nil)); end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_loader.rb#8
class Asciidoctor::PDF::ThemeLoader
  include ::Asciidoctor::PDF::Measurements
  include ::Asciidoctor::Logging
  extend ::Asciidoctor::Logging

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_loader.rb#125
  def load(hash, theme_data = T.unsafe(nil)); end

  private

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_loader.rb#197
  def evaluate(expr, vars, math: T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_loader.rb#231
  def evaluate_math(expr); end

  # NOTE: we assume expr is a String
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_loader.rb#209
  def expand_vars(expr, vars); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_loader.rb#131
  def process_entry(key, val, data, normalize_key = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_loader.rb#219
  def resolve_var(vars, ref, var); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_loader.rb#267
  def to_color(value); end

  class << self
    # NOTE: base theme is loaded "as is" (no post-processing)
    #
    # source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_loader.rb#70
    def load_base_theme; end

    # source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_loader.rb#99
    def load_file(filename, theme_data = T.unsafe(nil), theme_dir = T.unsafe(nil)); end

    # source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_loader.rb#76
    def load_theme(theme_name = T.unsafe(nil), theme_dir = T.unsafe(nil)); end

    # source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_loader.rb#65
    def resolve_theme_asset(asset_path, theme_dir = T.unsafe(nil)); end

    # source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_loader.rb#48
    def resolve_theme_file(theme_name = T.unsafe(nil), theme_dir = T.unsafe(nil)); end
  end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_loader.rb#25
Asciidoctor::PDF::ThemeLoader::AddSubtractOpRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_loader.rb#15
Asciidoctor::PDF::ThemeLoader::BaseThemePath = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_loader.rb#16
Asciidoctor::PDF::ThemeLoader::BundledThemeNames = T.let(T.unsafe(nil), Array)

# A marker module for a normalized CMYK array
# Prevents normalizing CMYK value more than once
#
# source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_loader.rb#33
module Asciidoctor::PDF::ThemeLoader::CMYKColorValue
  include ::Asciidoctor::PDF::ThemeLoader::ColorValue

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_loader.rb#35
  def to_s; end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_loader.rb#29
module Asciidoctor::PDF::ThemeLoader::ColorValue; end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_loader.rb#12
Asciidoctor::PDF::ThemeLoader::DataDir = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_loader.rb#17
Asciidoctor::PDF::ThemeLoader::DeprecatedCategoryKeys = T.let(T.unsafe(nil), Hash)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_loader.rb#18
Asciidoctor::PDF::ThemeLoader::DeprecatedKeys = T.let(T.unsafe(nil), Hash)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_loader.rb#14
Asciidoctor::PDF::ThemeLoader::FontsDir = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_loader.rb#23
Asciidoctor::PDF::ThemeLoader::HexColorEntryRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_loader.rb#40
class Asciidoctor::PDF::ThemeLoader::HexColorValue < ::String
  include ::Asciidoctor::PDF::ThemeLoader::ColorValue
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_loader.rb#22
Asciidoctor::PDF::ThemeLoader::LoneVariableRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_loader.rb#24
Asciidoctor::PDF::ThemeLoader::MultiplyDivideOpRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_loader.rb#19
Asciidoctor::PDF::ThemeLoader::PaddingBottomHackKeys = T.let(T.unsafe(nil), Array)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_loader.rb#26
Asciidoctor::PDF::ThemeLoader::PrecisionFuncRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_loader.rb#27
Asciidoctor::PDF::ThemeLoader::RoleAlignKeyRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_loader.rb#13
Asciidoctor::PDF::ThemeLoader::ThemesDir = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_loader.rb#44
class Asciidoctor::PDF::ThemeLoader::TransparentColorValue < ::String
  include ::Asciidoctor::PDF::ThemeLoader::ColorValue
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/theme_loader.rb#21
Asciidoctor::PDF::ThemeLoader::VariableRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/version.rb#5
Asciidoctor::PDF::VERSION = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/images.rb#4
module Asciidoctor::Prawn; end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#11
module Asciidoctor::Prawn::Extensions
  include ::Asciidoctor::PDF::Measurements
  include ::Asciidoctor::PDF::Sanitizer
  include ::Asciidoctor::PDF::TextTransformer

  # This method is a smarter version of start_new_page. It only calls start_new_page options are
  # specified and the current page is the last page in the document. Otherwise, it advances the
  # cursor to the next page (or column) using Bounds#move_past_bottom.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#955
  def advance_page(options = T.unsafe(nil)); end

  # Scratch
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#967
  def allocate_scratch_prototype; end

  # Yields to the specified block multiple times, first to determine where to render the content
  # so it fits properly, then once more, this time providing access to the content's extent, to
  # ink the content in the primary document.
  #
  # This method yields to the specified block in a scratch document by calling dry_run to
  # determine where the content should start in the primary document. In the process, it also
  # computes the extent of the content. It then returns to the primary document and yields to
  # the block again, this time passing in the extent of the content. The extent can be used to
  # draw a border and/or background under the content before inking it.
  #
  # This method is intended to enclose the conversion of a single content block, such as a
  # sidebar or example block. The arrange logic attempts to keep unbreakable content on the same
  # page, keeps the top caption pinned to the top of the content, computes the extent of the
  # content for the purpose of drawing a border and/or background underneath it, and ensures
  # that the extent does not begin near the bottom of a page if the first line of content
  # doesn't fit. If unbreakable content does not fit on a single page, the content is treated as
  # breakable.
  #
  # The block passed to this method should use advance_page to move to the next page rather than
  # start_new_page. Using start_new_page can mangle the calculation of content block's extent.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#1004
  def arrange_block(node, &block); end

  # Returns whether the cursor is at the top of the page (i.e., margin box).
  #
  # @return [Boolean]
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#254
  def at_page_top?; end

  # Returns the total left margin (to the page edge) for the current bounds.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#220
  def bounds_margin_left; end

  # Returns the total right margin (to the page edge) for the current bounds.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#226
  def bounds_margin_right; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#415
  def calc_line_metrics(line_height, font = T.unsafe(nil), font_size = T.unsafe(nil)); end

  # Retrieves the catalog reference data for the PDF.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#127
  def catalog; end

  # Wraps the column_box method and automatically sets the height unless the :height option is specified.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#697
  def column_box(point, options, &block); end

  # Prevents at_page_top? from returning true while yielding to the specified block.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#260
  def conceal_page_top; end

  # Deletes the current page and move the cursor
  # to the previous page.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#865
  def delete_current_page; end

  # Generates a destination object that resolves to the top of the page
  # specified by the page_num parameter or the current page if no page number
  # is provided. The destination preserves the user's zoom level unlike
  # the destinations generated by the outline builder.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#281
  def dest_top(page_num = T.unsafe(nil)); end

  # NOTE: override built-in draw_indented_formatted_line to set first_line flag
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#462
  def draw_indented_formatted_line(string, options); end

  # Yields to the specified block within the context of a scratch document up to three times to
  # acertain the extent of the content block.
  #
  # The purpose of this method is two-fold. First, it works out the position where the rendered
  # content should start in the calling document. Then, it precomputes the extent of the content
  # starting from that position.
  #
  # This method returns the content's extent (the range from the start page and cursor to the
  # end page and cursor) as a ScratchExtent object or, if the onto keyword parameter is
  # specified, an Extent object. A ScratchExtent always starts the page range at 1. When the
  # ScratchExtent is positioned onto the primary document using ScratchExtent#position_onto,
  # that's when the cursor may be advanced to the next page.
  #
  # This method performs all work in a scratch document (or documents). It begins by starting a
  # new page in the scratch document, first creating the scratch document if necessary. It then
  # applies all the settings from the main document to the scratch document that impact
  # rendering. This includes the bounds, the cursor position, and the font settings. This method
  # assumes that the content area remains constant when content flows from one page to the next.
  #
  # From this point, the number of attempts the method makes is determined by the value of the
  # keep_together keyword parameter. If the value is true (or the parent document is inhibiting
  # page creation), it starts from the top of the page, yields to the block, and tries to fit
  # the content on the current page. If the content fits, it computes and returns the
  # ScratchExtent (or Extent). If the content does not fit, it first checks if this scenario
  # should stop the operation. If the parent document is inhibiting page creation, it bubbles
  # the error. If the single_page keyword argument is :enforce, it raises a CannotFit error. If
  # the single_page keyword argument is true, it returns a ScratchExtent (or Extent) that
  # represents a full page. If none of those conditions are met, it restarts with the
  # keep_together parameter unset.
  #
  # If the keep_together parameter is not true, the method tries to render the content in the
  # scratch document from the location of the cursor in the main document. If the cursor is at
  # the top of the page, no special conditions are applied (this is the last attempt). The
  # content is rendered and the extent is computed based on where the content ended up (minus a
  # trailing empty page). If the cursor is not at the top of the page, the method renders the
  # content while listening for a page creation event before any content is written. If a new
  # page is created, and no content is written on the first page, the method restarts with the
  # cursor at the top of the page.
  #
  # Note that if the block has content that itself requires a dry run, that nested dry run will
  # be performed in a separate scratch document.
  #
  # The block passed to dry run should take steps to avoid leaving the document state modified.
  # This can be done by calling `push_scratch doc` at the start of the block and `pop_scratch`
  # in the ensure clause of the block.
  #
  # options - A Hash of options that configure the dry run computation:
  #           :keep_together - A Boolean indicating whether an attempt should be made to keep
  #           the content on the same page (optional, default: false).
  #           :single_page - A Boolean indicating whether the operation should stop if the
  #           content exceeds the height of a single page.
  #           :onto - The document onto which to position the scratch extent. If this option is
  #           set, the method returns an Extent instance (optional, default: false)
  #           :pages_advanced - The number of pages the content has been advanced during this
  #           operation (internal only) (optional, default: 0)
  #
  # Returns an Extent or ScratchExtent object that describes the bounds of the content block.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#1141
  def dry_run(keep_together: T.unsafe(nil), pages_advanced: T.unsafe(nil), single_page: T.unsafe(nil), onto: T.unsafe(nil), &block); end

  # Returns the effective (writable) height of the page
  #
  # If inside a fixed-height bounding box, returns height of box.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#155
  def effective_page_height; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#638
  def expand_grid_values(shorthand, default = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#610
  def expand_indent_value(value); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#614
  def expand_margin_value(shorthand); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#614
  def expand_padding_value(shorthand); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#659
  def expand_rect_values(shorthand, default = T.unsafe(nil)); end

  # Fills the absolute bounding box with the specified fill color. Before
  # returning from this method, the original fill color on the document is
  # restored.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#732
  def fill_absolute_bounds(f_color); end

  # Fills the current bounds using the specified fill color and strokes the
  # bounds using the specified stroke color. Sets the line with if specified
  # in the options. Before returning from this method, the original fill
  # color, stroke color and line width on the document are restored.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#741
  def fill_and_stroke_bounds(f_color = T.unsafe(nil), s_color = T.unsafe(nil), options = T.unsafe(nil)); end

  # Fills the current bounding box with the specified fill color. Before
  # returning from this method, the original fill color on the document is
  # restored.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#722
  def fill_bounds(f_color); end

  # NOTE: override built-in fill_formatted_text_box to insert leading before second line when :first_line is true
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#437
  def fill_formatted_text_box(text, options); end

  # Override the built-in float method to add support for restoring the current column of a ColumnBox
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#532
  def float; end

  # A flowing version of bounding_box. If the content runs to another page, the cursor starts at
  # the top of the page instead of from the original cursor position. Similar to span, except
  # the :position option is limited to a numeric value and additional options are passed through
  # to bounding_box.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#707
  def flow_bounding_box(options = T.unsafe(nil)); end

  # Enhances the built-in font method to allow the font
  # size to be specified as the second option and to
  # lazily load font-based icons.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#321
  def font(name = T.unsafe(nil), options = T.unsafe(nil)); end

  # Retrieves the current font name (i.e., family).
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#334
  def font_family; end

  # Retrieves the current font info (family, style, size) as a Hash
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#342
  def font_info; end

  # Retrieves the current font name (i.e., family).
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#334
  def font_name; end

  # Applies points as a scale factor of the current font if the value provided
  # is less than or equal to 1 or it's a string (e.g., 1.1em), then delegates to the super
  # implementation to carry out the built-in functionality.
  #
  # --
  # QUESTION: should we round the result?
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#362
  def font_size(points = T.unsafe(nil)); end

  # Set the font style on the document, if a style is given, otherwise return the current font style.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#348
  def font_style(style = T.unsafe(nil)); end

  # Retreives the collection of font styles from the given font style key,
  # which defaults to the current font style.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#397
  def font_styles(style = T.unsafe(nil)); end

  # remove once fixed upstream; see https://github.com/prawnpdf/prawn/pull/1122
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#160
  def generate_margin_box; end

  # Gets the destination registered for the specified name. The return value
  # matches that which was passed to the add_dest method.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#288
  def get_dest(name, node = T.unsafe(nil)); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#524
  def hyphenate_text(text, hyphenator); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#407
  def icon_font_data(family); end

  # Create a new page for the specified image.
  #
  # The image is positioned relative to the boundaries of the page.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#929
  def image_page(file, options = T.unsafe(nil)); end

  # Import the specified page into the current document.
  #
  # By default, advance to the next page afterwards, creating it if necessary.
  # This behavior can be disabled by passing the option `advance: false`.
  # However, due to how page creation works in Prawn, understand that advancing
  # to the next page is necessary to prevent the size & layout of the imported
  # page from affecting a newly created page.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#894
  def import_page(file, options = T.unsafe(nil)); end

  # Returns whether the current page is the last page in the document.
  #
  # @return [Boolean]
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#270
  def last_page?; end

  # Retrieves the compatiblity version of the PDF.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#133
  def min_version; end

  # Short-circuits the call to the built-in move_down operation
  # when n is 0.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#558
  def move_down(n); end

  # Override built-in move_text_position method to prevent Prawn from advancing
  # to next page if image doesn't fit before rendering image.
  # --
  # NOTE: could use :at option when calling image/embed_image instead
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#553
  def move_text_position(h); end

  # Short-circuits the call to the built-in move_up operation
  # when n is 0.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#545
  def move_up(n); end

  # Augments the built-in pad method by adding support for specifying padding on all four sizes.
  #
  # Padding may be specified as an array of four values, or as a single value.
  # The single value is used as the padding around all four sides of the box.
  #
  # If padding is nil, this method simply yields to the block and returns.
  #
  # Example:
  #
  #  pad_box 20 do
  #    text 'A paragraph inside a blox with even padding from all edges.'
  #  end
  #
  #  pad_box [10, 5] do
  #    text 'A paragraph inside a box with different padding from ends and sides.'
  #  end
  #
  #  pad_box [5, 10, 15, 20] do
  #    text 'A paragraph inside a box with different padding from each edge.'
  #  end
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#585
  def pad_box(padding, node = T.unsafe(nil)); end

  # Returns the height of the current page from edge-to-edge
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#147
  def page_height; end

  # Returns the margins for the current page as a 4 element array (top, right, bottom, left)
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#190
  def page_margin; end

  # Returns the width of the bottom margin for the current page
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#214
  def page_margin_bottom; end

  # Returns the width of the left margin for the current page
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#196
  def page_margin_left; end

  # Returns the width of the right margin for the current page
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#202
  def page_margin_right; end

  # Returns the width of the top margin for the current page
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#208
  def page_margin_top; end

  # Returns the side the current page is facing, :recto or :verso.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#232
  def page_side(pgnum = T.unsafe(nil), invert = T.unsafe(nil)); end

  # Returns the width of the current page from edge-to-edge
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#141
  def page_width; end

  # Parse the text into an array of fragments using the text formatter.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#425
  def parse_text(string, options = T.unsafe(nil)); end

  # Perform an operation (such as creating a new page) without triggering the on_page_create callback
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#945
  def perform_discretely; end

  # This method installs an on_page_create_callback that stops processing if the first page is
  # exceeded while yielding to the specified block. If the content fits on a single page, the
  # processing is not stopped. The purpose of this method is to determine if the content fits on
  # a single page.
  #
  # Returns a Boolean indicating whether the content fits on a single page.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#1032
  def perform_on_single_page; end

  # Returns whether the page is a recto page.
  #
  # @return [Boolean]
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#242
  def recto_page?(pgnum = T.unsafe(nil)); end

  # Registers a new custom font described in the data parameter
  # after converting the font name to a String.
  #
  # Example:
  #
  #  register_font Roboto: {
  #    normal: 'fonts/roboto-normal.ttf',
  #    italic: 'fonts/roboto-italic.ttf',
  #    bold: 'fonts/roboto-bold.ttf',
  #    bold_italic: 'fonts/roboto-bold_italic.ttf'
  #  }
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#313
  def register_font(data); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#384
  def resolve_font_style(styles); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#411
  def resolve_legacy_icon_name(name); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#971
  def scratch; end

  # @return [Boolean]
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#975
  def scratch?; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#379
  def set_font(font, size = T.unsafe(nil)); end

  # Set the margins for the current page.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#182
  def set_page_margin(margin); end

  # Stretch the current bounds to the left and right edges of the current page
  # while yielding the specified block if the verdict argument is true.
  # Otherwise, simply yield the specified block.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#686
  def span_page_width_if(verdict); end

  # Start a new page without triggering the on_page_create callback
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#961
  def start_new_page_discretely(options = T.unsafe(nil)); end

  # This method installs an on_page_create_callback that stops processing if a new page is
  # created without writing content to the first page while yielding to the specified block. If
  # any content is written to the first page, processing is not stopped. The purpose of this
  # method is to check whether any content fits on the remaining space on the current page.
  #
  # Returns a Boolean indicating whether any content is written on the first page.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#1048
  def stop_if_first_page_empty; end

  # Strokes a horizontal line using the current bounds. The width of the line
  # can be specified using the line_width option. The offset from the cursor
  # can be set using the at option.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#806
  def stroke_horizontal_rule(rule_color = T.unsafe(nil), options = T.unsafe(nil)); end

  # A compliment to the stroke_horizontal_rule method, strokes a
  # vertical line using the current bounds. The width of the line
  # can be specified using the line_width option. The horizontal (x)
  # position can be specified using the at option.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#839
  def stroke_vertical_rule(rule_color = T.unsafe(nil), options = T.unsafe(nil)); end

  # This method delegates to the provided block, then tares (i.e., resets) the content stream of
  # the initial page.
  #
  # The purpose of this method is to ink content while making it appear as though the page is
  # empty. This technique allows the caller to detect whether any subsequent content was written
  # to the page following the content inked by the block. It's often used to keep the title of a
  # content block with the block's first child.
  #
  # NOTE: this method should only used inside dry_run since that's when DetectEmptyFirstPage is active
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#1068
  def tare_first_page_content_stream; end

  # Performs the same work as Prawn::Text.text except that the first_line_options are applied to the first line of text
  # renderered. It's necessary to use low-level APIs in this method so we only style the first line and not the
  # remaining lines (which is the default behavior in Prawn).
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#469
  def text_with_formatted_first_line(string, first_line_options, options); end

  # Returns whether the page is a verso page.
  #
  # @return [Boolean]
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#248
  def verso_page?(pgnum = T.unsafe(nil)); end

  # Override width of string to check for placeholder char, which uses character spacing to control width
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#403
  def width_of_string(string, options); end

  # @yield [dry_run(&block).position_onto self, cursor]
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#979
  def with_dry_run(&block); end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#16
Asciidoctor::Prawn::Extensions::ColumnBox = Prawn::Document::ColumnBox

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#113
module Asciidoctor::Prawn::Extensions::DetectEmptyFirstPage; end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#115
Asciidoctor::Prawn::Extensions::DetectEmptyFirstPageProc = T.let(T.unsafe(nil), Proc)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#39
class Asciidoctor::Prawn::Extensions::Extent < ::Struct
  # @return [Extent] a new instance of Extent
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#40
  def initialize(current_page, current_column, current_cursor, from_page, from_column, from_cursor, to_page, to_cursor); end

  # Returns the value of attribute current
  #
  # @return [Object] the current value of current
  def current; end

  # Sets the attribute current
  #
  # @param value [Object] the value to set the attribute current to.
  # @return [Object] the newly set value
  def current=(_); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#47
  def each_page; end

  # Returns the value of attribute from
  #
  # @return [Object] the current value of from
  def from; end

  # Sets the attribute from
  #
  # @param value [Object] the value to set the attribute from to.
  # @return [Object] the newly set value
  def from=(_); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#61
  def page_range; end

  # @return [Boolean]
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#53
  def single_page?; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#57
  def single_page_height; end

  # Returns the value of attribute to
  #
  # @return [Object] the current value of to
  def to; end

  # Sets the attribute to
  #
  # @param value [Object] the value to set the attribute to to.
  # @return [Object] the newly set value
  def to=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#18
Asciidoctor::Prawn::Extensions::FontAwesomeIconSets = T.let(T.unsafe(nil), Array)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#22
Asciidoctor::Prawn::Extensions::FontStyleToSet = T.let(T.unsafe(nil), Hash)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#20
Asciidoctor::Prawn::Extensions::IconSetPrefixes = T.let(T.unsafe(nil), Array)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#19
Asciidoctor::Prawn::Extensions::IconSets = T.let(T.unsafe(nil), Set)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#108
Asciidoctor::Prawn::Extensions::InhibitNewPageProc = T.let(T.unsafe(nil), Proc)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#21
Asciidoctor::Prawn::Extensions::InitialPageContent = T.let(T.unsafe(nil), String)

# - :height is the height of a line
# - :leading is spacing between adjacent lines
# - :padding_top is half line spacing, plus any line_gap in the font
# - :padding_bottom is half line spacing
# - :final_gap determines whether a gap is added below the last line
#
# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#35
class Asciidoctor::Prawn::Extensions::LineMetrics < ::Struct
  # Returns the value of attribute final_gap
  #
  # @return [Object] the current value of final_gap
  def final_gap; end

  # Sets the attribute final_gap
  #
  # @param value [Object] the value to set the attribute final_gap to.
  # @return [Object] the newly set value
  def final_gap=(_); end

  # Returns the value of attribute height
  #
  # @return [Object] the current value of height
  def height; end

  # Sets the attribute height
  #
  # @param value [Object] the value to set the attribute height to.
  # @return [Object] the newly set value
  def height=(_); end

  # Returns the value of attribute leading
  #
  # @return [Object] the current value of leading
  def leading; end

  # Sets the attribute leading
  #
  # @param value [Object] the value to set the attribute leading to.
  # @return [Object] the newly set value
  def leading=(_); end

  # Returns the value of attribute padding_bottom
  #
  # @return [Object] the current value of padding_bottom
  def padding_bottom; end

  # Sets the attribute padding_bottom
  #
  # @param value [Object] the value to set the attribute padding_bottom to.
  # @return [Object] the newly set value
  def padding_bottom=(_); end

  # Returns the value of attribute padding_top
  #
  # @return [Object] the current value of padding_top
  def padding_top; end

  # Sets the attribute padding_top
  #
  # @param value [Object] the value to set the attribute padding_top to.
  # @return [Object] the newly set value
  def padding_top=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#106
class Asciidoctor::Prawn::Extensions::NewPageRequiredError < ::StopIteration; end

# NOTE: must use a visible char for placeholder or else Prawn won't reserve space for the fragment
#
# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#28
Asciidoctor::Prawn::Extensions::PlaceholderChar = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#37
class Asciidoctor::Prawn::Extensions::Position < ::Struct
  # Returns the value of attribute column
  #
  # @return [Object] the current value of column
  def column; end

  # Sets the attribute column
  #
  # @param value [Object] the value to set the attribute column to.
  # @return [Object] the newly set value
  def column=(_); end

  # Returns the value of attribute cursor
  #
  # @return [Object] the current value of cursor
  def cursor; end

  # Sets the attribute cursor
  #
  # @param value [Object] the value to set the attribute cursor to.
  # @return [Object] the newly set value
  def cursor=(_); end

  # Returns the value of attribute page
  #
  # @return [Object] the current value of page
  def page; end

  # Sets the attribute page
  #
  # @param value [Object] the value to set the attribute page to.
  # @return [Object] the newly set value
  def page=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#66
class Asciidoctor::Prawn::Extensions::ScratchExtent < ::Struct
  # @return [ScratchExtent] a new instance of ScratchExtent
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#67
  def initialize(start_page, start_cursor, end_page, end_cursor); end

  # Returns the value of attribute from
  #
  # @return [Object] the current value of from
  def from; end

  # Sets the attribute from
  #
  # @param value [Object] the value to set the attribute from to.
  # @return [Object] the newly set value
  def from=(_); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#72
  def position_onto(pdf, keep_together = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#87
  def single_page?; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#91
  def single_page_height; end

  # Returns the value of attribute to
  #
  # @return [Object] the current value of to
  def to; end

  # Sets the attribute to
  #
  # @param value [Object] the value to set the attribute to to.
  # @return [Object] the newly set value
  def to=(_); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/extensions.rb#95
  def try_to_fit_on_previous(reference_cursor); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/images.rb#5
module Asciidoctor::Prawn::Images
  # Dispatch to suitable image method in Prawn based on file extension.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/images.rb#7
  def image(file, opts = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/images.rb#36
  def recommend_prawn_gmagick?(err, image_format); end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/asciidoctor/section.rb#3
class Asciidoctor::Section < ::Asciidoctor::AbstractBlock
  # source://asciidoctor/2.0.23/lib/asciidoctor/section.rb#46
  def initialize(parent = T.unsafe(nil), level = T.unsafe(nil), numbered = T.unsafe(nil), opts = T.unsafe(nil)); end

  # source://asciidoctor/2.0.23/lib/asciidoctor/section.rb#166
  def <<(block); end

  # source://asciidoctor/2.0.23/lib/asciidoctor/section.rb#38
  def caption; end

  # @return [Boolean]
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/asciidoctor/section.rb#37
  def first_section_of_part?; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/section.rb#63
  def generate_id; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/section.rb#25
  def index; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/section.rb#25
  def index=(_arg0); end

  # source://asciidoctor/2.0.23/lib/asciidoctor/abstract_block.rb#288
  def name; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/section.rb#35
  def numbered; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/section.rb#35
  def numbered=(_arg0); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/asciidoctor/section.rb#4
  def numbered_title(opts = T.unsafe(nil)); end

  # source://asciidoctor/2.0.23/lib/asciidoctor/section.rb#70
  def sections?; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/section.rb#28
  def sectname; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/section.rb#28
  def sectname=(_arg0); end

  # source://asciidoctor/2.0.23/lib/asciidoctor/section.rb#119
  def sectnum(delimiter = T.unsafe(nil), append = T.unsafe(nil)); end

  # source://asciidoctor/2.0.23/lib/asciidoctor/section.rb#31
  def special; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/section.rb#31
  def special=(_arg0); end

  # source://asciidoctor/2.0.23/lib/asciidoctor/section.rb#171
  def to_s; end

  # source://asciidoctor/2.0.23/lib/asciidoctor/section.rb#125
  def xreftext(xrefstyle = T.unsafe(nil)); end

  class << self
    # source://asciidoctor/2.0.23/lib/asciidoctor/section.rb#198
    def generate_id(title, document); end
  end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_string.rb#3
class FormattedString < ::String
  # @return [FormattedString] a new instance of FormattedString
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_string.rb#6
  def initialize(fragments); end

  # @return [Boolean]
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_string.rb#10
  def eql?(other); end

  # Returns the value of attribute fragments.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/formatted_string.rb#4
  def fragments; end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/core/object.rb#3
class Object < ::BasicObject
  include ::Kernel
  include ::PP::ObjectMixin

  # Convert the object to a serialized PDF object.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/core/object.rb#5
  def to_pdf_object; end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/pdf-core/page.rb#3
class PDF::Core::Page
  # source://prawn-templates/0.1.2/lib/pdf/core/page.rb#5
  def initialize(document, options = T.unsafe(nil)); end

  # source://pdf-core/0.9.0/lib/pdf/core/page.rb#151
  def __dimensions; end

  # source://pdf-core/0.9.0/lib/pdf/core/page.rb#165
  def art_box; end

  # source://pdf-core/0.9.0/lib/pdf/core/page.rb#15
  def art_indents; end

  # source://pdf-core/0.9.0/lib/pdf/core/page.rb#15
  def art_indents=(_arg0); end

  # source://pdf-core/0.9.0/lib/pdf/core/page.rb#175
  def bleed_box; end

  # source://pdf-core/0.9.0/lib/pdf/core/page.rb#15
  def bleeds; end

  # source://pdf-core/0.9.0/lib/pdf/core/page.rb#15
  def bleeds=(_arg0); end

  # source://pdf-core/0.9.0/lib/pdf/core/page.rb#100
  def content; end

  # source://pdf-core/0.9.0/lib/pdf/core/page.rb#16
  def content=(_arg0); end

  # source://pdf-core/0.9.0/lib/pdf/core/page.rb#185
  def crop_box; end

  # source://pdf-core/0.9.0/lib/pdf/core/page.rb#15
  def crops; end

  # source://pdf-core/0.9.0/lib/pdf/core/page.rb#15
  def crops=(_arg0); end

  # source://pdf-core/0.9.0/lib/pdf/core/page.rb#104
  def dictionary; end

  # source://pdf-core/0.9.0/lib/pdf/core/page.rb#16
  def dictionary=(_arg0); end

  # source://prawn-templates/0.1.2/lib/pdf/core/page.rb#63
  def dimensions; end

  # source://pdf-core/0.9.0/lib/pdf/core/page.rb#15
  def document; end

  # source://pdf-core/0.9.0/lib/pdf/core/page.rb#15
  def document=(_arg0); end

  # Returns whether the current page is empty based on tare content stream (i.e., no content has been written).
  # Returns false if a page has not yet been created.
  #
  # @return [Boolean]
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/pdf-core/page.rb#13
  def empty?; end

  # source://pdf-core/0.9.0/lib/pdf/core/page.rb#133
  def ext_gstates; end

  # source://pdf-core/0.9.0/lib/pdf/core/page.rb#141
  def finalize; end

  # source://pdf-core/0.9.0/lib/pdf/core/page.rb#117
  def fonts; end

  # source://pdf-core/0.9.0/lib/pdf/core/page.rb#60
  def graphic_state; end

  # Flags this page as imported.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/pdf-core/page.rb#19
  def imported; end

  # Flags this page as imported.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/pdf-core/page.rb#19
  def imported_page; end

  # source://prawn-templates/0.1.2/lib/pdf/core/page.rb#57
  def imported_page?; end

  # source://pdf-core/0.9.0/lib/pdf/core/page.rb#79
  def in_stamp_stream?; end

  # source://prawn-templates/0.1.2/lib/pdf/core/page.rb#86
  def init_from_object(options); end

  # source://prawn-templates/0.1.2/lib/pdf/core/page.rb#102
  def init_new_page(options); end

  # source://pdf-core/0.9.0/lib/pdf/core/page.rb#64
  def layout; end

  # source://pdf-core/0.9.0/lib/pdf/core/page.rb#15
  def margins; end

  # source://pdf-core/0.9.0/lib/pdf/core/page.rb#15
  def margins=(_arg0); end

  # source://prawn-templates/0.1.2/lib/pdf/core/page.rb#47
  def new_content_stream; end

  # Reset the content of the page.
  # Note that this method may leave behind an orphaned background image.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/pdf-core/page.rb#27
  def reset_content; end

  # source://pdf-core/0.9.0/lib/pdf/core/page.rb#109
  def resources; end

  # source://pdf-core/0.9.0/lib/pdf/core/page.rb#75
  def size; end

  # source://pdf-core/0.9.0/lib/pdf/core/page.rb#15
  def stack; end

  # source://pdf-core/0.9.0/lib/pdf/core/page.rb#15
  def stack=(_arg0); end

  # source://pdf-core/0.9.0/lib/pdf/core/page.rb#83
  def stamp_stream(dictionary); end

  # Record the page's current state as the tare content stream (i.e., empty, meaning no content has been written).
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/pdf-core/page.rb#7
  def tare_content_stream; end

  # source://pdf-core/0.9.0/lib/pdf/core/page.rb#195
  def trim_box; end

  # source://pdf-core/0.9.0/lib/pdf/core/page.rb#15
  def trims; end

  # source://pdf-core/0.9.0/lib/pdf/core/page.rb#15
  def trims=(_arg0); end

  # source://prawn-templates/0.1.2/lib/pdf/core/page.rb#29
  def wrap_graphics_state; end

  # source://pdf-core/0.9.0/lib/pdf/core/page.rb#125
  def xobjects; end

  private

  # source://pdf-core/0.9.0/lib/pdf/core/page.rb#25
  def __initialize(document, options = T.unsafe(nil)); end

  # source://pdf-core/0.9.0/lib/pdf/core/page.rb#215
  def inherited_dictionary_value(key, local_dict = T.unsafe(nil)); end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/pdf-core/page.rb#4
PDF::Core::Page::InitialPageContent = T.let(T.unsafe(nil), String)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn-table/cell/asciidoc.rb#3
module Prawn
  private

  # source://prawn/2.4.0/lib/prawn.rb#34
  def debug; end

  # source://prawn/2.4.0/lib/prawn.rb#34
  def debug=(_arg0); end

  # source://prawn/2.4.0/lib/prawn.rb#41
  def verify_options(accepted, actual); end

  class << self
    # source://prawn/2.4.0/lib/prawn.rb#34
    def debug; end

    # source://prawn/2.4.0/lib/prawn.rb#34
    def debug=(_arg0); end

    # source://prawn/2.4.0/lib/prawn/image_handler.rb#12
    def image_handler; end

    # source://prawn/2.4.0/lib/prawn.rb#41
    def verify_options(accepted, actual); end
  end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn.rb#5
Prawn::FLOAT_PRECISION = T.let(T.unsafe(nil), Float)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/font/afm.rb#6
Prawn::Font::AFM::FALLBACK_CHARS = T.let(T.unsafe(nil), Hash)

# TODO: remove when upgrading to prawn-2.5.0
#
# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/font_metric_cache.rb#4
class Prawn::FontMetricCache::CacheEntry < ::Struct
  # @return [CacheEntry] a new instance of CacheEntry
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/font_metric_cache.rb#5
  def initialize(font, options, size); end

  def font; end
  def font=(_); end
  def options; end
  def options=(_); end
  def string; end
  def string=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

module Prawn::Fonts; end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/font/afm.rb#3
class Prawn::Fonts::AFM < ::Prawn::Font
  include ::Asciidoctor::Logging
  extend ::Asciidoctor::Logging

  # source://prawn/2.4.0/lib/prawn/fonts/afm.rb#54
  def initialize(document, name, options = T.unsafe(nil)); end

  # source://prawn/2.4.0/lib/prawn/fonts/afm.rb#47
  def attributes; end

  # source://prawn/2.4.0/lib/prawn/fonts/afm.rb#82
  def bbox; end

  # source://prawn/2.4.0/lib/prawn/fonts/afm.rb#129
  def character_count(str); end

  # source://prawn/2.4.0/lib/prawn/fonts/afm.rb#87
  def compute_width_of(string, options = T.unsafe(nil)); end

  # source://prawn/2.4.0/lib/prawn/fonts/afm.rb#145
  def encode_text(text, options = T.unsafe(nil)); end

  # source://prawn/2.4.0/lib/prawn/fonts/afm.rb#149
  def glyph_present?(char); end

  # source://prawn/2.4.0/lib/prawn/fonts/afm.rb#102
  def has_kerning_data?; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/font/afm.rb#22
  def normalize_encoding(text); end

  # source://prawn/2.4.0/lib/prawn/fonts/afm.rb#123
  def to_utf8(text); end

  # source://prawn/2.4.0/lib/prawn/fonts/afm.rb#29
  def unicode?; end

  private

  # source://prawn/2.4.0/lib/prawn/fonts/afm.rb#174
  def find_font(file); end

  # source://prawn/2.4.0/lib/prawn/fonts/afm.rb#261
  def kern(string); end

  # source://prawn/2.4.0/lib/prawn/fonts/afm.rb#183
  def parse_afm(file_name); end

  # source://prawn/2.4.0/lib/prawn/fonts/afm.rb#243
  def parse_generic_afm_attribute(line, hash); end

  # source://prawn/2.4.0/lib/prawn/fonts/afm.rb#157
  def register(_subset); end

  # source://prawn/2.4.0/lib/prawn/fonts/afm.rb#170
  def symbolic?; end

  # source://prawn/2.4.0/lib/prawn/fonts/afm.rb#285
  def unscaled_width_of(string); end

  class << self
    # source://prawn/2.4.0/lib/prawn/fonts/afm.rb#50
    def font_data; end

    # source://prawn/2.4.0/lib/prawn/fonts/afm.rb#17
    def hide_m17n_warning; end

    # source://prawn/2.4.0/lib/prawn/fonts/afm.rb#17
    def hide_m17n_warning=(_arg0); end

    # source://prawn/2.4.0/lib/prawn/fonts/afm.rb#33
    def metrics_path; end
  end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/font/afm.rb#6
Prawn::Fonts::AFM::FALLBACK_CHARS = T.let(T.unsafe(nil), Hash)

module Prawn::SVG; end
module Prawn::SVG::Calculators; end

class Prawn::SVG::Calculators::DocumentSizing
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn-svg/calculators/document_sizing.rb#4
  def initialize(*_args); end

  # source://prawn-svg/0.34.2/lib/prawn/svg/calculators/document_sizing.rb#8
  def bounds; end

  # source://prawn-svg/0.34.2/lib/prawn/svg/calculators/document_sizing.rb#24
  def calculate; end

  # source://prawn-svg/0.34.2/lib/prawn/svg/calculators/document_sizing.rb#5
  def document_height=(_arg0); end

  # source://prawn-svg/0.34.2/lib/prawn/svg/calculators/document_sizing.rb#5
  def document_width=(_arg0); end

  # source://prawn-svg/0.34.2/lib/prawn/svg/calculators/document_sizing.rb#87
  def invalid?; end

  # source://prawn-svg/0.34.2/lib/prawn/svg/calculators/document_sizing.rb#10
  def output_height; end

  # source://prawn-svg/0.34.2/lib/prawn/svg/calculators/document_sizing.rb#10
  def output_width; end

  # source://prawn-svg/0.34.2/lib/prawn/svg/calculators/document_sizing.rb#6
  def preserve_aspect_ratio=(_arg0); end

  # source://prawn-svg/0.34.2/lib/prawn/svg/calculators/document_sizing.rb#100
  def requested_height=(value); end

  # source://prawn-svg/0.34.2/lib/prawn/svg/calculators/document_sizing.rb#96
  def requested_width=(value); end

  # source://prawn-svg/0.34.2/lib/prawn/svg/calculators/document_sizing.rb#17
  def set_from_attributes(attributes); end

  # source://prawn-svg/0.34.2/lib/prawn/svg/calculators/document_sizing.rb#6
  def view_box=(_arg0); end

  # source://prawn-svg/0.34.2/lib/prawn/svg/calculators/document_sizing.rb#10
  def viewport_diagonal; end

  # source://prawn-svg/0.34.2/lib/prawn/svg/calculators/document_sizing.rb#10
  def viewport_height; end

  # source://prawn-svg/0.34.2/lib/prawn/svg/calculators/document_sizing.rb#10
  def viewport_width; end

  # source://prawn-svg/0.34.2/lib/prawn/svg/calculators/document_sizing.rb#9
  def x_offset; end

  # source://prawn-svg/0.34.2/lib/prawn/svg/calculators/document_sizing.rb#9
  def x_scale; end

  # source://prawn-svg/0.34.2/lib/prawn/svg/calculators/document_sizing.rb#9
  def y_offset; end

  # source://prawn-svg/0.34.2/lib/prawn/svg/calculators/document_sizing.rb#9
  def y_scale; end
end

module Prawn::SVG::Elements; end

class Prawn::SVG::Elements::Image < ::Prawn::SVG::Elements::Base
  # source://prawn-svg/0.34.2/lib/prawn/svg/elements/image.rb#55
  def apply; end

  # source://prawn-svg/0.34.2/lib/prawn/svg/elements/image.rb#74
  def bounding_box; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn-svg/elements/image.rb#12
  def find_image_handler(data); end

  # source://prawn-svg/0.34.2/lib/prawn/svg/elements/image.rb#16
  def parse; end

  protected

  # source://prawn-svg/0.34.2/lib/prawn/svg/elements/image.rb#107
  def potentially_svg?(data); end

  # source://prawn-svg/0.34.2/lib/prawn/svg/elements/image.rb#80
  def process_image(data, width, height, preserveAspectRatio); end

  # source://prawn-svg/0.34.2/lib/prawn/svg/elements/image.rb#111
  def raise_invalid_image_type; end
end

class Prawn::SVG::Elements::Use < ::Prawn::SVG::Elements::Base
  # source://prawn-svg/0.34.2/lib/prawn/svg/elements/use.rb#47
  def apply; end

  # source://prawn-svg/0.34.2/lib/prawn/svg/elements/use.rb#43
  def container?; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn-svg/elements/use.rb#5
  def parse; end

  # source://prawn-svg/0.34.2/lib/prawn/svg/elements/use.rb#53
  def process_child_elements; end

  # source://prawn-svg/0.34.2/lib/prawn/svg/elements/use.rb#2
  def referenced_element_class; end

  # source://prawn-svg/0.34.2/lib/prawn/svg/elements/use.rb#2
  def referenced_element_source; end
end

module Prawn::SVG::Loaders; end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn-svg/loaders/data.rb#3
class Prawn::SVG::Loaders::Data
  # source://prawn-svg/0.34.2/lib/prawn/svg/loaders/data.rb#5
  def from_url(url); end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn-svg/loaders/data.rb#5
Prawn::SVG::Loaders::Data::REGEXP = T.let(T.unsafe(nil), Regexp)

class Prawn::SVG::Loaders::File
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn-svg/loaders/file.rb#6
  def initialize(root_path); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn-svg/loaders/file.rb#17
  def assert_valid_path!(path); end

  # source://prawn-svg/0.34.2/lib/prawn/svg/loaders/file.rb#45
  def from_url(url); end

  # source://prawn-svg/0.34.2/lib/prawn/svg/loaders/file.rb#33
  def root_path; end

  private

  # source://prawn-svg/0.34.2/lib/prawn/svg/loaders/file.rb#95
  def assert_file_exists!(path); end

  # source://prawn-svg/0.34.2/lib/prawn/svg/loaders/file.rb#89
  def assert_valid_file_uri!(uri); end

  # source://prawn-svg/0.34.2/lib/prawn/svg/loaders/file.rb#85
  def build_absolute_and_expand_path(path); end

  # source://prawn-svg/0.34.2/lib/prawn/svg/loaders/file.rb#68
  def build_uri(url); end

  # source://prawn-svg/0.34.2/lib/prawn/svg/loaders/file.rb#101
  def fix_windows_path(path); end

  # source://prawn-svg/0.34.2/lib/prawn/svg/loaders/file.rb#60
  def load_file(path); end

  # source://prawn-svg/0.34.2/lib/prawn/svg/loaders/file.rb#109
  def windows?; end
end

class Prawn::SVG::Loaders::Web
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn-svg/loaders/web.rb#8
  def from_url(url); end

  private

  # source://prawn-svg/0.34.2/lib/prawn/svg/loaders/web.rb#15
  def build_uri(url); end

  # source://prawn-svg/0.34.2/lib/prawn/svg/loaders/web.rb#22
  def perform_request(uri); end
end

class Prawn::SVG::UrlLoader
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn-svg/url_loader.rb#4
  def initialize(enable_cache: T.unsafe(nil), enable_web: T.unsafe(nil), enable_file_with_root: T.unsafe(nil)); end

  # source://prawn-svg/0.34.2/lib/prawn/svg/url_loader.rb#20
  def add_to_cache(url, data); end

  # source://prawn-svg/0.34.2/lib/prawn/svg/url_loader.rb#4
  def enable_cache; end

  # source://prawn-svg/0.34.2/lib/prawn/svg/url_loader.rb#16
  def load(url); end

  # source://prawn-svg/0.34.2/lib/prawn/svg/url_loader.rb#4
  def loaders; end

  # source://prawn-svg/0.34.2/lib/prawn/svg/url_loader.rb#24
  def retrieve_from_cache(url); end

  private

  # source://prawn-svg/0.34.2/lib/prawn/svg/url_loader.rb#36
  def perform(url); end

  # source://prawn-svg/0.34.2/lib/prawn/svg/url_loader.rb#30
  def perform_and_cache(url); end

  # source://prawn-svg/0.34.2/lib/prawn/svg/url_loader.rb#40
  def try_each_loader(url); end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn-table/cell/asciidoc.rb#4
class Prawn::Table
  # source://prawn-table/0.2.2/lib/prawn/table.rb#137
  def initialize(data, document, options = T.unsafe(nil), &block); end

  # source://prawn-table/0.2.2/lib/prawn/table.rb#179
  def before_rendering_page(&block); end

  # source://prawn-table/0.2.2/lib/prawn/table.rb#234
  def cell_style=(style_hash); end

  # source://prawn-table/0.2.2/lib/prawn/table.rb#172
  def cells; end

  # source://prawn-table/0.2.2/lib/prawn/table/cells.rb#22
  def column(col_spec); end

  # source://prawn-table/0.2.2/lib/prawn/table.rb#158
  def column_length; end

  # source://prawn-table/0.2.2/lib/prawn/table.rb#327
  def column_widths; end

  # source://prawn-table/0.2.2/lib/prawn/table.rb#200
  def column_widths=(widths); end

  # source://prawn-table/0.2.2/lib/prawn/table/cells.rb#22
  def columns(col_spec); end

  # source://prawn-table/0.2.2/lib/prawn/table.rb#259
  def draw; end

  # source://prawn-table/0.2.2/lib/prawn/table.rb#224
  def header=(_arg0); end

  # source://prawn-table/0.2.2/lib/prawn/table.rb#215
  def height; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn-table.rb#6
  def initial_row_on_initial_page; end

  # source://prawn-table/0.2.2/lib/prawn/table.rb#167
  def position=(_arg0); end

  # source://prawn-table/0.2.2/lib/prawn/table/cells.rb#14
  def row(row_spec); end

  # source://prawn-table/0.2.2/lib/prawn/table.rb#228
  def row_colors=(_arg0); end

  # source://prawn-table/0.2.2/lib/prawn/table.rb#365
  def row_heights; end

  # source://prawn-table/0.2.2/lib/prawn/table.rb#154
  def row_length; end

  # source://prawn-table/0.2.2/lib/prawn/table/cells.rb#14
  def rows(row_spec); end

  # source://prawn-table/0.2.2/lib/prawn/table.rb#253
  def style(stylable, style_hash = T.unsafe(nil), &block); end

  # source://prawn-table/0.2.2/lib/prawn/table.rb#185
  def width; end

  # source://prawn-table/0.2.2/lib/prawn/table.rb#162
  def width=(_arg0); end

  protected

  # source://prawn-table/0.2.2/lib/prawn/table.rb#571
  def add_header(row_number, cells_this_page); end

  # source://prawn-table/0.2.2/lib/prawn/table.rb#591
  def add_one_header_row(page_of_cells, x_offset, y, row, row_of_header = T.unsafe(nil)); end

  # source://prawn-table/0.2.2/lib/prawn/table.rb#613
  def assert_proper_table_data(data); end

  # source://prawn-table/0.2.2/lib/prawn/table.rb#489
  def fits_on_page?(needed_height, use_reference_bounds = T.unsafe(nil)); end

  # source://prawn-table/0.2.2/lib/prawn/table.rb#500
  def header_rows; end

  # source://prawn-table/0.2.2/lib/prawn/table.rb#423
  def ink_and_draw_cells(cells_this_page, draw_cells = T.unsafe(nil)); end

  # source://prawn-table/0.2.2/lib/prawn/table.rb#429
  def ink_and_draw_cells_and_start_new_page(cells_this_page, cell); end

  # source://prawn-table/0.2.2/lib/prawn/table.rb#452
  def ink_cells(cells_this_page); end

  # source://prawn-table/0.2.2/lib/prawn/table.rb#512
  def make_cells(data); end

  # source://prawn-table/0.2.2/lib/prawn/table.rb#628
  def natural_column_widths; end

  # source://prawn-table/0.2.2/lib/prawn/table.rb#637
  def natural_width; end

  # source://prawn-table/0.2.2/lib/prawn/table.rb#401
  def number_of_header_rows; end

  # source://prawn-table/0.2.2/lib/prawn/table.rb#662
  def position_cells; end

  # source://prawn-table/0.2.2/lib/prawn/table.rb#386
  def set_background_color(cell, started_new_page_at_row); end

  # source://prawn-table/0.2.2/lib/prawn/table.rb#646
  def set_column_widths; end

  # source://prawn-table/0.2.2/lib/prawn/table.rb#655
  def set_row_heights; end

  # source://prawn-table/0.2.2/lib/prawn/table.rb#414
  def start_new_page?(cell, offset, ref_bounds); end

  # source://prawn-table/0.2.2/lib/prawn/table.rb#678
  def with_position; end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn-table/cell/asciidoc.rb#5
class Prawn::Table::Cell
  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#208
  def initialize(pdf, point, options = T.unsafe(nil)); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#83
  def avg_spanned_min_width; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#142
  def background_color; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#142
  def background_color=(_arg0); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#568
  def border_bottom_color; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#572
  def border_bottom_color=(val); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#694
  def border_bottom_line; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#698
  def border_bottom_line=(val); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#626
  def border_bottom_width; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#630
  def border_bottom_width=(val); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn-table/cell.rb#6
  def border_color=(color); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#126
  def border_colors; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#533
  def border_colors=(color); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#576
  def border_left_color; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#580
  def border_left_color=(val); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#702
  def border_left_line; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#706
  def border_left_line=(val); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#634
  def border_left_width; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#638
  def border_left_width=(val); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#659
  def border_line=(line); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#130
  def border_lines; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#659
  def border_lines=(line); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#560
  def border_right_color; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#564
  def border_right_color=(val); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#686
  def border_right_line; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#690
  def border_right_line=(val); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#618
  def border_right_width; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#622
  def border_right_width=(val); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#552
  def border_top_color; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#556
  def border_top_color=(val); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#678
  def border_top_line; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#682
  def border_top_line=(val); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#610
  def border_top_width; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#614
  def border_top_width=(val); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#591
  def border_width=(width); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#122
  def border_widths; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#591
  def border_widths=(width); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#118
  def borders; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#118
  def borders=(_arg0); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#146
  def colspan; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#365
  def colspan=(span); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#136
  def content; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#136
  def content=(_arg0); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#331
  def content_height; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#281
  def content_width; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#403
  def draw(pt = T.unsafe(nil)); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#712
  def draw_background(pt); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn-table/cell.rb#18
  def draw_borders(pt); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#425
  def draw_bounded_content(pt); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#776
  def draw_content; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#156
  def dummy_cells; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#316
  def height; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#113
  def height=(_arg0); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#306
  def height_ignoring_span; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#97
  def max_width; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#90
  def max_width_ignoring_span; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#68
  def min_width; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#61
  def min_width_ignoring_span; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#348
  def natural_content_height; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#298
  def natural_content_width; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#57
  def padding; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#476
  def padding=(pad); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#510
  def padding_bottom; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#514
  def padding_bottom=(val); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#518
  def padding_left; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#522
  def padding_left=(val); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#502
  def padding_right; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#506
  def padding_right=(val); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#494
  def padding_top; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#498
  def padding_top=(val); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#447
  def relative_x; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#465
  def relative_y(offset = T.unsafe(nil)); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#150
  def rowspan; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#386
  def rowspan=(span); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#645
  def set_width_constraints; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#341
  def spanned_content_height; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#291
  def spanned_content_width; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#236
  def style(options = T.unsafe(nil), &block); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#259
  def width; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#275
  def width=(w); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#249
  def width_ignoring_span; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#437
  def x; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#443
  def x=(val); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#455
  def y; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#461
  def y=(val); end

  class << self
    # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#411
    def draw_cells(cells); end

    # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#162
    def make(pdf, content, options = T.unsafe(nil)); end
  end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn-table/cell/asciidoc.rb#6
class Prawn::Table::Cell::AsciiDoc < ::Prawn::Table::Cell
  include ::Asciidoctor::Logging
  extend ::Asciidoctor::Logging

  # @return [AsciiDoc] a new instance of AsciiDoc
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn-table/cell/asciidoc.rb#13
  def initialize(pdf, opts = T.unsafe(nil)); end

  # Returns the value of attribute align.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn-table/cell/asciidoc.rb#9
  def align; end

  # Sets the attribute align
  #
  # @param value the value to set the attribute align to.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn-table/cell/asciidoc.rb#9
  def align=(_arg0); end

  # NOTE: prawn-table doesn't support cells that exceed the height of a single page
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn-table/cell/asciidoc.rb#69
  def draw_content; end

  # NOTE: automatic image sizing only works if cell has fixed width
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn-table/cell/asciidoc.rb#36
  def dry_run; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn-table/cell/asciidoc.rb#31
  def font=(val); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn-table/cell/asciidoc.rb#19
  def font_style=(val); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn-table/cell/asciidoc.rb#63
  def natural_content_height; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn-table/cell/asciidoc.rb#58
  def natural_content_width; end

  # Returns the value of attribute root_font_size.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn-table/cell/asciidoc.rb#10
  def root_font_size; end

  # Sets the attribute root_font_size
  #
  # @param value the value to set the attribute root_font_size to.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn-table/cell/asciidoc.rb#10
  def root_font_size=(_arg0); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn-table/cell/asciidoc.rb#27
  def size=(val); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn-table/cell/asciidoc.rb#23
  def text_color=(val); end

  # Returns the value of attribute valign.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn-table/cell/asciidoc.rb#11
  def valign; end

  # Sets the attribute valign
  #
  # @param value the value to set the attribute valign to.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn-table/cell/asciidoc.rb#11
  def valign=(_arg0); end

  private

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn-table/cell/asciidoc.rb#105
  def apply_font_properties; end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn-table/cell/text.rb#3
class Prawn::Table::Cell::Text < ::Prawn::Table::Cell
  include ::Asciidoctor::Logging
  extend ::Asciidoctor::Logging

  # source://prawn-table/0.2.2/lib/prawn/table/cell/text.rb#29
  def initialize(pdf, point, options = T.unsafe(nil)); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell/text.rb#24
  def align; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell/text.rb#23
  def align=(v); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn-table/cell/text.rb#10
  def draw_content; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell/text.rb#36
  def font; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell/text.rb#27
  def font=(_arg0); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell/text.rb#43
  def font_style=(style); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell/text.rb#24
  def inline_format; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell/text.rb#23
  def inline_format=(v); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell/text.rb#24
  def kerning; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell/text.rb#23
  def kerning=(v); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell/text.rb#24
  def leading; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell/text.rb#23
  def leading=(v); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell/text.rb#24
  def min_font_size; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell/text.rb#23
  def min_font_size=(v); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell/text.rb#57
  def natural_content_height; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell/text.rb#50
  def natural_content_width; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell/text.rb#24
  def overflow; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell/text.rb#23
  def overflow=(v); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell/text.rb#24
  def rotate; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell/text.rb#23
  def rotate=(v); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell/text.rb#24
  def rotate_around; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell/text.rb#23
  def rotate_around=(v); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell/text.rb#78
  def set_width_constraints; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell/text.rb#24
  def single_line; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell/text.rb#23
  def single_line=(v); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell/text.rb#24
  def size; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell/text.rb#23
  def size=(v); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell/text.rb#24
  def skip_encoding; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell/text.rb#23
  def skip_encoding=(v); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn-table/cell/text.rb#27
  def styled_width_of(text); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell/text.rb#27
  def text_color=(_arg0); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell/text.rb#24
  def valign; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell/text.rb#23
  def valign=(v); end

  protected

  # source://prawn-table/0.2.2/lib/prawn/table/cell/text.rb#117
  def text_box(extra_options = T.unsafe(nil)); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell/text.rb#91
  def with_font; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell/text.rb#103
  def with_text_color; end

  private

  # source://prawn-table/0.2.2/lib/prawn/table/cell/text.rb#148
  def styled_width_of_single_character; end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn-table/cell/text.rb#6
Prawn::Table::Cell::Text::ImageTagRx = T.let(T.unsafe(nil), Regexp)

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/formatted_text/indented_paragraph_wrap.rb#3
module Prawn::Text::Formatted
  # source://prawn/2.4.0/lib/prawn/text/formatted/box.rb#92
  def formatted_text_box(array, options = T.unsafe(nil)); end
end

class Prawn::Text::Formatted::Arranger
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/formatted_text/arranger.rb#8
  def initialize(*_args); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/arranger.rb#154
  def apply_color_and_font_settings(fragment, &block); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/arranger.rb#168
  def apply_font_settings(fragment = T.unsafe(nil), &block); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/formatted_text/arranger.rb#40
  def apply_font_size(size, styles); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/arranger.rb#39
  def consumed; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/arranger.rb#39
  def consumed=(_arg0); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/arranger.rb#44
  def current_format_state; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/formatted_text/arranger.rb#20
  def finalize_line; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/arranger.rb#38
  def finalized; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/arranger.rb#126
  def finished?; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/arranger.rb#236
  def font_style(styles); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/formatted_text/arranger.rb#15
  def format_array=(array); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/arranger.rb#43
  def fragments; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/arranger.rb#116
  def initialize_line; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/arranger.rb#73
  def line; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/arranger.rb#63
  def line_width; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/arranger.rb#37
  def max_ascender; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/arranger.rb#36
  def max_descender; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/arranger.rb#35
  def max_line_height; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/formatted_text/arranger.rb#25
  def next_string; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/arranger.rb#146
  def preview_next_string; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/arranger.rb#225
  def repack_unretrieved; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/arranger.rb#217
  def retrieve_fragment; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/arranger.rb#53
  def space_count; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/arranger.rb#42
  def unconsumed; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/arranger.rb#198
  def update_last_string(printed, unprinted, normalized_soft_hyphen = T.unsafe(nil)); end

  private

  # source://prawn/2.4.0/lib/prawn/text/formatted/arranger.rb#306
  def fragment_measurements=(fragment); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/arranger.rb#318
  def line_measurement_maximums=(fragment); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/arranger.rb#251
  def load_previous_format_state; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/arranger.rb#290
  def omit_trailing_whitespace_from_line_width; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/arranger.rb#278
  def subscript?(styles); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/arranger.rb#284
  def superscript?(styles); end
end

class Prawn::Text::Formatted::Box
  include ::Asciidoctor::PDF::Measurements
  include ::Asciidoctor::Logging
  include ::Asciidoctor::PDF::FormattedText::InlineImageArranger
end

class Prawn::Text::Formatted::Fragment
  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#22
  def initialize(text, format_state, document); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#185
  def absolute_bottom; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#197
  def absolute_bottom_left; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#201
  def absolute_bottom_right; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#62
  def absolute_bounding_box; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#173
  def absolute_left; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#177
  def absolute_right; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#181
  def absolute_top; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#189
  def absolute_top_left; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#193
  def absolute_top_right; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#89
  def anchor; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#19
  def ascender; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/formatted_text/fragment.rb#29
  def ascender=(val); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#20
  def baseline; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#20
  def baseline=(_arg0); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#153
  def bottom; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#169
  def bottom_left; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#165
  def bottom_right; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#58
  def bounding_box; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#134
  def callback_objects; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#109
  def character_spacing; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#97
  def color; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#118
  def default_direction=(direction); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#19
  def descender; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/formatted_text/fragment.rb#35
  def descender=(val); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#114
  def direction; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#101
  def font; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#17
  def format_state; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#39
  def height; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/formatted_text/fragment.rb#17
  def include_trailing_white_space!; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#20
  def left; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#20
  def left=(_arg0); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#19
  def line_height; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#19
  def line_height=(_arg0); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#85
  def link; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#93
  def local; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#145
  def right; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#105
  def size; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#130
  def space_count; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#76
  def strikethrough_points; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/formatted_text/fragment.rb#23
  def strip_zero_width_spaces(string); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#81
  def styles; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#43
  def subscript?; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#47
  def superscript?; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#17
  def text; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#149
  def top; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#157
  def top_left; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#161
  def top_right; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#71
  def underline_points; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/formatted_text/fragment.rb#39
  def width; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#18
  def width=(_arg0); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#20
  def word_spacing; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#20
  def word_spacing=(_arg0); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#51
  def y_offset; end

  private

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#227
  def exclude_trailing_white_space?; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#235
  def normalized_soft_hyphen; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#239
  def process_soft_hyphens(string); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#207
  def process_text(text); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/fragment.rb#231
  def soft_hyphens_need_processing?(string); end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/formatted_text/indented_paragraph_wrap.rb#4
module Prawn::Text::Formatted::IndentedParagraphWrap
  # Override Prawn::Text::Formatted::Box#wrap method to add support for :indent_paragraphs to (formatted_)text_box.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/formatted_text/indented_paragraph_wrap.rb#6
  def wrap(array); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/formatted_text/indented_paragraph_wrap.rb#23
  def wrap_and_print_line; end
end

class Prawn::Text::Formatted::LineWrap
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/formatted_text/line_wrap.rb#4
  def add_fragment_to_line(fragment); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/line_wrap.rb#26
  def paragraph_finished?; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/line_wrap.rb#23
  def space_count; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/line_wrap.rb#30
  def tokenize(fragment); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/line_wrap.rb#18
  def width; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/line_wrap.rb#38
  def wrap_line(options); end

  private

  # source://prawn/2.4.0/lib/prawn/text/formatted/line_wrap.rb#311
  def append_char(char); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/line_wrap.rb#77
  def apply_font_settings_and_add_fragment_to_line(fragment); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/line_wrap.rb#178
  def break_chars(encoding = T.unsafe(nil)); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/line_wrap.rb#65
  def empty_line?(fragment); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/line_wrap.rb#297
  def end_of_the_line_reached(segment); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/line_wrap.rb#61
  def first_fragment_on_this_line?(fragment); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/line_wrap.rb#283
  def fragment_begins_with_breakable?(fragment); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/line_wrap.rb#226
  def fragment_finished(fragment); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/line_wrap.rb#197
  def hyphen(_encoding = T.unsafe(nil)); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/line_wrap.rb#208
  def initialize_line(options); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/line_wrap.rb#204
  def line_empty?; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/line_wrap.rb#287
  def line_finished?; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/line_wrap.rb#73
  def next_string_newline?; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/line_wrap.rb#279
  def previous_fragment_ended_with_breakable?; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/line_wrap.rb#258
  def pull_preceding_fragment_to_join_this_one?(current_fragment); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/line_wrap.rb#268
  def remember_this_fragment_for_backward_looking_ops; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/line_wrap.rb#129
  def scan_pattern(encoding = T.unsafe(nil)); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/line_wrap.rb#171
  def soft_hyphen(encoding = T.unsafe(nil)); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/line_wrap.rb#291
  def update_line_status_based_on_last_output; end

  # source://prawn/2.4.0/lib/prawn/text/formatted/line_wrap.rb#241
  def update_output_based_on_last_fragment(fragment, normalized_soft_hyphen = T.unsafe(nil)); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/line_wrap.rb#193
  def whitespace(encoding = T.unsafe(nil)); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/line_wrap.rb#155
  def word_division_scan_pattern(encoding = T.unsafe(nil)); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/line_wrap.rb#305
  def wrap_by_char(segment); end

  # source://prawn/2.4.0/lib/prawn/text/formatted/line_wrap.rb#186
  def zero_width_space(encoding = T.unsafe(nil)); end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/formatted_text/protect_bottom_gutter.rb#3
module Prawn::Text::Formatted::ProtectBottomGutter
  # @return [Boolean]
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/formatted_text/protect_bottom_gutter.rb#4
  def enough_height_for_this_line?; end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/formatted_text/arranger.rb#3
module Prawn::Text::NoopLstripBang
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/prawn/formatted_text/arranger.rb#4
  def lstrip!; end
end

# A delegator that allows the size method to be used on the STDOUT object.
#
# The size of the content written to STDOUT cannot be measured normally. This
# class wraps the STDOUT object so the cumulative size of the content passed to
# the write method (while wrapped in this decorator) can be measured.
#
# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/core/quantifiable_stdout.rb#10
class QuantifiableStdout < ::SimpleDelegator
  # @return [QuantifiableStdout] a new instance of QuantifiableStdout
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/core/quantifiable_stdout.rb#13
  def initialize(delegate); end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/core/quantifiable_stdout.rb#19
  def <<(content); end

  # Returns the value of attribute size.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/core/quantifiable_stdout.rb#11
  def size; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/core/quantifiable_stdout.rb#19
  def write(content); end
end

# source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/core/string.rb#3
class String
  include ::Comparable

  # If the string is ASCII only, convert it to a PDF LiteralString object. Otherwise, return self.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/core/string.rb#13
  def as_pdf; end

  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/core/string.rb#4
  def pred; end

  # Convert the string to a serialized PDF object. If the string can be encoded as ASCII-8BIT, first convert it to a PDF
  # LiteralString object.
  #
  # source://asciidoctor-pdf//lib/asciidoctor/pdf/ext/core/string.rb#19
  def to_pdf_object; end
end
