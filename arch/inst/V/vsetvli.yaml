# yaml-language-server: $schema=../../../schemas/inst_schema.json

$schema: "inst_schema.json#"
kind: instruction
name: vsetvli
long_name: Set vector configuration (register immediate).
description: |
  Vset (r,i) allows rapid configuration of the values in vl and vtype CSRs to match application
  needs. The vsetvl instruction sets the vtype and vl CSRs based on the contents of the argument
  register rs1 and immediate, and writes the new value of vl into rd.
definedBy: V
assembly: xs1, xd, imm
encoding:
  match: 0----------------111-----1010111
  variables:
    - name: zimm11
      location: 30-20
    - name: rs1
      location: 19-15
    - name: rd
      location: 11-7
access:
  s: always
  u: always
  vs: always
  vu: always
data_independent_timing: false
operation(): |
  VectorState state = vector_state();
  XReg VLMAX = (VLEN <<< state.log2_multiplier) >> (3 + state.vsew);

  if (xs1 < VLMAX){
    CSR[vl].VALUE = X[rs1];
  } else if (xs1 < 2*VLMAX) {
    CSR[vl].VALUE = X[rs1] / 2;
  } else {
    CSR[vl].VALUE = VLMAX;
  }

  CSR[vtype] = zimm11;
  X[rd] = CSR[vl].VALUE;
  CSR[vstart].VALUE = 0;
sail(): |
  {
    let VLEN_pow      = get_vlen_pow();
    let ELEN_pow      = get_elen_pow();
    let LMUL_pow_ori  = get_lmul_pow();
    let SEW_pow_ori   = get_sew_pow();
    let ratio_pow_ori = SEW_pow_ori - LMUL_pow_ori;

    /* set vtype */
    match op {
      VSETVLI => {
        vtype->bits() = 0b0 @ zeros(sizeof(xlen) - 9) @ ma @ ta @ sew @ lmul
      },
      VSETVL  => {
        let rs2 : regidx = sew[1 .. 0] @ lmul;
        vtype->bits() = X(rs2)
      }
    };

    /* check legal SEW and LMUL and calculate VLMAX */
    let LMUL_pow_new = get_lmul_pow();
    let SEW_pow_new  = get_sew_pow();
    if SEW_pow_new > LMUL_pow_new + ELEN_pow then {
      /* Note: Implementations can set vill or trap if the vtype setting is not supported.
       * TODO: configuration support for both solutions
       */
      vtype->bits() = 0b1 @ zeros(sizeof(xlen) - 1); /* set vtype.vill */
      vl = zeros();
      print_reg("CSR vtype <- " ^ BitStr(vtype.bits()));
      print_reg("CSR vl <- " ^ BitStr(vl));
      return RETIRE_SUCCESS
    };
    let VLMAX = int_power(2, VLEN_pow + LMUL_pow_new - SEW_pow_new);

    /* set vl according to VLMAX and AVL */
    if (rs1 != 0b00000) then { /* normal stripmining */
      let rs1_val = X(rs1);
      let AVL = unsigned(rs1_val);
      vl = if AVL <= VLMAX then to_bits(sizeof(xlen), AVL)
           else if AVL < 2 * VLMAX then to_bits(sizeof(xlen), (AVL + 1) / 2)
           else to_bits(sizeof(xlen), VLMAX);
      /* Note: ceil(AVL / 2) <= vl <= VLMAX when VLMAX < AVL < (2 * VLMAX)
       * TODO: configuration support for either using ceil(AVL / 2) or VLMAX
       */
      X(rd) = vl;
    } else if (rd != 0b00000) then { /* set vl to VLMAX */
      let AVL = unsigned(ones(sizeof(xlen)));
      vl = to_bits(sizeof(xlen), VLMAX);
      X(rd) = vl;
    } else { /* keep existing vl */
      let AVL = unsigned(vl);
      let ratio_pow_new = SEW_pow_new - LMUL_pow_new;
      if (ratio_pow_new != ratio_pow_ori) then {
        /* Note: Implementations can set vill or trap if the vtype setting is not supported.
         * TODO: configuration support for both solutions
         */
        vtype->bits() = 0b1 @ zeros(sizeof(xlen) - 1); /* set vtype.vill */
        vl = zeros();
      }
    };
    print_reg("CSR vtype <- " ^ BitStr(vtype.bits()));
    print_reg("CSR vl <- " ^ BitStr(vl));

    /* reset vstart to 0 */
    vstart = zeros();
    print_reg("CSR vstart <- " ^ BitStr(vstart));

    RETIRE_SUCCESS
  }
