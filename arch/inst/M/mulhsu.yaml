# yaml-language-server: $schema=../../../schemas/inst_schema.json

mulhsu:
  long_name: Signed/unsigned multiply high
  description: |
    Multiply the signed value in rs1 by the unsigned value in rs2, and store the upper half of the result in rd.
    The lower half is thrown away.

    If both the upper and lower halves are needed, it suggested to use the sequence:

    ---
      mulhsu rdh, rs1, rs2
      mul    rdl, rs1, rs2
    ---

    Microarchitectures may look for that sequence and fuse the operations.
  definedBy:
    anyOf: [M, Zmmul]
  assembly: xd, xs1, xs2
  encoding:
    match: 0000001----------010-----0110011
    variables:
    - name: rs2
      location: 24-20
    - name: rs1
      location: 19-15
    - name: rd
      location: 11-7
  access:
    s: always
    u: always
    vs: always
    vu: always
  data_independent_timing: true
  operation(): |
    if (implemented?(ExtensionName::M) && (CSR[misa].M == 1'b0)) {
      raise (ExceptionCode::IllegalInstruction, mode(), $encoding);
    }

    # enlarge and extend the sources
    Bits<1> rs1_sign_bit = X[rs1][XLEN-1];
    Bits<XLEN*8'd2> src1 = {{XLEN{rs1_sign_bit}}, X[rs1]};
    Bits<XLEN*8'd2> src2 = {{XLEN{1'b0}}, X[rs2]};

    X[rd] = (src1 * src2)[(XLEN*8'd2)-1:XLEN];


  sail(): |
    {
      if extension("M") | haveZmmul() then {
        let rs1_val = X(rs1);
        let rs2_val = X(rs2);
        let rs1_int : int = if signed1 then signed(rs1_val) else unsigned(rs1_val);
        let rs2_int : int = if signed2 then signed(rs2_val) else unsigned(rs2_val);
        let result_wide = to_bits(2 * sizeof(xlen), rs1_int * rs2_int);
        let result = if   high
                     then result_wide[(2 * sizeof(xlen) - 1) .. sizeof(xlen)]
                     else result_wide[(sizeof(xlen) - 1) .. 0];
        X(rd) = result;
        RETIRE_SUCCESS
      } else {
        handle_illegal();
        RETIRE_FAIL
      }
    }
  
  


