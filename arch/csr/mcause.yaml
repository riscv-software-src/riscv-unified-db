# yaml-language-server: $schema=../../schemas/csr_schema.json


mcause:
  long_name: Machine Cause
  address: 0x342
  priv_mode: M
  length: MXLEN
  description: Reports the cause of the latest exception.
  definedBy: Sm
  fields:
    INT:
      location_rv32: 31
      location_rv64: 63
      description: |
        Written by hardware when a trap is taken into M-mode.
        
        When set, the last exception was caused by an asynchronous Interrupt.

        `mcause.INT` is writeable.

        [when,"TRAP_ON_ILLEGAL_WLRL == true"]
        If `mcause` is written with an undefined cause (combination of `mcause.INT` and `mcause.CODE`), an `Illegal Instruction` exception occurs.

        [when,"TRAP_ON_ILLEGAL_WLRL == false"]
        If `mcause` is written with an undefined cause (combination of `mcause.INT` and `mcause.CODE`), neither `mcause.INT` nor `mcause.CODE` are modified.
      type: RW-RH
      reset_value: 0
      sw_write(csr_value): |
        # the write only holds if the INT/CODE combination is valid
        if (csr_value.INT == 1) {
          if (valid_interrupt_code?(csr_value.CODE)) {
            return 1;
          }
          return ILLEGAL_WLRL;
        } else {
          if (valid_exception_code?(csr_value.CODE)) {
            return 1;
          }
          return ILLEGAL_WLRL;
        }
    CODE:
      location_rv32: 30-0
      location_rv64: 62-0
      description: |
        Written by hardware when a trap is taken into M-mode.

        Holds the interrupt or exception code for the last taken trap.

        `mcause.CODE` is writeable.

        [when,"TRAP_ON_ILLEGAL_WLRL == true"]
        If `mcause` is written with an undefined cause (combination of `mcause.INT` and `mcause.CODE`), an `Illegal Instruction` exception occurs.

        [when,"TRAP_ON_ILLEGAL_WLRL == false"]
        If `mcause` is written with an undefined cause (combination of `mcause.INT` and `mcause.CODE`), neither `mcause.INT` nor `mcause.CODE` are modified.

        Valid interrupt codes are:
        [separator="!"]
        !===
        <%- interrupt_codes.sort_by{ |code| code.num }.each do |code| -%>
        ! <%= code.num %> ! <%= code.name %>
        <%- end -%>
        !===

        Valid exception codes are:
        [separator="!"]
        !===
        <%- exception_codes.sort_by{ |code| code.num }.each do |code| -%>
        ! <%= code.num %> ! <%= code.name %>
        <%- end -%>
        !===
      type: RW-RH
      reset_value: 0
      sw_write(csr_value): |
        # the write only holds if the INT/CODE combination is valid
        if (csr_value.INT == 1) {
          if (valid_interrupt_code?(csr_value.CODE)) {
            return csr_value.CODE;
          }
          return ILLEGAL_WLRL;
        } else {
          if (valid_exception_code?(csr_value.CODE)) {
            return csr_value.CODE;
          }
          return ILLEGAL_WLRL;
        }
