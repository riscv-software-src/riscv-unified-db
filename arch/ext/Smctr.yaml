# yaml-language-server: $schema=../../schemas/ext_schema.json

$schema: "ext_schema.json#"
kind: extension
name: Smctr
long_name: Control Transfer Records
description: |
  A method for recording control flow transfer history is valuable not only for performance
  profiling but also for debugging.
  Control flow transfers refer to jump instructions (including function calls and returns), taken
  branch instructions, traps, and trap returns.
  Profiling tools, such as Linux perf, collect control transfer history when sampling software
  execution, thereby enabling tools, like AutoFDO, to identify hot paths for optimization.

  Control flow trace capabilities offer very deep transfer history, but the volume of data produced
  can result in significant performance overheads due to memory bandwidth consumption, buffer
  management, and decoder overhead.
  The Control Transfer Records (CTR) extension provides a method to record a limited history in
  register-accessible internal chip storage, with the intent of dramatically reducing the
  performance overhead and complexity of collecting transfer history.

  CTR defines a circular (FIFO) buffer. Each buffer entry holds a record for a single recorded
  control flow transfer.
  The number of records that can be held in the buffer depends upon both the implementation (the
  maximum supported depth) and the CTR configuration (the software selected depth).

  Only qualified transfers are recorded.
  Qualified transfers are those that meet the filtering criteria, which include the privilege mode
  and the transfer type.

  Recorded transfers are inserted at the write pointer, which is then incremented, while older
  recorded transfers may be overwritten once the buffer is full.
  Or the user can enable RAS (Return Address Stack) emulation mode, where only function calls are
  recorded, and function returns pop the last call record.
  The source PC, target PC, and some optional metadata (transfer type, elapsed cycles) are stored
  for each recorded transfer.

  The CTR buffer is accessible through an indirect CSR interface, such that software can specify
  which logical entry in the buffer it wishes to read or write.
  Logical entry 0 always corresponds to the youngest recorded transfer, followed by entry 1 as the
  next youngest, and so on.
params:
  CTR_CYCLE_COUNTER:
    description: |
      An internal counter used to count CPU cycles while CTR is active, where active implies that the
      current privilege mode is enabled for recording and CTR is not frozen. This counter is only for
      implementations that support cycle counting. It increments at the same rate as the mcycle counter.
      This counter is used to populate the CC field of ctrdata when a qualified control transfer occurs.
      It resets on writes to xctrctl and on execution of SCTRCLR.
    schema:
      type: integer
  CCV_HW:
    description: |
      An internal hardware flag, which is stored in ctrdata.CCV of the next record in case of a qualified
      control transfer.
      It is cleared out after a write to xctrctl or execution of SCTRCLR, since CTR_CYCLE_COUNTER is reset.
      This flag should additionally be cleared after any other implementation-specific scenarios where
      active cycles might not be counted in CTR_CYCLE_COUNTER.
    schema:
      type: boolean
type: privileged
versions:
  - version: "1.0.0"
    state: ratified
    ratification_date: 2024-11
    implies:
      name: Ssctr
      version: "1.0.0"
    requires:
      allOf:
        - name: S
          version: ~> 1.13 # The latest ratified version of S when Sscntr was ratified
        - name: Smcsrind
          version: ~> 1.0
