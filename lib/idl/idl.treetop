# grammar for the Isa Description Language
grammar Idl
  rule isa
    space*
      '%version:' space+ version_string space+
      definitions:(
        global_definition
        /
        enum_definition
        /
        bitfield_definition
        /
        function_definition
        / 
        space+
      )+ <Idl::IsaAst>
  end

  # declaring a global variable or constant
  rule global_definition
    single_declaration_with_initialization space* ';' <Idl::GlobalWithInitializationAst>
    /
    declaration space* ';' <GlobalAst>
  end

  rule enum_definition
    'builtin' space+ 'enum' space+ user_type_name space* ';' <Idl::BuiltinEnumDefinitionAst>
    /
    'enum' space+ user_type_name space+ '{' space*
      e:(user_type_name space+ i:(int space+)?)+ space*
    '}' <Idl::EnumDefinitionAst>
  end

  rule enum_ref
    enum_class:user_type_name space* '::' space* member:user_type_name <EnumRefSyntaxNode>
  end

  rule bitfield_definition
    'bitfield' space* '(' space* int space* ')' space* user_type_name space* '{' space*
      e:(field_name space+ range:(int lsb:(space* '-' space* int)?) space+)+ space*
    '}' <Idl::BitfieldDefinitionAst>
  end

  rule version_string
    [0-9]+ '.' [0-9]+
  end

  rule int
    # verilog style: explicit bit width
    ([0-9]+)? "'" 'b' [0-1] [0-1_]* <Idl::IntLiteralSyntaxNode> /
    ([0-9]+)? "'" 'o' [0-7] [0-7_]* <Idl::IntLiteralSyntaxNode> /
    ([0-9]+)? "'" 'd'? [0-9] [0-9_]* <Idl::IntLiteralSyntaxNode> /
    ([0-9]+)? "'" 'h' [0-9a-fA-F] [0-9a-fA-F_]* <Idl::IntLiteralSyntaxNode> /

    # verilog style: explicit bit width, signed
    ([0-9]+)? "'" 'sb' [0-1] [0-1_]* <Idl::IntLiteralSyntaxNode> /
    ([0-9]+)? "'" 'so' [0-7] [0-7_]* <Idl::IntLiteralSyntaxNode> /
    ([0-9]+)? "'" 's' 'd'? [0-9] [0-9_]* <Idl::IntLiteralSyntaxNode> /
    ([0-9]+)? "'" 'sh' [0-9a-fA-F] [0-9a-fA-F_]* <Idl::IntLiteralSyntaxNode> /

    # c++ style: signed
    '0b' [0-1] [0-1_]* 's' <Idl::IntLiteralSyntaxNode> /
    '0' [0-7] [0-7_]* 's' <Idl::IntLiteralSyntaxNode> /
    [1-9] [0-9]* 's' <Idl::IntLiteralSyntaxNode> /
    '0x' [0-9a-fA-F] [0-9a-fA-F]* 's' <Idl::IntLiteralSyntaxNode> /

    # c++ style: unsigned
    '0b' [0-1] [0-1_]* <Idl::IntLiteralSyntaxNode> /
    '0' [0-7] [0-7_]* <Idl::IntLiteralSyntaxNode> /
    [1-9] [0-9]* <Idl::IntLiteralSyntaxNode> /
    '0x' [0-9a-fA-F] [0-9a-fA-F]* <Idl::IntLiteralSyntaxNode> /

    # special case: just a single 0
    '0' 's'? <Idl::IntLiteralSyntaxNode>
  end

  rule bits
    "'" [01]+ "'"
  end

  rule p0_binary_operator
    # highest priority binary operators
      '/'   # division with ignored remainder
    / '%'   # remainder
    / '*'   # multiplication with ignored upper half
  end

  rule p1_binary_operator
      '+'   # addition with ignored overflow
    / '-'   # subtraction with ignored overflow
  end

  rule p2_binary_operator
      '<<'  # left shift
    / '>>>' # arithmetic right shift
    / '>>'  # logical left shift
  end

  rule p3_binary_operator
    '<=' /
    '>=' /
    '<'  /
    '>'
  end

  # when parsing inside a template argument list (<...>), we disallow the '>' character
  # if you need it for an expression, enclose the expression in ()
  rule p3_template_binary_operator
    '<=' /
    '<'
  end

  rule p4_binary_operator
    '!=' /
    '=='
  end

  rule p5_binary_operator
    '&' !'&'   # bitwise AND
  end

  rule p6_binary_operator
    '^'   # bitwise XOR
  end

  rule p7_binary_operator
    '|' !'|'  # bitwise OR
  end

  rule p8_binary_operator
    '&&'  # logical AND
  end

  rule p9_binary_operator
    '||' # logical OR
  end

  rule unary_operator
    '~' / '-' / '!'
  end

  rule p0_binary_expression
    l:unary_expression  r:(space* op:p0_binary_operator space* r:unary_expression)+ <Idl::BinaryExpressionRightSyntaxNode>
    /
    unary_expression
  end

  rule p1_binary_expression
    l:p0_binary_expression r:(space* op:p1_binary_operator space* r:p0_binary_expression)+ <Idl::BinaryExpressionRightSyntaxNode>
    /
    p0_binary_expression
  end

  rule p2_binary_expression
    l:p1_binary_expression r:(space* op:p2_binary_operator space* r:p1_binary_expression)+ <Idl::BinaryExpressionRightSyntaxNode>
    /
    p1_binary_expression
  end

  rule p3_binary_expression
    l:p2_binary_expression r:(space* op:p3_binary_operator space* r:p2_binary_expression)+ <Idl::BinaryExpressionRightSyntaxNode>
    /
    p2_binary_expression
  end

  rule template_safe_p3_binary_expression
    l:p2_binary_expression r:(space* op:p3_template_binary_operator space* r:p2_binary_expression)+ <Idl::BinaryExpressionRightSyntaxNode>
    /
    p2_binary_expression
  end

  rule p4_binary_expression
    l:p3_binary_expression r:(space* op:p4_binary_operator space* r:p3_binary_expression)+ <Idl::BinaryExpressionRightSyntaxNode>
    /
    p3_binary_expression
  end

  rule template_safe_p4_binary_expression
    l:template_safe_p3_binary_expression r:(space* op:p4_binary_operator space* r:p3_binary_expression)+ <Idl::BinaryExpressionRightSyntaxNode>
    /
    template_safe_p3_binary_expression
  end

  rule p5_binary_expression
    l:p4_binary_expression r:(space* op:p5_binary_operator space* r:p4_binary_expression)+ <Idl::BinaryExpressionRightSyntaxNode>
    /
    p4_binary_expression
  end

  rule template_safe_p5_binary_expression
    l:template_safe_p4_binary_expression r:(space* op:p5_binary_operator space* r:p4_binary_expression)+ <Idl::BinaryExpressionRightSyntaxNode>
    /
    template_safe_p4_binary_expression
  end

  rule p6_binary_expression
    l:p5_binary_expression r:(space* op:p6_binary_operator space* r:p5_binary_expression)+ <Idl::BinaryExpressionRightSyntaxNode>
    /
    p5_binary_expression
  end

  rule template_safe_p6_binary_expression
    l:template_safe_p5_binary_expression r:(space* op:p6_binary_operator space* r:p5_binary_expression)+ <Idl::BinaryExpressionRightSyntaxNode>
    /
    template_safe_p5_binary_expression
  end

  rule p7_binary_expression
    l:p6_binary_expression r:(space* op:p7_binary_operator space* r:p6_binary_expression)+ <Idl::BinaryExpressionRightSyntaxNode>
    /
    p6_binary_expression
  end

  rule template_safe_p7_binary_expression
    l:template_safe_p6_binary_expression r:(space* op:p7_binary_operator space* r:p6_binary_expression)+ <Idl::BinaryExpressionRightSyntaxNode>
    /
    template_safe_p6_binary_expression
  end

  rule p8_binary_expression
    l:p7_binary_expression r:(space* op:p8_binary_operator space* r:p7_binary_expression)+ <Idl::BinaryExpressionRightSyntaxNode>
    /
    p7_binary_expression
  end

  rule template_safe_p8_binary_expression
    l:template_safe_p7_binary_expression r:(space* op:p8_binary_operator space* r:p7_binary_expression)+ <Idl::BinaryExpressionRightSyntaxNode>
    /
    template_safe_p7_binary_expression
  end

  rule p9_binary_expression
    l:p8_binary_expression r:(space* op:p9_binary_operator space* r:p8_binary_expression)+ <Idl::BinaryExpressionRightSyntaxNode>
    /
    p8_binary_expression
  end

  rule template_safe_p9_binary_expression
    l:template_safe_p8_binary_expression r:(space* op:p9_binary_operator space* r:p8_binary_expression)+ <Idl::BinaryExpressionRightSyntaxNode>
    /
    template_safe_p8_binary_expression
  end

  rule paren_expression
    '(' space* e:expression space* ')' <Idl::ParenExpressionSyntaxNode>
  end

  rule replication_expression
    # verilog-style replication
    '{' space* n:expression space* '{' space* v:expression space* '}' space* '}' <Idl::ReplicationExpressionSyntaxNode>
  end

  rule concatenation_expression
    # verilog-style concatenation
    '{' space* first:expression rest:(space* ',' space* expression)* space* '}' <Idl::ConcatenationExpressionAst>
  end

  rule csr_field_access_expression
    # CSR field access
    'CSR' space* '[' space* idx:(csr_name / int) space* ']' space* '.' space* csr_field_name <Idl::CsrFieldReadExpressionAst>
  end

  rule csr_register_access_expression
    # CSR register access
    'CSR' space* '[' space* idx:expression space* ']' <Idl::CsrReadExpressionAst>
  end

  rule bitfield_access_expression
    rval space* '.' space* field_name <Idl::BitfieldAccessExpressionAst>
  end

  rule ary_eligible_expression
    paren_expression
    /
    replication_expression
    /
    concatenation_expression
    /
    function_call # Ast is assigned in function_call rule
    /
    csr_field_access_expression
    /
    csr_register_access_expression
    /
    bitfield_access_expression
    /
    rval # must come last!
  end

  rule ary_access
    a:ary_eligible_expression space* brackets:('[' space* msb:(expression space* ':' space*)? lsb:expression space* ']' space*)+ <Idl::AryAccessSyntaxNode>
  end

  rule post_dec
    rval space* '--' <Idl::PostDecrementExpressionAst>
  end

  rule post_inc
    rval space* '++' <Idl::PostIncrementExpressionAst>
  end

  rule unary_expression
    '[' space* first:expression rest:(space* ',' space* expression)* space* ']' <Idl::ArrayLiteralAst>
    /
    ary_access
    /
    '$signed' space* '(' space* expression space* ')' <Idl::SignCastSyntaxNode>
    /
    '$bits' space* '(' space* expression space* ')' <Idl::BitsCastAst>
    /
    paren_expression
    /
    o:unary_operator space* e:expression <Idl::UnaryOperatorExpressionAst>
    /
    post_dec
    /
    post_inc
    /
    replication_expression
    /
    concatenation_expression
    /
    function_call # Ast is assigned in function_call rule
    /
    csr_field_access_expression
    /
    csr_register_access_expression
    /
    bitfield_access_expression
    /
    enum_ref
    /
    rval # must come last
  end

  rule ternary_expression
    p9_binary_expression space* '?' space* t:expression space* ':' space* f:expression <Idl::TernaryOperatorExpressionSyntaxNode>
  end

  rule template_safe_ternary_expression
    template_safe_p9_binary_expression space* '?' space* t:expression space* ':' space* f:expression <Idl::TernaryOperatorExpressionAst>
  end

  rule expression
    (
     ternary_expression
     /
     p9_binary_expression
    )
  end


  rule template_safe_expression
    (
     template_safe_ternary_expression
     /
     template_safe_p9_binary_expression
    )
  end

  rule function_call_template_arguments
    first:(int / rval) rest:(space* ',' space* arg:(int / rval))*
  end

  rule function_call
    csr:csr_register_access_expression space* '.' space* 'sw_write' space* '(' space* expression space* ')' <Idl::CsrSoftwareWriteAst>
    /
    csr:csr_register_access_expression space* '.' space* 'sw_read' space* '(' space* ')' <Idl::CsrSoftwareReadAst>
    /
    function_name t:(space* '<' space* targs:function_call_template_arguments space* '>')? space* '(' space* function_arg_list space* ')' <Idl::FunctionCallExpressionSyntaxNode>
  end

  rule function_name
    !reserved [a-zA-Z] [a-zA-Z0-9_]* '?'? {
      def is_function_name? = true
    }
  end

  rule function_arg_list
    first:expression? rest:(space* ',' space* expression)*
  end

  rule body_function_definition
    'function' space+ function_name space* '{' space*
      targs:('template' space+ first:function_argument_definition rest:(space* ',' space* function_argument_definition)* space+)?
      ret:('returns' space+ first:type_name rest:(space* ',' space* type_name)* space+)?
      args:(
        'arguments' space+
        first:function_argument_definition
        rest:(space* ',' space* function_argument_definition)*
        space+
      )?
      'description' space* '{' space*
        desc:([^}] / "\n")+
      '}' space*
      body_block:(
        'body' space* '{' space*
          function_body space*
        '}' space*
      )
    '}' <Idl::FunctionDefAst>
  end

  rule builtin_function_definition
    'builtin' space+ 'function' space+ function_name space* '{' space*
      targs:('template' space+ first:function_argument_definition rest:(space* ',' space* function_argument_definition)* space+)?
      ret:('returns' space+ first:type_name rest:(space* ',' space* type_name)* space+)?
      args:(
        'arguments' space+
        first:function_argument_definition
        rest:(space* ',' space* function_argument_definition)*
        space+
      )?
      'description' space* '{' space*
        desc:([^}] / "\n")+
      '}' space*
    '}' <Idl::FunctionDefAst>
  end

  rule function_definition
    builtin_function_definition / body_function_definition
  end

  rule function_argument_definition
    type_name space+ id
  end

  rule rval
    (id / int / builtin_read_only_var / builtin_read_write_var)
  end

  rule assignment
    '(' first:(var_write / dontcare_lvalue) space* rest:(',' space* var:(var_write / dontcare_lvalue) space*)+ ')' space* '=' space* function_call <Idl::MultiVariableAssignmentAst> /
    single_declaration_with_initialization /
    var:var_write space* '=' space* rval:expression <Idl::VariableAssignmentSyntaxNode> /
    var:var_write '.' field_name space* '=' space* rval:expression <Idl::FieldAssignmentAst> /
    var:var_write space* '[' space* msb:expression space* ':' space* lsb:expression space* ']' space* '=' space* rval:expression <Idl::AryRangeAssignmentAst> /
    var:var_write space* '[' space* idx:expression space* ']' space* '=' space* rval:expression <Idl::AryElementAssignmentSyntaxNode>
  end

  rule ary_size_decl
    '[' space* expression space* ']'
  end

  rule single_declaration_with_initialization
    q:type_qualifier? space* type_name space+ var_write space* ary_size:ary_size_decl? space* '=' space* rval:expression <Idl::VariableDeclarationWithInitializationSyntaxNode>
  end

  rule declaration
    q:type_qualifier? space* type_name space+ first:var_write space* rest:(space* ',' space* var_write)+ space* <Idl::MultiVariableDeclarationAst>
    /
    single_declaration
  end

  rule single_declaration
    q:type_qualifier? space* type_name space+ var_write space* ary_size:ary_size_decl? space* <Idl::VariableDeclarationAst>
  end

  rule statement
    a:(function_call / assignment) space* 'if' space* expression space* ';' <Idl::ConditionalStatementSyntaxNode>
    /
    a:(function_call / assignment / declaration) space* ';' <Idl::StatementSyntaxNode>
  end

  rule dontcare_lvalue
    '-' <Idl::DontCareLvalueAst>
  end

  rule dontcare_return
    '-' <Idl::DontCareReturnSyntaxNode>
  end

  rule return_statement
    'return' space+ first:(expression/dontcare_return) rest:(space* ',' space* e:(expression/dontcare_return))* space* 'if' space* expression space* ';' <Idl::ConditionalReturnStatementAst>
    /
    'return' space+ first:(expression/dontcare_return) rest:(space* ',' space* e:(expression/dontcare_return))* space* ';' <Idl::ReturnStatementAst>
  end

  rule function_if_block
    'if' space* '(' space* if_cond:expression space* ')' space* '{' space*
      if_body:(e:(statement / return_statement / function_if_block / for_loop) space*)+
    '}'
    elseifs:(
      space* 'else' space+ 'if' space* '(' space* expression space* ')' space* '{' space*
        body:(e:(statement / return_statement / function_if_block / for_loop) space*)+
      '}'
    )*
    final_else:(
      space* 'else' space* '{' space*
        body:(e:(statement / return_statement / function_if_block / for_loop) space*)+
      '}'
    )? <Idl::IfSyntaxNode>
  end

  rule execute_if_block
    'if' space* '(' space* if_cond:expression space* ')' space* '{' space*
      if_body:(e:(statement / execute_if_block / for_loop) space*)+
    '}'
    elseifs:(
      space* 'else' space+ 'if' space* '(' space* expression space* ')' space* '{' space*
        body:(e:(statement / execute_if_block / for_loop) space*)+
      '}'
    )*
    final_else:(
      space* 'else' space* '{' space*
        body:(e:(statement / execute_if_block / for_loop) space*)+
      '}'
    )? <Idl::IfSyntaxNode>
  end

  rule for_loop
    'for' space* '(' space* single_declaration_with_initialization space* ';' space* condition:expression space* ';' space* action:(assignment / post_inc / post_dec) space*  ')' space* '{' space*
      stmts:(s:(statement / return_statement / function_if_block / for_loop) space*)+
    '}' <Idl::ForLoopSyntaxNode>
  end

  rule type_qualifier
    '' # 'signed'
  end

  rule builtin_type_name
    # alias for Bits<XLEN>
    'XReg' ![A-Za-z0-9] <Idl::BuiltinTypeNameSyntaxNode> /

    'Bits' space* '<' space* i:template_safe_expression space* '>' ![A-Za-z0-9] <Idl::BuiltinTypeNameSyntaxNode> /

    'Boolean' ![A-Za-z0-9] <Idl::BuiltinTypeNameSyntaxNode> /

    # 64-bit unsigned integer
    'U64' ![A-Za-z0-9] <Idl::BuiltinTypeNameSyntaxNode> /

    # 32-bit unsigned integer
    'U32' ![A-Za-z0-9] <Idl::BuiltinTypeNameSyntaxNode>
  end

  rule keyword
    'if' ![A-Za-z0-9] /
    'else' ![A-Za-z0-9] /
    'for' ![A-Za-z0-9] /
    'return' ![A-Za-z0-9] /
    'returns' ![A-Za-z0-9] /
    'arguments' ![A-Za-z0-9] /
    'description' ![A-Za-z0-9] /
    'body' ![A-Za-z0-9] /
    'function' ![A-Za-z0-9] /
    'builtin' ![A-Za-z0-9] /
    'enum' ![A-Za-z0-9]  /
    'bitfield' ![A-Za-z0-9]
  end

  rule user_type_name
    !reserved [A-Z] [A-Za-z0-9_]* <Idl::UserTypeNameAst>
  end

  rule field_name
    [a-zA-Z] [a-zA-Z0-9]* <Idl::FieldNameAst>
  end

  rule type_name
    (builtin_type_name / user_type_name)
  end

  rule reserved
    builtin_type_name / keyword
  end

  rule execution_comment
    '#' content:(!"\n" .)* "\n" <Idl::ExecutionCommentAst>
  end

  rule function_statement
    (return_statement/statement/function_if_block/for_loop)
  end

  rule function_body
    space* func_stmt_list:(choice:function_statement space*)* <Idl::FunctionBodySyntaxNode>
  end

  rule instruction_operation
    space* op_stmt_list:(choice:(statement/execute_if_block/for_loop) space*)* <Idl::InstructionOperationSyntaxNode>
  end

  rule id
    # we purposely omit _ from the starting character so that tools can safely use such names
    # without worrying about name collisions
    !reserved [A-Za-z] [A-Za-z_0-9]* <Idl::IdSyntaxNode>
  end

  rule builtin_read_only_var
    "$encoding" <Idl::BuiltinVariableSyntaxNode>
  end

  rule builtin_read_write_var
    "$pc" <Idl::BuiltinVariableSyntaxNode>
  end

  rule csr_name
    [a-z] ([a-z0-9])*
  end

  rule csr_field_name
    [a-zA-Z] ([a-zA-Z0-9])*
  end

  rule var_write
    'CSR' space* '[' space* idx:(csr_name / int) space* ']' <Idl::CsrWriteAst>
    /
    id
  end

  rule space
    [ \n] / single_line_comment / block_comment / execution_comment
  end

  rule block_comment
    '/*'
    (
      !'*/'
      (. / "\n")
    )*
    '*/'
  end

  rule single_line_comment
    '//' (!"\n" .)* "\n"
  end

end
