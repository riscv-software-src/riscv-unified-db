# yaml-language-server: $schema=../../schemas/config_schema.json

---
params:
  XLEN: 32

  # name of the configuration
  NAME: qc_iu

  # vendor-specific architecture ID in marchid
  ARCH_ID: 0x1000000000000000

  # vendor-specific implementation ID in mimpid
  IMP_ID: 0x0

  # JEDEC Vendor ID bank (Qualcomm = 0)
  VENDOR_ID_BANK: 0x0

  # JEDEC Vendor ID offset (Qualcomm = 0x70)
  VENDOR_ID_OFFSET: 0x70

  # whether or not the implementation supports misaligned loads and stores in main memory (not including atomics)
  # must be true when Zicclsm is supported
  MISALIGNED_LDST: true

  # whether or not the implementation supports misaligned atomics
  MISALIGNED_AMO: false

  # number of implemented programmable hardware performance counters
  NUM_HPM_COUNTERS: 8

  # Indicates which counters can be disabled from mcountinhibit
  #
  # An unimplemented counter cannot be specified, i.e., if
  # NUM_HPM_COUNTERS == 8, it would be illegal to add index
  # 11 in COUNTINHIBIT_EN since the highest implemented counter
  # would be at bit 10
  COUNTINHIBIT_EN:
  - true  # CY
  - false # empty
  - true  # IR
  - true  # HPME3
  - true  # HPME4
  - true  # HPME5
  - true  # HPME6
  - true  # HPME7
  - true  # HPME8
  - true  # HPME9
  - true  # HPME10
  - false # HPME11
  - false # HPME12
  - false # HPME13
  - false # HPME14
  - false # HPME15
  - false # HPME16
  - false # HPME17
  - false # HPME18
  - false # HPME19
  - false # HPME20
  - false # HPME21
  - false # HPME22
  - false # HPME23
  - false # HPME24
  - false # HPME25
  - false # HPME26
  - false # HPME27
  - false # HPME28
  - false # HPME29
  - false # HPME30
  - false # HPME31

  MISALIGNED_SPLIT_STRATEGY: by_byte

  # list of defined HPM events
  HPM_EVENTS:
  - 0
  - 3

  # Indicates which counters can delegated via mcounteren
  #
  # An unimplemented counter cannot be specified, i.e., if
  # NUM_HPM_COUNTERS == 8, it would be illegal to add index
  # 11 in COUNTEN_EN since the highest implemented counter
  # would be at bit 10
  COUNTENABLE_EN:
  - true  # CY
  - false # empty
  - true  # IR
  - true  # HPME3
  - true  # HPME4
  - true  # HPME5
  - true  # HPME6
  - true  # HPME7
  - true  # HPME8
  - true  # HPME9
  - true  # HPME10
  - false # HPME11
  - false # HPME12
  - false # HPME13
  - false # HPME14
  - false # HPME15
  - false # HPME16
  - false # HPME17
  - false # HPME18
  - false # HPME19
  - false # HPME20
  - false # HPME21
  - false # HPME22
  - false # HPME23
  - false # HPME24
  - false # HPME25
  - false # HPME26
  - false # HPME27
  - false # HPME28
  - false # HPME29
  - false # HPME30
  - false # HPME31

  # when true, writing an illegal value to a WLRL CSR field raises an Illegal Instruction exception
  # when false, writing an illegal value to a WLRL CSR field is ignored
  TRAP_ON_ILLEGAL_WLRL: true

  # when true, *tval is written with the virtual PC of the EBREAK instruction (same information as *epc)
  # when false, *tval is written with 0 on an EBREAK instruction
  #
  # regardless, *tval is always written with a virtual PC when an external breakpoint is generated
  REPORT_VA_IN_MTVAL_ON_BREAKPOINT: true

  REPORT_VA_IN_MTVAL_ON_LOAD_MISALIGNED: true
  REPORT_VA_IN_MTVAL_ON_STORE_AMO_MISALIGNED: true
  REPORT_VA_IN_MTVAL_ON_INSTRUCTION_MISALIGNED: true
  REPORT_VA_IN_MTVAL_ON_LOAD_ACCESS_FAULT: true
  REPORT_VA_IN_MTVAL_ON_STORE_AMO_ACCESS_FAULT: true
  REPORT_VA_IN_MTVAL_ON_INSTRUCTION_ACCESS_FAULT: true
  REPORT_VA_IN_MTVAL_ON_LOAD_PAGE_FAULT: true
  REPORT_VA_IN_MTVAL_ON_STORE_AMO_PAGE_FAULT: true
  REPORT_VA_IN_MTVAL_ON_INSTRUCTION_PAGE_FAULT: true
  REPORT_ENCODING_IN_MTVAL_ON_ILLEGAL_INSTRUCTION: true
  REPORT_CAUSE_IN_MTVAL_ON_SOFTWARE_CHECK: true
  MTVAL_WIDTH: 64 # must check that this can hold any valid VA if any REPORT_VA* or Sdext, and, if REPORT_ENCODING*, at least [MXLEN, ILEN].min bits

  REPORT_VA_IN_STVAL_ON_BREAKPOINT: true
  REPORT_VA_IN_STVAL_ON_STORE_AMO_MISALIGNED: true
  REPORT_VA_IN_STVAL_ON_INSTRUCTION_MISALIGNED: true
  REPORT_VA_IN_STVAL_ON_LOAD_ACCESS_FAULT: true
  REPORT_VA_IN_STVAL_ON_STORE_AMO_ACCESS_FAULT: true
  REPORT_VA_IN_STVAL_ON_INSTRUCTION_ACCESS_FAULT: true
  REPORT_VA_IN_STVAL_ON_LOAD_PAGE_FAULT: true
  REPORT_VA_IN_STVAL_ON_STORE_AMO_PAGE_FAULT: true
  REPORT_VA_IN_STVAL_ON_INSTRUCTION_PAGE_FAULT: true
  REPORT_ENCODING_IN_STVAL_ON_ILLEGAL_INSTRUCTION: true
  REPORT_CAUSE_IN_STVAL_ON_SOFTWARE_CHECK: true
  STVAL_WIDTH: 64 # must check that this can hold any valid VA, and, if REPORT_ENCODING*, at least [SXLEN, ILEN].min bits

  REPORT_VA_IN_VSTVAL_ON_BREAKPOINT: true
  REPORT_VA_IN_VSTVAL_ON_STORE_AMO_MISALIGNED: true
  REPORT_VA_IN_VSTVAL_ON_INSTRUCTION_MISALIGNED: true
  REPORT_VA_IN_VSTVAL_ON_LOAD_ACCESS_FAULT: true
  REPORT_VA_IN_VSTVAL_ON_STORE_AMO_ACCESS_FAULT: true
  REPORT_VA_IN_VSTVAL_ON_INSTRUCTION_ACCESS_FAULT: true
  REPORT_VA_IN_VSTVAL_ON_LOAD_PAGE_FAULT: true
  REPORT_VA_IN_VSTVAL_ON_STORE_AMO_PAGE_FAULT: true
  REPORT_VA_IN_VSTVAL_ON_INSTRUCTION_PAGE_FAULT: true
  REPORT_ENCODING_IN_VSTVAL_ON_ILLEGAL_INSTRUCTION: true
  REPORT_CAUSE_IN_VSTVAL_ON_SOFTWARE_CHECK: true
  # VSTVAL_WIDTH not needed; "vstval is a WARL register that must be able to hold the same set of values that stval can hold"

  # address of the unified discovery configuration data structure
  # this address is reported in the mconfigptr CSR
  CONFIG_PTR_ADDRESS: 0x1000

  # number of implemented PMP entries. Can be any value between 0-64, inclusive.
  #
  # the number of implemented PMP registers must be 0, 16, or 64.
  #
  # Therefore, whether or not a pmpaddrN or pmpcfgN register exists depends on
  # NUM_PMP_ENTRIES as follows:
  # |===
  # | NUM_PMP_ENTRIES | pmpaddr<0-15> / pmpcfg<0-3> | pmpaddr<16-63> / pmpcfg<4-15>
  # | 0               | N                           | N
  # | 1-16            | Y                           | N
  # | 17-64           | Y                           | Y
  # |===
  # ** pmpcfgN for an odd N never exist when XLEN == 64
  #
  # when NUM_PMP_ENTRIES is not exactly 0, 16, or 64, some extant pmp registers,
  # and associated pmpNcfg, will be read-only zero (but will not cause an exception).
  NUM_PMP_ENTRIES: 14

  # log2 of the smallest supported PMP region
  # generally, for systems with an MMU, should not be smaller than 12,
  # as that would preclude caching PMP results in the TLB along with
  # virtual memory translations
  #
  # Note that PMP_GRANULARITY is equal to G+2 (not G) as described in
  # the privileged architecture
  PMP_GRANULARITY: 12

  # log2 of the smallest supported PMA region
  # generally, for systems with an MMU, should not be smaller than 12,
  # as that would preclude caching PMP results in the TLB along with
  # virtual memory translations
  PMA_GRANULARITY: 12

  # number of bits in the physical address space
  PHYS_ADDR_WIDTH: 34

  # number of implemented ASID bits
  # maximum value is 16
  ASID_WIDTH: 12

  # when the A extension is supported, indicates whether or not
  # the extension can be disabled in the `misa.A` bit.
  MUTABLE_MISA_A: false

  # when the B extension is supported, indicates whether or not
  # the extension can be disabled in the `misa.B` bit.
  MUTABLE_MISA_B: false

  # when the C extension is supported, indicates whether or not
  # the extension can be disabled in the `misa.C` bit.
  MUTABLE_MISA_C: false

  # size of a cache block, in bytes
  CACHE_BLOCK_SIZE: 64

  # number of supported virtualized guest interrupts
  # corresponds to the `GEILEN` parameter in the RVI specs
  NUM_EXTERNAL_GUEST_INTERRUPTS: 4

  # Endianess of data in M-mode. Can be one of:
  #
  #  * 0: M-mode data is always little endian
  #  * 1: M-mode data is always big endian
  #  * 2: M-mode data can be either little or big endian, depending on the RW CSR field mstatus.MBE
  M_MODE_ENDIANESS: 0

  # Endianess of data in M-mode. Can be one of:
  #
  #  * 0: S-mode data is always little endian
  #  * 1: S-mode data is always big endian
  #  * 2: S-mode data can be either little or big endian, depending on the RW CSR field mstatus.SBE
  S_MODE_ENDIANESS: 0

  # Endianess of data in M-mode. Can be one of:
  #
  #  * 0: U-mode data is always little endian
  #  * 1: U-mode data is always big endian
  #  * 2: U-mode data can be either little or big endian, depending on the RW CSR field mstatus.UBE
  U_MODE_ENDIANESS: 0

  # Endianess of data in VU-mode. Can be one of:
  #
  #  * 0: VU-mode data is always little endian
  #  * 1: VU-mode data is always big endian
  #  * 2: VU-mode data can be either little or big endian, depending on the RW CSR field vsstatus.UBE
  VU_MODE_ENDIANESS: 0

  # Endianess of data in VS-mode. Can be one of:
  #
  #  * 0: VS-mode data is always little endian
  #  * 1: VS-mode data is always big endian
  #  * 2: VS-mode data can be either little or big endian, depending on the RW CSR field hstatus.VSBE
  VS_MODE_ENDIANESS: 0

  # XLENs supported in U-mode. Can be one of:
  #
  #  * 32:   SXLEN is always 32
  #  * 64:   SXLEN is always 64
  #  * 3264: SXLEN can be changed (via mstatus.SXL) between 32 and 64
  UXLEN: 32

  # XLENs supported in VS-mode. Can be one of:
  #
  #  * 32:   VSXLEN is always 32
  #  * 64:   VSXLEN is always 64
  #  * 3264: VSXLEN can be changed (via hstatus.VSXL) between 32 and 64
  VSXLEN: 32

  # XLENs supported in VS-mode. Can be one of:
  #
  #  * 32:   VSXLEN is always 32
  #  * 64:   VSXLEN is always 64
  #  * 3264: VSXLEN can be changed (via hstatus.VSXL) between 32 and 64
  VUXLEN: 32

  # HAS_FENCE_TSO indicates whether or not the implementation supports the fence.tso instruction
  # HAS_FENCE_TSO: true

  # PTE_A_D_ACCESS_EXCEPTION indicates support for hardware PTE access/dirty updates
  #
  #  * true:   Hardware automatically updates PTEs according to Svadu
  #  * false:  Hardware does not automatically update PTEs; as such, PageFaults may be generated
  # PTE_A_D_ACCESS_EXCEPTION: true

  # STVEC_MODE_DIRECT indicates that stvec.MODE can hold 0 (Direct)
  # STVEC_MODE_DIRECT: true

hpm_events:
  - 'L1_ICACHE_MISS'
  - 'L2_CACHE_MISS'

extensions:
  - [A, 2.1]
  - [B, 1.0]
  - [D, 2.2]
  # - [F, 2.2]
  - [I, 2.1]
  - [M, 2.0]
  - [Zicntr, 2.0]
  - [Zicsr, 2.0]
  - [Zihpm, 2.0]
  - [Zicboz, "1.0.1-b34ea8a"]
  - [Zicbom, "1.0.1-b34ea8a"]
  - [Xqciu, 0.1]
